{"compilable":1,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"size_t strlcpy_name_conflict(char *dst, const char *src, size_t siz) {\n  char *d = dst;\n  const char *s = src;\n  size_t n = siz;\n\n  if (n != 0) {\n    while (--n != 0) {\n      if ((*d++ = *s++) == '\\0')\n        break;\n    }\n  }\n\n  if (n == 0) {\n    if (siz != 0)\n      *d = '\\0';\n    while (*s++)\n      ;\n  }\n\n  return (s - src - 1);\n}","pass":1,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":1,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"size_t strlcpy_name_conflict(char *dst, const char *src, size_t siz) {\n  char *d = dst;\n  const char *s = src;\n  size_t n = siz;\n\n  if (n != 0) {\n    while (--n != 0) {\n      if ((*d++ = *s++) == '\\0')\n        break;\n    }\n  }\n\n  if (n == 0) {\n    if (siz != 0)\n      *d = '\\0';\n    while (*s++)\n      ;\n  }\n\n  return (s - src - 1);\n}","pass":1,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":1,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"size_t strlcpy_name_conflict(char *dst, const char *src, size_t siz) {\n  char *d = dst;\n  const char *s = src;\n  size_t n = siz;\n\n  if (n != 0) {\n    while (--n != 0) {\n      if ((*d++ = *s++) == '\\0')\n        break;\n    }\n  }\n\n  if (n == 0) {\n    if (siz != 0)\n      *d = '\\0';\n    while (*s++)\n      ;\n  }\n\n  return (s - src - 1);\n}","pass":1,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":1,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"off_t hash_file_name_conflict(MD5_CTX *ctx, int fd) {\n  char buf[4096];\n  off_t total = 0;\n  ssize_t n;\n\n  while ((n = read(fd, buf, sizeof(buf))) > 0) {\n    MD5Update(ctx, buf, n);\n    total += n;\n  }\n\n  buf[0] = '\\0';\n  MD5Update(ctx, buf, 1);\n\n  return total;\n}","pass":1,"source_file":"C_COMPILE/montiainen_BROS/package/x11r7/mcookie/mcookie.c"}
{"compilable":0,"function":"int bb_make_directory(char *path, long mode, int flags) {\n    mode_t mask;\n    const char *fail_msg;\n    char *s = path;\n    char c;\n    struct stat st;\n    mask = umask(0);\n    if (mode == -1) {\n        umask(mask);\n        mode = (64 | (64 >> 3) | ((64 >> 3) >> 3) | 128 | (128 >> 3) | ((128 >> 3) >> 3) | 256 | (256 >> 3) | ((256 >> 3) >> 3)) & ~mask;\n    } else {\n        umask(mask & ~192);\n    }\n    do {\n        c = 0;\n        if (flags & FILEUTILS_RECUR) {\n            while (*s)\n                {\n                    if (*s == '/') {\n                        do {\n                            ++s;\n                        } while (*s == '/');\n                        c = *s;\n                        *s = 0;\n                        break;\n                    }\n                    ++s;\n                }\n        }\n        if (mkdir(path, 511) < 0) {\n            if (((*__errno_location()) != 17 && (*__errno_location()) != 21) || !(flags & FILEUTILS_RECUR) || (stat(path, &st) < 0 || !((((st.st_mode)) & 61440) == (16384)))) {\n                fail_msg = \"create\";\n                umask(mask);\n                break;\n            }\n            if (!c) {\n                umask(mask);\n                return 0;\n            }\n        }\n        if (!c) {\n            umask(mask);\n            if ((mode != -1) && (chmod(path, mode) < 0)) {\n                fail_msg = \"set permissions of\";\n                break;\n            }\n            return 0;\n        }\n        *s = c;\n    } while (1);\n    bb_perror_msg(\"Cannot %s directory `%s'\", fail_msg, path);\n    return -1;\n}\n","function_prediction":"int bb_make_directory_name_conflict(char *path, mode_t mode, int flags) {\n  int ret;\n  char *p;\n  char c;\n  mode_t old_umask;\n  struct stat st;\n\n  old_umask = umask(0);\n  if (mode == (mode_t)-1)\n    mode = (~old_umask) & 0777;\n  else\n    umask(old_umask & ~0022);\n\n  for (;;) {\n    c = 0;\n    if (flags & 0004) {\n      for (p = path; *p; p++)\n        if (*p == '/')\n          break;\n      if (*p) {\n        c = *p;\n        *p = 0;\n      }\n    }\n\n    ret = mkdir(path, 0777);\n    if (ret < 0) {\n      if ((*__errno_location() == 17 || *__errno_location() == 21) &&\n          (flags & 0004) && (stat(path, &st) >= 0) &&\n          ((st.st_mode & 0170000) == 0040000)) {\n        if (c) {\n          *p = c;\n          continue;\n        }\n        umask(old_umask);\n        return 0;\n      } else {\n        bb_perror_msg(\"Cannot %s directory `%s'\", \"create\", path);\n        umask(old_umask);\n        return -1;\n      }\n    }\n\n    if (c) {\n      *p = c;\n      continue;\n    }\n\n    umask(old_umask);\n    break;\n  }\n\n  if (mode != (mode_t)-1) {\n    ret = chmod(path, mode);\n    if (ret < 0) {\n      bb_perror_msg(\"Cannot %s directory `%s'\", \"set permissions of\", path);\n      return -1;\n    }\n  }\n\n  return 0;","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":1,"function":"long my_getpwnam(const char *name) {\n    struct passwd *myuser;\n    myuser = getpwnam(name);\n    if (myuser == ((void *)0))\n        bb_error_msg_and_die(\"unknown user name: %s\", name);\n    return myuser->pw_uid;\n}\n","function_prediction":"uid_t my_getpwnam_name_conflict(const char *name) {\n  struct passwd *pw;\n\n  pw = getpwnam(name);\n  if (!pw)\n    bb_error_msg_and_die(\"unknown user name: %s\", name);\n\n  return pw->pw_uid;\n}","pass":1,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":1,"function":"long my_getgrnam(const char *name) {\n    struct group *mygroup;\n    mygroup = getgrnam(name);\n    if (mygroup == ((void *)0))\n        bb_error_msg_and_die(\"unknown group name: %s\", name);\n    return (mygroup->gr_gid);\n}\n","function_prediction":"gid_t my_getgrnam_name_conflict(const char *name) {\n  struct group *grp;\n\n  grp = getgrnam(name);\n  if (!grp)\n    bb_error_msg_and_die(\"unknown group name: %s\", name);\n\n  return grp->gr_gid;\n}","pass":1,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":1,"function":"char *last_char_is(const char *s, int c) {\n    char *sret = (char *)s;\n    if (sret) {\n        sret = strrchr(sret, c);\n        if (sret != ((void *)0) && *(sret + 1) != 0)\n            sret = ((void *)0);\n    }\n    return sret;\n}\n","function_prediction":"char *last_char_is_name_conflict(char *str, int c) {\n  char *p;\n\n  if (!str)\n    return NULL;\n\n  p = strrchr(str, c);\n  if (p && !p[1])\n    return p;\n\n  return NULL;\n}","pass":1,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":1,"function":"char *concat_path_file(const char *path, const char *filename) {\n    char *outbuf;\n    char *lc;\n    if (!path)\n        path = \"\";\n    lc = last_char_is(path, '/');\n    while (*filename == '/')\n        filename++;\n    bb_xasprintf(&outbuf, \"%s%s%s\", path, (lc == ((void *)0) ? \"/\" : \"\"), filename);\n    return outbuf;\n}\n","function_prediction":"char *concat_path_file_name_conflict(const char *path, const char *file) {\n  char *new_path;\n  int path_has_slash;\n\n  if (!path)\n    path = \"\";\n\n  path_has_slash = last_char_is(path, '/');\n\n  while (*file == '/')\n    file++;\n\n  bb_xasprintf(&new_path, \"%s%s%s\", path, path_has_slash ? \"\" : \"/\", file);\n\n  return new_path;\n}","pass":1,"source_file":"C_COMPILE/montiainen_BROS/package/makedevs/makedevs.c"}
{"compilable":0,"function":"pid_t getppidof(const pid_t pid) {\n    int ppid;\n    char buffer[8192];\n    size_t size;\n    FILE *fp;\n    sprintf(buffer, \"/proc/%d/stat\", pid);\n    fp = fopen(buffer, \"r\");\n    if (fp) {\n        size = fread(buffer, sizeof(char), sizeof (buffer), fp);\n        if (size > 0) {\n            strtok(buffer, \" \");\n            strtok(((void *)0), \" \");\n            strtok(((void *)0), \" \");\n            ppid = atoi(strtok(((void *)0), \" \"));\n        }\n        fclose(fp);\n    }\n    return ppid;\n}\n","function_prediction":"int getppidof_name_conflict(int pid) {\n  char buf[8192];\n  FILE *fp;\n  size_t n;\n  char *p;\n  int ppid;\n\n  sprintf(buf, \"/proc/%d/stat\", pid);\n  fp = fopen(buf, \"r\");\n  if (fp == NULL)\n    return 0;\n\n  n = fread(buf, 1, 8192, fp);\n  if (n == 0)\n    goto out;\n\n  strtok(buf, \" \");\n  strtok(NULL, \" \");\n  strtok(NULL, \" \");\n  p = strtok(NULL, \" \");\n  ppid = atoi(p);\n\nout:\n  fclose(fp);\n  return ppid;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"char *getnameof(const pid_t pid) {\n    static char buffer[8192];\n    char *old_buffer, *new_buffer;\n    FILE *fp;\n    size_t size;\n    sprintf(buffer, \"/proc/%d/cmdline\", pid);\n    fp = fopen(buffer, \"r\");\n    if (fp) {\n        size = fread(buffer, sizeof(char), sizeof (buffer), fp);\n        if (size > 0) {\n            new_buffer = strtok(buffer, \"/\");\n            while (new_buffer != ((void *)0))\n                {\n                    old_buffer = new_buffer;\n                    new_buffer = strtok(((void *)0), \"/\");\n                }\n        }\n        fclose(fp);\n    }\n    return old_buffer;\n}\n","function_prediction":"char *getnameof_name_conflict(int pid) {\n  FILE *fp;\n  char *token;\n  char *name;\n\n  sprintf(buffer, \"/proc/%d/cmdline\", pid);\n  fp = fopen(buffer, \"r\");\n  if (fp) {\n    if (fread(buffer, 1, 8192, fp)) {\n      token = strtok(buffer, \"/\");\n      while (token) {\n        name = token;\n        token = strtok(NULL, \"/\");\n      }\n    }\n    fclose(fp);\n  }\n  return name;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"char *_prisma_trytogettermname() {\n    static char _prisma_termname[64];\n    char *tmp = getnameof(getppidof(getsid(getpid())));\n    if (tmp) {\n        strncpy(_prisma_termname, tmp, 64);\n        if (!strncmp(_prisma_termname, \"initdline\", 64) || !strncmp(_prisma_termname, \"konsole\", 64))\n            return _prisma_termname;\n    }\n    strncpy(_prisma_termname, getenv(\"TERM\"), 64);\n    return _prisma_termname;\n}\n","function_prediction":"char *_prisma_trytogettermname_name_conflict() {\n  char *termname;\n  static char _prisma_termname[64];\n\n  termname = getnameof(getppidof(getsid(getpid())));\n  if (termname != NULL) {\n    strncpy(_prisma_termname, termname, 64);\n    if (!strcmp(_prisma_termname, \"initdline\") ||\n        !strcmp(_prisma_termname, \"konsole\"))\n      return _prisma_termname;\n  }\n  strncpy(_prisma_termname, getenv(\"TERM\"), 64);\n  return _prisma_termname;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"int8_t prisma_adapt(int8_t adaptation) {\n    char *termname;\n    if (adaptation == -1) {\n        termname = _prisma_trytogettermname();\n        if (!strcmp(termname, \"xterm\"))\n            _prisma_adaptation = 2;\n        else if (!strcmp(termname, \"konsole\"))\n            _prisma_adaptation = 1;\n        else if (!strcmp(termname, \"linux\") || !strcmp(termname, \"initdline\"))\n            _prisma_adaptation = 3;\n        else if (!strncmp(termname, \"windows\", 7))\n            _prisma_adaptation = 4;\n        else\n            _prisma_adaptation = 0;\n    } else\n        _prisma_adaptation = adaptation;\n    return _prisma_adaptation;\n}\n","function_prediction":"char prisma_adapt_name_conflict(char force) {\n  char *termname;\n\n  if (force != -1)\n    return _prisma_adapt_name_conflictation = force;\n\n  termname = _prisma_trytogettermname();\n\n  if (!strcmp(termname, \"xterm\"))\n    return _prisma_adapt_name_conflictation = 2;\n  else if (!strcmp(termname, \"konsole\"))\n    return _prisma_adapt_name_conflictation = 1;\n  else if (!strcmp(termname, \"linux\") || !strcmp(termname, \"initdline\"))\n    return _prisma_adapt_name_conflictation = 3;\n  else if (!strncmp(termname, \"windows\", 7))\n    return _prisma_adapt_name_conflictation = 4;\n  else\n    return _prisma_adapt_name_conflictation = 0;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint8_t prisma_argbto8color(uint32_t argb) {\n    argb = ((argb & 16711680) >= 8323072 ? 16711680 : 0) | ((argb & 65280) >= 32512 ? 65280 : 0) | ((argb & 255) >= 127 ? 255 : 0);\n    switch (argb) {\n      case 0:\n        return 0;\n      case 16711680:\n        return 1;\n      case 65280:\n        return 2;\n      case 16776960:\n        return 3;\n      case 255:\n        return 4;\n      case 16711935:\n        return 5;\n      case 65535:\n        return 6;\n      case 16777215:\n        return 7;\n    }\n}\n","function_prediction":"uint8_t prisma_argbto8color_name_conflict(uint32_t color) {\n  uint32_t r = (color & 0xff0000) > 0x7f0000 ? 0xff0000 : 0;\n  uint32_t g = (color & 0x00ff00) > 0x007f00 ? 0x00ff00 : 0;\n  uint32_t b = (color & 0x0000ff) > 0x00007f ? 0x0000ff : 0;\n\n  color = r | g | b;\n\n  if (color == 0xffffff)\n    return 7;\n  if (color == 0xffff00)\n    return 3;\n  if (color == 0xff00ff)\n    return 5;\n  if (color == 0xff0000)\n    return 1;\n  if (color == 0x00ffff)\n    return 6;\n  if (color == 0xff0000)\n    return 1;\n  if (color == 0x00ff00)\n    return 2;\n  if (color == 0x000000)\n    return 0;\n  if (color == 0x0000ff)\n    return 4;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint32_t prisma_8colortoargb(uint8_t src) {\n    switch (src) {\n      case 0:\n        return 4278190080U;\n      case 1:\n        return 4294901760U;\n      case 2:\n        return 4278255360U;\n      case 3:\n        return 4294967040U;\n      case 4:\n        return 4278190335U;\n      case 5:\n        return 4294902015U;\n      case 6:\n        return 4278255615U;\n      case 7:\n        return 4294967295U;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"unsigned int prisma_8colortoargb_name_conflict(unsigned char color) {\n  switch (color) {\n  case 0:\n    return 0x00000000;\n  case 1:\n    return 0x000000ff;\n  case 2:\n    return 0x0000ff00;\n  case 3:\n    return 0x0000ffff;\n  case 4:\n    return 0x00ff0000;\n  case 5:\n    return 0x00ff00ff;\n  case 6:\n    return 0x00ffff00;\n  case 7:\n    return 0x00ffffff;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint8_t prisma_argbtoxterm(uint32_t argb) {\n    uint8_t r, g, b;\n    prisma_argbtobytes(argb, ((void *)0), &r, &g, &b);\n    return ((r >= 4 && r <= 246 && r == g && g == b) ? (232 + ((r - 8) * 24 / 238)) : (16 + (36 * (r / 51)) + (6 * (g / 51)) + (b / 51)));\n}\n","function_prediction":"unsigned short prisma_argbtoxterm_name_conflict(unsigned int argb) {\n  unsigned char r, g, b;\n\n  prisma_argbtobytes(argb, 0, &r, &g, &b);\n\n  if (r < 4 || r > 246 || r != g || g != b)\n    return 16 + (r / 51) * 36 + (g / 51) * 6 + (b / 51);\n  else\n    return 232 + (r - 8) * 24 / 238;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint32_t prisma_xtermtoargb(uint8_t index) {\n    uint32_t argb;\n    if (index < 8) {\n        argb = prisma_8colortoargb(index);\n        if (argb == 4294967295U)\n            argb = 4290822336U;\n        else\n            argb = 4278190080U | ((argb & 16711680) != 0 ? 8388608 : 0) | ((argb & 65280) != 0 ? 32768 : 0) | ((argb & 255) != 0 ? 128 : 0);\n    } else if (index < 16) {\n        index -= 8;\n        argb = prisma_8colortoargb(index);\n        if (argb == 0)\n            argb = 4286611584U;\n    } else if (index < 232) {\n        index -= 16;\n        argb = 4278190080U | ((51 * (index / 36)) << 16) | ((51 * ((index % 36) / 6)) << 8) | (51 * (index % 6));\n    } else {\n        index -= 232;\n        argb = (8 + (10 * index));\n        argb |= 4278190080U | (argb << 16) | (argb << 8);\n    }\n    return argb;\n}\n","function_prediction":"int prisma_xtermtoargb_name_conflict(unsigned char c) {\n  if (c < 8) {\n    int rgb = prisma_8colortoargb(c);\n    if (rgb == -1)\n      return 0xffc0c0c0;\n    return (((rgb) & 0xff0000) ? 0xff800000 : 0xff000000) |\n           (((rgb) & 0x00ff00) ? 0x008000 : 0x000000) |\n           (((rgb) & 0x0000ff) ? 0x000080 : 0x000000);\n  }\n  if (c < 16) {\n    int rgb = prisma_8colortoargb(c - 8);\n    if (rgb == 0)\n      return 0xff808080;\n    return rgb;\n  }\n  if (c < 232) {\n    int r = (c - 16) / 36;\n    int g = ((c - 16) % 36) / 6;\n    int b = ((c - 16) % 36) % 6;\n    return (r * 0x330000) | (g * 0x3300) | (b * 0x33) | 0xff000000;\n  }\n  if (c < 256) {\n    int rgb = (c - 232 + 8) * 0x1000000;\n    return rgb | 0xff000000;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"const uint32_t *prisma_gradient(uint8_t resolution, uint32_t argb_first, uint32_t argb_last) {\n    static uint32_t gradient[256];\n    float i, a, r, g, b, offset;\n    memset(gradient, 0, 256 * sizeof(uint32_t));\n    if (resolution == 0)\n        return gradient;\n    if (resolution == 1) {\n        gradient[0] = argb_first;\n        return gradient;\n    }\n    gradient[0] = argb_first;\n    i = 1.F;\n    do {\n        if ((((argb_first) & 4278190080U) >> 24) < (((argb_last) & 4278190080U) >> 24)) {\n            offset = ((float)((((argb_last) & 4278190080U) >> 24) - (((argb_first) & 4278190080U) >> 24))) / (float)resolution;\n            a = (((argb_first) & 4278190080U) >> 24) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 4278190080U) >> 24) - (((argb_last) & 4278190080U) >> 24))) / (float)resolution;\n            a = (((argb_last) & 4278190080U) >> 24) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if ((((argb_first) & 16711680) >> 16) < (((argb_last) & 16711680) >> 16)) {\n            offset = ((float)((((argb_last) & 16711680) >> 16) - (((argb_first) & 16711680) >> 16))) / (float)resolution;\n            r = (((argb_first) & 16711680) >> 16) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 16711680) >> 16) - (((argb_last) & 16711680) >> 16))) / (float)resolution;\n            r = (((argb_last) & 16711680) >> 16) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if ((((argb_first) & 65280) >> 8) < (((argb_last) & 65280) >> 8)) {\n            offset = ((float)((((argb_last) & 65280) >> 8) - (((argb_first) & 65280) >> 8))) / (float)resolution;\n            g = (((argb_first) & 65280) >> 8) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 65280) >> 8) - (((argb_last) & 65280) >> 8))) / (float)resolution;\n            g = (((argb_last) & 65280) >> 8) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if (((argb_first) & 255) < ((argb_last) & 255)) {\n            offset = ((float)(((argb_last) & 255) - ((argb_first) & 255))) / (float)resolution;\n            b = ((argb_first) & 255) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)(((argb_first) & 255) - ((argb_last) & 255))) / (float)resolution;\n            b = ((argb_last) & 255) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        gradient[(uint8_t)i] = (((((uint8_t)a) << 24) & 4278190080U) | ((((uint8_t)r) << 16) & 16711680) | ((((uint8_t)g) << 8) & 65280) | (((uint8_t)b) & 255));\n        i++;\n    } while (i <= resolution && i != 0.F);\n    gradient[((uint8_t)i) - 2] = argb_last;\n    return gradient;\n}\n","function_prediction":"uint32_t *prisma_gradient_name_conflict(uint8_t steps, uint32_t start, uint32_t end) {\n  memset(gradient_0, 0, 256 * sizeof(uint32_t));\n\n  if (steps == 0)\n    return gradient_0;\n\n  gradient_0[0] = start;\n\n  if (steps == 1)\n    return gradient_0;\n\n  float step_size = (float)steps - 1.0f;\n  float step_start = 0.0f;\n  float step_end = 0.0f;\n\n  for (uint8_t i = 0; i < steps; i++) {\n    if (((start >> 24) & 0xFF) < ((end >> 24) & 0xFF)) {\n      step_start =\n          ceilf((step_size / step_size + step_start) *\n                ((float)((end >> 24) & 0xFF) - ((start >> 24) & 0xFF)) /\n                (float)steps);\n      step_start += (start >> 24) & 0xFF;\n    } else {\n      step_start =\n          ceilf((step_size / step_size + step_start) *\n                ((float)((start >> 24) & 0xFF) - ((end >> 24) & 0xFF)) /\n                (float)steps);\n      step_start = (end >> 24) & 0xFF - step_start;\n    }\n\n    if (((start >> 16) & 0xFF) < ((end >> 16) & 0xFF)) {\n      step_end = ceilf((step_size / step_size + step_end) *\n                       ((float)((end >> 16) & 0xFF) - ((start >> 16) & 0xFF)) /\n                       (float)steps);\n      step_end += (start >> 16) & 0xFF;\n    } else {\n            step_end = ceilf((step_size / step","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":1,"function":"static int main_ea_cycles(void) {\n    int l;\n    if (main_size == 4)\n        l = 4;\n    else\n        l = 0;\n    switch (main_eamode) {\n      case aind:\n        return (l + 4);\n      case ainc:\n        return (l + 4);\n      case adec:\n        return (l + 6);\n      case adsp:\n        return (l + 8);\n      case axdp:\n        return (l + 10);\n      case absw:\n        return (l + 8);\n      case absl:\n        return (l + 12);\n      case pcdp:\n        return (l + 8);\n      case pcxd:\n        return (l + 10);\n      case immd:\n        return (l + 4);\n      default:\n        break;\n    }\n    return 0;\n}\n","function_prediction":"int main_ea_cycles_name_conflict(void) {\n  int cycles = 0;\n\n  if (main_size == 4)\n    cycles += 4;\n\n  switch (main_eamode) {\n  case 2:\n    cycles += 4;\n    break;\n\n  case 3:\n    cycles += 4;\n    break;\n\n  case 4:\n    cycles += 6;\n    break;\n\n  case 5:\n    cycles += 8;\n    break;\n\n  case 6:\n    cycles += 10;\n    break;\n\n  case 7:\n    cycles += 8;\n    break;\n\n  case 8:\n    cycles += 12;\n    break;\n\n  case 9:\n    cycles += 8;\n    break;\n\n  case 10:\n    cycles += 10;\n    break;\n\n  case 11:\n    cycles += 4;\n    break;\n\n  default:\n    cycles = 0;\n    break;\n  }\n\n  return cycles;\n}","pass":1,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":1,"function":"static int main_ea_cycles_nofetch(void) {\n    switch (main_eamode) {\n      case aind:\n        return (2);\n      case ainc:\n        return (4);\n      case adec:\n        return (4);\n      case adsp:\n        return (4);\n      case axdp:\n        return (8);\n      case absw:\n        return (4);\n      case absl:\n        return (8);\n      default:\n        break;\n    }\n    return 0;\n}\n","function_prediction":"int main_ea_cycles_nofetch_name_conflict(void) {\n  switch (main_eamode) {\n  case 2:\n    return 2;\n  case 3:\n    return 4;\n  case 4:\n    return 4;\n  case 5:\n    return 4;\n  case 6:\n    return 8;\n  case 7:\n    return 4;\n  case 8:\n    return 8;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":1,"function":"static int test(int n, int m, int op) {\n    int t;\n    if ((n & m) != op)\n        return 0;\n    for (t = op & 61440; t < n; t++) {\n        if ((!unique[t]) && ((t & m) == (n & m))) {\n            rproc[n] = t;\n            return 2;\n        }\n    }\n    unique[n] = (m >> 16) & 1;\n    rproc[n] = n;\n    t = (m ^ 65535) & 4095;\n    if (!t) {\n        emit(\"; Opcode %04X\\n\", n);\n    } else {\n        emit(\"; Opcodes %04X - %04X\\n\", n, op + t);\n    }\n    emit(\"%c%03X:\\n\", ((n >> 12) & 15) + 'K', n & 4095);\n    routine_counter++;\n    return 1;\n}\n","function_prediction":"int test_name_conflict(int opc, int mask, int opc2) {\n  int i;\n\n  if ((opc & mask) != opc2)\n    return 0;\n\n  for (i = (opc2 & 0xf000); i < opc; i++)\n    if (unique[i] == 0 && (i & mask) == (opc & mask)) {\n      rproc[opc] = i;\n      return 2;\n    }\n\n  unique[opc] = (mask >> 16) & 1;\n  rproc[opc] = opc;\n\n  opc2 = (opc2 ^ 0xffff) & 0xfff;\n  if (opc2)\n    emit(\"; Opcodes %04X - %04X\\n\", opc, opc2 + opc2);\n  else\n    emit(\"; Opcode %04X\\n\", opc);\n\n  emit(\"%c%03X:\\n\", 'K' + ((opc >> 12) & 0xf), opc & 0xfff);\n  routine_counter++;\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":1,"function":"static char *getparameter(int *ip, int argc, char **argv) {\n    int i;\n    (*ip)++;\n    i = (*ip);\n    if (i >= argc) {\n        fprintf(stderr, \"Invalid use of %s option\\n\", argv[i - 1]);\n        return ((void *)0);\n    }\n    return argv[i];\n}\n","function_prediction":"char *getparameter_name_conflict(int *i, int argc, char *argv[]) {\n  (*i)++;\n  if (*i < argc)\n    return argv[*i];\n  else {\n    fprintf(stderr, \"Invalid use of %s option\\n\", argv[*i - 1]);\n    return NULL;\n  }\n}","pass":1,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":0,"function":"int set_interface_attribs(int fd, int speed, int parity) {\n    struct termios tty;\n    memset(&tty, 0, sizeof tty);\n    if (tcgetattr(fd, &tty) != 0) {\n        printf(\"error %d from tcgetattr\", (*__errno_location()));\n        return -1;\n    }\n    cfsetospeed(&tty, speed);\n    cfsetispeed(&tty, speed);\n    tty.c_cflag = (tty.c_cflag & ~48) | 48;\n    tty.c_iflag &= ~1;\n    tty.c_lflag = 0;\n    tty.c_oflag = 0;\n    tty.c_cc[6] = 0;\n    tty.c_cc[5] = 5;\n    tty.c_iflag &= ~(1024 | 4096 | 2048);\n    tty.c_cflag |= (2048 | 128);\n    tty.c_cflag &= ~(256 | 512);\n    tty.c_cflag |= parity;\n    tty.c_cflag &= ~64;\n    tty.c_cflag &= ~2147483648U;\n    if (tcsetattr(fd, 0, &tty) != 0) {\n        printf(\"error %d from tcsetattr\", (*__errno_location()));\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int set_interface_attribs_name_conflict(int fd, int speed, int parity) {\n  struct termios tty;\n  memset(&tty, 0, sizeof tty);\n  if (tcgetattr(fd, &tty) != 0) {\n    printf(\"error %d from tcgetattr\", errno);\n    return -1;\n  }\n\n  cfsetospeed(&tty, speed);\n  cfsetispeed(&tty, speed);\n\n  tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8;\n  tty.c_iflag &= ~IGNBRK;\n  tty.c_lflag = 0;\n  tty.c_oflag = 0;\n  tty.c_cc[VMIN] = 0;\n  tty.c_cc[VTIME] = 5;\n\n  tty.c_iflag &= ~(IXON | IXOFF | IXANY);\n\n  tty.c_cflag |= (CLOCAL | CREAD);\n  tty.c_cflag &= ~(PARENB | PARODD);\n  tty.c_cflag |= parity;\n  tty.c_cflag &= ~CSTOPB;\n  tty.c_cflag &= ~CRTSCTS;\n\n  if (tcsetattr(fd, 0, &tty) != 0) {\n    printf(\"error %d from tcsetattr\", errno);\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/abradner_homely/ard/tools/stdin-to-serial/serial.c"}
{"compilable":1,"function":"int extractLineNum(char *input) {\n    int n = strlen(input);\n    char *p = input + n - 1;\n    while (*p != ' ')\n        p--;\n    p++;\n    int lno = atoi(p);\n    *p = '\\x00';\n    return lno;\n}\n","function_prediction":"int extractLineNum_name_conflict(char *line) {\n  char *p;\n  int lineNum;\n\n  p = line + strlen(line) - 1;\n  while (*p != ' ')\n    p--;\n  lineNum = atoi(p + 1);\n  *(p + 1) = '\\0';\n  return lineNum;\n}","pass":0,"source_file":"C_COMPILE/anantsubramanian_graphL-compiler/src/parsetree_generator.c"}
{"compilable":1,"function":"char rotate(char dir) {\n    return (dir + 2) % 12;\n}\n","function_prediction":"char rotate_name_conflict(char c) { return (c + 2) % 24; }","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char flip(char dir) {\n    return (12 - dir) % 12;\n}\n","function_prediction":"char flip_name_conflict(char c) { return (12 - c) % 12; }","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char shift(char cell, char dir) {\n    switch (dir) {\n      case 0:\n        return cell + 1;\n      case 1:\n        if ((cell / 5) % 2)\n            return cell + 7;\n        else\n            return cell + 6;\n      case 2:\n        if ((cell / 5) % 2)\n            return cell + 6;\n        else\n            return cell + 5;\n      case 3:\n        return cell + 10;\n      case 4:\n        if ((cell / 5) % 2)\n            return cell + 5;\n        else\n            return cell + 4;\n      case 5:\n        if ((cell / 5) % 2)\n            return cell + 4;\n        else\n            return cell + 3;\n      case 6:\n        return cell - 1;\n      case 7:\n        if ((cell / 5) % 2)\n            return cell - 6;\n        else\n            return cell - 7;\n      case 8:\n        if ((cell / 5) % 2)\n            return cell - 5;\n        else\n            return cell - 6;\n      case 9:\n        return cell - 10;\n      case 10:\n        if ((cell / 5) % 2)\n            return cell - 4;\n        else\n            return cell - 5;\n      case 11:\n        if ((cell / 5) % 2)\n            return cell - 3;\n        else\n            return cell - 4;\n      default:\n        return cell;\n    }\n}\n","function_prediction":"char shift_name_conflict(char c, char s) {\n  switch (s) {\n  case 0:\n    return c + 1;\n  case 1:\n    if (c % 5 == 0)\n      return c + 7;\n    else\n      return c + 6;\n  case 2:\n    if (c % 5 == 0)\n      return c + 6;\n    else\n      return c + 5;\n  case 3:\n    return c + 10;\n  case 4:\n    if (c % 5 == 0)\n      return c + 5;\n    else\n      return c + 4;\n  case 5:\n    if (c % 5 == 0)\n      return c + 4;\n    else\n      return c + 3;\n  case 6:\n    return c - 1;\n  case 7:\n    if (c % 5 == 0)\n      return c - 6;\n    else\n      return c - 7;\n  case 8:\n    if (c % 5 == 0)\n      return c - 5;\n    else\n      return c - 6;\n  case 9:\n    return c - 10;\n  case 10:\n    if (c % 5 == 0)\n      return c - 4;\n    else\n      return c - 5;\n  case 11:\n    if (c % 5 == 0)\n      return c - 3;\n    else\n      return c - 4;\n  default:\n    return c;\n  }\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char out_of_bounds(char cell, char dir) {\n    char i;\n    switch (dir) {\n      case 0:\n        return cell % 5 == 4;\n      case 1:\n        i = cell % 10;\n        return i == 4 || i == 8 || i == 9 || cell >= 45;\n      case 2:\n        return cell % 10 == 9 || cell >= 45;\n      case 3:\n        return cell >= 40;\n      case 4:\n        return cell % 10 == 0 || cell >= 45;\n      case 5:\n        i = cell % 10;\n        return i == 0 || i == 1 || i == 5 || cell >= 45;\n      case 6:\n        return cell % 5 == 0;\n      case 7:\n        i = cell % 10;\n        return i == 0 || i == 1 || i == 5 || cell < 5;\n      case 8:\n        return cell % 10 == 0 || cell < 5;\n      case 9:\n        return cell < 10;\n      case 10:\n        return cell % 10 == 9 || cell < 5;\n      case 11:\n        i = cell % 10;\n        return i == 4 || i == 8 || i == 9 || cell < 5;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int out_of_bounds_name_conflict(char c, int i) {\n  switch (i) {\n  case 0:\n    return (c % 5) == 4;\n  case 1:\n    return (c % 10) == 4 || (c % 10) == 8 || (c % 10) == 9 || (c % 10) == 10;\n  case 2:\n    return (c % 10) == 9 || (c % 10) == 10;\n  case 3:\n    return c > 39;\n  case 4:\n    return (c % 10) == 0 || (c % 10) == 10;\n  case 5:\n    return (c % 10) == 0 || (c % 10) == 1 || (c % 10) == 5 || (c % 10) == 10;\n  case 6:\n    return (c % 5) == 0;\n  case 7:\n    return (c % 10) == 0 || (c % 10) == 1 || (c % 10) == 5 || c < 5;\n  case 8:\n    return (c % 10) == 0 || c < 5;\n  case 9:\n    return c < 10;\n  case 10:\n    return (c % 10) == 9 || c < 5;\n  case 11:\n    return (c % 10) == 4 || (c % 10) == 8 || (c % 10) == 9 || c < 5;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int cells_fit_on_board(char *cell, int piece) {\n    return (!out_of_bounds(cell[0], piece_def[piece][0]) && !out_of_bounds(cell[1], piece_def[piece][1]) && !out_of_bounds(cell[2], piece_def[piece][2]) && !out_of_bounds(cell[3], piece_def[piece][3]));\n}\n","function_prediction":"int cells_fit_on_board_name_conflict(const char *cells, int piece) {\n  return !out_of_bounds(cells[0], piece_def[piece].x) &&\n         !out_of_bounds(cells[1], piece_def[piece].y) &&\n         !out_of_bounds(cells[2], piece_def[piece].x) &&\n         !out_of_bounds(cells[3], piece_def[piece].y);\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char minimum_of_cells(char *cell) {\n    char minimum = cell[0];\n    minimum = cell[1] < minimum ? cell[1] : minimum;\n    minimum = cell[2] < minimum ? cell[2] : minimum;\n    minimum = cell[3] < minimum ? cell[3] : minimum;\n    minimum = cell[4] < minimum ? cell[4] : minimum;\n    return minimum;\n}\n","function_prediction":"char minimum_of_cells_name_conflict(char *cells) {\n  char min = cells[0];\n  for (int i = 1; i < 5; i++) {\n    if (cells[i] < min) {\n      min = cells[i];\n    }\n  }\n  return min;\n}","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char first_empty_cell(char *cell, char minimum) {\n    char first_empty = minimum;\n    while (first_empty == cell[0] || first_empty == cell[1] || first_empty == cell[2] || first_empty == cell[3] || first_empty == cell[4])\n        first_empty++;\n    return first_empty;\n}\n","function_prediction":"char first_empty_cell_name_conflict(char *board, char player) {\n  char i;\n  for (i = player; board[i - 1] == player || board[i - 2] == player ||\n                   board[i - 3] == player || board[i - 4] == player;\n       i++)\n    ;\n  return i;\n}","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"unsigned long long bitmask_from_cells(char *cell) {\n    unsigned long long piece_mask = 0ULL;\n    int i;\n    for (i = 0; i < 5; i++)\n        piece_mask |= 1ULL << cell[i];\n    return piece_mask;\n}\n","function_prediction":"uint64_t bitmask_from_cells_name_conflict(const uint8_t cells[5]) {\n  uint64_t mask = 0;\n  for (int i = 0; i < 5; i++)\n    mask |= (uint64_t)1 << (cells[i] & 0x3f);\n  return mask;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"int has_island(char *cell, int piece) {\n    char temp_board[50];\n    char c;\n    int i;\n    for (i = 0; i < 50; i++)\n        temp_board[i] = 0;\n    for (i = 0; i < 5; i++)\n        temp_board[((int)cell[i])] = 1;\n    i = 49;\n    while (temp_board[i] == 1)\n        i--;\n    fill_contiguous_space(temp_board, i);\n    c = 0;\n    for (i = 0; i < 50; i++)\n        if (temp_board[i] == 0)\n            c++;\n    if (c == 0 || (c == 5 && piece == 8) || (c == 40 && piece == 8) || (c % 5 == 0 && piece == 0))\n        return 0;\n    else\n        return 1;\n}\n","function_prediction":"int has_island_name_conflict(char *s, int n) {\n  char island[50];\n  int i, j;\n\n  for (i = 0; i < 50; i++)\n    island[i] = 0;\n\n  for (i = 0; i < 5; i++)\n    island[s[i]] = 1;\n\n  for (i = 50 - 1; island[i] == 1; i--)\n    ;\n\n  fill_contiguous_space(island, i);\n\n  j = 0;\n  for (i = 0; i < 50; i++)\n    if (island[i] == 0)\n      j++;\n\n  if (j == 0 || (j == 5 && n == 8) || (j == 4 && n == 8) ||\n      (j == j / 5 * 5 && n == 0))\n    return 0;\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"int rows_bad(char row1, char row2, int even) {\n    int i, in_zeroes, group_okay;\n    char block, row2_shift;\n    if (even)\n        row2_shift = ((row2 << 1) & 31) | 1;\n    else\n        row2_shift = (row2 >> 1) | 16;\n    block = ((row1 ^ row2) & row2) & ((row1 ^ row2_shift) & row2_shift);\n    in_zeroes = 0;\n    group_okay = 0;\n    for (i = 0; i < 5; i++) {\n        if (row1 & (1 << i)) {\n            if (in_zeroes) {\n                if (!group_okay)\n                    return 1;\n                in_zeroes = 0;\n                group_okay = 0;\n            }\n        } else {\n            if (!in_zeroes)\n                in_zeroes = 1;\n            if (!(block & (1 << i)))\n                group_okay = 1;\n        }\n    }\n    if (in_zeroes)\n        return !group_okay;\n    else\n        return 0;\n}\n","function_prediction":"int rows_bad_name_conflict(char row, char col, int flip) {\n  int i, bad_row = 0, bad_col = 0;\n  char mask;\n\n  if (flip)\n    mask = (col << 1) & 0x1e | 0x01;\n  else\n    mask = (col >> 1) | 0x10;\n\n  for (i = 0; i < 5; i++) {\n    if (row & (1 << i)) {\n      if (bad_row) {\n        if (bad_col)\n          return 1;\n        bad_row = 0;\n        bad_col = 0;\n      }\n    } else {\n      if (!bad_row)\n        bad_row = 1;\n      if (!(~row & col & mask))\n        bad_col = 1;\n    }\n  }\n  return bad_row && !bad_col;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"int triple_is_okay(char row1, char row2, char row3, int even) {\n    if (even) {\n        return ((row1 == 3) && (row2 == 11) && ((row3 & 28) == 12)) || ((row1 == 1) && (row2 == 5) && (row3 == 6)) || ((row1 == 25) && (row2 == 17)) || ((row1 == 21) && (row2 == 17));\n    } else {\n        return ((row1 == 19) && (row2 == 17)) || ((row1 == 21) && (row2 == 17));\n    }\n}\n","function_prediction":"int triple_is_okay_name_conflict(char a, char b, char c, int is_triple) {\n  if (is_triple) {\n    if ((a == 3 && b == 5 && c == 6) || (a == 1 && b == 5 && c == 6) ||\n        (a == 25 && b == 17 && c == 6) || (a == 21 && b == 17 && c == 6))\n      return 1;\n    else\n      return 0;\n  } else {\n    if ((a == 19 && b == 17) || (a == 21 && b == 17))\n      return 1;\n    else\n      return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int boardHasIslands(char cell) {\n    if (cell >= 40)\n        return 0;\n    int current_triple = (board >> ((cell / 5) * 5)) & 32767;\n    if ((cell / 5) % 2)\n        return bad_odd_triple[current_triple];\n    else\n        return bad_even_triple[current_triple];\n}\n","function_prediction":"int boardHasIslands_name_conflict(char pos) {\n  if (pos >= 12)\n    return 0;\n  int row = pos / 5;\n  int col = pos % 5;\n  int mask = (board.triple[row] >> (col * 11)) & 0x7fff;\n  if (row % 2 == 0) {\n    return bad_even_triple[mask];\n  } else {\n    return bad_odd_triple[mask];\n  }\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"static long fannkuch(int n) {\n    int *perm;\n    int *perm1;\n    int *count;\n    long flips;\n    long flipsMax;\n    int r;\n    int i;\n    int k;\n    int didpr;\n    const int n1 = n - 1;\n    if (n < 1)\n        return 0;\n    perm = calloc(n, sizeof (*perm));\n    perm1 = calloc(n, sizeof (*perm1));\n    count = calloc(n, sizeof (*count));\n    for (i = 0; i < n; ++i)\n        perm1[i] = i;\n    r = n;\n    didpr = 0;\n    flipsMax = 0;\n    for (;;) {\n        if (didpr < 30) {\n            for (i = 0; i < n; ++i)\n                printf(\"%d\", (int)(1 + perm1[i]));\n            printf(\"\\n\");\n            ++didpr;\n        }\n        for (; r != 1; --r) {\n            count[r - 1] = r;\n        }\n        if (!(perm1[0] == 0 || perm1[n1] == n1)) {\n            flips = 0;\n            for (i = 1; i < n; ++i) {\n                perm[i] = perm1[i];\n            }\n            k = perm1[0];\n            do {\n                int j;\n                for (i = 1 , j = k - 1; i < j; ++i , --j) {\n                    {\n                        int t_mp;\n                        t_mp = (perm[i]);\n                        (perm[i]) = (perm[j]);\n                        (perm[j]) = t_mp;\n                    }\n                }\n                ++flips;\n                j = perm[k];\n                perm[k] = k;\n                k = j;\n            } while (k);\n            if (flipsMax < flips) {\n                flipsMax = flips;\n            }\n        }\n        for (;;) {\n            if (r == n) {\n                return flipsMax;\n            }\n            {\n                int perm0 = perm1[0];\n                i = 0;\n                while (i < r)\n                    {\n                        k = i + 1;\n                        perm1[i] = perm1[k];\n                        i = k;\n                    }\n                perm1[r] = perm0;\n            }\n            if ((count[r] -= 1) > 0) {\n                break;\n            }\n            ++r;\n        }\n    }\n}\n","function_prediction":"long fannkuch_name_conflict(int n) {\n  int i, j, count, *perm, *perm0, *sign, *tmp, *tmp2;\n  long maxflips, flips;\n\n  if (n < 1)\n    return 0;\n\n  perm = (int *)calloc(n, sizeof(int));\n  perm0 = (int *)calloc(n, sizeof(int));\n  sign = (int *)calloc(n, sizeof(int));\n\n  for (i = 0; i < n; i++)\n    perm0[i] = i;\n\n  count = 0;\n  maxflips = 0;\n\n  for (i = 0; i < n;) {\n    if (count < 30) {\n      for (j = 0; j < n; j++)\n        printf(\"%d\", perm0[j] + 1);\n      printf(\"\\n\");\n      count++;\n    }\n\n    for (j = n - 1; j > 0; j--) {\n      sign[j] = j + 1;\n    }\n\n    for (flips = 0;;) {\n      if (perm0[0] == 0)\n        break;\n\n      if (perm0[0] == n - 1 && perm0[n - 1] == 0)\n        return maxflips;\n\n      for (j = 1; j < n; j++)\n        perm[j] = perm0[j];\n\n      tmp = perm + n;\n      tmp2 = perm + perm0[0];\n\n      do {\n        int x = *tmp2;\n        *tmp2 = n - 1;\n        if (x == 0)\n          break;\n        tmp = perm + x;\n        tmp2 = perm + n - 1;\n        do {\n          int y = *tmp;\n          *tmp = *tmp2;\n          *tmp2 = y;\n          tmp2 = perm + y;\n        } while (--x);\n      } while (1);\n\n      if (flips < ++flips)\n        maxflips = flips;\n\n      while (1) {\n        int newn;\n        for (newn = 0; newn < n; new","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/fannkuch.c"}
{"compilable":1,"function":"int errex(char *s, int n) {\n    fprintf(stderr, \"\\n*** Error: %s [%d]!\\n\", s, n);\n    return 1;\n}\n","function_prediction":"int errex_name_conflict(char *msg, int err) {\n  fprintf(stderr, \"\\n*** Error: %s [%d]!\\n\", msg, err);\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/reverse-complement.c"}
{"compilable":0,"function":"treeNode *NewTreeNode(treeNode *left, treeNode *right, long item) {\n    treeNode *new;\n    new = (treeNode *)malloc(sizeof(treeNode));\n    new->left = left;\n    new->right = right;\n    new->item = item;\n    return new;\n}\n","function_prediction":"TreeNode *NewTreeNode_name_conflict(void *data, TreeNode *left, TreeNode *right) {\n  TreeNode *node = (TreeNode *)malloc(sizeof(TreeNode));\n  node->data = data;\n  node->left = left;\n  node->right = right;\n  return node;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":0,"function":"long ItemCheck(treeNode *tree) {\n    if (tree->left == ((void *)0))\n        return tree->item;\n    else\n        return tree->item + ItemCheck(tree->left) - ItemCheck(tree->right);\n}\n","function_prediction":"long ItemCheck_name_conflict(Item *i) {\n  if (i->left == NULL)\n    return i->value;\n  else\n    return i->value + ItemCheck_name_conflict(i->left) - ItemCheck_name_conflict(i->right);\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":0,"function":"treeNode *BottomUpTree(long item, unsigned int depth) {\n    if (depth > 0)\n        return NewTreeNode(BottomUpTree(2 * item - 1, depth - 1), BottomUpTree(2 * item, depth - 1), item);\n    else\n        return NewTreeNode(((void *)0), ((void *)0), item);\n}\n","function_prediction":"TreeNode *BottomUpTree_name_conflict(int n, int height) {\n  if (height == 0)\n    return NewTreeNode(NULL, NULL, n);\n  return NewTreeNode(BottomUpTree_name_conflict(2 * n - 1, height - 1),\n                     BottomUpTree_name_conflict(2 * n, height - 1), n);\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":0,"function":"INT32 HTTPSendFile(HTTP_SESSION_HANDLE pSession, CHAR *FilePath) {\n    UINT32 ret = 0;\n    char *buf, p;\n    int buf_size = 0, sent_size;\n    FILE *f;\n    buf = (char *)malloc(65536);\n    f = fopen(FilePath, \"rb\");\n    if (!f) {\n        ret = 1;\n        return ret;\n    }\n    while ((buf_size = fread(buf, 1, 65536, f)) != 0)\n        {\n            ret = HTTPClientWriteData(pSession, buf, buf_size, 5);\n            if (ret != 0) {\n                break;\n            }\n        }\n    return ret;\n}\n","function_prediction":"int HTTPSendFile_name_conflict(HTTPClient *client, const char *filename) {\n  int ret = 0;\n  char *buffer = malloc(65536);\n  FILE *fp = fopen(filename, \"rb\");\n  if (fp == NULL) {\n    ret = 1;\n  } else {\n    int read;\n    while ((read = fread(buffer, 1, 65536, fp)) != 0) {\n      ret = HTTPClientWriteData(client, buffer, read, 5);\n      if (ret != 0) {\n        break;\n      }\n    }\n  }\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSample.c"}
{"compilable":0,"function":"INT32 HTTPParseCommandLineArgs(UINT32 argc, CHAR *argv[], HTTPParameters *pClientParams) {\n    UINT32 nArg;\n    UINT32 nResult;\n    CHAR *pSearchPtr = ((void *)0);\n    CHAR PortNum[64];\n    if (argc <= 1) {\n        HTTPDumpHelp(\"Error: did not get key parameters.\");\n        return -1;\n    }\n    ;\n    for (nArg = 1; nArg < argc; nArg++) {\n        if (strncasecmp(argv[nArg], \"/?\", 2) == 0) {\n            HTTPDumpHelp(((void *)0));\n            return -1;\n        }\n        if (strncasecmp(argv[nArg], \"/V\", 2) == 0) {\n            pClientParams->Verbose = 1;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H:\", 3) == 0) {\n            strcpy(pClientParams->Uri, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/R:\", 3) == 0) {\n            strcpy(pClientParams->ProxyHost, argv[nArg] + 3);\n            pClientParams->UseProxy = 1;\n            pSearchPtr = strstr(pClientParams->ProxyHost, \":\");\n            if (pSearchPtr) {\n                PortNum[0] = 0;\n                nResult = (int)(pSearchPtr - pClientParams->ProxyHost);\n                strcpy(PortNum, pClientParams->ProxyHost + nResult + 1);\n                pClientParams->ProxyHost[nResult] = 0;\n                pClientParams->ProxyPort = atol(PortNum);\n            } else {\n                pClientParams->ProxyPort = 8080;\n            }\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/C:\", 3) == 0) {\n            strcpy(pClientParams->UserName, argv[nArg] + 3);\n            pSearchPtr = strstr(pClientParams->UserName, \":\");\n            if (!pSearchPtr) {\n                HTTPDumpHelp(\"Error: /C argument must be in the form of user:password\");\n                return -1;\n            }\n            nResult = (int)(pSearchPtr - pClientParams->UserName);\n            strcpy(pClientParams->Password, pClientParams->UserName + nResult + 1);\n            pClientParams->UserName[nResult] = 0;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/A:\", 3) == 0) {\n            pSearchPtr = argv[nArg] + 3;\n            if (*pSearchPtr == 'b' || *pSearchPtr == 'B') {\n                pClientParams->AuthType = AuthSchemaBasic;\n                continue;\n            }\n            if (*pSearchPtr == 'd' || *pSearchPtr == 'D') {\n                pClientParams->AuthType = AuthSchemaDigest;\n                continue;\n            }\n            if (pClientParams->AuthType == AuthSchemaNone) {\n                HTTPDumpHelp(\"Error: /A argument must be 'b' (for basic) or 'd' (for digest)\");\n                return -1;\n            }\n        }\n        if (strncasecmp(argv[nArg], \"/D:\", 3) == 0) {\n            strcpy(pClientParams->PostData, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/F:\", 3) == 0) {\n            strcpy(pClientParams->PutFilePath, argv[nArg] + 3);\n            continue;\n        }\n    }\n    if (strlen(pClientParams->Uri) == 0) {\n        HTTPDumpHelp(\"Error: /H argument is missing\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int HTTPParseCommandLineArgs(int argc, char *argv[],\n                             HTTP_SERVER_CONFIG *pConfig) {\n  char *p;\n  int i;\n  char temp[64];\n\n  if (argc < 2) {\n    HTTPDumpHelp(\"Error: did not get key parameters.\");\n    return -1;\n  }\n\n  for (i = 1; i < argc; i++) {\n    if (!strncasecmp(argv[i], \"/?\", 2)) {\n      HTTPDumpHelp(NULL);\n      return -1;\n    }\n\n    if (!strncasecmp(argv[i], \"/V\", 2)) {\n      pConfig->verbose = 1;\n    } else if (!strncasecmp(argv[i], \"/H:\", 3)) {\n      strcpy(pConfig->host, argv[i] + 3);\n    } else if (!strncasecmp(argv[i], \"/R:\", 3)) {\n      strcpy(pConfig->root, argv[i] + 3);\n      pConfig->root_specified = 1;\n\n      p = strchr(pConfig->root, ':');\n      if (p) {\n        temp[0] = 0;\n        i = p - pConfig->root;\n        strcpy(temp, pConfig->root + i + 1);\n        pConfig->root[i] = 0;\n        pConfig->port = atol(temp);\n      } else {\n        pConfig->port = 8080;\n      }\n    } else if (!strncasecmp(argv[i], \"/C:\", 3)) {\n      strcpy(pConfig->credentials, argv[i] + 3);\n      p = strchr(pConfig->credentials, ':');\n      if (p) {\n        i = p - pConfig->credentials;\n                strcpy(pConfig->password, pConfig","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSample.c"}
{"compilable":0,"function":"BOOL HTTPStrInsensitiveCompare(CHAR *pSrc, CHAR *pDest, UINT32 nLength) {\n    UINT32 nPosition;\n    UINT32 nDestLength;\n    CHAR *pSrcIn, *pDestIn;\n    CHAR a, b;\n    pSrcIn = pSrc;\n    pDestIn = pDest;\n    nPosition = 0;\n    nDestLength = strlen(pDest);\n    if (nLength == 0) {\n        nLength = strlen(pSrc);\n    }\n    if (nDestLength != nLength) {\n        return 0;\n    }\n    while (pSrcIn || pDestIn)\n        {\n            if (nLength > 0 && nPosition == nLength) {\n                return 1;\n            }\n            a = *pSrcIn;\n            b = *pDestIn;\n            if (*pSrcIn >= 64 && *pSrcIn <= 90) {\n                a = *pSrcIn + 32;\n            }\n            if (*pDestIn >= 64 && *pDestIn <= 90) {\n                b = *pDestIn + 32;\n            }\n            if (a != b) {\n                return 0;\n            }\n            pSrcIn++;\n            pDestIn++;\n            nPosition++;\n        }\n    return 1;\n}\n","function_prediction":"int HTTPStrInsensitiveCompare_name_conflict(const char *s1, const char *s2, int len) {\n  int i = 0;\n  int l2 = strlen(s2);\n\n  if (len == 0)\n    len = strlen(s1);\n\n  while (1) {\n    char c1, c2;\n\n    if (l2 != len)\n      return 0;\n\n    if (s1 == NULL && s2 == NULL)\n      return 1;\n\n    if (len != 0 && i == len)\n      return 1;\n\n    c1 = *s1;\n    c2 = *s2;\n\n    if (c1 >= 'A' && c1 <= 'Z')\n      c1 += 32;\n\n    if (c2 >= 'A' && c2 <= 'Z')\n      c2 += 32;\n\n    if (c1 != c2)\n      return 0;\n\n    s1++;\n    s2++;\n    i++;\n  }\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR HTTPStrExtract(CHAR *pParam, UINT32 nOffset, CHAR Restore) {\n    CHAR Replaced;\n    if (!pParam) {\n        return 0;\n    }\n    if (Restore != 0) {\n        pParam[nOffset] = Restore;\n        return Restore;\n    } else {\n        Replaced = pParam[nOffset];\n        pParam[nOffset] = 0;\n        return Replaced;\n    }\n}\n","function_prediction":"char HTTPStrExtract_name_conflict(char *str, int pos, char c) {\n  if (str == NULL)\n    return '\\0';\n\n  if (c == '\\0') {\n    c = str[pos];\n    str[pos] = '\\0';\n  } else\n    str[pos] = c;\n\n  return c;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrCaseStr(const char *pSrc, UINT32 nSrcLength, const char *pFind) {\n    const char *ptr = pSrc;\n    const char *ptr2;\n    UINT32 iLength = 0;\n    while (1)\n        {\n            if (iLength >= nSrcLength) {\n                break;\n            }\n            ptr = strchr((char *)pSrc, toupper((int)*pFind));\n            ptr2 = strchr((char *)pSrc, tolower((int)*pFind));\n            if (!ptr) {\n                ptr = ptr2;\n            }\n            if (!ptr) {\n                break;\n            }\n            if (ptr2 && (ptr2 < ptr)) {\n                ptr = ptr2;\n            }\n            if (!strncasecmp(ptr, pFind, strlen(pFind))) {\n                return (char *)ptr;\n            }\n            pSrc = ptr + 1;\n            iLength++;\n        }\n    return 0;\n}\n","function_prediction":"char *HTTPStrCaseStr_name_conflict(char *s, unsigned int max, char *find) {\n  char *p, *p1, *p2;\n  unsigned int i;\n\n  for (i = 0, p = s; i < max; i++, p++) {\n    p1 = strchr(p, toupper(*find));\n    p2 = strchr(p, tolower(*find));\n    if (p1 == NULL)\n      p1 = p2;\n    if (p1 == NULL)\n      return NULL;\n    if (p2 != NULL && p1 > p2)\n      p1 = p2;\n    if (!strncasecmp(p1, find, strlen(find)))\n      return p1;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrGetToken(CHAR *pSrc, UINT32 nSrcLength, CHAR *pDest, UINT32 *nDestLength) {\n    CHAR *pStart = pSrc;\n    CHAR *pEnd;\n    UINT32 nTokenLength = 0;\n    UINT32 nPosition = 0;\n    pStart = strchr(pSrc, ':') + 1;\n    if (pStart) {\n        pEnd = pStart;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    nTokenLength++;\n                }\n                if (nSrcLength && nPosition > nSrcLength) {\n                    break;\n                }\n                pEnd++;\n                nPosition++;\n            }\n        if (nTokenLength > *(nDestLength)) {\n            *(nDestLength) = nTokenLength;\n            pDest = ((void *)0);\n            return pDest;\n        }\n        pEnd = pStart;\n        *(nDestLength) = nTokenLength;\n        nTokenLength = 0;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    pDest[nTokenLength++] = *pEnd;\n                }\n                pEnd++;\n            }\n        pDest[nTokenLength] = 0;\n    }\n    return pDest;\n}\n","function_prediction":"char *HTTPStrGetToken(char *str, unsigned int maxlen, char *token,\n                      unsigned int *len) {\n  unsigned int i = 0, j = 0;\n  char *p = strchr(str, ':');\n\n  if (p == NULL)\n    return NULL;\n\n  p++;\n\n  while (*p != '\\0' && *p != '\\r' && *p != '\\n') {\n    if (*p != ' ')\n      i++;\n\n    if (maxlen > 0 && j > maxlen)\n      break;\n\n    j++;\n    p++;\n  }\n\n  if (i > *len) {\n    *len = i;\n    return NULL;\n  }\n\n  *len = i;\n  i = 0;\n\n  while (*p != '\\0' && *p != '\\r' && *p != '\\n') {\n    if (*p != ' ') {\n      token[i] = *p;\n      i++;\n    }\n\n    p++;\n  }\n\n  token[i] = '\\0';\n\n  return token;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"UINT32 HTTPStrHToL(CHAR *s) {\n    UINT32 i, nn, digit;\n    UINT32 n;\n    n = i = nn = 0;\n    do {\n        if (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalnum)) {\n            s[i] = toupper((int)s[i]);\n            if (s[i] == 'X')\n                nn = n = 0;\n            else {\n                digit = (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalpha) ? (s[i] - 'A' + 10) : s[i] - '0');\n                if (digit > 15)\n                    digit = 15;\n                n = n * 16 + digit;\n                if (n |= 0)\n                    nn++;\n                if (nn == 8)\n                    break;\n            }\n        }\n        i++;\n    } while (s[i] |= 0);\n    return n;\n}\n","function_prediction":"unsigned long HTTPStrHToL_name_conflict(char *str) {\n  unsigned long result = 0;\n  unsigned int i = 0;\n  unsigned int j = 0;\n  unsigned int value;\n\n  while (1) {\n    if (__ctype_b_loc()[(unsigned char)str[i]] & 0x08) {\n      str[i] = toupper(str[i]);\n      if (str[i] == 'X') {\n        result = 0;\n        j = 0;\n      } else {\n        if (__ctype_b_loc()[(unsigned char)str[i]] & 0x400)\n          value = str[i] - 'A' + 10;\n        else\n          value = str[i] - '0';\n\n        if (value > 15)\n          value = 15;\n\n        result = result * 16 + value;\n        if (result)\n          j++;\n        if (j == 8)\n          break;\n      }\n    }\n    i++;\n    str[i] = str[i];\n    if (str[i] == '\\0')\n      break;\n  }\n\n  return result;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrLToH(CHAR *dest, UINT32 nSrc) {\n    char *hex = \"0123456789abcdef\";\n    int i;\n    if (nSrc == 0) {\n        dest[0] = '0';\n        dest[1] = 0;\n    } else {\n        for (i = 28; ((nSrc >> i) && 15) == 0; i -= 4)\n            ;\n        for (; i >= 0; i -= 4) {\n            *dest++ = hex[(nSrc >> i) & 15];\n        }\n        *dest = 0;\n    }\n    return dest;\n}\n","function_prediction":"char *HTTPStrLToH_name_conflict(char *s, unsigned long l) {\n  char *p = s;\n  int i;\n\n  if (l == 0) {\n    *p++ = '0';\n    *p = '\\0';\n    return p;\n  }\n\n  for (i = 28; (l >> i) == 0; i -= 4)\n    ;\n\n  for (; i >= 0; i -= 4) {\n    *p++ = \"0123456789abcdef\"[(l >> i) & 0x0f];\n  }\n\n  *p = '\\0';\n  return p;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"int HTTPWrapperIsAscii(int c) {\n    return (!(c & ~127));\n}\n","function_prediction":"int HTTPWrapperIsAscii_name_conflict(int c) { return (c & 0x80) == 0; }","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToUpper(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 97 && c <= 122) {\n            return (c - 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"int HTTPWrapperToUpper_name_conflict(int c) {\n  if (HTTPWrapperIsAscii(c) > 0 && c >= 'a' && c <= 'z')\n    c -= 'a' - 'A';\n  return c;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToLower(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 65 && c <= 90) {\n            return (c + 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"int HTTPWrapperToLower_name_conflict(int c) {\n  if (HTTPWrapperIsAscii(c) > 0 && c >= 'A' && c <= 'Z')\n    c += 'a' - 'A';\n  return c;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlpha(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90)) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int HTTPWrapperIsAlpha_name_conflict(int c) {\n  return HTTPWrapperIsAscii(c) &&\n         (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')));\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlNum(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (HTTPWrapperIsAlpha(c) > 0) {\n            return c;\n        }\n        if (c >= 48 && c <= 57) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int HTTPWrapperIsAlNum_name_conflict(int c) {\n  return (HTTPWrapperIsAscii(c) > 0 &&\n          (HTTPWrapperIsAlpha(c) > 0 || (c >= '0' && c <= '9')));\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"char *HTTPWrapperItoa(char *s, int a) {\n    unsigned int b;\n    if (a > 2147483647) {\n        return 0;\n    }\n    if (a < 0)\n        b = -a , *s++ = '-';\n    else\n        b = a;\n    for (; a; a = a / 10)\n        s++;\n    for (*s = '\\x00'; b; b = b / 10)\n        *--s = b % 10 + '0';\n    return s;\n}\n","function_prediction":"char *HTTPWrapperItoa_name_conflict(char *s, int n) {\n  int i, sign;\n\n  if ((sign = n) < 0)\n    n = -n;\n  i = 0;\n  do {\n    s[i++] = n % 10 + '0';\n  } while ((n /= 10) != 0);\n  if (sign < 0)\n    s[i++] = '-';\n  s[i] = '\\0';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperShutDown(int s, int how) {\n    return shutdown(s, how);\n}\n","function_prediction":"int HTTPWrapperShutDown_name_conflict(int sock, int how) { return shutdown(sock, how); }","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetSocketError(int s) {\n    return (*__errno_location());\n}\n","function_prediction":"int HTTPWrapperGetSocketError_name_conflict() { return *__errno_location(); }","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetHostByName(char *name, UINT32 *address) {\n    HTTP_HOSTNET *HostEntry;\n    int iPos = 0, iLen = 0, iNumPos = 0, iDots = 0;\n    long iIPElement;\n    char c = 0;\n    char Num[4];\n    int iHostType = 0;\n    iLen = strlen(name);\n    for (iPos = 0; iPos <= iLen; iPos++) {\n        c = name[iPos];\n        if ((c >= 48 && c <= 57) || (c == '.')) {\n            if (c != '.') {\n                if (iNumPos > 3) {\n                    iHostType++;\n                    break;\n                }\n                Num[iNumPos] = c;\n                Num[iNumPos + 1] = 0;\n                iNumPos++;\n            } else {\n                iNumPos = 0;\n                iDots++;\n                iIPElement = atol(Num);\n                if (iIPElement > 256 || iDots > 3) {\n                    return -1;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n    if (c == 0 && iHostType == 0 && iDots == 3) {\n        iIPElement = atol(Num);\n        if (iIPElement > 256) {\n            return -1;\n        }\n    } else {\n        iHostType++;\n    }\n    if (iHostType > 0) {\n        struct addrinfo hints;\n        struct addrinfo *result = ((void *)0);\n        int ret;\n        memset((void *)&hints, 0, sizeof(struct addrinfo));\n        hints.ai_family = 2;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = 0;\n        hints.ai_protocol = 0;\n        ret = getaddrinfo(name, ((void *)0), &hints, &result);\n        if (ret == 0) {\n            *(address) = ((struct sockaddr_in *)result->ai_addr)->sin_addr.s_addr;\n            freeaddrinfo(result);\n            return 0;\n        } else {\n            fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(ret));\n            return -1;\n        }\n    } else {\n        *(address) = inet_addr(name);\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"int HTTPWrapperGetHostByName_name_conflict(const char *hostname, unsigned long *ip) {\n  int i, j, k, l, m, n, o;\n  char c, s[4];\n  struct addrinfo hints, *res;\n  long ip_long;\n\n  i = j = k = l = m = n = o = 0;\n  c = '\\0';\n\n  j = strlen(hostname);\n\n  for (i = 0; i <= j; i++) {\n    c = hostname[i];\n\n    if ((c >= '0' && c <= '9') || c == '.') {\n      if (c == '.') {\n        k = 0;\n        l++;\n        ip_long = atol(s);\n\n        if (ip_long > 256 || l > 3)\n          return -1;\n      } else {\n        if (k < 4) {\n          s[k] = c;\n          s[k + 1] = '\\0';\n          k++;\n        } else {\n          o++;\n        }\n      }\n    } else {\n      o++;\n    }\n  }\n\n  if (c == '\\0' && o == 0 && l == 3) {\n    ip_long = atol(s);\n\n    if (ip_long > 256)\n      return -1;\n  } else {\n    o++;\n  }\n\n  if (o > 0) {\n    res = NULL;\n    memset(&hints, 0, sizeof hints);\n    hints.ai_family = 2;\n    hints.ai_socktype = 1;\n    hints.ai_flags = 0;\n    hints.ai_protocol = 0;\n\n    n = getaddrinfo(hostname, NULL, &hints, &res);\n\n    if (n != 0) {\n      fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(n));\n      return -1;\n    }\n\n  *","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetRandomeNumber() {\n    int num;\n    num = (int)(((double)rand() / ((double)2147483647 + 1)) * 16);\n    return num;\n}\n","function_prediction":"int HTTPWrapperGetRandomeNumber_name_conflict(void) {\n  return (int)(rand() / (RAND_MAX + 1.0) * 1000000);\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int64_t HTTPWrapperGetUpTime() {\n    struct timespec tp;\n    clock_gettime(1, &tp);\n    return (int64_t)tp.tv_sec;\n}\n","function_prediction":"time_t HTTPWrapperGetUpTime_name_conflict(void) {\n  struct timespec tp;\n  clock_gettime(1, &tp);\n  return tp.tv_sec;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLConnect(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLConnect_name_conflict(HTTPWrapper *wrapper, const char *host, int port) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jj101010/http-wrapper/refs/heads/master/http-wrapper.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLNegotiate(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLNegotiate_name_conflict(HTTPWrapper *wrapper, int sock) {\n# 100 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jj10110/http-wrapper/refs/heads/master/http_wrapper.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLSend(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLSend_name_conflict(HTTPWrapper *wrapper, const char *data, int len) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jj101010/http-wrapper/refs/heads/master/src/http_wrapper.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecv(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLRecv_name_conflict(HTTPWrapper *wrapper, char *buf, int len) { return -1; }","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecvPending(int s) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLRecvPending_name_conflict(HTTPWrapper *pWrapper) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jj101010/http_wrapper/refs/heads/master/http_wrapper_ssl.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLClose(int s) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLClose_name_conflict(HTTPWrapper *wrapper) {\n# 100 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jj10101/http-wrapper/refs/heads/master/src/http_wrapper_ssl.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int sktSetNonblocking(int socket, int on_off) {\n    int flags_orig, flags_new;\n    flags_orig = fcntl(socket, 3, 0);\n    if (flags_orig < 0)\n        return -1;\n    if (on_off != 0)\n        flags_new = flags_orig | 2048;\n    else\n        flags_new = flags_orig & ~2048;\n    if (fcntl(socket, 4, flags_new) < 0) {\n        fcntl(socket, 4, flags_orig);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int sktSetNonblocking_name_conflict(int skt, int on) {\n  int flags;\n\n  if ((flags = fcntl(skt, 3, 0)) < 0)\n    return -1;\n\n  if (on)\n    flags |= 0x800;\n  else\n    flags &= ~0x800;\n\n  if (fcntl(skt, 4, flags) < 0) {\n    fcntl(skt, 4, flags);\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetLocalConnection(HTTP_SESSION_HANDLE pSession, UINT32 nPort) {\n    return 0;\n}\n","function_prediction":"int HTTPClientSetLocalConnection_name_conflict(HTTPClient *client, int sock) {\n# 100 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmimu/libhttp/refs/heads/master/src/http_client.c\"\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"HTTP_SESSION_HANDLE HTTPClientOpenRequest(HTTP_CLIENT_SESSION_FLAGS Flags) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nAllocationSize;\n    pHTTPSession = (P_HTTP_SESSION)malloc(((sizeof(HTTP_SESSION) & 4294967292U) + ((sizeof(HTTP_SESSION) & 3) ? 4 : 0)));\n    if (!pHTTPSession) {\n        return 0;\n    }\n    memset(pHTTPSession, 0, sizeof(HTTP_SESSION));\n    if (0) {\n        nAllocationSize = (((2048) < (2048)) ? (2048) : (2048));\n    } else {\n        nAllocationSize = 2048;\n    }\n    pHTTPSession->HttpHeaders.HeadersBuffer.pParam = (CHAR *)malloc(((nAllocationSize & 4294967292U) + ((nAllocationSize & 3) ? 4 : 0)));\n    if (!pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession);\n        return 0;\n    }\n    memset(pHTTPSession->HttpHeaders.HeadersBuffer.pParam, 0, nAllocationSize);\n    pHTTPSession->HttpHeaders.HeadersBuffer.nLength = nAllocationSize;\n    HTTPClientSetVerb((HTTP_SESSION_HANDLE)pHTTPSession, (HTTP_VERB)0);\n    pHTTPSession->HttpUrl.nPort = 80;\n    pHTTPSession->HttpConnection.HttpSocket = (-1);\n    pHTTPSession->HttpHeaders.HeadersOut.pParam = pHTTPSession->HttpHeaders.HeadersBuffer.pParam;\n    pHTTPSession->HttpState = 1;\n    pHTTPSession->HttpFlags = Flags;\n    pHTTPSession->HttpHeadersInfo.nHTTPStatus = 0;\n    pHTTPSession->HttpNameCache.port = 80;\n    return (HTTP_SESSION_HANDLE)pHTTPSession;\n}\n","function_prediction":"HTTPClientRequest *HTTPClientOpenRequest_name_conflict(HTTPClient client) {\n  HTTPClientRequest *request;\n\n  request = malloc(sizeof(HTTPClientRequest));\n  if (request == NULL)\n    return NULL;\n  memset(request, 0, sizeof(HTTPClientRequest));\n\n  request->data = malloc(2048);\n  if (request->data == NULL) {\n    free(request);\n    return NULL;\n  }\n  memset(request->data, 0, 2048);\n  request->data_size = 2048;\n\n  HTTPClientSetVerb(request, NULL);\n\n  request->port = 80;\n  request->host = NULL;\n  request->path = NULL;\n  request->content_length = -1;\n  request->content_type = NULL;\n  request->content_encoding = NULL;\n  request->content_md5 = NULL;\n  request->content_range = NULL;\n  request->content_range_start = -1;\n  request->content_range_end = -1;\n  request->content_range_total = -1;\n  request->content_range_unit = NULL;\n  request->content_range_unit_size = -1;\n  request->content_range_unit_count = -1;\n  request->content_range_unit_start = -1;\n  request->content_range_unit_end = -1;\n  request->content_range_unit_total = -1;\n  request->content_range_unit_total_start = -1;\n  request->content_range_unit_total_end = -1;\n  request->content_range_unit_total_total = -1;\n  request->content_range_unit_total_total_start = -1;\n  request->content_range_unit_total_total_end = -1;\n  request->content_range_unit_total_total_total = -1;\n  request->content_range_unit_total_total_total_start = -1","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientReset(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    return HTTPIntrnSessionReset(pHTTPSession, 1);\n}\n","function_prediction":"int HTTPClientReset_name_conflict(HTTP_SESSION *session) {\n  // Validate arguments\n  if (session == NULL) {\n    return 2;\n  }\n\n  return HTTPIntrnSessionReset(session, 1);\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientCloseRequest(HTTP_SESSION_HANDLE *pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)*(pSession);\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession->HttpHeaders.HeadersBuffer.pParam);\n    }\n    HTTPIntrnConnectionClose(pHTTPSession);\n    free(pHTTPSession);\n    pHTTPSession = 0;\n    *(pSession) = 0;\n    return 0;\n}\n","function_prediction":"int HTTPClientCloseRequest_name_conflict(HTTPClientRequest **request) {\n  HTTPClientRequest *req = *request;\n  if (req == NULL)\n    return 2;\n  if (req->request_line != NULL)\n    free(req->request_line);\n  HTTPIntrnConnectionClose(&req->connection);\n  free(req);\n  *request = NULL;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetConnection(HTTP_SESSION_HANDLE pSession, BOOL Connection) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeadersInfo.Connection = Connection;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetConnection_name_conflict(HTTPClient *client, int connection) {\n  if (client == NULL)\n    return 2;\n\n  client->connection = connection;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetVerb(HTTP_SESSION_HANDLE pSession, HTTP_VERB HttpVerb) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.HttpVerb = HttpVerb;\n    switch (HttpVerb) {\n      case VerbGet:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"GET\");\n        break;\n      case VerbHead:\n        if (!0) {\n            return 18;\n        }\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"HEAD\");\n        break;\n      case VerbPost:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"POST\");\n        break;\n      case VerbPut:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"PUT\");\n        break;\n      default:\n        return 18;\n    }\n    ;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetVerb_name_conflict(HTTPClient *client, int verb) {\n  if (client == NULL)\n    return 2;\n\n  client->verb = verb;\n\n  switch (verb) {\n  case 0:\n    client->verb_str = \"GET\";\n    break;\n\n  case 1:\n    return 18;\n\n  case 2:\n    client->verb_str = \"POST\";\n    client->verb_str_len = 0;\n    break;\n\n  case 3:\n    client->verb_str = \"PUT\";\n    break;\n\n  default:\n    return 18;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetProxy(HTTP_SESSION_HANDLE pSession, CHAR *pProxyHost, UINT16 nPort, CHAR *pUserName, CHAR *pPassword) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    strncpy(pHTTPSession->HttpProxy.ProxyHost, pProxyHost, 64);\n    if (pUserName) {\n        strncpy(pHTTPSession->HttpProxy.ProxtUser, pUserName, 16);\n    }\n    if (pPassword) {\n        strncpy(pHTTPSession->HttpProxy.ProxyPassword, pPassword, 16);\n    }\n    pHTTPSession->HttpProxy.nProxyPort = nPort;\n    pHTTPSession->HttpFlags = pHTTPSession->HttpFlags | 128;\n    if (pPassword && pUserName) {\n        pHTTPSession->HttpProxy.ProxyAuthSchema = 1;\n    }\n    return 0;\n}\n","function_prediction":"int HTTPClientSetProxy(HTTPClient *client, const char *host,\n                       unsigned short port, const char *user,\n                       const char *password) {\n  if (client == NULL)\n    return 2;\n\n  strncpy(&client->proxy_host[0], host, 64);\n  if (user != NULL)\n    strncpy(&client->proxy_user[0], user, 16);\n  if (password != NULL)\n    strncpy(&client->proxy_password[0], password, 16);\n  client->proxy_port = port;\n\n  client->flags |= 0x80;\n\n  if (user != NULL && password != NULL)\n    client->proxy_auth = 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetCredentials(HTTP_SESSION_HANDLE pSession, CHAR *pUserName, CHAR *pPassword) {\n    UINT32 nLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nLength = strlen(pUserName);\n    if (nLength > 16) {\n        return 19;\n    }\n    nLength = strlen(pPassword);\n    if (nLength > 16) {\n        return 19;\n    }\n    strcpy(pHTTPSession->HttpCredentials.CredUser, pUserName);\n    strcpy(pHTTPSession->HttpCredentials.CredPassword, pPassword);\n    pHTTPSession->HttpHeadersInfo.HaveCredentials = 1;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetCredentials(HTTPClient *client, const char *username,\n                             const char *password) {\n  if (client == NULL)\n    return 2;\n\n  if (strlen(username) > 16)\n    return 19;\n\n  if (strlen(password) > 16)\n    return 19;\n\n  strcpy(&client->credentials[0], username);\n  strcpy(&client->credentials[16], password);\n\n  client->credentials_set = 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientAddRequestHeaders(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderName, CHAR *pHeaderData, BOOL nInsert) {\n    UINT32 nRetCode;\n    UINT32 nHeaderLength, nDataLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nHeaderLength = strlen(pHeaderName);\n    nDataLength = strlen(pHeaderData);\n    nRetCode = HTTPIntrnHeadersAdd(pHTTPSession, pHeaderName, nHeaderLength, pHeaderData, nDataLength);\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientAddRequestHeaders(HTTPClient *client, const char *name,\n                                const char *value) {\n  if (client == NULL)\n    return 2;\n\n  return HTTPIntrnHeadersAdd(&client->requestHeaders, name, strlen(name), value,\n                             strlen(value));\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientRecvResponse(HTTP_SESSION_HANDLE pSession, UINT32 nTimeout) {\n    UINT32 nRetCode;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    do {\n        if ((nRetCode = HTTPIntrnHeadersReceive(pHTTPSession, nTimeout)) != 0) {\n            break;\n        }\n    } while (0);\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientRecvResponse_name_conflict(HTTPClient *pClient, int timeout) {\n  if (pClient == NULL)\n    return 2;\n\n  return HTTPIntrnHeadersReceive(pClient, timeout);\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetInfo(HTTP_SESSION_HANDLE pSession, HTTP_CLIENT *HTTPClient) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    memset(HTTPClient, 0, sizeof(HTTP_CLIENT));\n    HTTPClient->HTTPStatusCode = pHTTPSession->HttpHeadersInfo.nHTTPStatus;\n    HTTPClient->RequestBodyLengthSent = pHTTPSession->HttpCounters.nSentBodyBytes;\n    HTTPClient->ResponseBodyLengthReceived = pHTTPSession->HttpCounters.nRecivedBodyLength;\n    HTTPClient->TotalResponseBodyLength = pHTTPSession->HttpHeadersInfo.nHTTPContentLength;\n    HTTPClient->HttpState = pHTTPSession->HttpState;\n    return 0;\n}\n","function_prediction":"int HTTPClientGetInfo_name_conflict(HTTPClient *client, HTTPClientInfo *info) {\n  if (client == NULL) {\n    return 2;\n  }\n\n  memset(info, 0, sizeof(HTTPClientInfo));\n\n  info->StatusCode = client->StatusCode;\n  info->StatusMessage = client->StatusMessage;\n  info->ContentType = client->ContentType;\n  info->ContentLength = client->ContentLength;\n  info->ContentEncoding = client->ContentEncoding;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindFirstHeader(HTTP_SESSION_HANDLE pSession, CHAR *pSearchClue, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nClueLength;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nClueLength = strlen(pSearchClue);\n    if (nClueLength >= 1024) {\n        return 13;\n    } else {\n        strcpy(pHTTPSession->HttpHeaders.SearchClue, pSearchClue);\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    }\n    return 0;\n}\n","function_prediction":"int HTTPClientFindFirstHeader_name_conflict(HTTP_CLIENT *http, const char *header) {\n  if (http == NULL) {\n    return 2;\n  }\n\n  if (strlen(header) >= 1024) {\n    return 13;\n  }\n\n  strcpy(http->HeaderName, header);\n  http->HeaderValue[0] = 0;\n  http->HeaderValuePos = 0;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindCloseHeader(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.SearchClue[0] = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    return 0;\n}\n","function_prediction":"int HTTPClientFindCloseHeader_name_conflict(HTTP_CLIENT *client) {\n  // Validate arguments\n  if (client == NULL) {\n    return 2;\n  }\n\n  client->HttpHeader.CloseHeader[104] = 0;\n  client->HttpHeader.CloseHeaderLen = 0;\n  client->HttpHeader.CloseHeaderPos = 0;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetNextHeader(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nOffset = 0;\n    UINT32 nRetCode;\n    HTTP_PARAM HttpHeader;\n    CHAR *pPtr;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeaderSearch.nLength > 0) {\n        nOffset = pHTTPSession->HttpHeaders.HeaderSearch.pParam - pHTTPSession->HttpHeaders.HeadersIn.pParam;\n    }\n    nRetCode = HTTPIntrnHeadersFind(pHTTPSession, pHTTPSession->HttpHeaders.SearchClue, &HttpHeader, 1, nOffset);\n    if (nRetCode == 0) {\n        if (HttpHeader.nLength > *(nLength)) {\n            *(nLength) = HttpHeader.nLength;\n            pHeaderBuffer[0] = 0;\n            return 3;\n        }\n        pPtr = HttpHeader.pParam;\n        nOffset = 0;\n        if (*pPtr == 13) {\n            nOffset++;\n            pPtr++;\n        }\n        if (*pPtr == 10) {\n            nOffset++;\n            pPtr++;\n        }\n        strncpy(pHeaderBuffer, pPtr, HttpHeader.nLength - nOffset);\n        pHeaderBuffer[HttpHeader.nLength - nOffset] = 0;\n        *(nLength) = HttpHeader.nLength - nOffset;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = HttpHeader.pParam + HttpHeader.nLength;\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength++;\n        return 0;\n    }\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientGetNextHeader_name_conflict(HTTPClient *http, char *header, int *header_len) {\n  int ret;\n  int offset = 0;\n  char *p;\n  char *q;\n  int len;\n\n  if (http == NULL)\n    return 2;\n\n  if (http->headers_pos != 0)\n    offset = http->headers_end - http->headers_pos;\n\n  ret = HTTPIntrnHeadersFind(http, &http->headers, &p, 1, offset);\n  if (ret != 0)\n    return ret;\n\n  len = p - http->headers_pos;\n  if (len > *header_len) {\n    *header_len = len;\n    header[0] = '\\0';\n    return 3;\n  }\n\n  q = p;\n  if (*q == '\\r')\n    q++;\n  if (*q == '\\n')\n    q++;\n\n  strncpy(header, q, len - (q - p));\n  header[len - (q - p)] = '\\0';\n  *header_len = len - (q - p);\n\n  http->headers_pos = p + len;\n  http->headers_pos++;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPIntrnSessionGetUpTime(void) {\n    return HTTPWrapperGetUpTime();\n}\n","function_prediction":"uint32_t HTTPIntrnSessionGetUpTime_name_conflict(HTTP_SESSION *pSession) {\n  return HTTPWrapperGetUpTime();\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"int HTTPBase64Decoder(char *out, const char *in) {\n    int len = 0;\n    register unsigned char digit1, digit2, digit3, digit4;\n    if (in[0] == '+' && in[1] == ' ')\n        in += 2;\n    if (*in == '\\r')\n        return (0);\n    do {\n        digit1 = in[0];\n        if (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) == -1)\n            return (-1);\n        digit2 = in[1];\n        if (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) == -1)\n            return (-1);\n        digit3 = in[2];\n        if (digit3 != '=' && ((((digit3) & ~127) == 0) ? base64val[digit3] : -1) == -1)\n            return (-1);\n        digit4 = in[3];\n        if (digit4 != '=' && ((((digit4) & ~127) == 0) ? base64val[digit4] : -1) == -1)\n            return (-1);\n        in += 4;\n        *out++ = (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) << 2) | (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) >> 4);\n        ++len;\n        if (digit3 != '=') {\n            *out++ = ((((((digit2) & ~127) == 0) ? base64val[digit2] : -1) << 4) & 240) | (((((digit3) & ~127) == 0) ? base64val[digit3] : -1) >> 2);\n            ++len;\n            if (digit4 != '=') {\n                *out++ = ((((((digit3) & ~127) == 0) ? base64val[digit3] : -1) << 6) & 192) | ((((digit4) & ~127) == 0) ? base64val[digit4] : -1);\n                ++len;\n            }\n        }\n    } while (*in && *in != '\\r' && digit4 != '=');\n    return (len);\n}\n","function_prediction":"int HTTPBase64Decoder_name_conflict(char *out, const char *in) {\n  int i, j, k, l;\n  char c1, c2, c3, c4;\n  char *p;\n\n  i = 0;\n  p = (char *)in;\n\n  if (*p == '+' && *(p + 1) == ' ')\n    p += 2;\n\n  while (*p != '\\r' && *p != '\\0') {\n    c1 = *p++;\n    c2 = *p++;\n    c3 = *p++;\n    c4 = *p++;\n\n    if (c1 < 0 || base64val[(int)c1] == -1 || c2 < 0 ||\n        base64val[(int)c2] == -1 || c3 < 0 || base64val[(int)c3] == -1 ||\n        c4 < 0 || base64val[(int)c4] == -1)\n      return -1;\n\n    j = base64val[(int)c1];\n    k = base64val[(int)c2];\n    l = base64val[(int)c3];\n\n    out[i++] = (j << 2) | (k >> 4);\n    if (c3 != '=')\n      out[i++] = (k << 4) | (l >> 2);\n    if (c4 != '=')\n      out[i++] = (l << 6) | base64val[(int)c4];\n  }\n\n  return i;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientAuth.c"}
{"compilable":0,"function":"INT32 HTTPSendFile(HTTP_SESSION_HANDLE pSession, CHAR *FilePath) {\n    UINT32 ret = 0;\n    char *buf, p;\n    int buf_size = 0, sent_size;\n    FILE *f;\n    buf = (char *)malloc(65536);\n    f = fopen(FilePath, \"rb\");\n    if (!f) {\n        ret = 1;\n        return ret;\n    }\n    while ((buf_size = fread(buf, 1, 65536, f)) != 0)\n        {\n            ret = HTTPClientWriteData(pSession, buf, buf_size, 5);\n            if (ret != 0) {\n                break;\n            }\n        }\n    return ret;\n}\n","function_prediction":"int HTTPSendFile_name_conflict(HTTPClient *client, const char *filename) {\n  int ret = 0;\n  char *buffer = malloc(65536);\n  FILE *fp = fopen(filename, \"rb\");\n  if (fp == NULL) {\n    ret = 1;\n  } else {\n    int read;\n    while ((read = fread(buffer, 1, 65536, fp)) != 0) {\n      ret = HTTPClientWriteData(client, buffer, read, 5);\n      if (ret != 0) {\n        break;\n      }\n    }\n  }\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"INT32 HTTPParseCommandLineArgs(UINT32 argc, CHAR *argv[], HTTPParameters *pClientParams) {\n    UINT32 nArg;\n    UINT32 nResult;\n    CHAR *pSearchPtr = ((void *)0);\n    CHAR PortNum[64];\n    if (argc <= 1) {\n        HTTPDumpHelp(\"Error: did not get key parameters.\");\n        return -1;\n    }\n    ;\n    for (nArg = 1; nArg < argc; nArg++) {\n        if (strncasecmp(argv[nArg], \"/?\", 2) == 0) {\n            HTTPDumpHelp(((void *)0));\n            return -1;\n        }\n        if (strncasecmp(argv[nArg], \"/V\", 2) == 0) {\n            pClientParams->Verbose = 1;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H:\", 3) == 0) {\n            strcpy(pClientParams->Uri, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H2:\", 3) == 0) {\n            strcpy(pClientParams->Uri2, argv[nArg] + 4);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/D:\", 3) == 0) {\n            strcpy(pClientParams->PostData, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/F:\", 3) == 0) {\n            strcpy(pClientParams->PutFilePath, argv[nArg] + 3);\n            continue;\n        }\n    }\n    if (strlen(pClientParams->Uri) == 0 || strlen(pClientParams->Uri2) == 0) {\n        HTTPDumpHelp(\"Error: /H or /H2 argument is missing\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int HTTPParseCommandLineArgs_name_conflict(int argc, char *argv[], HTTP_CONFIG *config) {\n  unsigned int i;\n\n  if (argc < 2) {\n    HTTPDumpHelp(\"Error: did not get key parameters.\");\n    return -1;\n  }\n\n  for (i = 1; i < argc; i++) {\n    if (!strncasecmp(argv[i], \"/?\", 2)) {\n      HTTPDumpHelp(NULL);\n      return -1;\n    } else if (!strncasecmp(argv[i], \"/V\", 2)) {\n      config->verbose = 1;\n    } else if (!strncasecmp(argv[i], \"/H:\", 3)) {\n      strcpy(config->http_header, argv[i] + 3);\n    } else if (!strncasecmp(argv[i], \"/H2:\", 3)) {\n      strcpy(config->http2_header, argv[i] + 4);\n    } else if (!strncasecmp(argv[i], \"/D:\", 3)) {\n      strcpy(config->default_file, argv[i] + 3);\n    } else if (!strncasecmp(argv[i], \"/F:\", 3)) {\n      strcpy(config->file_list, argv[i] + 3);\n    }\n  }\n\n  if (config->http_header[0] == '\\0' || config->http2_header[0] == '\\0') {\n    HTTPDumpHelp(\"Error: /H or /H2 argument is missing\");\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"int handle_http_request(HTTP_SESSION_HANDLE pHTTP, CHAR *uri, HTTPParameters *ClientParams) {\n    CHAR Buffer[8193];\n    INT32 nRetCode;\n    UINT32 nSize, nTotal = 0;\n    INT32 status_code;\n    HTTP_CLIENT HTTPClient;\n    do {\n        memset(&HTTPClient, 0, sizeof(HTTP_CLIENT));\n        if (strlen(ClientParams->PostData) != 0) {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbPost)) != 0) {\n                break;\n            }\n        } else if (strlen(ClientParams->PutFilePath) != 0) {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbPut)) != 0) {\n                break;\n            }\n        } else {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbGet)) != 0) {\n                break;\n            }\n        }\n        if (strlen(ClientParams->PostData) != 0) {\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ClientParams->PostData, strlen(ClientParams->PostData), 1, 5, 0)) != 0) {\n                break;\n            }\n        } else if (strlen(ClientParams->PutFilePath) != 0) {\n            int ret;\n            struct stat stat_buf;\n            char file_size_str[32];\n            memset(&stat_buf, 0, sizeof(struct stat));\n            memset(file_size_str, 0, 32);\n            ret = stat(ClientParams->PutFilePath, &stat_buf);\n            if (ret) {\n                nRetCode = 19;\n                break;\n            }\n            HTTPWrapperItoa(file_size_str, (int)stat_buf.st_size);\n            if ((nRetCode = HTTPClientAddRequestHeaders(pHTTP, \"Content-Length\", file_size_str, 0)) != 0) {\n                break;\n            }\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ((void *)0), 0, 0, 5, 0)) != 0) {\n                break;\n            }\n            if ((nRetCode = HTTPSendFile(pHTTP, ClientParams->PutFilePath)) != 0) {\n                break;\n            }\n        } else {\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ((void *)0), 0, 0, 5, 0)) != 0) {\n                break;\n            }\n        }\n        if ((nRetCode = HTTPClientRecvResponse(pHTTP, 3)) != 0) {\n            break;\n        }\n        if ((nRetCode = HTTPClientGetInfo(pHTTP, &HTTPClient)) != 0) {\n            break;\n        }\n        while (nRetCode == 0 || nRetCode != 1000)\n            {\n                if (nTotal >= HTTPClient.TotalResponseBodyLength) {\n                    break;\n                }\n                nSize = 8192;\n                nRetCode = HTTPClientReadData(pHTTP, Buffer, nSize, 5, &nSize);\n                nTotal += nSize;\n                Buffer[nSize] = 0;\n                printf(\"%s\", Buffer);\n            }\n    } while (0);\n    printf(\"\\n\");\n    if (ClientParams->Verbose == 1) {\n        printf(\"\\n\\nHTTP Client terminated %d (got %d bytes, status_code %d)\\n\\n\", (int)nRetCode, (int)(nTotal), HTTPClient.HTTPStatusCode);\n    }\n    return nRetCode;\n}\n","function_prediction":"int handle_http_request(HTTP_CLIENT *http_client, const char *url,\n                        const char *request_data) {\n  int ret;\n  int bytes_read = 0;\n  HTTP_INFO http_info;\n\n  memset(&http_info, 0, sizeof(http_info));\n\n  if (request_data[1024 + 4] != '\\0') {\n    ret = HTTPClientSetVerb(http_client, 2);\n  } else if (request_data[2048 + 4] != '\\0') {\n    ret = HTTPClientSetVerb(http_client, 3);\n  } else {\n    ret = HTTPClientSetVerb(http_client, 0);\n  }\n\n  if (ret != 0) {\n    goto end;\n  }\n\n  if (request_data[1024 + 4] != '\\0') {\n    ret = HTTPClientSendRequest(http_client, url, &request_data[1024 + 4],\n                                strlen(&request_data[1024 + 4]), 1, 5, 0);\n  } else if (request_data[2048 + 4] != '\\0') {\n    struct stat file_stat;\n    char content_length[32];\n\n    memset(&file_stat, 0, sizeof(file_stat));\n    memset(content_length, 0, sizeof(content_length));\n\n    ret = stat(&request_data[2048 + 4], &file_stat);\n    if (ret != 0) {\n      ret = 19;\n      goto end;\n    }\n\n    HTTPWrapperItoa(content_length, file_stat.st_size);\n\n    ret = HTTPClientAddRequestHeaders(http_client, \"Content-Length\",\n                                      content_length, 0);\n    if (ret != 0) {\n      goto end;\n    }\n\n    ret = HTTPClientSendRequest(http_client, url, NULL, 0, 0, 5, 0);","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"BOOL HTTPStrInsensitiveCompare(CHAR *pSrc, CHAR *pDest, UINT32 nLength) {\n    UINT32 nPosition;\n    UINT32 nDestLength;\n    CHAR *pSrcIn, *pDestIn;\n    CHAR a, b;\n    pSrcIn = pSrc;\n    pDestIn = pDest;\n    nPosition = 0;\n    nDestLength = strlen(pDest);\n    if (nLength == 0) {\n        nLength = strlen(pSrc);\n    }\n    if (nDestLength != nLength) {\n        return 0;\n    }\n    while (pSrcIn || pDestIn)\n        {\n            if (nLength > 0 && nPosition == nLength) {\n                return 1;\n            }\n            a = *pSrcIn;\n            b = *pDestIn;\n            if (*pSrcIn >= 64 && *pSrcIn <= 90) {\n                a = *pSrcIn + 32;\n            }\n            if (*pDestIn >= 64 && *pDestIn <= 90) {\n                b = *pDestIn + 32;\n            }\n            if (a != b) {\n                return 0;\n            }\n            pSrcIn++;\n            pDestIn++;\n            nPosition++;\n        }\n    return 1;\n}\n","function_prediction":"int HTTPStrInsensitiveCompare_name_conflict(const char *s1, const char *s2, int len) {\n  int i = 0;\n  int l2 = strlen(s2);\n\n  if (len == 0)\n    len = strlen(s1);\n\n  while (1) {\n    char c1, c2;\n\n    if (l2 != len)\n      return 0;\n\n    if (s1 == NULL && s2 == NULL)\n      return 1;\n\n    if (len != 0 && i == len)\n      return 1;\n\n    c1 = *s1;\n    c2 = *s2;\n\n    if (c1 >= 'A' && c1 <= 'Z')\n      c1 += 32;\n\n    if (c2 >= 'A' && c2 <= 'Z')\n      c2 += 32;\n\n    if (c1 != c2)\n      return 0;\n\n    s1++;\n    s2++;\n    i++;\n  }\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR HTTPStrExtract(CHAR *pParam, UINT32 nOffset, CHAR Restore) {\n    CHAR Replaced;\n    if (!pParam) {\n        return 0;\n    }\n    if (Restore != 0) {\n        pParam[nOffset] = Restore;\n        return Restore;\n    } else {\n        Replaced = pParam[nOffset];\n        pParam[nOffset] = 0;\n        return Replaced;\n    }\n}\n","function_prediction":"char HTTPStrExtract_name_conflict(char *str, int pos, char c) {\n  if (str == NULL)\n    return '\\0';\n\n  if (c == '\\0') {\n    c = str[pos];\n    str[pos] = '\\0';\n  } else\n    str[pos] = c;\n\n  return c;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrCaseStr(const char *pSrc, UINT32 nSrcLength, const char *pFind) {\n    const char *ptr = pSrc;\n    const char *ptr2;\n    UINT32 iLength = 0;\n    while (1)\n        {\n            if (iLength >= nSrcLength) {\n                break;\n            }\n            ptr = strchr((char *)pSrc, toupper((int)*pFind));\n            ptr2 = strchr((char *)pSrc, tolower((int)*pFind));\n            if (!ptr) {\n                ptr = ptr2;\n            }\n            if (!ptr) {\n                break;\n            }\n            if (ptr2 && (ptr2 < ptr)) {\n                ptr = ptr2;\n            }\n            if (!strncasecmp(ptr, pFind, strlen(pFind))) {\n                return (char *)ptr;\n            }\n            pSrc = ptr + 1;\n            iLength++;\n        }\n    return 0;\n}\n","function_prediction":"char *HTTPStrCaseStr_name_conflict(char *s, unsigned int max, char *find) {\n  char *p, *p1, *p2;\n  unsigned int i;\n\n  for (i = 0, p = s; i < max; i++, p++) {\n    p1 = strchr(p, toupper(*find));\n    p2 = strchr(p, tolower(*find));\n    if (p1 == NULL)\n      p1 = p2;\n    if (p1 == NULL)\n      return NULL;\n    if (p2 != NULL && p1 > p2)\n      p1 = p2;\n    if (!strncasecmp(p1, find, strlen(find)))\n      return p1;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrGetToken(CHAR *pSrc, UINT32 nSrcLength, CHAR *pDest, UINT32 *nDestLength) {\n    CHAR *pStart = pSrc;\n    CHAR *pEnd;\n    UINT32 nTokenLength = 0;\n    UINT32 nPosition = 0;\n    pStart = strchr(pSrc, ':') + 1;\n    if (pStart) {\n        pEnd = pStart;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    nTokenLength++;\n                }\n                if (nSrcLength && nPosition > nSrcLength) {\n                    break;\n                }\n                pEnd++;\n                nPosition++;\n            }\n        if (nTokenLength > *(nDestLength)) {\n            *(nDestLength) = nTokenLength;\n            pDest = ((void *)0);\n            return pDest;\n        }\n        pEnd = pStart;\n        *(nDestLength) = nTokenLength;\n        nTokenLength = 0;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    pDest[nTokenLength++] = *pEnd;\n                }\n                pEnd++;\n            }\n        pDest[nTokenLength] = 0;\n    }\n    return pDest;\n}\n","function_prediction":"char *HTTPStrGetToken(char *str, unsigned int maxlen, char *token,\n                      unsigned int *len) {\n  unsigned int i = 0, j = 0;\n  char *p = strchr(str, ':');\n\n  if (p == NULL)\n    return NULL;\n\n  p++;\n\n  while (*p != '\\0' && *p != '\\r' && *p != '\\n') {\n    if (*p != ' ')\n      i++;\n\n    if (maxlen > 0 && j > maxlen)\n      break;\n\n    j++;\n    p++;\n  }\n\n  if (i > *len) {\n    *len = i;\n    return NULL;\n  }\n\n  *len = i;\n  i = 0;\n\n  while (*p != '\\0' && *p != '\\r' && *p != '\\n') {\n    if (*p != ' ') {\n      token[i] = *p;\n      i++;\n    }\n\n    p++;\n  }\n\n  token[i] = '\\0';\n\n  return token;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"UINT32 HTTPStrHToL(CHAR *s) {\n    UINT32 i, nn, digit;\n    UINT32 n;\n    n = i = nn = 0;\n    do {\n        if (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalnum)) {\n            s[i] = toupper((int)s[i]);\n            if (s[i] == 'X')\n                nn = n = 0;\n            else {\n                digit = (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalpha) ? (s[i] - 'A' + 10) : s[i] - '0');\n                if (digit > 15)\n                    digit = 15;\n                n = n * 16 + digit;\n                if (n |= 0)\n                    nn++;\n                if (nn == 8)\n                    break;\n            }\n        }\n        i++;\n    } while (s[i] |= 0);\n    return n;\n}\n","function_prediction":"unsigned long HTTPStrHToL_name_conflict(char *str) {\n  unsigned long result = 0;\n  unsigned int i = 0;\n  unsigned int j = 0;\n  unsigned int value;\n\n  while (1) {\n    if (__ctype_b_loc()[(unsigned char)str[i]] & 0x08) {\n      str[i] = toupper(str[i]);\n      if (str[i] == 'X') {\n        result = 0;\n        j = 0;\n      } else {\n        if (__ctype_b_loc()[(unsigned char)str[i]] & 0x400)\n          value = str[i] - 'A' + 10;\n        else\n          value = str[i] - '0';\n\n        if (value > 15)\n          value = 15;\n\n        result = result * 16 + value;\n        if (result)\n          j++;\n        if (j == 8)\n          break;\n      }\n    }\n    i++;\n    str[i] = str[i];\n    if (str[i] == '\\0')\n      break;\n  }\n\n  return result;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrLToH(CHAR *dest, UINT32 nSrc) {\n    char *hex = \"0123456789abcdef\";\n    int i;\n    if (nSrc == 0) {\n        dest[0] = '0';\n        dest[1] = 0;\n    } else {\n        for (i = 28; ((nSrc >> i) && 15) == 0; i -= 4)\n            ;\n        for (; i >= 0; i -= 4) {\n            *dest++ = hex[(nSrc >> i) & 15];\n        }\n        *dest = 0;\n    }\n    return dest;\n}\n","function_prediction":"char *HTTPStrLToH_name_conflict(char *s, unsigned long l) {\n  char *p = s;\n  int i;\n\n  if (l == 0) {\n    *p++ = '0';\n    *p = '\\0';\n    return p;\n  }\n\n  for (i = 28; (l >> i) == 0; i -= 4)\n    ;\n\n  for (; i >= 0; i -= 4) {\n    *p++ = \"0123456789abcdef\"[(l >> i) & 0x0f];\n  }\n\n  *p = '\\0';\n  return p;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"int HTTPWrapperIsAscii(int c) {\n    return (!(c & ~127));\n}\n","function_prediction":"int HTTPWrapperIsAscii_name_conflict(int c) { return (c & 0x80) == 0; }","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToUpper(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 97 && c <= 122) {\n            return (c - 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"int HTTPWrapperToUpper_name_conflict(int c) {\n  if (HTTPWrapperIsAscii(c) > 0 && c >= 'a' && c <= 'z')\n    c -= 'a' - 'A';\n  return c;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToLower(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 65 && c <= 90) {\n            return (c + 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"int HTTPWrapperToLower_name_conflict(int c) {\n  if (HTTPWrapperIsAscii(c) > 0 && c >= 'A' && c <= 'Z')\n    c += 'a' - 'A';\n  return c;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlpha(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90)) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int HTTPWrapperIsAlpha_name_conflict(int c) {\n  return HTTPWrapperIsAscii(c) &&\n         (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')));\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlNum(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (HTTPWrapperIsAlpha(c) > 0) {\n            return c;\n        }\n        if (c >= 48 && c <= 57) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int HTTPWrapperIsAlNum_name_conflict(int c) {\n  return (HTTPWrapperIsAscii(c) > 0 &&\n          (HTTPWrapperIsAlpha(c) > 0 || (c >= '0' && c <= '9')));\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"char *HTTPWrapperItoa(char *s, int a) {\n    unsigned int b;\n    if (a > 2147483647) {\n        return 0;\n    }\n    if (a < 0)\n        b = -a , *s++ = '-';\n    else\n        b = a;\n    for (; a; a = a / 10)\n        s++;\n    for (*s = '\\x00'; b; b = b / 10)\n        *--s = b % 10 + '0';\n    return s;\n}\n","function_prediction":"char *HTTPWrapperItoa_name_conflict(char *s, int n) {\n  int i, sign;\n\n  if ((sign = n) < 0)\n    n = -n;\n  i = 0;\n  do {\n    s[i++] = n % 10 + '0';\n  } while ((n /= 10) != 0);\n  if (sign < 0)\n    s[i++] = '-';\n  s[i] = '\\0';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperShutDown(int s, int how) {\n    return shutdown(s, how);\n}\n","function_prediction":"int HTTPWrapperShutDown_name_conflict(int sock, int how) { return shutdown(sock, how); }","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetSocketError(int s) {\n    return (*__errno_location());\n}\n","function_prediction":"int HTTPWrapperGetSocketError_name_conflict() { return *__errno_location(); }","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetHostByName(char *name, UINT32 *address) {\n    HTTP_HOSTNET *HostEntry;\n    int iPos = 0, iLen = 0, iNumPos = 0, iDots = 0;\n    long iIPElement;\n    char c = 0;\n    char Num[4];\n    int iHostType = 0;\n    iLen = strlen(name);\n    for (iPos = 0; iPos <= iLen; iPos++) {\n        c = name[iPos];\n        if ((c >= 48 && c <= 57) || (c == '.')) {\n            if (c != '.') {\n                if (iNumPos > 3) {\n                    iHostType++;\n                    break;\n                }\n                Num[iNumPos] = c;\n                Num[iNumPos + 1] = 0;\n                iNumPos++;\n            } else {\n                iNumPos = 0;\n                iDots++;\n                iIPElement = atol(Num);\n                if (iIPElement > 256 || iDots > 3) {\n                    return -1;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n    if (c == 0 && iHostType == 0 && iDots == 3) {\n        iIPElement = atol(Num);\n        if (iIPElement > 256) {\n            return -1;\n        }\n    } else {\n        iHostType++;\n    }\n    if (iHostType > 0) {\n        struct addrinfo hints;\n        struct addrinfo *result = ((void *)0);\n        int ret;\n        memset((void *)&hints, 0, sizeof(struct addrinfo));\n        hints.ai_family = 2;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = 0;\n        hints.ai_protocol = 0;\n        ret = getaddrinfo(name, ((void *)0), &hints, &result);\n        if (ret == 0) {\n            *(address) = ((struct sockaddr_in *)result->ai_addr)->sin_addr.s_addr;\n            freeaddrinfo(result);\n            return 0;\n        } else {\n            fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(ret));\n            return -1;\n        }\n    } else {\n        *(address) = inet_addr(name);\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"int HTTPWrapperGetHostByName_name_conflict(const char *hostname, unsigned long *ip) {\n  int i, j, k, l, m, n, o;\n  char c, d[4];\n  struct addrinfo hints, *res;\n  long ip_long;\n\n  i = j = k = l = m = n = o = 0;\n  c = '\\0';\n\n  j = strlen(hostname);\n\n  for (i = 0; i <= j; i++) {\n    c = hostname[i];\n\n    if ((c >= '0' && c <= '9') || c == '.') {\n      if (c == '.') {\n        k = 0;\n        l++;\n        ip_long = atol(d);\n\n        if (ip_long > 256 || l > 3)\n          return -1;\n      } else {\n        if (k < 4) {\n          d[k] = c;\n          d[k + 1] = '\\0';\n          k++;\n        } else {\n          o++;\n        }\n      }\n    } else {\n      o++;\n    }\n  }\n\n  if (c == '\\0' && o == 0 && l == 3) {\n    ip_long = atol(d);\n\n    if (ip_long > 256)\n      return -1;\n  } else {\n    o++;\n  }\n\n  if (o > 0) {\n    res = NULL;\n    memset(&hints, 0, sizeof hints);\n    hints.ai_family = 2;\n    hints.ai_socktype = 1;\n    hints.ai_flags = 0;\n    hints.ai_protocol = 0;\n\n    n = getaddrinfo(hostname, NULL, &hints, &res);\n\n    if (n != 0) {\n      fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(n));\n      return -1;\n    }\n\n  *","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetRandomeNumber() {\n    int num;\n    num = (int)(((double)rand() / ((double)2147483647 + 1)) * 16);\n    return num;\n}\n","function_prediction":"int HTTPWrapperGetRandomeNumber_name_conflict() {\n  return (int)(rand() / (RAND_MAX + 1.0) * 1000000);\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int64_t HTTPWrapperGetUpTime() {\n    struct timespec tp;\n    clock_gettime(1, &tp);\n    return (int64_t)tp.tv_sec;\n}\n","function_prediction":"time_t HTTPWrapperGetUpTime_name_conflict(void) {\n  struct timespec tp;\n  clock_gettime(1, &tp);\n  return tp.tv_sec;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLConnect(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLConnect_name_conflict(HTTPWrapper *wrapper, const char *host, int port) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jj101010/http-wrapper/refs/heads/master/http-wrapper.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLNegotiate(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLNegotiate_name_conflict(HTTPWrapper *wrapper, int sock) {\n# 100 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jj10110/http-wrapper/refs/heads/master/http_wrapper.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLSend(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLSend_name_conflict(HTTPWrapper *wrapper, const char *data, int len) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jj101010/http-wrapper/refs/heads/master/src/http_wrapper.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecv(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLRecv_name_conflict(HTTPWrapper *wrapper, char *buf, int len) { return -1; }","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecvPending(int s) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLRecvPending_name_conflict(HTTPWrapper *pWrapper) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jj101010/http_wrapper/refs/heads/master/http_wrapper_ssl.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLClose(int s) {\n    return -1;\n}\n","function_prediction":"int HTTPWrapperSSLClose_name_conflict(HTTPWrapper *wrapper) {\n# 100 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jj10101/http-wrapper/refs/heads/master/src/http_wrapper_ssl.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int sktSetNonblocking(int socket, int on_off) {\n    int flags_orig, flags_new;\n    flags_orig = fcntl(socket, 3, 0);\n    if (flags_orig < 0)\n        return -1;\n    if (on_off != 0)\n        flags_new = flags_orig | 2048;\n    else\n        flags_new = flags_orig & ~2048;\n    if (fcntl(socket, 4, flags_new) < 0) {\n        fcntl(socket, 4, flags_orig);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int sktSetNonblocking_name_conflict(int skt, int on) {\n  int flags;\n\n  if ((flags = fcntl(skt, 3, 0)) < 0)\n    return -1;\n\n  if (on)\n    flags |= 0x800;\n  else\n    flags &= ~0x800;\n\n  if (fcntl(skt, 4, flags) < 0) {\n    fcntl(skt, 4, flags);\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetLocalConnection(HTTP_SESSION_HANDLE pSession, UINT32 nPort) {\n    return 0;\n}\n","function_prediction":"int HTTPClientSetLocalConnection_name_conflict(HTTPClient *client, int sock) {\n# 100 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmimu/libhttp/refs/heads/master/src/http_client.c\"\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"HTTP_SESSION_HANDLE HTTPClientOpenRequest(HTTP_CLIENT_SESSION_FLAGS Flags) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nAllocationSize;\n    pHTTPSession = (P_HTTP_SESSION)malloc(((sizeof(HTTP_SESSION) & 4294967292U) + ((sizeof(HTTP_SESSION) & 3) ? 4 : 0)));\n    if (!pHTTPSession) {\n        return 0;\n    }\n    memset(pHTTPSession, 0, sizeof(HTTP_SESSION));\n    if (0) {\n        nAllocationSize = (((2048) < (2048)) ? (2048) : (2048));\n    } else {\n        nAllocationSize = 2048;\n    }\n    pHTTPSession->HttpHeaders.HeadersBuffer.pParam = (CHAR *)malloc(((nAllocationSize & 4294967292U) + ((nAllocationSize & 3) ? 4 : 0)));\n    if (!pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession);\n        return 0;\n    }\n    memset(pHTTPSession->HttpHeaders.HeadersBuffer.pParam, 0, nAllocationSize);\n    pHTTPSession->HttpHeaders.HeadersBuffer.nLength = nAllocationSize;\n    HTTPClientSetVerb((HTTP_SESSION_HANDLE)pHTTPSession, (HTTP_VERB)0);\n    pHTTPSession->HttpUrl.nPort = 80;\n    pHTTPSession->HttpConnection.HttpSocket = (-1);\n    pHTTPSession->HttpHeaders.HeadersOut.pParam = pHTTPSession->HttpHeaders.HeadersBuffer.pParam;\n    pHTTPSession->HttpState = 1;\n    pHTTPSession->HttpFlags = Flags;\n    pHTTPSession->HttpHeadersInfo.nHTTPStatus = 0;\n    pHTTPSession->HttpNameCache.port = 80;\n    return (HTTP_SESSION_HANDLE)pHTTPSession;\n}\n","function_prediction":"HTTPClientRequest *HTTPClientOpenRequest_name_conflict(HTTPClient client) {\n  HTTPClientRequest *request;\n\n  request = malloc(sizeof(HTTPClientRequest));\n  if (request == NULL)\n    return NULL;\n  memset(request, 0, sizeof(HTTPClientRequest));\n\n  request->data = malloc(2048);\n  if (request->data == NULL) {\n    free(request);\n    return NULL;\n  }\n  memset(request->data, 0, 2048);\n  request->data_size = 2048;\n\n  HTTPClientSetVerb(request, NULL);\n\n  request->port = 80;\n  request->host = NULL;\n  request->path = NULL;\n  request->content_length = -1;\n  request->content_type = NULL;\n  request->content_encoding = NULL;\n  request->content_md5 = NULL;\n  request->content_range = NULL;\n  request->content_range_start = -1;\n  request->content_range_end = -1;\n  request->content_range_total = -1;\n  request->content_range_unit = NULL;\n  request->content_range_unit_size = -1;\n  request->content_range_unit_count = -1;\n  request->content_range_unit_start = -1;\n  request->content_range_unit_end = -1;\n  request->content_range_unit_total = -1;\n  request->content_range_unit_total_start = -1;\n  request->content_range_unit_total_end = -1;\n  request->content_range_unit_total_total = -1;\n  request->content_range_unit_total_total_start = -1;\n  request->content_range_unit_total_total_end = -1;\n  request->content_range_unit_total_total_total = -1;\n  request->content_range_unit_total_total_total_start = -1","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientReset(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    return HTTPIntrnSessionReset(pHTTPSession, 1);\n}\n","function_prediction":"int HTTPClientReset_name_conflict(HTTP_SESSION *session) {\n  // Validate arguments\n  if (session == NULL) {\n    return 2;\n  }\n\n  return HTTPIntrnSessionReset(session, 1);\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientCloseRequest(HTTP_SESSION_HANDLE *pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)*(pSession);\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession->HttpHeaders.HeadersBuffer.pParam);\n    }\n    HTTPIntrnConnectionClose(pHTTPSession);\n    free(pHTTPSession);\n    pHTTPSession = 0;\n    *(pSession) = 0;\n    return 0;\n}\n","function_prediction":"int HTTPClientCloseRequest_name_conflict(HTTPClientRequest **request) {\n  HTTPClientRequest *req = *request;\n  if (req == NULL)\n    return 2;\n  if (req->request_line != NULL)\n    free(req->request_line);\n  HTTPIntrnConnectionClose(&req->connection);\n  free(req);\n  *request = NULL;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetConnection(HTTP_SESSION_HANDLE pSession, BOOL Connection) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeadersInfo.Connection = Connection;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetConnection_name_conflict(HTTPClient *client, int connection) {\n  if (client == NULL)\n    return 2;\n\n  client->connection = connection;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetVerb(HTTP_SESSION_HANDLE pSession, HTTP_VERB HttpVerb) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.HttpVerb = HttpVerb;\n    switch (HttpVerb) {\n      case VerbGet:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"GET\");\n        break;\n      case VerbHead:\n        if (!0) {\n            return 18;\n        }\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"HEAD\");\n        break;\n      case VerbPost:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"POST\");\n        break;\n      case VerbPut:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"PUT\");\n        break;\n      default:\n        return 18;\n    }\n    ;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetVerb_name_conflict(HTTPClient *client, int verb) {\n  if (client == NULL)\n    return 2;\n\n  client->verb = verb;\n\n  switch (verb) {\n  case 0:\n    client->verb_str = \"GET\";\n    break;\n\n  case 1:\n    return 18;\n\n  case 2:\n    client->verb_str = \"POST\";\n    client->verb_str_len = 0;\n    break;\n\n  case 3:\n    client->verb_str = \"PUT\";\n    break;\n\n  default:\n    return 18;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetProxy(HTTP_SESSION_HANDLE pSession, CHAR *pProxyHost, UINT16 nPort, CHAR *pUserName, CHAR *pPassword) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    strncpy(pHTTPSession->HttpProxy.ProxyHost, pProxyHost, 64);\n    if (pUserName) {\n        strncpy(pHTTPSession->HttpProxy.ProxtUser, pUserName, 16);\n    }\n    if (pPassword) {\n        strncpy(pHTTPSession->HttpProxy.ProxyPassword, pPassword, 16);\n    }\n    pHTTPSession->HttpProxy.nProxyPort = nPort;\n    pHTTPSession->HttpFlags = pHTTPSession->HttpFlags | 128;\n    if (pPassword && pUserName) {\n        pHTTPSession->HttpProxy.ProxyAuthSchema = 1;\n    }\n    return 0;\n}\n","function_prediction":"int HTTPClientSetProxy(HTTPClient *client, const char *host,\n                       unsigned short port, const char *user,\n                       const char *password) {\n  if (client == NULL)\n    return 2;\n\n  strncpy(&client->proxy_host[0], host, 64);\n  if (user != NULL)\n    strncpy(&client->proxy_user[0], user, 16);\n  if (password != NULL)\n    strncpy(&client->proxy_password[0], password, 16);\n  client->proxy_port = port;\n\n  client->flags |= 0x80;\n\n  if (user != NULL && password != NULL)\n    client->proxy_auth = 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetCredentials(HTTP_SESSION_HANDLE pSession, CHAR *pUserName, CHAR *pPassword) {\n    UINT32 nLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nLength = strlen(pUserName);\n    if (nLength > 16) {\n        return 19;\n    }\n    nLength = strlen(pPassword);\n    if (nLength > 16) {\n        return 19;\n    }\n    strcpy(pHTTPSession->HttpCredentials.CredUser, pUserName);\n    strcpy(pHTTPSession->HttpCredentials.CredPassword, pPassword);\n    pHTTPSession->HttpHeadersInfo.HaveCredentials = 1;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetCredentials(HTTPClient *client, const char *username,\n                             const char *password) {\n  if (client == NULL)\n    return 2;\n\n  if (strlen(username) > 16)\n    return 19;\n\n  if (strlen(password) > 16)\n    return 19;\n\n  strcpy(&client->credentials[0], username);\n  strcpy(&client->credentials[16], password);\n\n  client->credentials_set = 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientAddRequestHeaders(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderName, CHAR *pHeaderData, BOOL nInsert) {\n    UINT32 nRetCode;\n    UINT32 nHeaderLength, nDataLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nHeaderLength = strlen(pHeaderName);\n    nDataLength = strlen(pHeaderData);\n    nRetCode = HTTPIntrnHeadersAdd(pHTTPSession, pHeaderName, nHeaderLength, pHeaderData, nDataLength);\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientAddRequestHeaders(HTTPClient *client, const char *name,\n                                const char *value) {\n  if (client == NULL)\n    return 2;\n\n  return HTTPIntrnHeadersAdd(&client->requestHeaders, name, strlen(name), value,\n                             strlen(value));\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientRecvResponse(HTTP_SESSION_HANDLE pSession, UINT32 nTimeout) {\n    UINT32 nRetCode;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    do {\n        if ((nRetCode = HTTPIntrnHeadersReceive(pHTTPSession, nTimeout)) != 0) {\n            break;\n        }\n    } while (0);\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientRecvResponse_name_conflict(HTTPClient *pClient, int timeout) {\n  if (pClient == NULL)\n    return 2;\n\n  return HTTPIntrnHeadersReceive(pClient, timeout);\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetInfo(HTTP_SESSION_HANDLE pSession, HTTP_CLIENT *HTTPClient) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    memset(HTTPClient, 0, sizeof(HTTP_CLIENT));\n    HTTPClient->HTTPStatusCode = pHTTPSession->HttpHeadersInfo.nHTTPStatus;\n    HTTPClient->RequestBodyLengthSent = pHTTPSession->HttpCounters.nSentBodyBytes;\n    HTTPClient->ResponseBodyLengthReceived = pHTTPSession->HttpCounters.nRecivedBodyLength;\n    HTTPClient->TotalResponseBodyLength = pHTTPSession->HttpHeadersInfo.nHTTPContentLength;\n    HTTPClient->HttpState = pHTTPSession->HttpState;\n    return 0;\n}\n","function_prediction":"int HTTPClientGetInfo_name_conflict(HTTPClient *client, HTTPClientInfo *info) {\n  if (client == NULL) {\n    return 2;\n  }\n\n  memset(info, 0, sizeof(HTTPClientInfo));\n\n  info->StatusCode = client->StatusCode;\n  info->StatusMessage = client->StatusMessage;\n  info->ContentType = client->ContentType;\n  info->ContentLength = client->ContentLength;\n  info->ContentEncoding = client->ContentEncoding;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindFirstHeader(HTTP_SESSION_HANDLE pSession, CHAR *pSearchClue, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nClueLength;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nClueLength = strlen(pSearchClue);\n    if (nClueLength >= 1024) {\n        return 13;\n    } else {\n        strcpy(pHTTPSession->HttpHeaders.SearchClue, pSearchClue);\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    }\n    return 0;\n}\n","function_prediction":"int HTTPClientFindFirstHeader_name_conflict(HTTP_CLIENT *http, const char *header) {\n  if (http == NULL) {\n    return 2;\n  }\n\n  if (strlen(header) >= 1024) {\n    return 13;\n  }\n\n  strcpy(http->HeaderName, header);\n  http->HeaderValue[0] = 0;\n  http->HeaderValuePos = 0;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindCloseHeader(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.SearchClue[0] = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    return 0;\n}\n","function_prediction":"int HTTPClientFindCloseHeader_name_conflict(HTTP_CLIENT *client) {\n  // Validate arguments\n  if (client == NULL) {\n    return 2;\n  }\n\n  client->HttpHeader.CloseHeader[104] = 0;\n  client->HttpHeader.CloseHeaderLen = 0;\n  client->HttpHeader.CloseHeaderPos = 0;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetNextHeader(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nOffset = 0;\n    UINT32 nRetCode;\n    HTTP_PARAM HttpHeader;\n    CHAR *pPtr;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeaderSearch.nLength > 0) {\n        nOffset = pHTTPSession->HttpHeaders.HeaderSearch.pParam - pHTTPSession->HttpHeaders.HeadersIn.pParam;\n    }\n    nRetCode = HTTPIntrnHeadersFind(pHTTPSession, pHTTPSession->HttpHeaders.SearchClue, &HttpHeader, 1, nOffset);\n    if (nRetCode == 0) {\n        if (HttpHeader.nLength > *(nLength)) {\n            *(nLength) = HttpHeader.nLength;\n            pHeaderBuffer[0] = 0;\n            return 3;\n        }\n        pPtr = HttpHeader.pParam;\n        nOffset = 0;\n        if (*pPtr == 13) {\n            nOffset++;\n            pPtr++;\n        }\n        if (*pPtr == 10) {\n            nOffset++;\n            pPtr++;\n        }\n        strncpy(pHeaderBuffer, pPtr, HttpHeader.nLength - nOffset);\n        pHeaderBuffer[HttpHeader.nLength - nOffset] = 0;\n        *(nLength) = HttpHeader.nLength - nOffset;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = HttpHeader.pParam + HttpHeader.nLength;\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength++;\n        return 0;\n    }\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientGetNextHeader_name_conflict(HTTPClient *http, char *header, int *header_len) {\n  int ret;\n  int offset = 0;\n  char *p;\n  char *q;\n  int len;\n\n  if (http == NULL)\n    return 2;\n\n  if (http->headers_pos != 0)\n    offset = http->headers_end - http->headers_pos;\n\n  ret = HTTPIntrnHeadersFind(http, &http->headers, &p, 1, offset);\n  if (ret != 0)\n    return ret;\n\n  len = p - http->headers_pos;\n  if (len > *header_len) {\n    *header_len = len;\n    header[0] = '\\0';\n    return 3;\n  }\n\n  q = p;\n  if (*q == '\\r')\n    q++;\n  if (*q == '\\n')\n    q++;\n\n  strncpy(header, q, len - (q - p));\n  header[len - (q - p)] = '\\0';\n  *header_len = len - (q - p);\n\n  http->headers_pos = p + len;\n  http->headers_pos++;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPIntrnSessionGetUpTime(void) {\n    return HTTPWrapperGetUpTime();\n}\n","function_prediction":"uint32_t HTTPIntrnSessionGetUpTime_name_conflict(HTTP_SESSION *pSession) {\n  return HTTPWrapperGetUpTime();\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"int HTTPBase64Decoder(char *out, const char *in) {\n    int len = 0;\n    register unsigned char digit1, digit2, digit3, digit4;\n    if (in[0] == '+' && in[1] == ' ')\n        in += 2;\n    if (*in == '\\r')\n        return (0);\n    do {\n        digit1 = in[0];\n        if (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) == -1)\n            return (-1);\n        digit2 = in[1];\n        if (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) == -1)\n            return (-1);\n        digit3 = in[2];\n        if (digit3 != '=' && ((((digit3) & ~127) == 0) ? base64val[digit3] : -1) == -1)\n            return (-1);\n        digit4 = in[3];\n        if (digit4 != '=' && ((((digit4) & ~127) == 0) ? base64val[digit4] : -1) == -1)\n            return (-1);\n        in += 4;\n        *out++ = (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) << 2) | (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) >> 4);\n        ++len;\n        if (digit3 != '=') {\n            *out++ = ((((((digit2) & ~127) == 0) ? base64val[digit2] : -1) << 4) & 240) | (((((digit3) & ~127) == 0) ? base64val[digit3] : -1) >> 2);\n            ++len;\n            if (digit4 != '=') {\n                *out++ = ((((((digit3) & ~127) == 0) ? base64val[digit3] : -1) << 6) & 192) | ((((digit4) & ~127) == 0) ? base64val[digit4] : -1);\n                ++len;\n            }\n        }\n    } while (*in && *in != '\\r' && digit4 != '=');\n    return (len);\n}\n","function_prediction":"int HTTPBase64Decoder_name_conflict(char *out, const char *in) {\n  int i, j, k, l;\n  char c1, c2, c3, c4;\n  char *p;\n\n  i = 0;\n  p = (char *)in;\n\n  if (*p == '+' && *(p + 1) == ' ')\n    p += 2;\n\n  while (*p != '\\r' && *p != '\\0') {\n    c1 = *p++;\n    c2 = *p++;\n    c3 = *p++;\n    c4 = *p++;\n\n    if (c1 < 0 || base64val[(int)c1] == -1 || c2 < 0 ||\n        base64val[(int)c2] == -1 || c3 < 0 || base64val[(int)c3] == -1 ||\n        c4 < 0 || base64val[(int)c4] == -1)\n      return -1;\n\n    j = base64val[(int)c1];\n    k = base64val[(int)c2];\n    l = base64val[(int)c3];\n\n    out[i++] = (j << 2) | (k >> 4);\n    if (c3 != '=')\n      out[i++] = (k << 4) | (l >> 2);\n    if (c4 != '=')\n      out[i++] = (l << 6) | base64val[(int)c4];\n  }\n\n  return i;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientAuth.c"}
{"compilable":1,"function":"static u8 gf_mult(u8 x, u8 y) {\n    u8 result = 0;\n    while (x != 0)\n        {\n            result ^= x & 1 ? y : 0;\n            x >>= 1;\n            y = ((y) & 128 ? ((y) << 1) ^ 27 : ((y) << 1));\n        }\n    return result;\n}\n","function_prediction":"unsigned char gf_mult_name_conflict(unsigned char a, unsigned char b) {\n  unsigned char p = 0;\n  for (unsigned char c = a; c; c >>= 1) {\n    if (c & 1)\n      p ^= b;\n    if (b & 0x80)\n      b = (b << 1) ^ 0x1b;\n    else\n      b <<= 1;\n  }\n  return p;\n}","pass":1,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":0,"function":"static u64 F(u64 x) {\n    u8 *temp = (u8 *)&x;\n    u8 a[8] = {};\n    int i, j;\n    for (i = 0; i < 8; i++)\n        temp[i] = sbox[temp[i]];\n    for (i = 0; i < 8; i++) {\n        for (j = 0; j < 8; j++) {\n            a[i] ^= gf_mult(temp[j], mds_matrix[i][j]);\n        }\n    }\n    x = *((u64 *)a);\n    return x;\n}\n","function_prediction":"void FUN_00101020(void) { PTR_00103ff8(); }","pass":0,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":1,"function":"static u8 char_val(char c) {\n    if (c >= '0' && c <= '9')\n        return c - '0';\n    if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    else if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    printf(\"Illegal character \\\"%c\\\"\\n\", c);\n    exit(1);\n    return 0;\n}\n","function_prediction":"int char_val_name_conflict(char c) {\n  if (c >= '0' && c <= '9')\n    return c - '0';\n  else if (c >= 'a' && c <= 'f')\n    return c - 'a' + 10;\n  else if (c >= 'A' && c <= 'F')\n    return c - 'A' + 10;\n  else {\n    printf(\"Illegal character \\\"%c\\\"\\n\", c);\n    exit(1);\n  }\n}","pass":1,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":1,"function":"char *build_chunked_response(int content_length, int *response_len) {\n    char *response_buffer;\n    char *content_buffer;\n    int buffer_length;\n    int i, n;\n    buffer_length = 256 + content_length + (content_length >> 4);\n    response_buffer = malloc(buffer_length);\n    *response_len = snprintf(response_buffer, buffer_length, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");\n    content_buffer = malloc(content_length);\n    build_content(content_buffer, content_length);\n    i = 0;\n    while (i < content_length)\n        {\n            n = (rand() % 199) + 1;\n            if (i + n > content_length) {\n                n = content_length - i;\n            }\n            *response_len += snprintf(response_buffer + *response_len, buffer_length - *response_len, \"%x\\r\\n\", n);\n            memcpy(response_buffer + *response_len, content_buffer + i, n);\n            *response_len += n;\n            i += n;\n            response_buffer[(*response_len)++] = '\\r';\n            response_buffer[(*response_len)++] = '\\n';\n        }\n    memcpy(response_buffer + *response_len, \"0\\r\\n\\r\\n\", 5);\n    *response_len += 5;\n    free(content_buffer);\n    printf(\"resp_length=%d buffer_length=%d content_length=%d\\n\", *response_len, buffer_length, content_length);\n    return response_buffer;\n}\n","function_prediction":"char *build_chunked_response_name_conflict(int content_length, int *resp_length) {\n  int buffer_length = content_length + (content_length >> 4) + 256;\n  char *buffer = malloc(buffer_length);\n  *resp_length = snprintf(buffer, buffer_length,\n                          \"HTTP/1.1 200 OK\\r\\n\"\n                          \"Content-Type: text/plain\\r\\n\"\n                          \"Transfer-Encoding: chunked\\r\\n\"\n                          \"\\r\\n\");\n\n  char *content = malloc(content_length);\n  build_content(content, content_length);\n\n  int offset = 0;\n  while (offset < content_length) {\n    int chunk_length = rand() % 199 + 1;\n    if (offset + chunk_length > content_length) {\n      chunk_length = content_length - offset;\n    }\n    *resp_length +=\n        snprintf(buffer + *resp_length, buffer_length - *resp_length, \"%x\\r\\n\",\n                 chunk_length);\n    memcpy(buffer + *resp_length, content + offset, chunk_length);\n    *resp_length += chunk_length;\n    buffer[(*resp_length)++] = '\\r';\n    buffer[(*resp_length)++] = '\\n';\n    offset += chunk_length;\n  }\n  memcpy(buffer + *resp_length, \"0\\r\\n\\r\\n\", 5);\n  *resp_length += 5;\n  free(content);\n  printf(\"resp_length=%d buffer_length=%d content_length=%d\\n\", *resp_length,\n         buffer_length, content_length);\n  return buffer;\n}","pass":1,"source_file":"C_COMPILE/mdilai_jweegad/external/miniupnpc/minihttptestserver.c"}
{"compilable":0,"function":"unsigned long long fatorial(unsigned int valor) {\n    unsigned long long i, fatorial = 1;\n    for (i = 1; i <= valor; i++) {\n        fatorial *= i;\n    }\n    return fatorial;\n}\n","function_prediction":"long fatorial_name_conflict(int n) {\n  long fat = 1;\n  for (int i = 1; i <= n; i++) {\n    fat *= i;\n  }\n  return fat;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_29-05/ex1.c"}
{"compilable":1,"function":"bool comparar(int *v1, int *v2) {\n    if (*v1 > *v2) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int comparar_name_conflict(const void *a, const void *b) { return (*(int *)a > *(int *)b); }","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_31-05/bouble_sort.c"}
{"compilable":0,"function":"char *init_palavra(char *texto_palavra) {\n    char *palavra = (char *)malloc(sizeof(char) * (strlen(texto_palavra) + 1));\n    strcpy(palavra, texto_palavra);\n    return palavra;\n}\n","function_prediction":"char *init_palavra_name_conflict(char *palavra) {\n  char *palavra_inicial = (char *)malloc(strlen(palavra) + 1);\n  strcpy(palavra_inicial, palavra);\n  return palavra_inicial;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":0,"function":"char *init_mascara(unsigned int tamanho_palavra) {\n    unsigned int i;\n    char *mascara = (char *)malloc(sizeof(char) * (tamanho_palavra + 1));\n    for (i = 0; i < tamanho_palavra; i++) {\n        mascara[i] = '_';\n    }\n    mascara[i] = '\\x00';\n    return mascara;\n}\n","function_prediction":"char *init_mascara_name_conflict(unsigned int tam) {\n  char *mascara = malloc(tam + 1);\n  unsigned int i;\n\n  for (i = 0; i < tam; i++)\n    mascara[i] = '_';\n  mascara[i] = '\\0';\n\n  return mascara;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":0,"function":"bool existe_letra_na_palavra(char letra, char *palavra) {\n    unsigned int i;\n    for (i = 0; i < strlen(palavra); i++) {\n        if (letra == palavra[i]) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int existe_letra_na_palavra_name_conflict(char letra, char *palavra) {\n  for (int i = 0; i < strlen(palavra); i++) {\n    if (palavra[i] == letra) {\n      return 1;\n    }\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":1,"function":"bool eh_palindromo(int *vetor, int tamanho) {\n    int i = 0;\n    for (i = 0; i < tamanho / 2; i++) {\n        if (vetor[i] != vetor[tamanho - 1 - i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"int eh_palindromo_name_conflict(int *vetor, int tamanho) {\n  int i;\n\n  for (i = 0; i < tamanho / 2; i++) {\n    if (vetor[i] != vetor[tamanho - 1 - i]) {\n      return 0;\n    }\n  }\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_05-06/ex1.c"}
{"compilable":0,"function":"unsigned int calcularTamanhoRegistro(const Registro registro) {\n    unsigned int tamanhoRegistro = strlen(registro.ra) + strlen(registro.nome) + strlen(registro.curso) + strlen(registro.ano);\n    tamanhoRegistro *= sizeof(char);\n    tamanhoRegistro += 5;\n    return tamanhoRegistro;\n}\n","function_prediction":"int calcularTamanhoRegistro_name_conflict() {\n    return strlen(\"00000\") + strlen(\"00000\") + strlen(\"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":0,"function":"LittleEndian toLittleEndian(const unsigned short numero) {\n    unsigned short primeiroByte = (numero & 65280) >> 8;\n    unsigned short segundoByte = (numero & 255);\n    LittleEndian little;\n    little.number[0] = segundoByte;\n    little.number[1] = primeiroByte;\n    return little;\n}\n","function_prediction":"uint16_t toLittleEndian_name_conflict(uint16_t value) { return value; }","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":0,"function":"unsigned short revertLittleEndian(const LittleEndian little) {\n    unsigned short primeiroByte = (little.number[1] & 255) << 8;\n    unsigned short segundoByte = little.number[0] & 255;\n    return primeiroByte | segundoByte;\n}\n","function_prediction":"unsigned short revertLittleEndian_name_conflict(unsigned short value) {\n  return (value & 0x00FFU) << 8 | (value & 0xFF00U) >> 8;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":1,"function":"int count(char *string) {\n    int length = 0;\n    while (string[length] != '\\x00')\n        {\n            length++;\n        }\n    return length;\n}\n","function_prediction":"int count_name_conflict(char *s) {\n  int i;\n  for (i = 0; s[i] != '\\0'; i++)\n    ;\n  return i;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/08-09/ex3.c"}
{"compilable":1,"function":"int ordenar(const char *nomeBase) {\n    int quantidadeArquivos = 0;\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    quantidadeArquivos = contarArquivos(nomeBase);\n    if (quantidadeArquivos == 0) {\n        fprintf(stderr, \"Nao existe outros arquivos a patir do arquivo base especificado!\\n\");\n        return 1;\n    }\n    return intercalar(nomeBase, quantidadeArquivos);\n}\n","function_prediction":"int ordenar_name_conflict(char *nomeArquivo) {\n\n  int numArquivos;\n  char *nomeArquivoSaida = malloc(strlen(nomeArquivo + 10));\n\n  if (nomeArquivoSaida == NULL) {\n    fwrite(\"Problema com alocacao dinamica! Possivel falta de memoria\\n\", 1, 58,\n           stderr);\n    return 1;\n  }\n\n  numArquivos = contarArquivos(nomeArquivo);\n\n  if (numArquivos == 0) {\n    fwrite(\"Nao existe outros arquivos a patir do arquivo base especificado!\\n\",\n           1, 65, stderr);\n    return 1;\n  }\n\n  intercalar(nomeArquivo, numArquivos);\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":1,"function":"int contarArquivos(const char *nomeBase) {\n    int quantidadeArquivos = 0;\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    for (int i = 0; i < 10; i++) {\n        sprintf(nomeArquivo, \"%s%d\", nomeBase, i);\n        if (existeArquivo(nomeArquivo)) {\n            quantidadeArquivos++;\n        }\n    }\n    free(nomeArquivo);\n    return quantidadeArquivos;\n}\n","function_prediction":"int contarArquivos_name_conflict(char *nomeArquivo) {\n  int i, cont = 0;\n  char *nomeArquivoAux;\n\n  nomeArquivoAux = (char *)malloc(strlen(nomeArquivo + 10) * sizeof(char));\n  if (nomeArquivoAux == NULL) {\n    fprintf(stderr,\n            \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n    return 1;\n  }\n\n  for (i = 0; i < 10; i++) {\n    sprintf(nomeArquivoAux, \"%s%d\", nomeArquivo, i);\n    if (existeArquivo(nomeArquivoAux)) {\n      cont++;\n    }\n  }\n\n  free(nomeArquivoAux);\n  return cont;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":1,"function":"_Bool existeArquivo(const char *nomeArquivo) {\n    FILE *arquivo = fopen(nomeArquivo, \"rb\");\n    _Bool result = arquivo != ((void *)0);\n    if (result) {\n        fclose(arquivo);\n    }\n    return result;\n}\n","function_prediction":"int existeArquivo_name_conflict(char *nomeArquivo) {\n  FILE *arquivo;\n\n  arquivo = fopen(nomeArquivo, \"rb\");\n\n  if (arquivo != NULL) {\n    fclose(arquivo);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"int intercalar(const char *nomeBase, int quantidadeArquivos) {\n    FILE *arquivosEntrada[10];\n    FILE *arquivoSaida;\n    int buffer[10][5];\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        sprintf(nomeArquivo, \"%s%d\", nomeBase, i);\n        arquivosEntrada[i] = fopen(nomeArquivo, \"rb\");\n        if (arquivosEntrada[i] == ((void *)0)) {\n            fprintf(stderr, \"Problema na abertura do arquivo %s\\n\", nomeArquivo);\n            for (int j = 0; j < i; j++) {\n                fclose(arquivosEntrada[j]);\n            }\n            free(nomeArquivo);\n            return 1;\n        }\n    }\n    arquivoSaida = fopen(nomeBase, \"wb\");\n    if (arquivoSaida == ((void *)0)) {\n        fprintf(stderr, \"Problema na abertura do arquivo %s\\n\", nomeBase);\n        for (int i = 0; i < quantidadeArquivos; i++) {\n            fclose(arquivosEntrada[i]);\n        }\n        free(nomeArquivo);\n        return 1;\n    }\n    while (!leuTodosOsArquivosPorCompleto(arquivosEntrada, quantidadeArquivos))\n        {\n            int lidoAtual[10] = {0};\n            for (int i = 0; i < quantidadeArquivos; i++) {\n                lidoAtual[i] = fread(buffer[i], sizeof(int), 5, arquivosEntrada[i]);\n            }\n            int indices[10] = {0};\n            int min = pegaMenor(buffer, quantidadeArquivos, indices, lidoAtual);\n            while (min != -1)\n                {\n                    fwrite(&buffer[min][indices[min]], sizeof(int), 1, arquivoSaida);\n                    indices[min]++;\n                    if (indices[min] == lidoAtual[min]) {\n                        lidoAtual[min] = fread(buffer[min], sizeof(int), 5, arquivosEntrada[min]);\n                        indices[min] = 0;\n                    }\n                    min = pegaMenor(buffer, quantidadeArquivos, indices, lidoAtual);\n                }\n        }\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        fclose(arquivosEntrada[i]);\n    }\n    fclose(arquivoSaida);\n    free(nomeArquivo);\n    return 0;\n}\n","function_prediction":"int intercalar_name_conflict(char *nomeArquivo, int nroArquivos) {\n  int i, j, k, menor, indice;\n  int tamanho[10];\n  int posicao[10];\n  int tamanhoArquivo;\n  int posicaoArquivo;\n  int tamanhoArquivoLido[10];\n  int posicaoArquivoLido[10];\n  int tamanhoArquivoLidoAux[10];\n  int posicaoArquivoLidoAux[10];\n  int tamanhoArquivoLidoAux2[10];\n  int posicaoArquivoLidoAux2[10];\n  int tamanhoArquivoLidoAux3[10];\n  int posicaoArquivoLidoAux3[10];\n  int tamanhoArquivoLidoAux4[10];\n  int posicaoArquivoLidoAux4[10];\n  int tamanhoArquivoLidoAux5[10];\n  int posicaoArquivoLidoAux5[10];\n  int tamanhoArquivoLidoAux6[10];\n  int posicaoArquivoLidoAux6[10];\n  int tamanhoArquivoLidoAux7[10];\n  int posicaoArquivoLidoAux7[10];\n  int tamanhoArquivoLidoAux8[10];\n  int posicaoArquivoLidoAux8[10];\n  int tamanhoArquivoLidoAux9[10];\n  int posicaoArquivoLidoAux9[10];\n  int tamanhoArquivoLidoAux10[10];\n  int posicaoArquivoLidoAux10[10];\n  int tamanhoArquivoLidoAux11[10];\n  int posicaoArquivoLidoAux11[10];\n  int tamanhoArquivo","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"int pegaMenor(const int buffer[][5], const int quantidadeArquivos, const int *indices, const int *lidoAtual) {\n    int min = -1;\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        if (lidoAtual[i] > 0 && indices[i] < lidoAtual[i]) {\n            min = i;\n            break;\n        }\n    }\n    if (min != -1) {\n        for (int i = 0; i < quantidadeArquivos; i++) {\n            if (buffer[min][indices[min]] > buffer[i][indices[i]] && indices[i] < lidoAtual[i]) {\n                min = i;\n            }\n        }\n    }\n    return min;\n}\n","function_prediction":"int pegaMenor_name_conflict(int matriz[10][20], int n, int vetor[10], int vetor2[10]) {\n  int i, j, menor = -1;\n  for (i = 0; i < n; i++) {\n    if (vetor2[i] > 0 && vetor[i] < vetor2[i]) {\n      menor = i;\n      break;\n    }\n  }\n  if (menor != -1) {\n    for (j = 0; j < n; j++) {\n      if (matriz[vetor[j]][j] < matriz[vetor[menor]][j] &&\n          vetor[j] < vetor2[j]) {\n        menor = j;\n      }\n    }\n  }\n  return menor;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":1,"function":"int comprimento(char *string) {\n    unsigned int quantidade = 0;\n    while (*string != '\\x00')\n        {\n            quantidade++;\n            string++;\n        }\n    return quantidade;\n}\n","function_prediction":"int comprimento_name_conflict(char *str) {\n  int i;\n  for (i = 0; *(str + i) != '\\0'; i++)\n    ;\n  return i;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":1,"function":"char *maiuscula(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string > 96) {\n            *string -= 32;\n        }\n    }\n    return string;\n}\n","function_prediction":"char *maiuscula_name_conflict(char *s) {\n  unsigned int i, tam = comprimento(s);\n  for (i = 0; i < tam; i++)\n    if (s[i] >= 'a' && s[i] <= 'z')\n      s[i] -= 'a' - 'A';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":1,"function":"char *intercala(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    bool foi = 0;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string > 96 && *string < 123) {\n            if (!foi) {\n                *string -= 32;\n                foi = 1;\n            } else {\n                foi = 0;\n            }\n        }\n    }\n    return string;\n}\n","function_prediction":"char *intercala_name_conflict(char *str) {\n  unsigned int i, tam;\n  int flag = 0;\n\n  tam = comprimento(str);\n\n  for (i = 0; i < tam; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      if (flag == 0) {\n        str[i] -= 32;\n        flag = 1;\n      } else\n        flag = 0;\n    }\n  }\n\n  return str;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":1,"function":"char *minuscula(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string < 91 && *string > 64) {\n            *string += 32;\n        }\n    }\n    return string;\n}\n","function_prediction":"char *minuscula_name_conflict(char *str) {\n  unsigned int i, tam;\n  tam = comprimento(str);\n  for (i = 0; i < tam; i++) {\n    if (str[i] >= 'A' && str[i] <= 'Z') {\n      str[i] = str[i] + 32;\n    }\n  }\n  return str;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":1,"function":"int jogar(int ev1, int ev2, int at, int d) {\n    int dado, ganhador;\n    while (ev1 > 0 && ev2 > 0)\n        {\n            dado = aleatorio();\n            if (dado <= at) {\n                ev1 += d;\n                ev2 -= d;\n            } else {\n                ev1 -= d;\n                ev2 += d;\n            }\n            printf(\"Dado %d EV1 %d EV2 %d\\n\", dado, ev1, ev2);\n        }\n    if (ev1 <= 0) {\n        ganhador = 2;\n    } else {\n        ganhador = 1;\n    }\n    return ganhador;\n}\n","function_prediction":"int jogar_name_conflict(int EV1, int EV2, int limiar, int incremento) {\n  int dado;\n\n  while (EV1 > 0 && EV2 > 0) {\n    dado = aleatorio();\n    if (dado > limiar) {\n      EV1 -= incremento;\n      EV2 += incremento;\n    } else {\n      EV1 += incremento;\n      EV2 -= incremento;\n    }\n    printf(\"Dado %d EV1 %d EV2 %d\\n\", dado, EV1, EV2);\n  }\n\n  if (EV1 > 0)\n    return 1;\n  else\n    return 2;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_03-05/uri-1093.c"}
{"compilable":1,"function":"int aleatorio() {\n    srand(time(((void *)0)));\n    return rand() % 6 + 1;\n}\n","function_prediction":"int aleatorio_name_conflict() {\n  srand(time(NULL));\n  return (rand() % 6) + 1;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_03-05/uri-1093.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"int **new_board_name_conflict() {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"int **clone_name_conflict(int **board) {\n  int **newBoard = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    newBoard[i] = calloc(3, sizeof(int));\n    for (int j = 0; j < 3; j++) {\n      newBoard[i][j] = board[i][j];\n    }\n  }\n  return newBoard;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"board_t read_encode_name_conflict(char *str) {\n  board_t board = new_board();\n  int i, j;\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 3; j++) {\n      switch (*str) {\n      case 'X':\n        board[i][j] = 1;\n        break;\n      case 'O':\n        board[i][j] = 2;\n        break;\n      case '-':\n        board[i][j] = 0;\n        break;\n      }\n      str++;\n    }\n  }\n  return board;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"int turn_name_conflict(int **board) {\n  int i, j, x = 0, o = 0;\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      if (board[i][j] == 1)\n        x++;\n      else if (board[i][j] == 2)\n        o++;\n  if (x + o == 9)\n    return_name_conflict 0;\n  else if (x > o)\n    return_name_conflict 1;\n  else\n    return_name_conflict 2;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"struct board move_name_conflict(struct board b, struct move_name_conflict m) {\n  b = clone(b, m);\n  b.cells[m.row][m.col] = turn(b);\n  return b;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"int winner_name_conflict(int **board) {\n  int i;\n  for (i = 0; i < 3; i++) {\n    if (board[i][0] != 0 && board[i][0] == board[i][1] &&\n        board[i][0] == board[i][2])\n      return board[i][0];\n    if (board[0][i] != 0 && board[0][i] == board[1][i] &&\n        board[0][i] == board[2][i])\n      return board[0][i];\n  }\n  if (board[0][0] != 0 && board[0][0] == board[1][1] &&\n      board[0][0] == board[2][2])\n    return board[0][0];\n  if (board[2][0] != 0 && board[2][0] == board[1][1] &&\n      board[2][0] == board[0][2])\n    return board[2][0];\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"int cpu_name_conflict(int board[3][3]) {\n  int t = turn(board);\n  int best = -9;\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      if (board[i][j] == 0) {\n        int *newboard = move(board, i, j);\n        if (winner(newboard) == t) {\n          return 18 + i * 3 + j;\n        }\n        if (turn(newboard) == 0) {\n          if (best < 9) {\n            best = 9 + i * 3 + j;\n          }\n        } else {\n          int score = 2 - cpu_name_conflict(newboard) / 9;\n          if (score > best / 9) {\n            best = i * 3 + j + score * 9;\n          }\n        }\n      }\n    }\n  }\n  return best;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"int **new_board_name_conflict() {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"int **clone_name_conflict(int **board) {\n  int **newBoard = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    newBoard[i] = calloc(3, sizeof(int));\n    for (int j = 0; j < 3; j++) {\n      newBoard[i][j] = board[i][j];\n    }\n  }\n  return newBoard;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"board_t read_encode_name_conflict(char *str) {\n  board_t board = new_board();\n  int i, j;\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 3; j++) {\n      switch (*str) {\n      case 'X':\n        board[i][j] = 1;\n        break;\n      case 'O':\n        board[i][j] = 2;\n        break;\n      case '-':\n        board[i][j] = 0;\n        break;\n      }\n      str++;\n    }\n  }\n  return board;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"int turn_name_conflict(int **board) {\n  int i, j, x = 0, o = 0;\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      if (board[i][j] == 1)\n        x++;\n      else if (board[i][j] == 2)\n        o++;\n  if (x + o == 9)\n    return_name_conflict 0;\n  else if (x > o)\n    return_name_conflict 1;\n  else\n    return_name_conflict 2;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"struct board move_name_conflict(struct board b, struct move_name_conflict m) {\n  b = clone(b, m);\n  b.cells[m.row][m.col] = turn(b);\n  return b;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"int winner_name_conflict(int **board) {\n  int i;\n  for (i = 0; i < 3; i++) {\n    if (board[i][0] != 0 && board[i][0] == board[i][1] &&\n        board[i][0] == board[i][2])\n      return board[i][0];\n    if (board[0][i] != 0 && board[0][i] == board[1][i] &&\n        board[0][i] == board[2][i])\n      return board[0][i];\n  }\n  if (board[0][0] != 0 && board[0][0] == board[1][1] &&\n      board[0][0] == board[2][2])\n    return board[0][0];\n  if (board[2][0] != 0 && board[2][0] == board[1][1] &&\n      board[2][0] == board[0][2])\n    return board[2][0];\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"int cpu_name_conflict(int board[3][3]) {\n  int t = turn(board);\n  int best = -9;\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      if (board[i][j] == 0) {\n        int *newboard = move(board, i, j);\n        if (winner(newboard) == t) {\n          return 18 + i * 3 + j;\n        }\n        if (turn(newboard) == 0) {\n          if (best < 9) {\n            best = 9 + i * 3 + j;\n          }\n        } else {\n          int score = 2 - cpu_name_conflict(newboard) / 9;\n          if (score > best / 9) {\n            best = i * 3 + j + score * 9;\n          }\n        }\n      }\n    }\n  }\n  return best;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"int **new_board_name_conflict() {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"int **clone_name_conflict(int **board) {\n  int **newBoard = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    newBoard[i] = calloc(3, sizeof(int));\n    for (int j = 0; j < 3; j++) {\n      newBoard[i][j] = board[i][j];\n    }\n  }\n  return newBoard;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"board_t read_encode_name_conflict(char *str) {\n  board_t board = new_board();\n  int i, j;\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 3; j++) {\n      switch (*str) {\n      case 'X':\n        board[i][j] = 1;\n        break;\n      case 'O':\n        board[i][j] = 2;\n        break;\n      case '-':\n        board[i][j] = 0;\n        break;\n      }\n      str++;\n    }\n  }\n  return board;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"int turn_name_conflict(int **board) {\n  int i, j, x = 0, o = 0;\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      if (board[i][j] == 1)\n        x++;\n      else if (board[i][j] == 2)\n        o++;\n  if (x + o == 9)\n    return_name_conflict 0;\n  else if (x > o)\n    return_name_conflict 1;\n  else\n    return_name_conflict 2;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"struct board move_name_conflict(struct board b, struct move_name_conflict m) {\n  b = clone(b, m);\n  b.cells[m.row][m.col] = turn(b);\n  return b;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"int winner_name_conflict(int **board) {\n  int i;\n  for (i = 0; i < 3; i++) {\n    if (board[i][0] != 0 && board[i][0] == board[i][1] &&\n        board[i][0] == board[i][2])\n      return board[i][0];\n    if (board[0][i] != 0 && board[0][i] == board[1][i] &&\n        board[0][i] == board[2][i])\n      return board[0][i];\n  }\n  if (board[0][0] != 0 && board[0][0] == board[1][1] &&\n      board[0][0] == board[2][2])\n    return board[0][0];\n  if (board[2][0] != 0 && board[2][0] == board[1][1] &&\n      board[2][0] == board[0][2])\n    return board[2][0];\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"int cpu_name_conflict(int board[3][3]) {\n  int t = turn(board);\n  int best = -9;\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      if (board[i][j] == 0) {\n        int *newboard = move(board, i, j);\n        if (winner(newboard) == t) {\n          return 18 + i * 3 + j;\n        }\n        if (turn(newboard) == 0) {\n          if (best < 9) {\n            best = 9 + i * 3 + j;\n          }\n        } else {\n          int score = 2 - cpu_name_conflict(newboard) / 9;\n          if (score > best / 9) {\n            best = i * 3 + j + score * 9;\n          }\n        }\n      }\n    }\n  }\n  return best;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"int **new_board_name_conflict() {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"int **clone_name_conflict(int **board) {\n  int **newBoard = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    newBoard[i] = calloc(3, sizeof(int));\n    for (int j = 0; j < 3; j++) {\n      newBoard[i][j] = board[i][j];\n    }\n  }\n  return newBoard;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"board_t read_encode_name_conflict(char *str) {\n  board_t board = new_board();\n  int i, j;\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 3; j++) {\n      switch (*str) {\n      case 'X':\n        board[i][j] = 1;\n        break;\n      case 'O':\n        board[i][j] = 2;\n        break;\n      case '-':\n        board[i][j] = 0;\n        break;\n      }\n      str++;\n    }\n  }\n  return board;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"int turn_name_conflict(int **board) {\n  int i, j, x = 0, o = 0;\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      if (board[i][j] == 1)\n        x++;\n      else if (board[i][j] == 2)\n        o++;\n  if (x + o == 9)\n    return_name_conflict 0;\n  else if (x > o)\n    return_name_conflict 1;\n  else\n    return_name_conflict 2;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"struct board move_name_conflict(struct board b, struct move_name_conflict m) {\n  b = clone(b, m);\n  b.cells[m.row][m.col] = turn(b);\n  return b;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"int winner_name_conflict(int **board) {\n  int i;\n  for (i = 0; i < 3; i++) {\n    if (board[i][0] != 0 && board[i][0] == board[i][1] &&\n        board[i][0] == board[i][2])\n      return board[i][0];\n    if (board[0][i] != 0 && board[0][i] == board[1][i] &&\n        board[0][i] == board[2][i])\n      return board[0][i];\n  }\n  if (board[0][0] != 0 && board[0][0] == board[1][1] &&\n      board[0][0] == board[2][2])\n    return board[0][0];\n  if (board[2][0] != 0 && board[2][0] == board[1][1] &&\n      board[2][0] == board[0][2])\n    return board[2][0];\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"int cpu_name_conflict(int board[3][3]) {\n  int t = turn(board);\n  int best = -9;\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      if (board[i][j] == 0) {\n        int *newboard = move(board, i, j);\n        if (winner(newboard) == t) {\n          return 18 + i * 3 + j;\n        }\n        if (turn(newboard) == 0) {\n          if (best < 9) {\n            best = 9 + i * 3 + j;\n          }\n        } else {\n          int score = 2 - cpu_name_conflict(newboard) / 9;\n          if (score > best / 9) {\n            best = i * 3 + j + score * 9;\n          }\n        }\n      }\n    }\n  }\n  return best;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"int **new_board_name_conflict() {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"int **clone_name_conflict(int **board) {\n  int **newBoard = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    newBoard[i] = calloc(3, sizeof(int));\n    for (int j = 0; j < 3; j++) {\n      newBoard[i][j] = board[i][j];\n    }\n  }\n  return newBoard;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"board_t read_encode_name_conflict(char *str) {\n  board_t board = new_board();\n  int i, j;\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < 3; j++) {\n      switch (*str) {\n      case 'X':\n        board[i][j] = 1;\n        break;\n      case 'O':\n        board[i][j] = 2;\n        break;\n      case '-':\n        board[i][j] = 0;\n        break;\n      }\n      str++;\n    }\n  }\n  return board;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"int turn_name_conflict(int **board) {\n  int i, j, x = 0, o = 0;\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      if (board[i][j] == 1)\n        x++;\n      else if (board[i][j] == 2)\n        o++;\n  if (x + o == 9)\n    return_name_conflict 0;\n  else if (x > o)\n    return_name_conflict 1;\n  else\n    return_name_conflict 2;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"struct board move_name_conflict(struct board b, struct move_name_conflict m) {\n  b = clone(b, m);\n  b.cells[m.row][m.col] = turn(b);\n  return b;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"int winner_name_conflict(int **board) {\n  int i;\n  for (i = 0; i < 3; i++) {\n    if (board[i][0] != 0 && board[i][0] == board[i][1] &&\n        board[i][0] == board[i][2])\n      return board[i][0];\n    if (board[0][i] != 0 && board[0][i] == board[1][i] &&\n        board[0][i] == board[2][i])\n      return board[0][i];\n  }\n  if (board[0][0] != 0 && board[0][0] == board[1][1] &&\n      board[0][0] == board[2][2])\n    return board[0][0];\n  if (board[2][0] != 0 && board[2][0] == board[1][1] &&\n      board[2][0] == board[0][2])\n    return board[2][0];\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"int cpu_name_conflict(int board[3][3]) {\n  int t = turn(board);\n  int best = -9;\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      if (board[i][j] == 0) {\n        int *newboard = move(board, i, j);\n        if (winner(newboard) == t) {\n          return 18 + i * 3 + j;\n        }\n        if (turn(newboard) == 0) {\n          if (best < 9) {\n            best = 9 + i * 3 + j;\n          }\n        } else {\n          int score = 2 - cpu_name_conflict(newboard) / 9;\n          if (score > best / 9) {\n            best = i * 3 + j + score * 9;\n          }\n        }\n      }\n    }\n  }\n  return best;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int init_net(char *address, char *port, int *sock) {\n    int s, v, i;\n    struct addrinfo hints, *result, *rp;\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = 0;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = 1 | 4;\n    hints.ai_protocol = IPPROTO_IP;\n    if ((s = getaddrinfo(address, port, &hints, &result)) != 0) {\n        fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(s));\n        exit(1);\n    }\n    for (rp = result , i = 0; rp != ((void *)0) && i < 2; rp = rp->ai_next , ++i) {\n        sock[i] = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n        if (sock[i] == -1) {\n            perror(\"socket\");\n            continue;\n        }\n        v = 1;\n        if (setsockopt(sock[i], 1, 2, &v, sizeof (v)) < 0) {\n            perror(\"setsockopt\");\n            return -1;\n        }\n        if (bind(sock[i], rp->ai_addr, rp->ai_addrlen) < 0) {\n            perror(\"socket\");\n            return -1;\n        }\n        if (listen(sock[i], 5) < 0) {\n            perror(\"listen\");\n            return -1;\n        }\n    }\n    freeaddrinfo(result);\n    return 0;\n}\n","function_prediction":"int init_net_name_conflict(char *host, char *port, int *sock) {\n  struct addrinfo hints, *res, *p;\n  int status;\n  int yes = 1;\n\n  memset(&hints, 0, sizeof hints);\n  hints.ai_family = 0;\n  hints.ai_socktype = 1;\n  hints.ai_flags = 5;\n  hints.ai_protocol = 0;\n\n  if ((status = getaddrinfo(host, port, &hints, &res)) != 0) {\n    fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(status));\n    exit(1);\n  }\n\n  p = res;\n  int i = 0;\n  while (p != NULL && i < 2) {\n    sock[i] = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n    if (sock[i] == -1) {\n      perror(\"socket\");\n    } else {\n      if (setsockopt(sock[i], 1, 2, &yes, sizeof(int)) < 0) {\n        perror(\"setsockopt\");\n        return -1;\n      }\n      if (bind(sock[i], p->ai_addr, p->ai_addrlen) < 0) {\n        perror(\"socket\");\n        return -1;\n      }\n      if (listen(sock[i], 5) < 0) {\n        perror(\"listen\");\n        return -1;\n      }\n    }\n    p = p->ai_next;\n    i++;\n  }\n\n  freeaddrinfo(res);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/binarylu_cs631/HW3/net.c"}
{"compilable":1,"function":"int sockaddr2string(struct sockaddr *sa, char *address) {\n    struct sockaddr_in *server;\n    struct sockaddr_in6 *server6;\n    if (sa->sa_family == 2) {\n        server = (struct sockaddr_in *)sa;\n        if (inet_ntop(sa->sa_family, &(server->sin_addr), address, 46) == ((void *)0)) {\n            perror(\"inet_ntop\");\n            return -1;\n        }\n    } else {\n        server6 = (struct sockaddr_in6 *)sa;\n        if (inet_ntop(sa->sa_family, &(server6->sin6_addr), address, 46) == ((void *)0)) {\n            perror(\"inet_ntop\");\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int sockaddr2string_name_conflict(struct sockaddr *sa, char *str) {\n  if (sa->sa_family == 2) {\n    if (inet_ntop(sa->sa_family, &(((struct sockaddr_in *)sa)->sin_addr), str,\n                  46) == NULL) {\n      perror(\"inet_ntop\");\n      return -1;\n    }\n  } else {\n    if (inet_ntop(sa->sa_family, &(((struct sockaddr_in6 *)sa)->sin6_addr), str,\n                  46) == NULL) {\n      perror(\"inet_ntop\");\n      return -1;\n    }\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/binarylu_cs631/HW3/net.c"}
{"compilable":0,"function":"int is_number(char *str) {\n    int i;\n    int len = strlen(str);\n    for (i = 0; i < len; ++i)\n        if (!((*__ctype_b_loc())[(int)((str[i]))] & (unsigned short)_ISdigit))\n            return 0;\n    return 1;\n}\n","function_prediction":"int is_number_name_conflict(char *str) {\n  int i, len;\n\n  len = strlen(str);\n  for (i = 0; i < len; i++)\n    if (!((__ctype_b_loc())->__b[str[i]] & 02000))\n      return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/binarylu_cs631/HW3/main.c"}
{"compilable":0,"function":"int q_isEmpty(enum_q_type t) {\n    int ret = 0;\n    pthread_mutex_t *mutex = ((void *)0);\n    _task_queue_entry **head = ((void *)0);\n    if (t == TASK) {\n        mutex = &task_mutex;\n        head = &task_head;\n    } else if (t == RESPONSE) {\n        mutex = &response_mutex;\n        head = &response_head;\n    } else {\n        return 1;\n    }\n    pthread_mutex_lock(mutex);\n    ret = *head == ((void *)0) ? 1 : 0;\n    pthread_mutex_unlock(mutex);\n    return ret;\n}\n","function_prediction":"int q_isEmpty_name_conflict(int type) {\n  int isEmpty = 0;\n  struct task_node *task_head_ptr;\n  struct response_node *response_head_ptr;\n  pthread_mutex_t *mutex_ptr;\n\n  if (type == 0) {\n    task_head_ptr = &task_head;\n    mutex_ptr = &task_mutex;\n  } else if (type == 1) {\n    response_head_ptr = &response_head;\n    mutex_ptr = &response_mutex;\n  } else {\n    return 1;\n  }\n\n  pthread_mutex_lock(mutex_ptr);\n  if (type == 0) {\n    if (task_head_ptr->next == NULL) {\n      isEmpty = 1;\n    }\n  } else if (type == 1) {\n    if (response_head_ptr->next == NULL) {\n      isEmpty = 1;\n    }\n  }\n  pthread_mutex_unlock(mutex_ptr);\n\n  return isEmpty;\n}","pass":0,"source_file":"C_COMPILE/binarylu_cs631/Final/task_queue.c"}
{"compilable":1,"function":"int init_epoll(int sock) {\n    int epfd;\n    struct epoll_event ev;\n    if ((epfd = epoll_create(100)) < 0) {\n        perror(\"epoll_create\");\n        return -1;\n    }\n    ev.events = EPOLLIN | EPOLLET;\n    ev.data.fd = sock;\n    if (epoll_ctl(epfd, 1, sock, &ev) < 0) {\n        perror(\"epoll_ctl\");\n        return -1;\n    }\n    return epfd;\n}\n","function_prediction":"int init_epoll_name_conflict(int listenfd) {\n  int epollfd;\n  struct epoll_event event;\n\n  epollfd = epoll_create(100);\n  if (epollfd < 0) {\n    perror(\"epoll_create\");\n    return -1;\n  }\n\n  event.data.fd = listenfd;\n  event.events = EPOLLIN | EPOLLET;\n  if (epoll_ctl(epollfd, 1, listenfd, &event) < 0) {\n    perror(\"epoll_ctl\");\n    return -1;\n  }\n\n  return epollfd;\n}","pass":1,"source_file":"C_COMPILE/binarylu_cs631/Final/main.c"}
{"compilable":1,"function":"int setnonblocking(int fd) {\n    int flags = fcntl(fd, 3, 0);\n    if (flags < 0) {\n        return -1;\n    }\n    if (fcntl(fd, 4, flags | 2048) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int setnonblocking_name_conflict(int fd) {\n  int opts;\n  opts = fcntl(fd, 3, 0);\n  if (opts < 0)\n    return -1;\n  opts = opts | O_NONBLOCK;\n  opts = fcntl(fd, 4, opts);\n  if (opts == -1)\n    return -1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/binarylu_cs631/Final/util.c"}
{"compilable":1,"function":"int spawn(char *program, char **arg_list) {\n    pid_t child_pid;\n    child_pid = fork();\n    if (child_pid != 0)\n        return child_pid;\n    else {\n        execvp(program, arg_list);\n        fprintf(stderr, \"an error occurred in execvp\\n\");\n        abort();\n    }\n}\n","function_prediction":"pid_t spawn_name_conflict(const char *program, char *argv[]) {\n  pid_t pid;\n\n  pid = fork();\n  if (pid == 0) {\n    execvp(program, argv);\n    fwrite(\"an error occurred in execvp\\n\", 1, 28, stderr);\n    abort();\n  }\n\n  return pid;\n}","pass":1,"source_file":"C_COMPILE/lavenliu_cprogram/chap03/fork-exec.c"}
{"compilable":0,"function":"int f() {\n    return 3;\n}\n","function_prediction":"void frame_dummy(void) { register_tm_clones(); }","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap02/test.c"}
{"compilable":1,"function":"char *xstrdup(const char *s) {\n    char *copy = strdup(s);\n    if (copy == ((void *)0))\n        abort();\n    else\n        return copy;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p = strdup(s);\n  if (!p)\n    abort();\n  return p;\n}","pass":1,"source_file":"C_COMPILE/lavenliu_cprogram/chap11/common.c"}
{"compilable":1,"function":"char *get_self_executable_directory() {\n    int rval;\n    char link_target[1024];\n    char *last_slash;\n    size_t result_length;\n    char *result;\n    rval = readlink(\"/proc/self/exe\", link_target, sizeof (link_target));\n    if (rval == -1)\n        abort();\n    else\n        link_target[rval] = '\\x00';\n    last_slash = strrchr(link_target, '/');\n    if (last_slash == ((void *)0) || last_slash == link_target)\n        abort();\n    result_length = last_slash - link_target;\n    result = (char *)xmalloc(result_length + 1);\n    strncpy(result, link_target, result_length);\n    result[result_length] = '\\x00';\n    return result;\n}\n","function_prediction":"char *get_self_executable_directory_name_conflict(void) {\n  char buf[1024];\n  char *p;\n  size_t len;\n  ssize_t n;\n\n  n = readlink(\"/proc/self/exe\", buf, sizeof(buf));\n  if (n == -1)\n    abort();\n  buf[n] = '\\0';\n\n  p = strrchr(buf, '/');\n  if (p == NULL || p == buf)\n    abort();\n\n  len = p - buf;\n  p = xmalloc(len + 1);\n  strncpy(p, buf, len);\n  p[len] = '\\0';\n\n  return p;\n}","pass":1,"source_file":"C_COMPILE/lavenliu_cprogram/chap11/common.c"}
{"compilable":0,"function":"ipstats_t *ip_get(char *ip_txt) {\n    unsigned int ip;\n    ipstats_t *l;\n    int p[4];\n    sscanf(ip_txt, \"%d.%d.%d.%d\", p + 0, p + 1, p + 2, p + 3);\n    ip = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | (p[3]);\n    for (l = ipstats; l; l = l->next) {\n        if (l->ip == ip) {\n            return (l);\n        }\n    }\n    if (ipstats) {\n        for (l = ipstats; l->next; l = l->next) {\n            ;\n        }\n        l->next = malloc(sizeof(ipstats_t));\n        l = l->next;\n    } else {\n        l = malloc(sizeof(ipstats_t));\n        ipstats = l;\n    }\n    memset(l, 0, sizeof(ipstats_t));\n    l->ip = ip;\n    return (l);\n}\n","function_prediction":"struct ipstat *ip_get_name_conflict(char *ip) {\n  struct ipstat *p;\n  int a, b, c, d;\n  unsigned int i;\n\n  __isoc99_sscanf(ip, \"%d.%d.%d.%d\", &a, &b, &c, &d);\n  i = (a << 24) | (b << 16) | (c << 8) | d;\n\n  for (p = ipstats; p; p = p->next)\n    if (p->ip == i)\n      return p;\n\n  if (!ipstats)\n    ipstats = malloc(sizeof(struct ipstat));\n  else {\n    for (p = ipstats; p->next; p = p->next)\n      ;\n    p->next = malloc(sizeof(struct ipstat));\n    p = p->next;\n  }\n  memset(p, 0, sizeof(struct ipstat));\n  p->ip = i;\n  return p;\n}","pass":0,"source_file":"C_COMPILE/meh_bitlbee/utils/bitlbeed.c"}
{"compilable":0,"function":"static int *get_arr() {\n    static int arr[50000] = {8};\n    return arr;\n}\n","function_prediction":"int *get_arr_name_conflict() { return arr_0; }","pass":0,"source_file":"C_COMPILE/JMWY_sorting_algorithms_compared/array.c"}
{"compilable":0,"function":"static int pop() {\n    int val = heap[0];\n    heap[0] = heap[--sz];\n    heap[sz] = val;\n    heap_adjust(heap, sz, 0);\n    return val;\n}\n","function_prediction":"int pop_name_conflict() {\n  int tmp = heap[0];\n  heap[0] = heap[--sz];\n  heap[sz] = tmp;\n  heap_adjust(heap, sz, 0);\n  return tmp;\n}","pass":0,"source_file":"C_COMPILE/JMWY_sorting_algorithms_compared/algorithms/heap_sort.c"}
{"compilable":0,"function":"QueryConnexionResponse callback_new_connexion(QueryConnexion *q) {\n    static int i;\n    static int iter = (int)(16 / 6);\n    for (i = 0; i < 16; i += iter) {\n        if (__anneau->connexion[i] == 0) {\n            break;\n        }\n    }\n    if (i > 16) {\n        for (i = 16; i >= 0; i--) {\n            if (__anneau->connexion[i] == 0) {\n                break;\n            }\n        }\n    }\n    QueryConnexionResponse r;\n    r.type = q->bot.pid;\n    r.pos = i;\n    return r;\n}\n","function_prediction":"struct sockaddr_in callback_new_connexion_name_conflict(struct sockaddr_in *client) {\n  struct sockaddr_in new_client;\n\n  i_4 = 0;\n  while (i_4 < 16 && __anneau.client[i_4 + 16].socket != 0)\n    i_4 += iter_3;\n  if (i_4 > 16) {\n    i_4 = 16;\n    while (i_4 >= 0 && __anneau.client[i_4 + 16].socket != 0)\n      i_4--;\n  }\n  new_client.sin_addr.s_addr = client->sin_addr.s_addr;\n  new_client.sin_port = client->sin_port;\n  new_client.sin_family = client->sin_family;\n  return (new_client);\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"int ya_til_des_robots_connectes() {\n    static int i;\n    for (i = 0; i < 6; i++) {\n        if (__anneau->connexion[i] != 0 && __anneau->connexion[i] != __pid) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int ya_til_des_robots_connectes_name_conflict() {\n  int i;\n  for (i = 0; i < 6; i++) {\n    if (__anneau.robot[i + 1] && __anneau.robot[i + 1] != __pid)\n      return 1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"int puis_je_prendre_produit() {\n    if ((__anneau->cases[16 - 1]).p.etat == -1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int puis_je_prendre_produit_name_conflict() { return __anneau.produit_a_prendre == -1; }","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"int nb_composants_restants() {\n    static int i, num;\n    for (i = 0 , num = 0; i < 4; i++) {\n        num += stockComposants[i];\n    }\n    return num;\n}\n","function_prediction":"int nb_composants_restants_name_conflict() {\n  num_0 = 0;\n  for (i_1 = 0; i_1 < 4; i_1++) {\n    num_0 += stockComposants[i_1];\n  }\n  return num_0;\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"static int has(char *array, char val) {\n    static int i;\n    for (i = 0; array[i]; i++) {\n        if (array[i] == val) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int has_name_conflict(char *s, char c) {\n  i_8 = 0;\n  while (s[i_8] != '\\0') {\n    if (s[i_8] == c)\n      return 1;\n    i_8++;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"int puis_je_prendre_composant() {\n    if (has(bot.mode == NORMAL ? bot.prods : bot.prodsDegrades, (__anneau->cases[bot.pos]).c.num)) {\n        static int i;\n        i = ctoi((__anneau->cases[bot.pos]).c.num) - 1;\n        if (bot.stockComposants[i] < 3) {\n            if (bot.stockComposants[i] == (produits[i].nbComp - 1)) {\n                if (bot.stockProduits[i] == 0) {\n                    return 1;\n                }\n            } else {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"int puis_je_prendre_composant_name_conflict() {\n  if (__anneau[DAT_00105188].type == 1) {\n    if (!has(\"bot\", __anneau[DAT_00105188].composant))\n      return 0;\n    i_7 = ctoi(__anneau[DAT_00105188].composant) - 1;\n    if (bot[i_7].type < 3) {\n      if (bot[i_7].type == produits[i_7].type - 1) {\n        if (bot[i_7].quantite == 0)\n          return 1;\n      } else\n        return 1;\n    }\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"int puis_je_prendre_produit() {\n    if (bot.mode == NORMAL) {\n        if ((__anneau->cases[bot.pos]).p.etat >= 0) {\n            if (bot.stockProduits[ctoi((__anneau->cases[bot.pos]).p.num) - 1] == 0) {\n                if (has(bot.prods, (__anneau->cases[bot.pos]).p.num)) {\n                    if (bot.ops[0] == (__anneau->cases[bot.pos]).p.ops[(__anneau->cases[bot.pos]).p.etat]) {\n                        return 1;\n                    }\n                }\n            }\n        }\n    } else {\n        if ((__anneau->cases[bot.pos]).p.etat >= 0) {\n            if (bot.stockProduits[ctoi((__anneau->cases[bot.pos]).p.num) - 1] == 0) {\n                if (has(bot.prodsDegrades, (__anneau->cases[bot.pos]).p.num)) {\n                    if (has(bot.ops, (__anneau->cases[bot.pos]).p.ops[(__anneau->cases[bot.pos]).p.etat])) {\n                        return 1;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"int puis_je_prendre_produit_name_conflict() {\n  if (bot.mode_de_jeu == 1) {\n    if (__anneau[DAT_00105188].pos_x >= 0 &&\n        bot.inventaire[ctoi(__anneau[DAT_00105188].type) - 1] == 0 &&\n        has(\"105196\", __anneau[DAT_00105188].type) &&\n        __anneau[DAT_00105188].pos_x + __anneau[DAT_00105188].pos_y == '1')\n      return (1);\n  } else {\n    if (__anneau[DAT_00105188].pos_x >= 0 &&\n        bot.inventaire[ctoi(__anneau[DAT_00105188].type) - 1] == 0 &&\n        has(\"10519A\", __anneau[DAT_00105188].type) &&\n        has(\"1\", __anneau[DAT_00105188].pos_x + __anneau[DAT_00105188].pos_y))\n      return (1);\n  }\n  return (0);\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"Composant prendre_composant() {\n    static Composant c;\n    c = (__anneau->cases[bot.pos]).c;\n    (__anneau->cases[bot.pos]).type = VIDE;\n    (__anneau->cases[bot.pos]).c.num = 0;\n    return c;\n}\n","function_prediction":"char prendre_composant_name_conflict() {\n  c_6 = __anneau.composants[10].composant;\n  __anneau.composants[10].composant = '\\0';\n  __anneau.composants[10].est_prete = 0;\n  return c_6;\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"Produit prendre_produit() {\n    static Produit p;\n    p = (__anneau->cases[bot.pos]).p;\n    (__anneau->cases[bot.pos]).type = VIDE;\n    (__anneau->cases[bot.pos]).p.num = 0;\n    return p;\n}\n","function_prediction":"produit prendre_produit_name_conflict(int i) {\n  p_5.nom = __anneau[i].produit.nom;\n  p_5.prix = __anneau[i].produit.prix;\n  p_5.quantite = __anneau[i].produit.quantite;\n  __anneau[i].produit.nom = NULL;\n  __anneau[i].produit.prix = 0;\n  __anneau[i].produit.quantite = 0;\n  return p_5;\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":1,"function":"static int bind_local(uint16_t port) {\n    int fd;\n    struct sockaddr_in servaddr;\n    fd = socket(2, SOCK_STREAM, 0);\n    if (fd < 0) {\n        perror(\"socket\");\n        exit(1);\n    }\n    bzero(&servaddr, sizeof (servaddr));\n    servaddr.sin_family = 2;\n    servaddr.sin_port = htons(port);\n    if (inet_pton(2, \"127.0.0.1\", &servaddr.sin_addr) <= 0) {\n        perror(\"inet_pton\");\n        exit(1);\n    }\n    if (bind(fd, (struct sockaddr *)&servaddr, sizeof (servaddr)) < 0) {\n        perror(\"bind\");\n        exit(1);\n    }\n    if (listen(fd, 128) < 0) {\n        perror(\"listen\");\n        exit(1);\n    }\n    return fd;\n}\n","function_prediction":"int bind_local_name_conflict(int port) {\n  int sock;\n  struct sockaddr_in addr;\n  int ret;\n\n  sock = socket(2, 1, 0);\n  if (sock < 0) {\n    perror(\"socket\");\n    exit(1);\n  }\n\n  addr.sin_family = 2;\n  addr.sin_port = htons(port);\n  ret = inet_pton(2, \"127.0.0.1\", &addr.sin_addr);\n  if (ret <= 0) {\n    perror(\"inet_pton\");\n    exit(1);\n  }\n\n  ret = bind(sock, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret < 0) {\n    perror(\"bind\");\n    exit(1);\n  }\n\n  ret = listen(sock, 128);\n  if (ret < 0) {\n    perror(\"listen\");\n    exit(1);\n  }\n\n  return sock;\n}","pass":0,"source_file":"C_COMPILE/sduzh_snippet/src/net/test_epoll.c"}
{"compilable":1,"function":"static int test_hexdigit(char ch) {\n    if (ch >= '0' && ch <= '9')\n        return ch - '0';\n    if (ch >= 'A' && ch <= 'F')\n        return ch - 'A' + 10;\n    if (ch >= 'a' && ch <= 'f')\n        return ch - 'a' + 10;\n    return -1;\n}\n","function_prediction":"int test_hexdigit_name_conflict(char c) {\n  if (c >= '0' && c <= '9')\n    return c - '0';\n  if (c >= 'A' && c <= 'F')\n    return c - 'A' + 10;\n  if (c >= 'a' && c <= 'f')\n    return c - 'a' + 10;\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":1,"function":"static int test_readhex(uint8_t *buf, const char *str, int maxbytes) {\n    int i, h, l;\n    for (i = 0; i < maxbytes; i++) {\n        h = test_hexdigit(str[2 * i]);\n        if (h < 0)\n            return i;\n        l = test_hexdigit(str[2 * i + 1]);\n        if (l < 0)\n            return i;\n        buf[i] = (h << 4) + l;\n    }\n    return i;\n}\n","function_prediction":"int test_readhex_name_conflict(char *dst, const char *src, int len) {\n  int i;\n  for (i = 0; i < len; i++) {\n    int a = test_hexdigit(src[i * 2]);\n    int b = test_hexdigit(src[i * 2 + 1]);\n    if (a < 0 || b < 0)\n      break;\n    dst[i] = (a << 4) + b;\n  }\n  return i;\n}","pass":1,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"int test_sha3() {\n    const char *testvec[][2] = {{\"\", \"6B4E03423667DBB73B6E15454F0EB1ABD4597F9A1B078E3F5B5A6BC7\"}, {\"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\", \"2F1A5F7159E34EA19CDDC70EBF9B81F1A66DB40615D7EAD3CC1F1B954D82A3AF\"}, {\"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F80189D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F33E3FBA850D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\", \"D1C0FA85C8D183BEFF99AD9D752B263E286B477F79F0710B010317017397813344B99DAF3BB7B1BC5E8D722BAC85943A\"}, {\"3A3A819C48EFDE2AD914FBF00E18AB6BC4F14513AB27D0C178A188B61431E7F5623CB66B23346775D386B50E982C493ADBBFC54B9A3CD383382336A1A0B2150A15358F336D03AE18F666C7573D55C4FD181C29E6CCFDE63EA35F0ADF5885CFC0A3D84A2B2E4DD24496DB789E663170CEF74798AA1BBCD4574EA0BBA40489D764B2F83AADC66B148B4A0CD95246C127D5871C4F11418690A5DDF01246A0C80A43C70088B6183639DCFDA4125BD113A8F49EE23ED306FAAC576C3FB0C1E256671D817FC2534A52F5B439F72E424DE376F4C565CCA82307DD9EF76DA5B7C4EB7E085172E328807C02D011FFBF33785378D79DC266F6A5BE6BB0E4A92ECEEBAEB1\", \"6E8B8BD195BDD560689AF2348BDC74AB7CD05ED8B9A57711E9BE71E9726FDA4591FEE12205EDACAF82FFBBAF16DFF9E702A708862080166C2FF6BA379BC7FFC2\"}};\n    int i, fails, msg_len, sha_len;\n    uint8_t sha[64], buf[64], msg[256];\n    fails = 0;\n    for (i = 0; i < 4; i++) {\n        memset(sha, 0, sizeof (sha));\n        memset(buf, 0, sizeof (buf));\n        memset(msg, 0, sizeof (msg));\n        msg_len = test_readhex(msg, testvec[i][0], sizeof (msg));\n        sha_len = test_readhex(sha, testvec[i][1], sizeof (sha));\n        sha3(msg, msg_len, buf, sha_len);\n        if (memcmp(sha, buf, sha_len) != 0) {\n            fprintf(stderr, \"[%d] SHA3-%d, len %d test FAILED.\\n\", i, sha_len * 8, msg_len);\n            fails++;\n        }\n    }\n    return fails;\n}\n","function_prediction":"int test_sha3_name_conflict(void) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  int ret = 0;\n  unsigned char in[256], out[64], exp[64];\n  const char *in_str[4] = {\n      \"\", \"6B4E03423667DBB73B6E15454F0EB1ABD4597F9A1B078E3F5B5A6BC7\",\n      \"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\",\n      \"2F1A5F7159E34EA19CDDC70EBF9B81F1A66DB40615D7EAD3CC1F1B954D82A3AF\"};\n  const char *out_str[4] = {\n    \"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F80189\"\n    \"D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F33E3FBA8\"\n    \"50D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\",\n    \"D1C0FA85C8D183BEFF99AD9D752B263E286","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"int test_shake() {\n    const char *testhex[4] = {\"43E41B45A653F2A5C4492C1ADD544512DDA2529833462B71A41A45BE97290B6F\", \"AB0BAE316339894304E35877B0C28A9B1FD166C796B9CC258A064A8F57E27F2A\", \"44C9FB359FD56AC0A9A75A743CFF6862F17D7259AB075216C0699511643B6439\", \"6A1A9D7846436E4DCA5728B6F760EEF0CA92BF0BE5615E96959D767197A0BEEB\"};\n    int i, j, fails;\n    sha3_ctx_t sha3;\n    uint8_t buf[32], ref[32];\n    fails = 0;\n    for (i = 0; i < 4; i++) {\n        if ((i & 1) == 0) {\n            sha3_init(&sha3, 16);\n        } else {\n            sha3_init(&sha3, 32);\n        }\n        if (i >= 2) {\n            memset(buf, 163, 20);\n            for (j = 0; j < 200; j += 20)\n                sha3_update(&sha3, buf, 20);\n        }\n        shake_xof(&sha3);\n        for (j = 0; j < 512; j += 32)\n            shake_out(&sha3, buf, 32);\n        test_readhex(ref, testhex[i], sizeof (ref));\n        if (memcmp(buf, ref, 32) != 0) {\n            fprintf(stderr, \"[%d] SHAKE%d, len %d test FAILED.\\n\", i, i & 1 ? 256 : 128, i >= 2 ? 1600 : 0);\n            fails++;\n        }\n    }\n    return fails;\n}\n","function_prediction":"int test_shake_name_conflict(void) {\n  int i, j, k, ret = 0;\n  const char *ref[4] = {\n      \"43E41B45A653F2A5C4492C1ADD544512DDA2529833462B71A41A45BE97290B6F\",\n      \"AB0BAE316339894304E35877B0C28A9B1FD166C796B9CC258A064A8F57E27F2A\",\n      \"44C9FB359FD56AC0A9A75A743CFF6862F17D7259AB075216C0699511643B6439\",\n      \"6A1A9D7846436E4DCA5728B6F760EEF0CA92BF0BE5615E96959D767197A0BEEB\"};\n  uint8_t buf[32], refbuf[32];\n  uint8_t state[200];\n  sha3_ctx ctx;\n\n  for (i = 0; i < 4; i++) {\n    if (i % 2 == 0)\n      sha3_init(&ctx, 16);\n    else\n      sha3_init(&ctx, 32);\n    if (i > 1) {\n      memset(state, 0xa3, sizeof(state));\n      for (j = 0; j < 200; j += 20)\n        sha3_update(&ctx, state, 20);\n    }\n    shake_xof(&ctx);\n    for (j = 0; j < 512; j += 32)\n      shake_out(&ctx, state, 32);\n    test_readhex(refbuf, ref[i], 32);\n        if (mem","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":1,"function":"int sha3_init(sha3_ctx_t *c, int mdlen) {\n    int i;\n    for (i = 0; i < 25; i++)\n        c->st.q[i] = 0;\n    c->mdlen = mdlen;\n    c->rsiz = 200 - 2 * mdlen;\n    c->pt = 0;\n    return 1;\n}\n","function_prediction":"int sha3_init_name_conflict(uint64_t *state, int digest_length) {\n  int i;\n\n  for (i = 0; i < 25; i++)\n    state[i] = 0;\n\n  state[24] = digest_length;\n  state[23] = 100 - digest_length;\n  state[23] *= 2;\n  state[25] = 0;\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/sha3.c"}
{"compilable":1,"function":"int randomTile(int lowerLim, int upperLim) {\n    return rand() % (upperLim - lowerLim + 1) + lowerLim;\n}\n","function_prediction":"int randomTile_name_conflict(int min, int max) { return rand() % (max - min + 1) + min; }","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int swapTile(char grid[6][6], gridcoord tile, char direction) {\n    gridcoord partnertile;\n    char temp;\n    partnertile.x = tile.x;\n    partnertile.y = tile.y;\n    unsigned long score = 0;\n    gridcoord lmatches[36];\n    gridcoord cmatches[36];\n    int linsertat = 0;\n    int cinsertat = 0;\n    int lengtmt = 0;\n    int crossmt = 0;\n    char prompt_resp;\n    switch (direction) {\n      case 'w':\n      case 'W':\n        partnertile.y = tile.y - 1;\n        break;\n      case 's':\n      case 'S':\n        partnertile.y = tile.y + 1;\n        break;\n      case 'a':\n      case 'A':\n        partnertile.x = tile.x - 1;\n        break;\n      case 'd':\n      case 'D':\n        partnertile.x = tile.x + 1;\n        break;\n      default:\n        printf(\"\\n:( ERROR. Unknown command.\");\n    }\n    temp = grid[tile.y][tile.x];\n    grid[tile.y][tile.x] = grid[partnertile.y][partnertile.x];\n    grid[partnertile.y][partnertile.x] = temp;\n    lengtmt = checkmatches_lengthwise(grid, partnertile, lmatches, &linsertat);\n    crossmt = checkmatches_crosswise(grid, partnertile, cmatches, &cinsertat);\n    if (lengtmt >= 2 || crossmt >= 2) {\n        if (lengtmt >= 2) {\n            score += lengtmt;\n            assasinate(grid, lmatches, lengtmt);\n        }\n        if (crossmt >= 2) {\n            score += crossmt;\n            assasinate(grid, cmatches, crossmt);\n        }\n        grid[partnertile.y][partnertile.x] = '\\x00';\n        score += 1;\n    } else {\n        linsertat = 0;\n        cinsertat = 0;\n        lengtmt = checkmatches_lengthwise(grid, tile, lmatches, &linsertat);\n        crossmt = checkmatches_crosswise(grid, tile, cmatches, &cinsertat);\n        if (lengtmt >= 2 || crossmt >= 2) {\n            if (lengtmt >= 2) {\n                score += lengtmt;\n                assasinate(grid, lmatches, lengtmt);\n            }\n            if (crossmt >= 2) {\n                score += crossmt;\n                assasinate(grid, cmatches, crossmt);\n            }\n            grid[tile.y][tile.x] = '\\x00';\n            score += 1;\n        } else {\n            temp = grid[partnertile.y][partnertile.x];\n            grid[partnertile.y][partnertile.x] = grid[tile.y][tile.x];\n            grid[tile.y][tile.x] = temp;\n        }\n    }\n    return score;\n}\n","function_prediction":"long swapTile_name_conflict(char board[4][4], struct position pos, char command) {\n  int i, j, k, l, m, n, o, p;\n  char temp, matches[200], matches2[200];\n  long score = 0;\n  i = pos.x;\n  j = pos.y;\n  k = 0;\n  l = 0;\n  m = 0;\n  n = 0;\n  o = 0;\n  p = 0;\n  switch (command) {\n  case 'w':\n  case 'W':\n    j--;\n    break;\n  case 's':\n  case 'S':\n    j++;\n    break;\n  case 'a':\n  case 'A':\n    i--;\n    break;\n  case 'd':\n  case 'D':\n    i++;\n    break;\n  default:\n    printf(\"\\n:( ERROR. Unknown command.\");\n    break;\n  }\n  temp = board[pos.y][pos.x];\n  board[pos.y][pos.x] = board[j][i];\n  board[j][i] = temp;\n  k = checkmatches_lengthwise(board, pos, matches, &l);\n  m = checkmatches_crosswise(board, pos, matches2, &n);\n  if (k > 1 || m > 1) {\n    if (k > 1) {\n      score += k;\n      assasinate(board, matches, k);\n    }\n    if (m > 1) {\n      score += m;\n      assasinate(board, matches2, m);\n    }\n    board[j][i] = '\\0';\n    score++;\n  } else {\n    l = 0;\n    n = 0;\n    k = checkmatches_lengthwise(board, pos, matches, &l);\n    m = checkmatches_crosswise(board, pos, matches2, &n);\n    if (k > 1 || m > 1) {\n      if (k > 1) {\n        score += k;\n      assasinate","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int popmatches_universal(char grid[6][6]) {\n    int i = 0;\n    int k = 0;\n    int lengtmt = 0;\n    int crossmt = 0;\n    char gridcopy[6][6];\n    gridcoord lmatches[36];\n    gridcoord cmatches[36];\n    gridcoord tile;\n    int didchangel = 0;\n    int didchangec = 0;\n    int tsambapoints = 0;\n    int linsertat = 0;\n    int cinsertat = 0;\n    copymatrix2d(grid, gridcopy);\n    for (k = 0; k < 6; k++) {\n        for (i = 0; i < 6; i++) {\n            tile.x = i;\n            tile.y = k;\n            lengtmt = checkmatches_lengthwise(gridcopy, tile, lmatches, &linsertat);\n            crossmt = checkmatches_crosswise(gridcopy, tile, cmatches, &cinsertat);\n            if (lengtmt >= 2 || crossmt >= 2) {\n                if (lengtmt >= 2) {\n                    didchangel = 1;\n                    tsambapoints += lengtmt;\n                }\n                if (crossmt >= 2) {\n                    didchangec = 1;\n                    tsambapoints += crossmt;\n                }\n                grid[tile.y][tile.x] = '\\x00';\n                tsambapoints += 1;\n            }\n        }\n    }\n    if (didchangel) {\n        assasinate(gridcopy, lmatches, linsertat);\n        copymatrix2d(gridcopy, grid);\n    }\n    if (didchangec) {\n        assasinate(gridcopy, cmatches, cinsertat);\n        copymatrix2d(gridcopy, grid);\n    }\n    fillGaps(grid);\n    if (didchangec == 1 || didchangel == 1) {\n        return tsambapoints += popmatches_universal(grid);\n    }\n    return tsambapoints;\n}\n","function_prediction":"int popmatches_universal_name_conflict(char matrix[6][6]) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae,\n      af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw,\n      ax, ay, az, ba, bb, bc, bd, be, bf, bg, bh, bi, bj, bk, bl, bm, bn, bo,\n      bp, bq, br, bs, bt, bu, bv, bw, bx, by, bz, ca, cb, cc, cd, ce, cf, cg,\n      ch, ci, cj, ck, cl, cm, cn, co, cp, cq, cr, cs, ct, cu, cv, cw, cx, cy,\n      cz, da, db, dc, dd, de, df, dg, dh, di, dj, dk, dl, dm, dn, do, dp, dq,\n      dr, ds, dt, du, dv, dw, dx, dy, dz;\n  int matches_lengthwise[6][6];\n  int matches_crosswise[6][6];\n  int matches_lengthwise_count = 0;\n  int matches_crosswise_count = 0;\n  int matches_count = 0;\n  int matches_lengthwise_flag = 0;\n  int matches_crosswise_flag = 0;\n  char matrix2[6][6];\n  copymatrix2d(matrix, matrix2);\n  for (i = 0; i < 6; i++) {\n    for (j = 0; j < 6; j++) {\n      k = j;\n      l = i;\n      m = checkmatches_lengthwise(matrix2, i, j, matches_lengthwise,\n                                  &matches_lengthwise_count);\n      n = checkmatches_crosswise(matrix2, i, j, matches_crosswise,\n                                 &matches_crosswise_count);\n      if (m > 1 || n > 1) {\n        if (m > 1)\n","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int checkmatches_lengthwise(char grid[6][6], gridcoord lastmoved, gridcoord list[36], int *insertat) {\n    int i = 0;\n    int matches = 0;\n    i = lastmoved.y - 1;\n    while (i >= 0)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[i][lastmoved.x]) {\n                matches += 1;\n                list[*insertat].x = lastmoved.x;\n                list[*insertat].y = i;\n                *insertat += 1;\n            } else\n                break;\n            i--;\n        }\n    i = lastmoved.y + 1;\n    while (i < 6)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[i][lastmoved.x]) {\n                matches += 1;\n                list[*insertat].x = lastmoved.x;\n                list[*insertat].y = i;\n                *insertat += 1;\n            } else\n                break;\n            i++;\n        }\n    return matches;\n}\n","function_prediction":"int checkmatches_lengthwise(char board[6][6], struct move move,\n                            struct match matches[26], int *nummatches) {\n  int i, j, k, l;\n  int nummatches_lengthwise = 0;\n\n  i = move.i;\n  j = move.j;\n\n  k = j;\n  l = j;\n\n  while (k >= 0 && board[i][k] == board[i][j]) {\n    nummatches_lengthwise++;\n    matches[*nummatches].i = i;\n    matches[*nummatches].j = k;\n    (*nummatches)++;\n    k--;\n  }\n\n  while (l < 6 && board[i][j] == board[i][l]) {\n    nummatches_lengthwise++;\n    matches[*nummatches].i = i;\n    matches[*nummatches].j = l;\n    (*nummatches)++;\n    l++;\n  }\n\n  return nummatches_lengthwise;\n}","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int checkmatches_crosswise(char grid[6][6], gridcoord lastmoved, gridcoord list[36], int *insertat) {\n    int i = 0;\n    int matches = 0;\n    i = lastmoved.x - 1;\n    while (i >= 0)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[lastmoved.y][i]) {\n                matches += 1;\n                list[*insertat].x = i;\n                list[*insertat].y = lastmoved.y;\n                *insertat += 1;\n            } else\n                break;\n            i--;\n        }\n    i = lastmoved.x + 1;\n    while (i < 6)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[lastmoved.y][i]) {\n                matches += 1;\n                list[*insertat].x = i;\n                list[*insertat].y = lastmoved.y;\n                *insertat += 1;\n            } else\n                break;\n            i++;\n        }\n    return matches;\n}\n","function_prediction":"int checkmatches_crosswise(char board[6][6], struct point p,\n                           struct point matches[26], int *nummatches) {\n  int i, j;\n  int num = 0;\n  char c = board[p.x][p.y];\n\n  for (i = p.x - 1; i >= 0; i--) {\n    if (board[i][p.y] != c)\n      break;\n    num++;\n    matches[*nummatches].x = i;\n    matches[*nummatches].y = p.y;\n    (*nummatches)++;\n  }\n  for (j = p.x + 1; j < 6; j++) {\n    if (board[j][p.y] != c)\n      break;\n    num++;\n    matches[*nummatches].x = j;\n    matches[*nummatches].y = p.y;\n    (*nummatches)++;\n  }\n  return num;\n}","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int isValid(gridcoord move, char direction) {\n    if (move.x == -1 && move.y == -1 && direction == '0') {\n        return 1;\n    }\n    if (move.x == 0 && (direction == 'a' || direction == 'A')) {\n        printf(\"\\tYou can't move that to the left.\\n\");\n        return 0;\n    }\n    if (move.x == 6 - 1 && (direction == 'd' || direction == 'D')) {\n        printf(\"\\tYou can't move that to the right.\\n\");\n        return 0;\n    }\n    if (move.y == 0 && (direction == 'w' || direction == 'W')) {\n        printf(\"\\tYou can't move that up.\\n\");\n        return 0;\n    }\n    if (move.y == 6 - 1 && (direction == 's' || direction == 'S')) {\n        printf(\"\\tYou can't move that down.\\n\");\n        return 0;\n    }\n    if (move.y < 0 || move.x < 0 || move.y >= 6 || move.x >= 6) {\n        printf(\"\\tI can't find those coordinates. Terminals are dumb, huh?\\n\");\n        return 0;\n    }\n    if (direction != 'a' && direction != 'A' && direction != 's' && direction != 'S' && direction != 'd' && direction != 'D' && direction != 'w' && direction != 'W') {\n        printf(\"\\tWrong Directions. Enter W for UP, A for LEFT, S for DOWN, and D for RIGHT.\\n\");\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"int isValid_name_conflict(struct position current, char direction) {\n  if (current.x == -1 && current.y == -1 && direction == '0') {\n    return 1;\n  } else if (current.x == 0 && (direction == 'a' || direction == 'A')) {\n    puts(\"\\tYou can't move that to the left.\");\n    return 0;\n  } else if (current.x == 5 && (direction == 'd' || direction == 'D')) {\n    puts(\"\\tYou can't move that to the right.\");\n    return 0;\n  } else if (current.y == 0 && (direction == 'w' || direction == 'W')) {\n    puts(\"\\tYou can't move that up.\");\n    return 0;\n  } else if (current.y == 5 && (direction == 's' || direction == 'S')) {\n    puts(\"\\tYou can't move that down.\");\n    return 0;\n  } else if (current.x < 0 || current.y < 0 || current.x > 5 || current.y > 5) {\n    puts(\"\\tI can't find those coordinates. Terminals are dumb, huh?\");\n    return 0;\n  } else if (direction == 'a' || direction == 'A' || direction == 's' ||\n             direction == 'S' || direction == 'd' || direction == 'D' ||\n             direction == 'w' || direction == 'W') {\n    return 1;\n  } else {\n    puts(\"\\tWrong Directions. Enter W for UP, A for LEFT, S for DOWN, and D \"\n         \"for RIGHT.\");\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int game() {\n    char grid[6][6];\n    gridcoord target;\n    unsigned long gamescore = 0;\n    char direction;\n    do {\n        populate(grid);\n        popmatches_universal(grid);\n    } while (!trymatches(grid));\n    do {\n        drawGrid(grid, gamescore);\n        do {\n            printf(\"\\n\\tMOVE: \");\n            scanf(\"%d %d %c\", &target.x, &target.y, &direction);\n            target.x -= 1;\n            target.y -= 1;\n            if (target.x == -1 && target.y == -1 && direction == '0') {\n                return gamescore;\n            }\n        } while (!isValid(target, direction));\n        gamescore += swapTile(grid, target, direction);\n        gamescore += popmatches_universal(grid);\n    } while ((target.x != -1 && target.y != -1 && direction != '0') && (trymatches(grid) == 1));\n    return gamescore;\n}\n","function_prediction":"int game_name_conflict() {\n  int score = 0;\n  int x, y;\n  char c;\n  char grid[4][4];\n\n  do {\n    populate(grid);\n    popmatches_universal(grid);\n  } while (!trymatches(grid));\n\n  do {\n    drawGrid(grid, score);\n\n    do {\n      printf(\"\\n\\tMOVE: \");\n      __isoc99_scanf(\"%d %d %c\", &x, &y, &c);\n      x--;\n      y--;\n    } while (x != -1 && y != -1 && c != '0' && !isValid(x, y, c));\n\n    if (x == -1 && y == -1 && c == '0') {\n      return score;\n    }\n\n    score += swapTile(grid, x, y, c);\n    score += popmatches_universal(grid);\n  } while (x != -1 && y != -1 && c != '0' && trymatches(grid));\n\n  return score;\n}","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int trymatches(char grid[6][6]) {\n    int i = 0;\n    int k = 0;\n    gridcoord tile;\n    char prompt_resp;\n    for (k = 0; k < 6; k++) {\n        for (i = 0; i < 6; i++) {\n            tile.x = i;\n            tile.y = k;\n            if (isValid(tile, 'w')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y - 1][tile.x]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y - 1][tile.x], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y - 1][tile.x], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 's')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y + 1][tile.x]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y + 1][tile.x], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y + 1][tile.x], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 'a')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y][tile.x - 1]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y][tile.x - 1], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y][tile.x - 1], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 'd')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y][tile.x + 1]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y][tile.x + 1], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y][tile.x + 1], &grid[tile.y][tile.x]);\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"int trymatches_name_conflict(int board[6][6]) {\n  int i, j;\n  for (i = 0; i < 6; i++) {\n    for (j = 0; j < 6; j++) {\n      if (isValid(i, j, 'w')) {\n        primitSwapTiles(&board[i][j], &board[i - 1][j]);\n        if (areThereMatches(board, i, j)) {\n          primitSwapTiles(&board[i - 1][j], &board[i][j]);\n          return 1;\n        }\n        primitSwapTiles(&board[i - 1][j], &board[i][j]);\n      }\n      if (isValid(i, j, 's')) {\n        primitSwapTiles(&board[i][j], &board[i + 1][j]);\n        if (areThereMatches(board, i, j)) {\n          primitSwapTiles(&board[i + 1][j], &board[i][j]);\n          return 1;\n        }\n        primitSwapTiles(&board[i + 1][j], &board[i][j]);\n      }\n      if (isValid(i, j, 'a')) {\n        primitSwapTiles(&board[i][j], &board[i][j - 1]);\n        if (areThereMatches(board, i, j)) {\n          primitSwapTiles(&board[i][j - 1], &board[i][j]);\n          return 1;\n        }\n        primitSwapTiles(&board[i][j - 1], &board[i][j]);\n      }\n      if (isValid(i, j, 'd')) {\n        primitSwapTiles(&board[i][j], &board[i][j + 1]);\n        if (areThereMatches(board, i, j)) {\n          primitSwapTiles(&board[i][j + 1], &board[i][j]);\n          return 1;\n        }\n      primitSw","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int areThereMatches(char grid[6][6], gridcoord tile) {\n    gridcoord dummy[36];\n    int dummyinsertat = 0;\n    if (checkmatches_lengthwise(grid, tile, dummy, &dummyinsertat) >= 2) {\n        return 1;\n    }\n    if (checkmatches_crosswise(grid, tile, dummy, &dummyinsertat) >= 2) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int areThereMatches_name_conflict(char *word1, char *word2) {\n  int matches[26];\n  int num_matches = 0;\n\n  if (checkmatches_lengthwise(word1, word2, matches, &num_matches) > 1)\n    return 1;\n  if (checkmatches_crosswise(word1, word2, matches, &num_matches) > 1)\n    return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int params_finish(struct params *fsm) {\n    if (fsm->cs == params_error)\n        return -1;\n    if (fsm->cs >= params_first_final)\n        return 1;\n    return 0;\n}\n","function_prediction":"int params_finish_name_conflict(uint8_t *buf) {\n  if (!buf[0x102])\n    return -1;\n  if (buf[0x102] > 23)\n    return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/brson_ragel-dist/examples/params.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"struct nucleotide_counts count_nucleotides_name_conflict(const char *dna) {\n  size_t len = strlen(dna);\n  struct nucleotide_counts counts = {0};\n\n  for (size_t i = 0; i < len; i++) {\n    switch (dna[i]) {\n    case 'A':\n    case 'a':\n      counts.a++;\n      break;\n    case 'C':\n    case 'c':\n      counts.c++;\n      break;\n    case 'G':\n    case 'g':\n      counts.g++;\n      break;\n    case 'T':\n    case 't':\n      counts.t++;\n      break;\n    case 'U':\n    case 'u':\n      counts.u++;\n      break;\n    default:\n      fprintf(stderr, \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\",\n              dna[i]);\n      i = len;\n      break;\n    }\n  }\n\n  return counts;\n}","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"char *transcribe_dna_to_rna_name_conflict(const char *dna) {\n  char *rna = strdup(dna);\n  size_t i, len = strlen(rna);\n\n  for (i = 0; i < len; i++) {\n    if (rna[i] == 't' || rna[i] == 'T') {\n      rna[i]++;\n    }\n  }\n\n  return rna;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"char *get_dna_complement_name_conflict(const char *dna) {\n  char *dna_complement = strdup(dna);\n  size_t i, len = strlen(dna_complement);\n\n  for (i = 0; i < len; i++) {\n    switch (dna_complement[i]) {\n    case 'A':\n    case 'a':\n      dna_complement[i] = 'T';\n      break;\n    case 'C':\n    case 'c':\n      dna_complement[i] = 'G';\n      break;\n    case 'G':\n    case 'g':\n      dna_complement[i] = 'C';\n      break;\n    case 'T':\n    case 't':\n      dna_complement[i] = 'A';\n      break;\n    default:\n      free(dna_complement);\n      return NULL;\n    }\n  }\n\n  return dna_complement;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"size_t hamming_distance_name_conflict(const char *s1, const char *s2) {\n  size_t len1 = strlen(s1);\n  size_t len2 = strlen(s2);\n  if (len1 != len2)\n    return -1;\n\n  size_t i, dist = 0;\n  for (i = 0; i < len1; i++)\n    if (s1[i] != s2[i])\n      dist++;\n\n  return dist;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"char *strstrip_name_conflict(char *s) {\n  size_t len = strlen(s);\n  char *p = s;\n  char *q = s + len - 1;\n\n  if (len == 0)\n    return s;\n\n  while (q >= s &&\n         ((*(const unsigned short *)__ctype_b_loc())[*q] & (0x00002000)))\n    q--;\n  *++q = '\\0';\n\n  while (*p && ((*(const unsigned short *)__ctype_b_loc())[*p] & (0x00002000)))\n    p++;\n\n  return p;\n}","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"char *strrev_name_conflict(const char *str) {\n  size_t len = strlen(str);\n  char *rev = calloc(len + 1, sizeof(char));\n  if (rev == NULL)\n    return NULL;\n\n  for (size_t i = 0; i < len; i++)\n    rev[i] = str[len - i - 1];\n\n  return rev;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"struct nucleotide_counts count_nucleotides_name_conflict(const char *dna) {\n  size_t len = strlen(dna);\n  struct nucleotide_counts counts = {0};\n\n  for (size_t i = 0; i < len; i++) {\n    switch (dna[i]) {\n    case 'A':\n    case 'a':\n      counts.a++;\n      break;\n    case 'C':\n    case 'c':\n      counts.c++;\n      break;\n    case 'G':\n    case 'g':\n      counts.g++;\n      break;\n    case 'T':\n    case 't':\n      counts.t++;\n      break;\n    case 'U':\n    case 'u':\n      counts.u++;\n      break;\n    default:\n      fprintf(stderr, \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\",\n              dna[i]);\n      i = len;\n      break;\n    }\n  }\n\n  return counts;\n}","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"char *transcribe_dna_to_rna_name_conflict(const char *dna) {\n  char *rna = strdup(dna);\n  size_t i, len = strlen(rna);\n\n  for (i = 0; i < len; i++) {\n    if (rna[i] == 't' || rna[i] == 'T') {\n      rna[i]++;\n    }\n  }\n\n  return rna;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"char *get_dna_complement_name_conflict(const char *dna) {\n  char *dna_complement = strdup(dna);\n  size_t i, len = strlen(dna_complement);\n\n  for (i = 0; i < len; i++) {\n    switch (dna_complement[i]) {\n    case 'A':\n    case 'a':\n      dna_complement[i] = 'T';\n      break;\n    case 'C':\n    case 'c':\n      dna_complement[i] = 'G';\n      break;\n    case 'G':\n    case 'g':\n      dna_complement[i] = 'C';\n      break;\n    case 'T':\n    case 't':\n      dna_complement[i] = 'A';\n      break;\n    default:\n      free(dna_complement);\n      return NULL;\n    }\n  }\n\n  return dna_complement;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"size_t hamming_distance_name_conflict(const char *s1, const char *s2) {\n  size_t len1 = strlen(s1);\n  size_t len2 = strlen(s2);\n  if (len1 != len2)\n    return -1;\n\n  size_t i, dist = 0;\n  for (i = 0; i < len1; i++)\n    if (s1[i] != s2[i])\n      dist++;\n\n  return dist;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"char *strstrip_name_conflict(char *s) {\n  size_t len = strlen(s);\n  char *p = s;\n  char *q = s + len - 1;\n\n  if (len == 0)\n    return s;\n\n  while (q >= s &&\n         ((*(const unsigned short *)__ctype_b_loc())[*q] & (0x00002000)))\n    q--;\n  *++q = '\\0';\n\n  while (*p && ((*(const unsigned short *)__ctype_b_loc())[*p] & (0x00002000)))\n    p++;\n\n  return p;\n}","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"char *strrev_name_conflict(const char *str) {\n  size_t len = strlen(str);\n  char *rev = calloc(len + 1, sizeof(char));\n  if (rev == NULL)\n    return NULL;\n\n  for (size_t i = 0; i < len; i++)\n    rev[i] = str[len - i - 1];\n\n  return rev;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"struct nucleotide_counts count_nucleotides_name_conflict(const char *dna) {\n  size_t len = strlen(dna);\n  struct nucleotide_counts counts = {0};\n\n  for (size_t i = 0; i < len; i++) {\n    switch (dna[i]) {\n    case 'A':\n    case 'a':\n      counts.a++;\n      break;\n    case 'C':\n    case 'c':\n      counts.c++;\n      break;\n    case 'G':\n    case 'g':\n      counts.g++;\n      break;\n    case 'T':\n    case 't':\n      counts.t++;\n      break;\n    case 'U':\n    case 'u':\n      counts.u++;\n      break;\n    default:\n      fprintf(stderr, \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\",\n              dna[i]);\n      i = len;\n      break;\n    }\n  }\n\n  return counts;\n}","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"char *transcribe_dna_to_rna_name_conflict(const char *dna) {\n  char *rna = strdup(dna);\n  size_t i, len = strlen(rna);\n\n  for (i = 0; i < len; i++) {\n    if (rna[i] == 't' || rna[i] == 'T') {\n      rna[i]++;\n    }\n  }\n\n  return rna;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"char *get_dna_complement_name_conflict(const char *dna) {\n  char *dna_complement = strdup(dna);\n  size_t i, len = strlen(dna_complement);\n\n  for (i = 0; i < len; i++) {\n    switch (dna_complement[i]) {\n    case 'A':\n    case 'a':\n      dna_complement[i] = 'T';\n      break;\n    case 'C':\n    case 'c':\n      dna_complement[i] = 'G';\n      break;\n    case 'G':\n    case 'g':\n      dna_complement[i] = 'C';\n      break;\n    case 'T':\n    case 't':\n      dna_complement[i] = 'A';\n      break;\n    default:\n      free(dna_complement);\n      return NULL;\n    }\n  }\n\n  return dna_complement;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"size_t hamming_distance_name_conflict(const char *s1, const char *s2) {\n  size_t len1 = strlen(s1);\n  size_t len2 = strlen(s2);\n  if (len1 != len2)\n    return -1;\n\n  size_t i, dist = 0;\n  for (i = 0; i < len1; i++)\n    if (s1[i] != s2[i])\n      dist++;\n\n  return dist;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":0,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"char *strstrip_name_conflict(char *s) {\n  size_t len = strlen(s);\n  char *p = s;\n  char *q = s + len - 1;\n\n  if (len == 0)\n    return s;\n\n  while (q >= s &&\n         ((*(const unsigned short *)__ctype_b_loc())[*q] & (0x00002000)))\n    q--;\n  *++q = '\\0';\n\n  while (*p && ((*(const unsigned short *)__ctype_b_loc())[*p] & (0x00002000)))\n    p++;\n\n  return p;\n}","pass":0,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"char *strrev_name_conflict(const char *str) {\n  size_t len = strlen(str);\n  char *rev = calloc(len + 1, sizeof(char));\n  if (rev == NULL)\n    return NULL;\n\n  for (size_t i = 0; i < len; i++)\n    rev[i] = str[len - i - 1];\n\n  return rev;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"char rot13(char character) {\n    if (((*__ctype_b_loc())[(int)((character))] & (unsigned short)_ISalpha)) {\n        char c = character - 'A';\n        return hashmap[(int)c];\n    } else {\n        return character;\n    }\n}\n","function_prediction":"char rot13_name_conflict(char c) {\n  if (__ctype_b_loc().alnum[c] & 0x400)\n    return hashmap[c - 'A'];\n  return c;\n}","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":1,"function":"char *srot13(char *str) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        str[i] = rot13(str[i]);\n    }\n    return str;\n}\n","function_prediction":"char *srot13_name_conflict(char *s) {\n  int i, len;\n\n  len = strlen(s);\n  for (i = 0; i < len; i++)\n    s[i] = rot13(s[i]);\n  return s;\n}","pass":1,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char rot13(char character) {\n    if (((*__ctype_b_loc())[(int)((character))] & (unsigned short)_ISalpha)) {\n        char c = character - 'A';\n        return hashmap[(int)c];\n    } else {\n        return character;\n    }\n}\n","function_prediction":"char rot13_name_conflict(char c) {\n  if (__ctype_b_loc().alnum[c] & 0x400)\n    return hashmap[c - 'A'];\n  return c;\n}","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":1,"function":"char *srot13(char *str) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        str[i] = rot13(str[i]);\n    }\n    return str;\n}\n","function_prediction":"char *srot13_name_conflict(char *s) {\n  int i, len;\n\n  len = strlen(s);\n  for (i = 0; i < len; i++)\n    s[i] = rot13(s[i]);\n  return s;\n}","pass":1,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":1,"function":"char *s_tolower(char *s) {\n    char *cp;\n    if (s == ((void *)0))\n        return ((void *)0);\n    if (!*s)\n        return s;\n    for (cp = s; (*cp = tolower(*cp)); cp++)\n        ;\n    return s;\n}\n","function_prediction":"char *s_tolower_name_conflict(char *s) {\n  char *p;\n\n  if (s == NULL)\n    return NULL;\n\n  for (p = s; *p != '\\0'; p++)\n    *p = tolower(*p);\n\n  return s;\n}","pass":0,"source_file":"C_COMPILE/Ilias95_Hunt/src/misc.c"}
{"compilable":1,"function":"int s_tokenize(char *s, char *tokens[], int ntoks, const char *delims) {\n    register int i;\n    if (s == ((void *)0) || tokens == ((void *)0) || delims == ((void *)0) || !*s || !*delims || ntoks < 1)\n        return 0;\n    tokens[0] = strtok(s, delims);\n    if (tokens[0] == ((void *)0))\n        return 0;\n    for (i = 1; i < ntoks && (tokens[i] = strtok(((void *)0), delims)) != ((void *)0); i++)\n        ;\n    return i;\n}\n","function_prediction":"int s_tokenize_name_conflict(char *str, char **tokens, int max_tokens, char *delim) {\n  int i;\n\n  if (str == NULL || tokens == NULL || delim == NULL)\n    return 0;\n\n  if (str[0] == '\\0' || delim[0] == '\\0' || max_tokens < 1)\n    return 0;\n\n  tokens[0] = strtok(str, delim);\n  if (tokens[0] == NULL)\n    return 0;\n\n  for (i = 1; i < max_tokens; i++) {\n    tokens[i] = strtok(NULL, delim);\n    if (tokens[i] == NULL)\n      break;\n  }\n\n  return i;\n}","pass":0,"source_file":"C_COMPILE/Ilias95_Hunt/src/misc.c"}
{"compilable":0,"function":"static inline size_t SCREEN(size_t x, size_t y) {\n    y = min(y, (terminal.rows - 1));\n    if (between(y, terminal.page.top, terminal.page.bottom)) {\n        return PAGE(x, y - terminal.page.top);\n    } else {\n        return y * terminal.cols + min(x, (terminal.cols - 1));\n    }\n}\n","function_prediction":"char *SCREEN_name_conflict(int x, int y) {\n  y = min(y, 24 - 1);\n  if (between(y, 0, 2))\n    return PAGE(x, y - 0);\n  else\n    return terminal.screen + min(x, 80 - 1) + y * 80;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"static bool term_flushlines() {\n    size_t row;\n    size_t col_start, col_stop, col_this;\n    struct glyph_t *start, *this;\n    bool retval = 0;\n    wchar_t *buffer = emalloc(terminal.cols * sizeof (*buffer));\n    for (row = 0; row < terminal.rows; row++) {\n        col_start = terminal.dirty[row].left;\n        col_stop = terminal.dirty[row].right;\n        start = terminal.text + SCREEN(col_start, row);\n        for (col_this = col_start , this = start; col_this < col_stop; col_this++ , this++) {\n            buffer[col_this] = this->c;\n            if ((start->c != '\\x00') != (this->c != '\\x00') || start->background != this->background || start->foreground != this->foreground || start->attr != this->attr) {\n                term_flush_section(col_start, row, buffer + col_start, col_this - col_start, start->foreground, start->background, start->attr);\n                col_start = col_this;\n                start = this;\n                retval = 1;\n            }\n        }\n        if (col_stop > col_start) {\n            term_flush_section(col_start, row, buffer + col_start, col_this - col_start, start->foreground, start->background, start->attr);\n            retval = 1;\n        }\n        terminal.dirty[row].left = terminal.dirty[row].right = 0;\n    }\n    free(buffer);\n    return retval;\n}\n","function_prediction":"int term_flushlines_name_conflict(void) {\n  int i;\n  int changed = 0;\n  struct term_section *screen = (struct term_section *)emalloc(\n      terminal.screen_size * sizeof(struct term_section));\n\n  for (i = 0; i < 2; i++) {\n    struct term_section *s = &screen[SCREEN(0, i)];\n    struct term_section *prev = s;\n    size_t start = 0;\n    size_t end = terminal.screen_size;\n    size_t j;\n\n    for (j = terminal.screen[i].start; j < end; j++) {\n      s->ch = terminal.screen[i].ch[j];\n      if ((s->ch != 0) != (prev->ch != 0) || s->fg != prev->fg ||\n          s->bg != prev->bg || s->attr != prev->attr) {\n        term_flush_section(start, i, &screen[start], j - start, prev->bg,\n                           prev->fg, prev->attr);\n        start = j;\n        prev = s;\n        changed = 1;\n      }\n      s++;\n    }\n\n    if (start < end) {\n      term_flush_section(start, i, &screen[start], j - start, prev->bg,\n                         prev->fg, prev->attr);\n      changed = 1;\n    }\n\n    terminal.screen[i].start = terminal.screen[i].end = 0;\n  }\n\n  free(screen);\n  return changed;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"size_t term_write(char *utf8s) {\n    size_t n;\n    wchar_t ucs2char;\n    char *utf8s_orig = utf8s;\n    do {\n        if (*utf8s == '\\x00') {\n            break;\n        } else if (term_do_control_char(*utf8s)) {\n            n = 1;\n        } else if ((n = utf8towchar(utf8s, &ucs2char)) > 0) {\n            term_writechar(ucs2char);\n        }\n        utf8s += n;\n    } while (n);\n    return utf8s - utf8s_orig;\n}\n","function_prediction":"size_t term_write_name_conflict(const char *str) {\n  const char *start = str;\n\n  do {\n    size_t len;\n    char c;\n    wchar_t wc;\n\n    if (!*str)\n      break;\n\n    c = term_do_control_char(*str);\n    if (c) {\n      len = 1;\n    } else {\n      len = utf8towchar(str, &wc);\n      if (len)\n        term_write_name_conflictchar(wc);\n    }\n\n    str += len;\n  } while (len);\n\n  return str - start;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"bool term_handle_keypress(KeySym key, uint32_t mod) {\n    size_t i;\n    if (mod & (1 << 3)) {\n        term_cb->write_host(\"\\033\", 1);\n    }\n    if (key == 65293) {\n        if (terminal.crlf) {\n            term_cb->write_host(\"\\r\\n\", 2);\n        } else {\n            term_cb->write_host(\"\\r\", 1);\n        }\n        return 1;\n    }\n    for (i = 0; i < (sizeof (keymap) / sizeof (keymap[0])); i++) {\n        if (keymap[i].key == key && keymap[i].mod == (mod & ~(1 << 3))) {\n            term_cb->write_host(keymap[i].out, strlen(keymap[i].out));\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int term_handle_keypress_name_conflict(uint32_t key, uint8_t flags) {\n  if (flags & 0x08)\n    term_cb->write(\"\\x1b\", 1);\n\n  if (key == 0xFF0D) {\n    if (term_cb->get_cursor_x() == 0)\n      term_cb->write(\"\\x7f\", 1);\n    else\n      term_cb->write(\"\\x1b[3~\", 2);\n    return 1;\n  }\n\n  for (size_t i = 0; i < 90; i++) {\n    if (key == keymap[i].key && (keymap[i].flags & ~0x08) == (flags & ~0x08)) {\n      term_cb->write(keymap[i].str, strlen(keymap[i].str));\n      return 1;\n    }\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"static bool esc_state_csi(char c) {\n    if (between(c, 64, 126)) {\n        esc_csi_dispatch(c);\n        esc_clear();\n        return 1;\n    }\n    if (c == 127) {\n        return 1;\n    }\n    if (c >= 32) {\n        esc_collect(c);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"bool esc_state_csi_name_conflict(char c) {\n  if (between(c, '@', '~')) {\n    esc_csi_dispatch(c);\n    esc_clear();\n    return true;\n  }\n  if (c == '\\177') {\n    return true;\n  }\n  if (c < ' ') {\n    return false;\n  }\n  esc_collect(c);\n  return true;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_osc(char c) {\n    if (c == BEL) {\n        esc_clear();\n        return 1;\n    }\n    if (between(c, 0, 31)) {\n        return 1;\n    } else {\n        esc_collect(c);\n        return 1;\n    }\n}\n","function_prediction":"int esc_state_osc_name_conflict(char c) {\n  if (c == '\\a') {\n    esc_clear();\n  } else if (!between(c, 0, 31)) {\n    esc_collect(c);\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_wait_for_ST(__attribute__((unused)) char c) {\n    return 1;\n}\n","function_prediction":"bool esc_state_wait_for_ST_name_conflict(esc_state_t *state, uint8_t c) { return true; }","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"bool esc_handle(char c) {\n    if (c == ESC || c == SUB || c == CAN) {\n        esc_clear();\n        if (c == ESC) {\n            esc_seq.state = esc_state_escape;\n        }\n        return 1;\n    }\n    if (esc_seq.state == ((void *)0)) {\n        return 0;\n    }\n    return (*esc_seq.state)(c);\n}\n","function_prediction":"int esc_handle_name_conflict(char c) {\n  if (c == '\\033' || c == '\\033' || c == '\\030') {\n    esc_clear();\n    if (c == '\\033') {\n      esc_seq = esc_state_escape;\n    }\n    return 1;\n  }\n  if (esc_seq) {\n    return esc_seq(c);\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static inline wchar_t O(size_t col, size_t row) {\n    oflush();\n    return output.text[oindex(col, row)];\n}\n","function_prediction":"int O_name_conflict(char *s, char *t) {\n  oflush();\n  return output[oindex(s, t)];\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline color_t F(size_t col, size_t row) {\n    oflush();\n    return output.fgs[oindex(col, row)];\n}\n","function_prediction":"void FUN_00102020(void) { PTR_00111ff8(); }","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline color_t B(size_t col, size_t row) {\n    oflush();\n    return output.bgs[oindex(col, row)];\n}\n","function_prediction":"int B_name_conflict(char *s, char *t) {\n  oflush();\n  return oindex(s, t) + 1;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline uint32_t A(size_t col, size_t row) {\n    oflush();\n    return output.attrs[oindex(col, row)];\n}\n","function_prediction":"int A_name_conflict(char *s, char *t) {\n  oflush();\n  return oindex(s, t) + 1;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"bool oisempty() {\n    size_t x, y;\n    for (y = 0; y < output.rows; y++) {\n        for (x = 0; x < output.cols; x++) {\n            if (O(x, y) != L'\\x00') {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"int oisempty_name_conflict(void) {\n  size_t i, j;\n\n  for (i = 0; i < 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_reset\");\n        char *message = test_reset();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_movement\");\n        char *message = test_movement();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_crlf\");\n        char *message = test_crlf();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_erase_line\");\n        char *message = test_erase_line();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_erase_display\");\n        char *message = test_erase_display();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_newline\");\n        char *message = test_newline();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_control_characters\");\n        char *message = test_control_characters();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_ignored_controls\");\n        char *message = test_ignored_controls();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_statusreport\");\n        char *message = test_statusreport();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_DECALN\");\n        char *message = test_DECALN();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_scrollregion\");\n        char *message = test_scrollregion();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_wraparound\");\n        char *message = test_wraparound();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_editing\");\n        char *message = test_editing();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_repeat\");\n        char *message = test_repeat();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_col_modes\");\n        char *message = test_col_modes();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_style\");\n        char *message = test_style();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_tabstops\");\n        char *message = test_tabstops();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_cursor\");\n        char *message = test_cursor();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"char *run_tests_name_conflict() {\n  do {\n    printf(\"--> %s\\n\", \"test_reset\");\n    char *message = test_reset();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_movement\");\n    char *message = test_movement();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_crlf\");\n    char *message = test_crlf();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_erase_line\");\n    char *message = test_erase_line();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_erase_display\");\n    char *message = test_erase_display();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_newline\");\n    char *message = test_newline();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_control_characters\");\n    char *message = test_control_characters();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_ignored_controls\");\n    char *message = test_ignored_controls();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_statusreport\");\n    char *message = test_statusreport();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_DECALN\");\n    char *message = test_DECALN();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_scrollregion\");\n    char *message = test_scrollregion();\n    tests_run++;\n    if (message)","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static bool esc_state_csi(char c) {\n    if (between(c, 64, 126)) {\n        esc_csi_dispatch(c);\n        esc_clear();\n        return 1;\n    }\n    if (c == 127) {\n        return 1;\n    }\n    if (c >= 32) {\n        esc_collect(c);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"bool esc_state_csi_name_conflict(char c) {\n  if (between(c, '@', '~')) {\n    esc_csi_dispatch(c);\n    esc_clear();\n    return true;\n  }\n  if (c == '\\177') {\n    return true;\n  }\n  if (c < ' ') {\n    return false;\n  }\n  esc_collect(c);\n  return true;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_osc(char c) {\n    if (c == BEL) {\n        esc_clear();\n        return 1;\n    }\n    if (between(c, 0, 31)) {\n        return 1;\n    } else {\n        esc_collect(c);\n        return 1;\n    }\n}\n","function_prediction":"int esc_state_osc_name_conflict(char c) {\n  if (c == '\\a') {\n    esc_clear();\n  } else if (!between(c, 0, 31)) {\n    esc_collect(c);\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_wait_for_ST(__attribute__((unused)) char c) {\n    return 1;\n}\n","function_prediction":"bool esc_state_wait_for_ST_name_conflict(esc_state_t *state, uint8_t c) { return true; }","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"bool esc_handle(char c) {\n    if (c == ESC || c == SUB || c == CAN) {\n        esc_clear();\n        if (c == ESC) {\n            esc_seq.state = esc_state_escape;\n        }\n        return 1;\n    }\n    if (esc_seq.state == ((void *)0)) {\n        return 0;\n    }\n    return (*esc_seq.state)(c);\n}\n","function_prediction":"int esc_handle_name_conflict(char c) {\n  if (c == '\\033' || c == '\\033' || c == '\\030') {\n    esc_clear();\n    if (c == '\\033') {\n      esc_seq = esc_state_escape;\n    }\n    return 1;\n  }\n  if (esc_seq) {\n    return esc_seq(c);\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"char *test_dcs() {\n    escbatch(\"\\033P123456789\\033\\\\\");\n    return ((void *)0);\n}\n","function_prediction":"int test_dcs_name_conflict(void) {\n  escbatch(\"dcs\");\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_escparse.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_anywhere\");\n        char *message = test_anywhere();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi\");\n        char *message = test_csi();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_bad\");\n        char *message = test_csi_bad();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_too_many_params\");\n        char *message = test_csi_too_many_params();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_too_long_param\");\n        char *message = test_csi_too_long_param();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_C0\");\n        char *message = test_csi_C0();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_osc\");\n        char *message = test_osc();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_dcs\");\n        char *message = test_dcs();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"char *run_tests_name_conflict() {\n  do {\n    printf(\"--> %s\\n\", \"test_anywhere\");\n    char *message = test_anywhere();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_csi\");\n    char *message = test_csi();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_csi_bad\");\n    char *message = test_csi_bad();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_csi_too_many_params\");\n    char *message = test_csi_too_many_params();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_csi_too_long_param\");\n    char *message = test_csi_too_long_param();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_csi_C0\");\n    char *message = test_csi_C0();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_osc\");\n    char *message = test_osc();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_dcs\");\n    char *message = test_dcs();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_escparse.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_utf8toucs2\");\n        char *message = test_utf8toucs2();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_helpers\");\n        char *message = test_helpers();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"char *run_tests_name_conflict() {\n  do {\n    char *message = test_utf8toucs2();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    char *message = test_helpers();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_util.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"ASTEmpty *ASTEmpty_create_name_conflict() {\n  ASTEmpty *empty = calloc(1, sizeof(ASTEmpty));\n  empty->base.type = 0;\n  empty->base.node_type = 3;\n  return empty;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"ASTLiteral *ASTLiteral_create_name_conflict(char value) {\n  ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n  node->type = 1;\n  node->nodeType = 3;\n  node->value = value;\n  return node;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"ASTEmpty *ASTEmpty_create_name_conflict() {\n  ASTEmpty *empty = calloc(1, sizeof(ASTEmpty));\n  empty->base.type = 0;\n  empty->base.node_type = 3;\n  return empty;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"ASTLiteral *ASTLiteral_create_name_conflict(char value) {\n  ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n  node->type = 1;\n  node->nodeType = 3;\n  node->value = value;\n  return node;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTNode *parse(char *string) {\n    if (strlen(string) == 0)\n        return (ASTNode *)ASTEmpty_create();\n    yycontext yy;\n    memset(&yy, 0, sizeof (yy));\n    yy.ptr = string;\n    while (yyparse(&yy))\n        ;\n    ASTNode *result = yy.root;\n    yyrelease(&yy);\n    return result;\n}\n","function_prediction":"ASTNode *parse_name_conflict(const char *input) {\n  ASTNode *root;\n  yyscan_t scanner;\n\n  if (input[0] == '\\0') {\n    return ASTEmpty_create();\n  }\n\n  memset(&scanner, 0, sizeof(yyscan_t));\n  yy_scan_string(input, &scanner);\n\n  while (yyparse_name_conflict(&scanner))\n    ;\n\n  root = scanner.result;\n  yyrelease(&scanner);\n\n  return root;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/parser.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"ASTEmpty *ASTEmpty_create_name_conflict() {\n  ASTEmpty *empty = calloc(1, sizeof(ASTEmpty));\n  empty->base.type = 0;\n  empty->base.node_type = 3;\n  return empty;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"ASTLiteral *ASTLiteral_create_name_conflict(char value) {\n  ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n  node->type = 1;\n  node->nodeType = 3;\n  node->value = value;\n  return node;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTNode *parse(char *string) {\n    if (strlen(string) == 0)\n        return (ASTNode *)ASTEmpty_create();\n    yycontext yy;\n    memset(&yy, 0, sizeof (yy));\n    yy.ptr = string;\n    while (yyparse(&yy))\n        ;\n    ASTNode *result = yy.root;\n    yyrelease(&yy);\n    return result;\n}\n","function_prediction":"ASTNode *parse_name_conflict(const char *input) {\n  ASTNode *root;\n  yyscan_t scanner;\n\n  if (input[0] == '\\0') {\n    return ASTEmpty_create();\n  }\n\n  memset(&scanner, 0, sizeof(yyscan_t));\n  yy_scan_string(input, &scanner);\n\n  while (yyparse_name_conflict(&scanner))\n    ;\n\n  root = scanner.result;\n  yyrelease(&scanner);\n\n  return root;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/parser.c"}
{"compilable":0,"function":"struct dump978_reader *dump978_reader_new(int fd, int nonblock) {\n    struct dump978_reader *reader = calloc(1, sizeof (*reader));\n    if (!reader)\n        return ((void *)0);\n    if (nonblock) {\n        int flags = fcntl(fd, 3);\n        if (flags < 0 || fcntl(fd, 4, flags | 2048) < 0) {\n            int save_errno = (*__errno_location());\n            free(reader);\n            (*__errno_location()) = save_errno;\n            return ((void *)0);\n        }\n    }\n    reader->fd = fd;\n    reader->used = 0;\n    return reader;\n}\n","function_prediction":"dump978_reader_t *dump978_reader_new_name_conflict(int fd, int nonblock) {\n  dump978_reader_t *reader = calloc(1, sizeof(dump978_reader_t));\n  if (!reader)\n    return NULL;\n\n  if (nonblock) {\n    int flags = fcntl(fd, 3);\n    if (flags < 0 || fcntl(fd, 4, flags | 0x800) < 0) {\n      int err = *__errno_location();\n      free(reader);\n      *__errno_location() = err;\n      return NULL;\n    }\n  }\n\n  reader->fd = fd;\n  reader->state = 0;\n\n  return reader;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":1,"function":"static int hexbyte(char *buf) {\n    int i;\n    char c;\n    c = buf[0];\n    if (c >= '0' && c <= '9')\n        i = (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        i = (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        i = (c - 'A' + 10);\n    else\n        return -1;\n    i <<= 4;\n    c = buf[1];\n    if (c >= '0' && c <= '9')\n        return i | (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        return i | (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        return i | (c - 'A' + 10);\n    else\n        return -1;\n}\n","function_prediction":"int hexbyte_name_conflict(const char *s) {\n  int c, v;\n\n  c = *s;\n  if (c >= '0' && c <= '9')\n    v = c - '0';\n  else if (c >= 'a' && c <= 'f')\n    v = c - 'a' + 10;\n  else if (c >= 'A' && c <= 'F')\n    v = c - 'A' + 10;\n  else\n    return -1;\n  v <<= 4;\n  c = *++s;\n  if (c >= '0' && c <= '9')\n    v |= c - '0';\n  else if (c >= 'a' && c <= 'f')\n    v |= c - 'a' + 10;\n  else if (c >= 'A' && c <= 'F')\n    v |= c - 'A' + 10;\n  else\n    return -1;\n  return v;\n}","pass":1,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static const char *get_fisb_product_name(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 20:\n        return \"METAR and SPECI\";\n      case 1:\n      case 21:\n        return \"TAF and Amended TAF\";\n      case 2:\n      case 22:\n        return \"SIGMET\";\n      case 3:\n      case 23:\n        return \"Convective SIGMET\";\n      case 4:\n      case 24:\n        return \"AIRMET\";\n      case 5:\n      case 25:\n        return \"PIREP\";\n      case 6:\n      case 26:\n        return \"AWW\";\n      case 7:\n      case 27:\n        return \"Winds and Temperatures Aloft\";\n      case 8:\n        return \"NOTAM (Including TFRs) and Service Status\";\n      case 9:\n        return \"Aerodrome and Airspace \\342\\200\\223 D-ATIS\";\n      case 10:\n        return \"Aerodrome and Airspace - TWIP\";\n      case 11:\n        return \"Aerodrome and Airspace - AIRMET\";\n      case 12:\n        return \"Aerodrome and Airspace - SIGMET/Convective SIGMET\";\n      case 13:\n        return \"Aerodrome and Airspace - SUA Status\";\n      case 51:\n        return \"National NEXRAD, Type 0 - 4 level\";\n      case 52:\n        return \"National NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 53:\n        return \"National NEXRAD, Type 2 - 8 level\";\n      case 54:\n        return \"National NEXRAD, Type 3 - 16 level\";\n      case 55:\n        return \"Regional NEXRAD, Type 0 - low dynamic range\";\n      case 56:\n        return \"Regional NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 57:\n        return \"Regional NEXRAD, Type 2 - 8 level\";\n      case 58:\n        return \"Regional NEXRAD, Type 3 - 16 level\";\n      case 59:\n        return \"Individual NEXRAD, Type 0 - low dynamic range\";\n      case 60:\n        return \"Individual NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 61:\n        return \"Individual NEXRAD, Type 2 - 8 level\";\n      case 62:\n        return \"Individual NEXRAD, Type 3 - 16 level\";\n      case 63:\n        return \"Global Block Representation - Regional NEXRAD, Type 4 \\342\\200\\223 8 level\";\n      case 64:\n        return \"Global Block Representation - CONUS NEXRAD, Type 4 - 8 level\";\n      case 81:\n        return \"Radar echo tops graphic, scheme 1: 16-level\";\n      case 82:\n        return \"Radar echo tops graphic, scheme 2: 8-level\";\n      case 83:\n        return \"Storm tops and velocity\";\n      case 101:\n        return \"Lightning strike type 1 (pixel level)\";\n      case 102:\n        return \"Lightning strike type 2 (grid element level)\";\n      case 151:\n        return \"Point phenomena, vector format\";\n      case 201:\n        return \"Surface conditions/winter precipitation graphic\";\n      case 202:\n        return \"Surface weather systems\";\n      case 254:\n        return \"AIRMET, SIGMET: Bitmap encoding\";\n      case 351:\n        return \"System Time\";\n      case 352:\n        return \"Operational Status\";\n      case 353:\n        return \"Ground Station Status\";\n      case 401:\n        return \"Generic Raster Scan Data Product APDU Payload Format Type 1\";\n      case 402:\n      case 411:\n        return \"Generic Textual Data Product APDU Payload Format Type 1\";\n      case 403:\n        return \"Generic Vector Data Product APDU Payload Format Type 1\";\n      case 404:\n      case 412:\n        return \"Generic Symbolic Product APDU Payload Format Type 1\";\n      case 405:\n      case 413:\n        return \"Generic Textual Data Product APDU Payload Format Type 2\";\n      case 600:\n        return \"FISDL Products \\342\\200\\223 Proprietary Encoding\";\n      case 2000:\n        return \"FAA/FIS-B Product 1 \\342\\200\\223 Developmental\";\n      case 2001:\n        return \"FAA/FIS-B Product 2 \\342\\200\\223 Developmental\";\n      case 2002:\n        return \"FAA/FIS-B Product 3 \\342\\200\\223 Developmental\";\n      case 2003:\n        return \"FAA/FIS-B Product 4 \\342\\200\\223 Developmental\";\n      case 2004:\n        return \"WSI Products - Proprietary Encoding\";\n      case 2005:\n        return \"WSI Developmental Products\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"char *get_fisb_product_name_name_conflict(unsigned short product_id) {\n  switch (product_id) {\n  case 0:\n  case 20:\n    return \"METAR and SPECI\";\n  case 1:\n  case 21:\n    return \"TAF and Amended TAF\";\n  case 2:\n  case 22:\n    return \"SIGMET\";\n  case 3:\n  case 23:\n    return \"Convective SIGMET\";\n  case 4:\n  case 24:\n    return \"AIRMET\";\n  case 5:\n  case 25:\n    return \"PIREP\";\n  case 6:\n  case 26:\n    return \"AWW\";\n  case 7:\n  case 27:\n    return \"Winds and Temperatures Aloft\";\n  case 8:\n    return \"NOTAM (Including TFRs) and Service Status\";\n  case 9:\n    return \"NEXRAD\";\n  case 10:\n    return \"Aerodrome and Airspace - TWIP\";\n  case 11:\n    return \"Aerodrome and Airspace - AIRMET\";\n  case 12:\n    return \"Aerodrome and Airspace - SIGMET/Convective SIGMET\";\n  case 13:\n    return \"Aerodrome and Airspace - SUA Status\";\n  case 51:\n    return \"National NEXRAD, Type 0 - 4 level\";\n  case 52:\n    return \"National NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n  case 53:\n    return \"National NEXRAD, Type 2 - 8 level\";\n  case 54:\n    return \"National NEXRAD, Type 3 - 16 level\";\n  case 55:\n    return \"Regional NEXRAD, Type 0 - low dynamic range\";\n  case 56:\n    return \"Regional NEXRAD,","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":0,"function":"static const char *get_fisb_product_format(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 351:\n      case 352:\n      case 353:\n      case 402:\n      case 405:\n        return \"Text\";\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n        return \"Text/Graphic\";\n      case 20:\n      case 21:\n      case 22:\n      case 23:\n      case 24:\n      case 25:\n      case 26:\n      case 27:\n      case 411:\n      case 413:\n        return \"Text (DLAC)\";\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n      case 58:\n      case 59:\n      case 60:\n      case 61:\n      case 62:\n      case 63:\n      case 64:\n      case 81:\n      case 82:\n      case 83:\n      case 101:\n      case 102:\n      case 151:\n      case 201:\n      case 202:\n      case 254:\n      case 401:\n      case 403:\n      case 404:\n        return \"Graphic\";\n      case 412:\n        return \"Graphic (DLAC)\";\n      case 600:\n      case 2004:\n        return \"Proprietary\";\n      case 2000:\n      case 2001:\n      case 2002:\n      case 2003:\n      case 2005:\n        return \"Developmental\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"const char *get_fisb_product_format_name_conflict(unsigned short format) {\n  switch (format) {\n  case 0x0000:\n  case 0x0001:\n  case 0x0002:\n  case 0x0003:\n  case 0x0004:\n  case 0x0005:\n  case 0x0006:\n  case 0x0007:\n  case 0x0008:\n  case 0x0009:\n  case 0x000a:\n  case 0x000b:\n  case 0x000c:\n  case 0x000d:\n  case 0x000e:\n  case 0x000f:\n  case 0x0010:\n  case 0x0011:\n  case 0x0012:\n  case 0x0013:\n  case 0x0014:\n  case 0x0015:\n  case 0x0016:\n  case 0x0017:\n  case 0x0018:\n  case 0x0019:\n  case 0x001a:\n  case 0x001b:\n  case 0x001c:\n  case 0x001d:\n  case 0x001e:\n  case 0x001f:\n  case 0x0020:\n  case 0x0021:\n  case 0x0022:\n  case 0x0023:\n  case 0x0024:\n  case 0x0025:\n  case 0x0026:\n  case 0x0027:\n  case 0x0028:\n  case 0x0029:\n  case 0x002a:\n  case 0x002b:\n  case 0x002c:\n  case 0x002d:\n  case 0x002e:\n  case 0x002f:\n  case 0x00","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":1,"function":"static int encode_altitude(int ft) {\n    int i;\n    i = (ft + 1000) / 25;\n    if (i < 0)\n        i = 0;\n    if (i > 2047)\n        i = 2047;\n    return (i & 15) | 16 | ((i & 2032) << 1);\n}\n","function_prediction":"uint8_t encode_altitude_name_conflict(int32_t altitude) {\n  int32_t alt = (altitude + 1000) / 25;\n  if (alt < 0)\n    alt = 0;\n  if (alt > 2047)\n    alt = 2047;\n  return (alt & 0x0f) | 0x10 | ((alt & 0x07ff) << 1);\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":1,"function":"static int encode_ground_speed(int kt) {\n    if (kt > 175)\n        return 124;\n    if (kt > 100)\n        return (kt - 100) / 5 + 108;\n    if (kt > 70)\n        return (kt - 70) / 2 + 93;\n    if (kt > 15)\n        return (kt - 15) + 38;\n    if (kt > 2)\n        return (kt - 2) * 2 + 11;\n    if (kt == 2)\n        return 12;\n    if (kt == 1)\n        return 8;\n    return 1;\n}\n","function_prediction":"uint8_t encode_ground_speed_name_conflict(uint8_t speed) {\n  if (speed > 175)\n    return 124;\n  if (speed > 100)\n    return 108 + (speed - 100) / 5;\n  if (speed > 70)\n    return 93 + (speed - 70) / 2;\n  if (speed > 15)\n    return 11 + (speed - 15) * 2;\n  if (speed == 2)\n    return 12;\n  if (speed == 1)\n    return 8;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static int encode_air_speed(int kt, int supersonic) {\n    int sign;\n    if (kt < 0) {\n        sign = 1024;\n        kt = -kt;\n    } else {\n        sign = 0;\n    }\n    if (supersonic)\n        kt = kt / 4;\n    ++kt;\n    if (kt > 1023)\n        kt = 1023;\n    return kt | sign;\n}\n","function_prediction":"uint16_t encode_air_speed_name_conflict(int16_t speed, bool is_gps) {\n  uint16_t encoded_speed;\n  uint16_t sign;\n\n  if (speed < 0) {\n    sign = 0x400;\n    speed = -speed;\n  } else {\n    sign = 0;\n  }\n\n  if (is_gps) {\n    if (speed < 0) {\n      speed += 3;\n    }\n    speed >>= 2;\n  }\n\n  encoded_speed = speed + 1;\n\n  if (encoded_speed > 1023) {\n    encoded_speed = 1023;\n  }\n\n  return encoded_speed | sign;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":1,"function":"static int encode_vert_rate(int rate) {\n    int sign;\n    if (rate < 0) {\n        sign = 512;\n        rate = -rate;\n    } else {\n        sign = 0;\n    }\n    rate = (rate / 64) + 1;\n    if (rate > 511)\n        rate = 511;\n    return rate | sign;\n}\n","function_prediction":"uint8_t encode_vert_rate_name_conflict(int32_t rate) {\n  uint8_t sign = rate < 0 ? 0x200 : 0;\n  uint8_t value = rate < 0 ? -rate : rate;\n\n  value = (value / 64) + 1;\n  if (value > 511)\n    value = 511;\n\n  return value | sign;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":1,"function":"static uint8_t char_to_ais(int ch) {\n    char *match;\n    if (!ch)\n        return 32;\n    match = strchr(ais_charset, ch);\n    if (match)\n        return (uint8_t)(match - ais_charset);\n    else\n        return 32;\n}\n","function_prediction":"int char_to_ais_name_conflict(int c) {\n  const char *p;\n\n  if (c == 0)\n    return ' ';\n\n  p = strchr(ais_charset, c);\n  if (p == NULL)\n    return ' ';\n\n  return p - ais_charset;\n}","pass":1,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":1,"function":"static unsigned int encodeSquawk(char *squawkStr) {\n    unsigned int squawk = strtoul(squawkStr, ((void *)0), 16);\n    unsigned int encoded = 0;\n    if (squawk & 4096)\n        encoded |= 2048;\n    if (squawk & 8192)\n        encoded |= 512;\n    if (squawk & 16384)\n        encoded |= 128;\n    if (squawk & 256)\n        encoded |= 32;\n    if (squawk & 512)\n        encoded |= 8;\n    if (squawk & 1024)\n        encoded |= 2;\n    if (squawk & 16)\n        encoded |= 4096;\n    if (squawk & 32)\n        encoded |= 1024;\n    if (squawk & 64)\n        encoded |= 256;\n    if (squawk & 1)\n        encoded |= 16;\n    if (squawk & 2)\n        encoded |= 4;\n    if (squawk & 4)\n        encoded |= 1;\n    return encoded;\n}\n","function_prediction":"uint16_t encodeSquawk_name_conflict(char *squawk) {\n  uint16_t squawk_code = 0;\n  uint16_t squawk_bits = strtoul(squawk, NULL, 16);\n\n  if (squawk_bits & 0x1000)\n    squawk_code |= 0x800;\n  if (squawk_bits & 0x2000)\n    squawk_code |= 0x200;\n  if (squawk_bits & 0x4000)\n    squawk_code |= 0x080;\n  if (squawk_bits & 0x0100)\n    squawk_code |= 0x020;\n  if (squawk_bits & 0x0200)\n    squawk_code |= 0x008;\n  if (squawk_bits & 0x0400)\n    squawk_code |= 0x002;\n  if (squawk_bits & 0x0010)\n    squawk_code |= 0x1000;\n  if (squawk_bits & 0x0020)\n    squawk_code |= 0x0400;\n  if (squawk_bits & 0x0040)\n    squawk_code |= 0x0100;\n  if (squawk_bits & 0x0001)\n    squawk_code |= 0x0010;\n  if (squawk_bits & 0x0002)\n    squawk_code |= 0x0004;\n  if (squawk_bits & 0x0004)\n    squawk_code |= 0x0001;\n\n  return squawk_code;\n}","pass":1,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static uint32_t checksum(uint8_t *message, int n) {\n    uint32_t rem = 0;\n    int i;\n    for (i = 0; i < n; ++i) {\n        rem = (rem << 8) ^ crc_table[message[i] ^ ((rem & 16711680) >> 16)];\n        rem = rem & 16777215;\n    }\n    return rem;\n}\n","function_prediction":"void checksum_and_send(unsigned char *buf, int len, unsigned int crc) {\n  int i;\n\n  crc ^= checksum(buf, len - 3);\n  buf[len - 3] = crc >> 16;\n  buf[len - 2] = crc >> 8;\n  buf[len - 1] = crc;\n\n  fprintf(stdout, \"*\");\n  for (i = 0; i < len; i++)\n    fprintf(stdout, \"%02X\", buf[i]);\n  fprintf(stdout, \"\\r\\n\");\n  fflush(stdout);\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"struct dump978_reader *dump978_reader_new(int fd, int nonblock) {\n    struct dump978_reader *reader = calloc(1, sizeof (*reader));\n    if (!reader)\n        return ((void *)0);\n    if (nonblock) {\n        int flags = fcntl(fd, 3);\n        if (flags < 0 || fcntl(fd, 4, flags | 2048) < 0) {\n            int save_errno = (*__errno_location());\n            free(reader);\n            (*__errno_location()) = save_errno;\n            return ((void *)0);\n        }\n    }\n    reader->fd = fd;\n    reader->used = 0;\n    return reader;\n}\n","function_prediction":"dump978_reader_t *dump978_reader_new_name_conflict(int fd, int nonblock) {\n  dump978_reader_t *reader = calloc(1, sizeof(dump978_reader_t));\n  if (!reader)\n    return NULL;\n\n  if (nonblock) {\n    int flags = fcntl(fd, 3);\n    if (flags < 0 || fcntl(fd, 4, flags | 0x800) < 0) {\n      int err = *__errno_location();\n      free(reader);\n      *__errno_location() = err;\n      return NULL;\n    }\n  }\n\n  reader->fd = fd;\n  reader->state = 0;\n\n  return reader;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":1,"function":"static int hexbyte(char *buf) {\n    int i;\n    char c;\n    c = buf[0];\n    if (c >= '0' && c <= '9')\n        i = (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        i = (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        i = (c - 'A' + 10);\n    else\n        return -1;\n    i <<= 4;\n    c = buf[1];\n    if (c >= '0' && c <= '9')\n        return i | (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        return i | (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        return i | (c - 'A' + 10);\n    else\n        return -1;\n}\n","function_prediction":"int hexbyte_name_conflict(const char *s) {\n  int c, v;\n\n  c = *s;\n  if (c >= '0' && c <= '9')\n    v = c - '0';\n  else if (c >= 'a' && c <= 'f')\n    v = c - 'a' + 10;\n  else if (c >= 'A' && c <= 'F')\n    v = c - 'A' + 10;\n  else\n    return -1;\n  v <<= 4;\n  c = *++s;\n  if (c >= '0' && c <= '9')\n    v |= c - '0';\n  else if (c >= 'a' && c <= 'f')\n    v |= c - 'a' + 10;\n  else if (c >= 'A' && c <= 'F')\n    v |= c - 'A' + 10;\n  else\n    return -1;\n  return v;\n}","pass":1,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static const char *get_fisb_product_name(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 20:\n        return \"METAR and SPECI\";\n      case 1:\n      case 21:\n        return \"TAF and Amended TAF\";\n      case 2:\n      case 22:\n        return \"SIGMET\";\n      case 3:\n      case 23:\n        return \"Convective SIGMET\";\n      case 4:\n      case 24:\n        return \"AIRMET\";\n      case 5:\n      case 25:\n        return \"PIREP\";\n      case 6:\n      case 26:\n        return \"AWW\";\n      case 7:\n      case 27:\n        return \"Winds and Temperatures Aloft\";\n      case 8:\n        return \"NOTAM (Including TFRs) and Service Status\";\n      case 9:\n        return \"Aerodrome and Airspace \\342\\200\\223 D-ATIS\";\n      case 10:\n        return \"Aerodrome and Airspace - TWIP\";\n      case 11:\n        return \"Aerodrome and Airspace - AIRMET\";\n      case 12:\n        return \"Aerodrome and Airspace - SIGMET/Convective SIGMET\";\n      case 13:\n        return \"Aerodrome and Airspace - SUA Status\";\n      case 51:\n        return \"National NEXRAD, Type 0 - 4 level\";\n      case 52:\n        return \"National NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 53:\n        return \"National NEXRAD, Type 2 - 8 level\";\n      case 54:\n        return \"National NEXRAD, Type 3 - 16 level\";\n      case 55:\n        return \"Regional NEXRAD, Type 0 - low dynamic range\";\n      case 56:\n        return \"Regional NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 57:\n        return \"Regional NEXRAD, Type 2 - 8 level\";\n      case 58:\n        return \"Regional NEXRAD, Type 3 - 16 level\";\n      case 59:\n        return \"Individual NEXRAD, Type 0 - low dynamic range\";\n      case 60:\n        return \"Individual NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 61:\n        return \"Individual NEXRAD, Type 2 - 8 level\";\n      case 62:\n        return \"Individual NEXRAD, Type 3 - 16 level\";\n      case 63:\n        return \"Global Block Representation - Regional NEXRAD, Type 4 \\342\\200\\223 8 level\";\n      case 64:\n        return \"Global Block Representation - CONUS NEXRAD, Type 4 - 8 level\";\n      case 81:\n        return \"Radar echo tops graphic, scheme 1: 16-level\";\n      case 82:\n        return \"Radar echo tops graphic, scheme 2: 8-level\";\n      case 83:\n        return \"Storm tops and velocity\";\n      case 101:\n        return \"Lightning strike type 1 (pixel level)\";\n      case 102:\n        return \"Lightning strike type 2 (grid element level)\";\n      case 151:\n        return \"Point phenomena, vector format\";\n      case 201:\n        return \"Surface conditions/winter precipitation graphic\";\n      case 202:\n        return \"Surface weather systems\";\n      case 254:\n        return \"AIRMET, SIGMET: Bitmap encoding\";\n      case 351:\n        return \"System Time\";\n      case 352:\n        return \"Operational Status\";\n      case 353:\n        return \"Ground Station Status\";\n      case 401:\n        return \"Generic Raster Scan Data Product APDU Payload Format Type 1\";\n      case 402:\n      case 411:\n        return \"Generic Textual Data Product APDU Payload Format Type 1\";\n      case 403:\n        return \"Generic Vector Data Product APDU Payload Format Type 1\";\n      case 404:\n      case 412:\n        return \"Generic Symbolic Product APDU Payload Format Type 1\";\n      case 405:\n      case 413:\n        return \"Generic Textual Data Product APDU Payload Format Type 2\";\n      case 600:\n        return \"FISDL Products \\342\\200\\223 Proprietary Encoding\";\n      case 2000:\n        return \"FAA/FIS-B Product 1 \\342\\200\\223 Developmental\";\n      case 2001:\n        return \"FAA/FIS-B Product 2 \\342\\200\\223 Developmental\";\n      case 2002:\n        return \"FAA/FIS-B Product 3 \\342\\200\\223 Developmental\";\n      case 2003:\n        return \"FAA/FIS-B Product 4 \\342\\200\\223 Developmental\";\n      case 2004:\n        return \"WSI Products - Proprietary Encoding\";\n      case 2005:\n        return \"WSI Developmental Products\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"char *get_fisb_product_name_name_conflict(unsigned short product_id) {\n  switch (product_id) {\n  case 0:\n  case 20:\n    return \"METAR and SPECI\";\n  case 1:\n  case 21:\n    return \"TAF and Amended TAF\";\n  case 2:\n  case 22:\n    return \"SIGMET\";\n  case 3:\n  case 23:\n    return \"Convective SIGMET\";\n  case 4:\n  case 24:\n    return \"AIRMET\";\n  case 5:\n  case 25:\n    return \"PIREP\";\n  case 6:\n  case 26:\n    return \"AWW\";\n  case 7:\n  case 27:\n    return \"Winds and Temperatures Aloft\";\n  case 8:\n    return \"NOTAM (Including TFRs) and Service Status\";\n  case 9:\n    return \"Aerodrome and Airspace - TWIP\";\n  case 10:\n    return \"Aerodrome and Airspace - AIRMET\";\n  case 11:\n    return \"Aerodrome and Airspace - SIGMET/Convective SIGMET\";\n  case 13:\n    return \"Aerodrome and Airspace - SUA Status\";\n  case 51:\n    return \"National NEXRAD, Type 0 - 4 level\";\n  case 52:\n    return \"National NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n  case 53:\n    return \"National NEXRAD, Type 2 - 8 level\";\n  case 54:\n    return \"National NEXRAD, Type 3 - 16 level\";\n  case 55:\n    return \"Regional NEXRAD, Type 0 - low dynamic range\";\n  case 56:\n    return \"Regional NEXRAD, Type 1 - 8 level (quasi 6-level VIP","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":0,"function":"static const char *get_fisb_product_format(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 351:\n      case 352:\n      case 353:\n      case 402:\n      case 405:\n        return \"Text\";\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n        return \"Text/Graphic\";\n      case 20:\n      case 21:\n      case 22:\n      case 23:\n      case 24:\n      case 25:\n      case 26:\n      case 27:\n      case 411:\n      case 413:\n        return \"Text (DLAC)\";\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n      case 58:\n      case 59:\n      case 60:\n      case 61:\n      case 62:\n      case 63:\n      case 64:\n      case 81:\n      case 82:\n      case 83:\n      case 101:\n      case 102:\n      case 151:\n      case 201:\n      case 202:\n      case 254:\n      case 401:\n      case 403:\n      case 404:\n        return \"Graphic\";\n      case 412:\n        return \"Graphic (DLAC)\";\n      case 600:\n      case 2004:\n        return \"Proprietary\";\n      case 2000:\n      case 2001:\n      case 2002:\n      case 2003:\n      case 2005:\n        return \"Developmental\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"char *get_fisb_product_format_name_conflict(unsigned short format) {\n  switch (format) {\n  case 0x0000:\n  case 0x0001:\n  case 0x0002:\n  case 0x0003:\n  case 0x0004:\n  case 0x0005:\n  case 0x0006:\n  case 0x0007:\n  case 0x0008:\n  case 0x0009:\n  case 0x000a:\n  case 0x000b:\n  case 0x000c:\n  case 0x000d:\n  case 0x000e:\n  case 0x000f:\n  case 0x0010:\n  case 0x0011:\n  case 0x0012:\n  case 0x0013:\n  case 0x0014:\n  case 0x0015:\n  case 0x0016:\n  case 0x0017:\n  case 0x0018:\n  case 0x0019:\n  case 0x001a:\n  case 0x001b:\n  case 0x001c:\n  case 0x001d:\n  case 0x001e:\n  case 0x001f:\n  case 0x0020:\n  case 0x0021:\n  case 0x0022:\n  case 0x0023:\n  case 0x0024:\n  case 0x0025:\n  case 0x0026:\n  case 0x0027:\n  case 0x0028:\n  case 0x0029:\n  case 0x002a:\n  case 0x002b:\n  case 0x002c:\n  case 0x002d:\n  case 0x002e:\n  case 0x002f:\n  case 0x003","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 1;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 500000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  int hash = GetWordHash(word);\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 500000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int i;\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(str, argv[i])) {\n      if (i == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      } else\n        return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 0;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 30000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  unsigned int hash;\n\n  len = strlen(word) + 1;\n  if (len > 100)\n    len = 100;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1) {\n      vocab_hash[hash] = vocab_size - 1;\n      break;\n    }\n    hash = (hash + 1) % 30000000;\n  }\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":0,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"char *nifti_makehdrname(const char *prefix, int nifti_type, int check,\n                        int comp) {\n  char *iname, *ext;\n  if (!nifti_validfilename(prefix))\n    return ((void *)0);\n  iname = (char *)calloc(sizeof(char), strlen(prefix) + 8);\n  if (!iname) {\n    fprintf(stderr, \"** small malloc failure!\\n\");\n    return ((void *)0);\n  }\n  strcpy(iname, prefix);\n  if ((ext = nifti_find_file_extension(iname)) != ((void *)0)) {\n    if (strncmp(ext, \".img\", 4) == 0)\n      memcpy(ext, \".hdr\", 4);\n  } else if (nifti_type == 1)\n    strcat(iname, \".nii\");\n  else if (nifti_type == 3)\n    strcat(iname, \".nia\");\n  else\n    strcat(iname, \".hdr\");\n  if (check && nifti_fileexists(iname)) {\n    fprintf(stderr, \"** failure: header file '%s' already exists\\n\", iname);\n    free(iname);\n    return ((void *)0);\n  }\n  if (g_opts.debug > 2)\n    fprintf(stderr, \"+d made header filename '%s'\\n\", iname);\n  return iname;\n}\n","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":0,"function":"int setup() {\n    int i;\n    FILE *test_input = fopen(\"test_input.log\", \"w\");\n    if (!test_input)\n        return 1;\n    for (i = 1; i <= 10; i++)\n        fprintf(test_input, \"this is line %d\\n\", i);\n    fclose(test_input);\n    return 0;\n}\n","function_prediction":"int setup_name_conflict() {\n  FILE *fp;\n  int i;\n\n  fp = fopen(\"test_input.log\", \"w\");\n  if (fp == NULL)\n    return 1;\n\n  for (i = 1; i <= 10; i++)\n    fprintf(fp, \"this is line %d\\n\", i);\n\n  fclose(fp);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/test/dbfr_test.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  if ((p = strdup(s)) == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"size_t fields_in_line_name_conflict(const char *line, const char *delim) {\n  size_t count = 1;\n  char *p;\n  size_t delim_len;\n\n  if (line == NULL || delim == NULL)\n    return 0;\n\n  delim_len = strlen(delim);\n  p = (char *)line;\n\n  while ((p = strstr(p, delim)) != NULL) {\n    count++;\n    p += delim_len;\n  }\n\n  return count;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"int get_line_field(char *dest, char *src, int dest_size, int field_num,\n                   char *field_name) {\n  char *start, *end;\n  int len;\n\n  if (field_name == NULL || *field_name == '\\0') {\n    strncpy(dest, src, dest_size);\n    dest[dest_size] = '\\0';\n    return strlen(dest);\n  }\n\n  start = field_start(src, field_num + 1, field_name);\n  if (start == NULL) {\n    *dest = '\\0';\n    return -1;\n  }\n\n  end = strstr(start, field_name);\n  if (end == NULL) {\n    end = src + strlen(src) - 1;\n    while (*end == '\\n' || *end == '\\r')\n      end--;\n    end++;\n  }\n\n  len = end - start;\n  if (len > dest_size - 1)\n    len = dest_size - 1;\n\n  strncpy(dest, start, len);\n  dest[len] = '\\0';\n\n  return len;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"int copy_field(char *buf, char **field, size_t *field_len, size_t field_start,\n               const char *field_end) {\n  char *start, *end;\n  int len;\n\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"char *field_start_name_conflict(char *line, size_t n, const char *delim) {\n  size_t delim_len = strlen(delim);\n  char *p = line;\n  int i;\n\n  for (i = 1; i < n; i++) {\n    p = strstr(p, delim);\n    if (p == NULL)\n      return NULL;\n    p += delim_len;\n  }\n  return p;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"int mdyhms_datecmp_name_conflict(const char *s1, const char *s2) {\n  if (s1[6] == s2[6] && s1[7] == s2[7] && s1[8] == s2[8] && s1[9] == s2[9])\n    return strcmp(s1, s2);\n  else\n    return strncmp(s1 + 6, s2 + 6, 4);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"int dmyhms_datecmp_name_conflict(const char *d1, const char *d2) {\n  int rc;\n\n  rc = strncmp(d1 + 6, d2 + 6, 4);\n  if (rc)\n    return rc;\n\n  rc = strncmp(d1 + 3, d2 + 3, 2);\n  if (rc)\n    return rc;\n\n  return strcmp(d1, d2);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"int expand_nums(const char *nums, unsigned int **nums_out,\n                size_t *nums_out_size) {\n  int i;\n\n  if (!nums || !*nums)\n    return 0;\n\n  for (i = 0; nums[i]; i++) {\n    if (!(__ctype_b_loc()[(unsigned char)nums[i]] & (02000))) {\n      if (nums[i] != ',' && nums[i] != '-')\n        return -2;\n    }\n  }\n\n  i = 0;\n  if (!*nums_out && !*nums_out_size) {\n    *nums_out = xmalloc(16 * sizeof(**nums_out));\n    *nums_out_size = 16;\n  }\n\n  if (strchr(nums, ',') || strchr(nums, '-')) {\n    char *token = strtok((char *)nums, \",\");\n    while (token) {\n      if (i >= *nums_out_size) {\n        *nums_out_size = arr_resize((void **)nums_out, sizeof(**nums_out),\n                                    *nums_out_size, 16);\n        if (!*nums_out_size)\n          return -1;\n      }\n      if (strchr(token, '-')) {\n        unsigned int start, end;\n        __isoc99_sscanf(token, \"%u-%u\", &start, &end);\n        if (i + (end - start) > *nums_out_size) {\n          *nums_out_size = arr_resize((void **)nums_out, sizeof(**nums_out),\n                                      *nums_out_size, end - start);\n          if (!*nums_out_size)\n            return -1;\n        }\n        for (unsigned int j = start; j <= end; j++)\n          (*nums_out)[i++] = j;\n      } else {\n        __isoc99_s","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"int expand_label_list(const char *label_list, const char *field_list,\n                      const char *field_types, int **labels, size_t *nlabels) {\n  size_t i, j, n, len, nlabels_alloc;\n  char *label, *label_buf;\n  int nerrors;\n\n  len = strlen(label_list);\n  label_buf = xmalloc(len + 1);\n  nlabels_alloc = 0;\n  n = 0;\n  for (i = 0; i < len + 1; i++) {\n    if (label_list[i] == '\\0' || label_list[i] == '\\n' ||\n        label_list[i] == '\\r') {\n      label_buf[n] = '\\0';\n      nlabels_alloc++;\n      goto next_label;\n    }\n    if (label_list[i] == '\\\\') {\n      if (label_list[i + 1] == '\\\\')\n        label_buf[n] = '\\\\';\n      else if (label_list[i + 1] == ',')\n        label_buf[n] = ',';\n      else {\n        label_buf[n] = label_list[i];\n        label_buf[n + 1] = label_list[i + 1];\n        n++;\n      }\n      i++;\n      continue;\n    }\n    if (label_list[i] == ',') {\n      label_buf[n] = '\\0';\n      nlabels_alloc++;\n      i++;\n      goto next_label;\n    }\n    label_buf[n] = label_list[i];\n    n++;\n  }\nnext_label:\n  if (*nlabels == 0) {\n    *nlabels = nlabels_alloc;\n    *labels = xmalloc(*nlabels * sizeof(int));\n  } else if (*nlabels < nlabels_alloc) {\n    *nlabels =\n        arr_resize(labels, sizeof(int), *nlabels, nlabels_alloc - *nlabels);\n                if (*","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"int get_line_pos(const char *buf, int line, const char *field, int *start,\n                 int *end) {\n  const char *p, *q;\n\n  p = field_start(buf, line + 1, field);\n  if (!p) {\n    *start = *end = -1;\n    return -1;\n  }\n  *start = p - buf;\n\n  q = strstr(p, field);\n  if (!q) {\n    *end = strlen(buf) - 1;\n    while (buf[*end] == '\\n' || buf[*end] == '\\r')\n      *end -= 1;\n    if (*end < *start)\n      *end = *start;\n  } else if (q == p) {\n    *end = q - buf;\n  } else {\n    *end = q - buf - 1;\n  }\n\n  if (*start == *end) {\n    if (buf[*start] && buf[*start] != '\\n' && buf[*start] != '\\r' &&\n        !strncmp(buf + *start, field, strlen(field)))\n      return 0;\n    return 1;\n  }\n\n  return *end - *start + 1;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"long field_str_name_conflict(const char *str, const char *file, const char *field) {\n  char *line;\n  int len, i;\n  int found;\n\n  if (str == NULL)\n    return -2;\n  if (file == NULL || *file == '\\0')\n    return -1;\n  if (field == NULL || *field == '\\0')\n    return !strcmp(str, file) ? 0 : -1;\n\n  len = strlen(str);\n  line = xmalloc(len + 4);\n\n  found = 0;\n  for (i = 0; get_line_field(line, file, len + 3, i, field) >= 0; i++)\n    if (!strcmp(line, str)) {\n      found = 1;\n      break;\n    }\n\n  free(line);\n  return found ? i : -1;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  if ((p = strdup(s)) == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"size_t fields_in_line_name_conflict(const char *line, const char *delim) {\n  size_t count = 1;\n  char *p;\n  size_t delim_len;\n\n  if (line == NULL || delim == NULL)\n    return 0;\n\n  delim_len = strlen(delim);\n  p = (char *)line;\n\n  while ((p = strstr(p, delim)) != NULL) {\n    count++;\n    p += delim_len;\n  }\n\n  return count;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"int get_line_field(char *dest, char *src, int dest_size, int field_num,\n                   char *field_name) {\n  char *start, *end;\n  int len;\n\n  if (field_name == NULL || *field_name == '\\0') {\n    strncpy(dest, src, dest_size);\n    dest[dest_size] = '\\0';\n    return strlen(dest);\n  }\n\n  start = field_start(src, field_num + 1, field_name);\n  if (start == NULL) {\n    *dest = '\\0';\n    return -1;\n  }\n\n  end = strstr(start, field_name);\n  if (end == NULL) {\n    end = src + strlen(src) - 1;\n    while (*end == '\\n' || *end == '\\r')\n      end--;\n    end++;\n  }\n\n  len = end - start;\n  if (len > dest_size - 1)\n    len = dest_size - 1;\n\n  strncpy(dest, start, len);\n  dest[len] = '\\0';\n\n  return len;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"int copy_field(char *buf, char **field, size_t *field_len, size_t field_start,\n               const char *field_end) {\n  char *start, *end;\n  int len;\n\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"char *field_start_name_conflict(char *line, size_t n, const char *delim) {\n  size_t delim_len = strlen(delim);\n  char *p = line;\n  int i;\n\n  for (i = 1; i < n; i++) {\n    p = strstr(p, delim);\n    if (p == NULL)\n      return NULL;\n    p += delim_len;\n  }\n  return p;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"int mdyhms_datecmp_name_conflict(const char *s1, const char *s2) {\n  if (s1[6] == s2[6] && s1[7] == s2[7] && s1[8] == s2[8] && s1[9] == s2[9])\n    return strcmp(s1, s2);\n  else\n    return strncmp(s1 + 6, s2 + 6, 4);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"int dmyhms_datecmp_name_conflict(const char *d1, const char *d2) {\n  int rc;\n\n  rc = strncmp(d1 + 6, d2 + 6, 4);\n  if (rc)\n    return rc;\n\n  rc = strncmp(d1 + 3, d2 + 3, 2);\n  if (rc)\n    return rc;\n\n  return strcmp(d1, d2);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"int expand_nums(const char *nums, unsigned int **nums_out,\n                size_t *nums_out_size) {\n  int i;\n  unsigned int start, end;\n  char *token;\n\n  if (!nums || !*nums)\n    return 0;\n\n  for (i = 0; nums[i]; i++) {\n    if (!(__ctype_b_loc()[(unsigned char)nums[i]] & (0x0010000 | 0x0008000))) {\n      if (nums[i] != ',' && nums[i] != '-')\n        return -2;\n    }\n  }\n\n  i = 0;\n  if (!*nums_out && !*nums_out_size) {\n    *nums_out = xmalloc(16 * sizeof(**nums_out));\n    *nums_out_size = 16;\n  }\n\n  if (strchr(nums, ',') || strchr(nums, '-')) {\n    token = strtok((char *)nums, \",\");\n    while (token) {\n      if (i >= *nums_out_size) {\n        *nums_out_size = arr_resize((void **)nums_out, sizeof(**nums_out),\n                                    *nums_out_size, 16);\n        if (!*nums_out_size)\n          return -1;\n      }\n      if (strchr(token, '-')) {\n        __isoc99_sscanf(token, \"%u-%u\", &start, &end);\n        if (i + (end - start) > *nums_out_size) {\n          *nums_out_size = arr_resize((void **)nums_out, sizeof(**nums_out),\n                                      *nums_out_size, end - start);\n          if (!*nums_out_size)\n            return -1;\n        }\n        for (; start <= end; start++)\n          (*nums_out)[i++] = start;\n      }","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"int expand_label_list(const char *label_list, const char *field_names[],\n                      const char *field_types[], int **labels,\n                      size_t *nlabels) {\n  size_t i, j, n, nfields, nescapes;\n  char *label, *label_buf;\n  int f, nerrors;\n\n  nfields = strlen(label_list);\n  label_buf = xmalloc(nfields + 1);\n  nescapes = 0;\n  for (i = j = 0; i < nfields + 1; i++) {\n    if (label_list[i] == '\\0' || label_list[i] == '\\n' ||\n        label_list[i] == '\\r') {\n      label_buf[j] = '\\0';\n      nescapes++;\n      goto next_label;\n    }\n    if (label_list[i] == '\\\\') {\n      if (label_list[i + 1] == '\\\\')\n        label_buf[j] = '\\\\';\n      else if (label_list[i + 1] == ',')\n        label_buf[j] = ',';\n      else {\n        label_buf[j] = label_list[i];\n        label_buf[j + 1] = label_list[i + 1];\n        j++;\n      }\n      i++;\n      goto next_char;\n    }\n    if (label_list[i] == ',') {\n      label_buf[j] = '\\0';\n      nescapes++;\n      goto next_label;\n    }\n    label_buf[j] = label_list[i];\n  next_char:\n    j++;\n  }\nnext_label:\n  n = j;\n  if (*nlabels == 0) {\n    *nlabels = nescapes;\n    *labels = xmalloc(sizeof(int) * nescapes);\n  } else if (*nlabels < nescapes) {\n                *nlabels = arr_resize(labels, sizeof(int), *nlabels,\n\t\t    nescapes -","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"int get_line_pos(const char *buf, int line, const char *field, int *start,\n                 int *end) {\n  const char *p, *q;\n\n  p = field_start(buf, line + 1, field);\n  if (!p) {\n    *start = *end = -1;\n    return -1;\n  }\n  *start = p - buf;\n\n  q = strstr(p, field);\n  if (!q) {\n    *end = strlen(buf) - 1;\n    while (buf[*end] == '\\n' || buf[*end] == '\\r')\n      *end -= 1;\n    if (*end < *start)\n      *end = *start;\n  } else if (q == p) {\n    *end = q - buf;\n  } else {\n    *end = q - buf - 1;\n  }\n\n  if (*start == *end) {\n    if (buf[*start] && buf[*start] != '\\n' && buf[*start] != '\\r' &&\n        !strncmp(buf + *start, field, strlen(field)))\n      return 0;\n    return 1;\n  }\n\n  return *end - *start + 1;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"long field_str_name_conflict(const char *str, const char *file, const char *field) {\n  char *line;\n  int len, i;\n  int found;\n\n  if (str == NULL)\n    return -2;\n  if (file == NULL || *file == '\\0')\n    return -1;\n  if (field == NULL || *field == '\\0')\n    return !strcmp(str, file) ? 0 : -1;\n\n  len = strlen(str);\n  line = xmalloc(len + 4);\n\n  found = 0;\n  for (i = 0; get_line_field(line, file, len + 3, i, field) >= 0; i++)\n    if (!strcmp(line, str)) {\n      found = 1;\n      break;\n    }\n\n  free(line);\n  return found ? i : -1;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  if ((p = strdup(s)) == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"size_t fields_in_line_name_conflict(const char *line, const char *delim) {\n  size_t count = 1;\n  char *p;\n  size_t delim_len;\n\n  if (line == NULL || delim == NULL)\n    return 0;\n\n  delim_len = strlen(delim);\n  p = (char *)line;\n\n  while ((p = strstr(p, delim)) != NULL) {\n    count++;\n    p += delim_len;\n  }\n\n  return count;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"int get_line_field(char *dest, char *src, int dest_size, int field_num,\n                   char *field_name) {\n  char *start, *end;\n  int len;\n\n  if (field_name == NULL || *field_name == '\\0') {\n    strncpy(dest, src, dest_size);\n    dest[dest_size] = '\\0';\n    return strlen(dest);\n  }\n\n  start = field_start(src, field_num + 1, field_name);\n  if (start == NULL) {\n    *dest = '\\0';\n    return -1;\n  }\n\n  end = strstr(start, field_name);\n  if (end == NULL) {\n    end = src + strlen(src) - 1;\n    while (*end == '\\n' || *end == '\\r')\n      end--;\n    end++;\n  }\n\n  len = end - start;\n  if (len > dest_size - 1)\n    len = dest_size - 1;\n\n  strncpy(dest, start, len);\n  dest[len] = '\\0';\n\n  return len;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"int copy_field(char *buf, char **field, size_t *field_len, size_t field_start,\n               const char *field_end) {\n  char *start, *end;\n  int len;\n\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_start + 1 : buf;\n  start = field_start ? field_","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"char *field_start_name_conflict(char *line, size_t n, const char *delim) {\n  size_t delim_len = strlen(delim);\n  char *p = line;\n  int i;\n\n  for (i = 1; i < n; i++) {\n    p = strstr(p, delim);\n    if (p == NULL)\n      return NULL;\n    p += delim_len;\n  }\n  return p;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"int mdyhms_datecmp_name_conflict(const char *s1, const char *s2) {\n  if (s1[6] == s2[6] && s1[7] == s2[7] && s1[8] == s2[8] && s1[9] == s2[9])\n    return strcmp(s1, s2);\n  else\n    return strncmp(s1 + 6, s2 + 6, 4);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"int dmyhms_datecmp_name_conflict(const char *d1, const char *d2) {\n  int rc;\n\n  rc = strncmp(d1 + 6, d2 + 6, 4);\n  if (rc)\n    return rc;\n\n  rc = strncmp(d1 + 3, d2 + 3, 2);\n  if (rc)\n    return rc;\n\n  return strcmp(d1, d2);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"int expand_nums(const char *nums, unsigned int **nums_arr,\n                size_t *nums_arr_size) {\n  int i;\n  unsigned int start, end;\n  char *token;\n\n  if (!nums || !*nums)\n    return 0;\n\n  for (i = 0; nums[i]; i++) {\n    if (!(__ctype_b_loc()[(unsigned char)nums[i]] & (0x0010000))) {\n      if (nums[i] != ',' && nums[i] != '-')\n        return -2;\n    }\n  }\n\n  i = 0;\n  if (!*nums_arr && !*nums_arr_size) {\n    *nums_arr = xmalloc(16 * sizeof(**nums_arr));\n    *nums_arr_size = 16;\n  }\n\n  if (strchr(nums, ',') || strchr(nums, '-')) {\n    token = strtok((char *)nums, \",\");\n    while (token) {\n      if (i >= *nums_arr_size) {\n        *nums_arr_size = arr_resize((void **)nums_arr, sizeof(**nums_arr),\n                                    *nums_arr_size, 16);\n        if (!*nums_arr_size)\n          return -1;\n      }\n      if (strchr(token, '-')) {\n        __isoc99_sscanf(token, \"%u-%u\", &start, &end);\n        if (i + (end - start) > *nums_arr_size) {\n          *nums_arr_size = arr_resize((void **)nums_arr, sizeof(**nums_arr),\n                                      *nums_arr_size, end - start);\n          if (!*nums_arr_size)\n            return -1;\n        }\n        for (; start <= end; start++)\n          (*nums_arr)[i++] = start;\n      } else {\n        __isoc99_","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"int expand_label_list(const char *label_list, const char *field_names[],\n                      const char *field_types[], int **labels,\n                      size_t *nlabels) {\n  int i, j, k, n, nfields, nerrors;\n  size_t len;\n  char *label, *label_buf;\n\n  len = strlen(label_list);\n  label_buf = xmalloc(len + 1);\n\n  nfields = 0;\n  nerrors = 0;\n  for (i = j = 0; i < (int)len + 1; i++) {\n    if (label_list[i] == '\\0' || label_list[i] == '\\n' ||\n        label_list[i] == '\\r') {\n      label_buf[j] = '\\0';\n      nfields++;\n    } else if (label_list[i] == '\\\\') {\n      if (label_list[i + 1] == '\\\\') {\n        label_buf[j] = '\\\\';\n      } else if (label_list[i + 1] == ',') {\n        label_buf[j] = ',';\n      } else {\n        label_buf[j] = label_list[i];\n        label_buf[j + 1] = label_list[i + 1];\n        j++;\n      }\n      i++;\n    } else if (label_list[i] == ',') {\n      label_buf[j] = '\\0';\n      nfields++;\n    } else {\n      label_buf[j] = label_list[i];\n    }\n    j++;\n  }\n\n  if (*nlabels == 0) {\n    *nlabels = nfields;\n    *labels = xmalloc(sizeof(int) * nfields);\n  } else if (*nlabels < nfields) {\n    *nlabels =\n        arr_resize((void **)labels, sizeof(int), *nlabels, nfields - *nlabels);\n    if (*nlabels == 0)\n      return -2;\n  }\n\n    for (i = j = 0; i < (int)nfields","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"int get_line_pos(const char *buf, int line, const char *field, int *start,\n                 int *end) {\n  const char *p, *q;\n\n  p = field_start(buf, line + 1, field);\n  if (!p) {\n    *start = *end = -1;\n    return -1;\n  }\n  *start = p - buf;\n\n  q = strstr(p, field);\n  if (!q) {\n    *end = strlen(buf) - 1;\n    while (buf[*end] == '\\n' || buf[*end] == '\\r')\n      *end -= 1;\n    if (*end < *start)\n      *end = *start;\n  } else if (q == p) {\n    *end = q - buf;\n  } else {\n    *end = q - buf - 1;\n  }\n\n  if (*start == *end) {\n    if (buf[*start] && buf[*start] != '\\n' && buf[*start] != '\\r' &&\n        !strncmp(buf + *start, field, strlen(field)))\n      return 0;\n    return 1;\n  }\n\n  return *end - *start + 1;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"long field_str_name_conflict(const char *str, const char *file, const char *field) {\n  char *line;\n  int len, i;\n  int found;\n\n  if (str == NULL)\n    return -2;\n  if (file == NULL || *file == '\\0')\n    return -1;\n  if (field == NULL || *field == '\\0')\n    return !strcmp(str, file) ? 0 : -1;\n\n  len = strlen(str);\n  line = xmalloc(len + 4);\n\n  found = 0;\n  for (i = 0; get_line_field(line, file, len + 3, i, field) >= 0; i++)\n    if (!strcmp(line, str)) {\n      found = 1;\n      break;\n    }\n\n  free(line);\n  return found ? i : -1;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  if ((p = strdup(s)) == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  if ((p = strdup(s)) == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  if ((p = strdup(s)) == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"int qsort_strcmp(const char **a, const char **b) {\n    return strcmp(*a, *b);\n}\n","function_prediction":"int qsort_strcmp_name_conflict(const void *a, const void *b) {\n  return strcmp(*(const char **)a, *(const char **)b);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":0,"function":"int qsort_intcmp(const int *a, const int *b) {\n    return *a - *b;\n}\n","function_prediction":"int qsort_intcmp_name_conflict(const void *a, const void *b) { return *(int *)a - *(int *)b; }","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":0,"function":"int qsort_uintcmp(const unsigned int *a, const unsigned int *b) {\n    return *a - *b;\n}\n","function_prediction":"int qsort_uintcmp_name_conflict(const void *a, const void *b) {\n  return *(const uint32_t *)a - *(const uint32_t *)b;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":1,"function":"static char *striplower(char *s) {\n    char *p = ((void *)0);\n    for (p = s; p && *p; p++) {\n        if (*p == '/')\n            *p = ',';\n        *p = tolower(*p);\n    }\n    return s;\n}\n","function_prediction":"char *striplower_name_conflict(char *s) {\n  char *p;\n\n  for (p = s; p && *p; p++) {\n    if (*p == '/')\n      *p = ',';\n    *p = tolower(*p);\n  }\n  return s;\n}","pass":1,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int get_filepath(char *filepath, size_t len, char *channel, char *file) {\n    if (channel) {\n        if (!snprintf(filepath, len, \"%s/%s\", path, channel))\n            return 0;\n        create_dirtree(filepath);\n        return snprintf(filepath, len, \"%s/%s/%s\", path, channel, file);\n    }\n    return snprintf(filepath, len, \"%s/%s\", path, file);\n}\n","function_prediction":"int get_filepath(char *filepath, size_t size, const char *dir,\n                 const char *filename) {\n  int ret;\n\n  if (dir == NULL) {\n    ret = snprintf(filepath, size, \"%s/%s\", path, filename);\n  } else {\n    ret = snprintf(filepath, size, \"%s/%s\", path, dir);\n    if (ret == 0) {\n      return 0;\n    }\n    create_dirtree(filepath);\n    ret = snprintf(filepath, size, \"%s/%s/%s\", path, dir, filename);\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int open_channel(char *name) {\n    static char infile[256];\n    create_filepath(infile, sizeof (infile), name, \"in\");\n    if (access(infile, 0) == -1)\n        mkfifo(infile, (256 | 128 | 64));\n    return open(infile, 0 | 2048, 0);\n}\n","function_prediction":"int open_channel_name_conflict(char *channel) {\n  create_filepath(infile_4, 256, channel, \"\");\n  if (access(infile_4, 0) == -1)\n    mkfifo(infile_4, 0600);\n  return open(infile_4, 02000, 0);\n}","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":1,"function":"static int tcpopen(unsigned short port) {\n    int fd;\n    struct sockaddr_in sin;\n    memset(&sin, 0, sizeof(struct sockaddr_in));\n    struct hostent *hp = gethostbyname(host);\n    if (!hp) {\n        perror(\"plom-ii: cannot retrieve host information\");\n        exit(1);\n    }\n    memcpy(&sin.sin_addr, hp->h_addr_list[0], hp->h_length);\n    sin.sin_family = 2;\n    sin.sin_port = htons(port);\n    if ((fd = socket(2, SOCK_STREAM, 0)) < 0) {\n        perror(\"plom-ii: cannot create socket\");\n        exit(1);\n    }\n    if (connect(fd, (const struct sockaddr *)&sin, sizeof (sin)) < 0) {\n        perror(\"plom-ii: cannot connect to host\");\n        exit(1);\n    }\n    return fd;\n}\n","function_prediction":"int tcpopen_name_conflict(int port) {\n  struct sockaddr_in sockaddr;\n  struct hostent *hostinfo;\n  int sock;\n\n  memset(&sockaddr, 0, sizeof(sockaddr));\n  hostinfo = gethostbyname(host);\n  if (hostinfo == NULL) {\n    perror(\"plom-ii: cannot retrieve host information\");\n    exit(1);\n  }\n  memcpy((char *)&sockaddr.sin_addr, hostinfo->h_addr, hostinfo->h_length);\n  sockaddr.sin_family = AF_INET;\n  sockaddr.sin_port = htons(port);\n  sock = socket(AF_INET, 1, 0);\n  if (sock < 0) {\n    perror(\"plom-ii: cannot create socket\");\n    exit(1);\n  }\n  if (connect(sock, (struct sockaddr *)&sockaddr, sizeof(sockaddr)) < 0) {\n    perror(\"plom-ii: cannot connect to host\");\n    exit(1);\n  }\n  return sock;\n}","pass":1,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":1,"function":"static size_t tokenize(char **result, size_t reslen, char *str, char delim) {\n    char *p = ((void *)0), *n = ((void *)0);\n    size_t i;\n    if (!str)\n        return 0;\n    for (n = str; *n == ' '; n++)\n        ;\n    p = n;\n    for (i = 0; *n != 0;) {\n        if (i == reslen)\n            return 0;\n        if (*n == delim) {\n            *n = 0;\n            result[i++] = p;\n            p = ++n;\n        } else\n            n++;\n    }\n    if (i < reslen && p < n && strlen(p))\n        result[i++] = p;\n    return i;\n}\n","function_prediction":"size_t tokenize_name_conflict(char **tokens, size_t max_tokens, char *str, char delim) {\n  if (str == NULL)\n    return 0;\n\n  while (*str == ' ')\n    str++;\n\n  char *start = str;\n  size_t ntokens = 0;\n\n  while (*str != '\\0') {\n    if (ntokens == max_tokens)\n      return 0;\n\n    if (*str == delim) {\n      *str = '\\0';\n      tokens[ntokens++] = start;\n      str++;\n      start = str;\n    } else {\n      str++;\n    }\n  }\n\n  if (ntokens < max_tokens && start < str && *start != '\\0')\n    tokens[ntokens++] = start;\n\n  return ntokens;\n}","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":1,"function":"static int read_line(int fd, size_t res_len, char *buf) {\n    size_t i = 0;\n    char c = 0;\n    do {\n        if (read(fd, &c, sizeof(char)) != sizeof(char))\n            return -1;\n        buf[i++] = c;\n    } while (c != '\\n' && i < res_len);\n    buf[i - 1] = 0;\n    return 0;\n}\n","function_prediction":"int read_line_name_conflict(int fd, size_t size, char *buf) {\n  size_t i = 0;\n  char c = 0;\n\n  do {\n    if (read(fd, &c, 1) != 1)\n      return -1;\n    buf[i] = c;\n    i++;\n  } while (c != '\\n' && i < size);\n\n  buf[i] = '\\0';\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"int Needs_Quote(char *str) {\n    while (*str)\n        {\n            if (!((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISalnum) && strchr(\"-_./\", *str) == ((void *)0))\n                return 1;\n            str++;\n        }\n    return 0;\n}\n","function_prediction":"int Needs_Quote_name_conflict(char *s) {\n  while (*s) {\n    if (!((__ctype_b_loc()->__b[((unsigned char)(*s))] & 0x08) != 0) &&\n        strchr(\"-_./\", *s) == NULL)\n      return 1;\n    s++;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":0,"function":"char *Get_Label(char *str) {\n    if (((*__ctype_b_loc())[(int)((*buff))] & (unsigned short)_ISspace))\n        return ((void *)0);\n    while (((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISalnum) || strchr(\".$_\", *str))\n        str++;\n    if (*str != ':' || str[1] != '\\x00')\n        return ((void *)0);\n    *str = '\\x00';\n    return buff;\n}\n","function_prediction":"char *Get_Label_name_conflict(char *p) {\n  if (__ctype_b_loc()->__b[buff.label] & 0x2000)\n    return NULL;\n\n  while (__ctype_b_loc()->__b[*p] & 0x0008 || strchr(\".$_\", *p))\n    p++;\n\n  if (*p == ':' && !p[1]) {\n    *p = '\\0';\n    return &buff.label;\n  }\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":1,"function":"int Detect_End_Of_Fct(char *buff) {\n    if (strncmp(buff, \"END\", 3) == 0)\n        return 1;\n    {\n        static int i = 0;\n        if (i == 0) {\n            fprintf(stderr, \"warning, Detect_End_Of_Fct() not customizedfor this architecture\\n)\");\n            i++;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int Detect_End_Of_Fct_name_conflict(char *line) {\n  static int i = 0;\n\n  if (!strncmp(line, \"END\", 3))\n    return 1;\n\n  if (!i) {\n    fputs(\"warning, Detect_End_Of_Fct_name_conflict() not customized\"\n          \"for this architecture\\n)\",\n          stderr);\n    i++;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":1,"function":"static int Common_Prefix_Length(char *str1, int l1, char *str2, int l2) {\n    if (l1 < l2)\n        l2 = l1;\n    l1 = 0;\n    while (l1 < l2 && *str1 == *str2)\n        {\n            str1++;\n            str2++;\n            l1++;\n        }\n    return l1;\n}\n","function_prediction":"int Common_Prefix_Length_name_conflict(char *s1, int len1, char *s2, int len2) {\n  int i, len;\n\n  if (len1 < len2)\n    len = len1;\n  else\n    len = len2;\n\n  for (i = 0; i < len; i++)\n    if (s1[i] != s2[i])\n      break;\n\n  return i;\n}","pass":1,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/cpt_string.c"}
{"compilable":1,"function":"int Display_Completion(char *str, int length, int no) {\n    printf(\"match %6d  :<%s> len=%d\\n\", no, str, length);\n    return 1;\n}\n","function_prediction":"int Display_Completion_name_conflict(char *text, int len, int match_no) {\n  printf(\"match %6d  :<%s> len=%d\\n\", match_no, text, len);\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/cpt_string.c"}
{"compilable":0,"function":"static int init_mparams(void) {\n    ;\n    if (mparams.magic == 0) {\n        size_t magic;\n        size_t psize;\n        size_t gsize;\n        psize = sysconf(_SC_PAGESIZE);\n        gsize = (((0) != 0) ? (0) : psize);\n        if ((sizeof(size_t) != sizeof(char *)) || ((~(size_t)0) < (((sizeof(mchunk)) + (((size_t)8U) - ((size_t)1))) & ~(((size_t)8U) - ((size_t)1)))) || (sizeof(int) < 4) || (((size_t)8U) < (size_t)8U) || ((((size_t)8U) & (((size_t)8U) - ((size_t)1))) != 0) || (((sizeof(mchunk)) & ((sizeof(mchunk)) - ((size_t)1))) != 0) || ((gsize & (gsize - ((size_t)1))) != 0) || ((psize & (psize - ((size_t)1))) != 0))\n            abort();\n        mparams.granularity = gsize;\n        mparams.page_size = psize;\n        mparams.mmap_threshold = ((size_t)256U * (size_t)1024U);\n        mparams.trim_threshold = ((size_t)2U * (size_t)1024U * (size_t)1024U);\n        mparams.default_mflags = (0U) | (((size_t)1));\n        (&_gm_)->mflags = mparams.default_mflags;\n        (void)(0);\n        {\n            magic = (size_t)(time(0) ^ (size_t)1431655765U);\n            magic |= (size_t)8U;\n            magic &= ~(size_t)7U;\n            (*(volatile size_t *)(&(mparams.magic))) = magic;\n        }\n    }\n    ;\n    return 1;\n}\n","function_prediction":"int init_mparams_name_conflict(void) {\n  if (mparams)\n    return 1;\n\n  size_t pagesize = sysconf(_SC_PAGESIZE);\n  if (pagesize != (pagesize & (pagesize - 1)))\n    abort();\n\n  mparams.pagesize = pagesize;\n  mparams.max_pages = 1024;\n  mparams.max_size = mparams.max_pages * mparams.pagesize;\n  mparams.min_size = mparams.pagesize;\n  mparams.min_pages = 1;\n  mparams.max_align = 1;\n  mparams.seed = time(NULL) ^ 0x55555555;\n  mparams.seed &= ~(sizeof(void *) - 1);\n  mparams.seed |= 8;\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"static int change_mparam(int param_number, int value) {\n    size_t val;\n    (void)(mparams.magic != 0 || init_mparams());\n    val = (value == -1) ? (~(size_t)0) : (size_t)value;\n    switch (param_number) {\n      case (-1):\n        mparams.trim_threshold = val;\n        return 1;\n      case (-2):\n        if (val >= mparams.page_size && ((val & (val - 1)) == 0)) {\n            mparams.granularity = val;\n            return 1;\n        } else\n            return 0;\n      case (-3):\n        mparams.mmap_threshold = val;\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int change_mparam_name_conflict(int param, int value) {\n  if (mparams == NULL)\n    init_mparams();\n\n  if (value == -1)\n    value = -1;\n\n  switch (param) {\n  case -1:\n    mparams->m_max_depth = value;\n    break;\n  case -2:\n    if (value < 0 || value % 2 != 0 || value < -1)\n      return 0;\n    mparams->m_max_width = value;\n    break;\n  case -3:\n    mparams->m_max_height = value;\n    break;\n  default:\n    return 0;\n  }\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"int malloc_trim(size_t pad) {\n    int result = 0;\n    (void)(mparams.magic != 0 || init_mparams());\n    if (!(0)) {\n        result = sys_trim((&_gm_), pad);\n        ;\n    }\n    return result;\n}\n","function_prediction":"int malloc_trim_name_conflict(size_t pad) {\n  if (!mparams.initialized)\n    init_mparams();\n\n  return sys_trim(&_gm_, pad);\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_footprint(void) {\n    return (&_gm_)->footprint;\n}\n","function_prediction":"size_t malloc_footprint_name_conflict(void) { return 1024; }","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_max_footprint(void) {\n    return (&_gm_)->max_footprint;\n}\n","function_prediction":"size_t malloc_max_footprint_name_conflict(void) { return 1024 * 1024 * 1024; }","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"size_t malloc_footprint_limit(void) {\n    size_t maf = (&_gm_)->footprint_limit;\n    return maf == 0 ? (~(size_t)0) : maf;\n}\n","function_prediction":"size_t malloc_footprint_limit_name_conflict(void) {\n  return (size_t)(&_malloc_footprint_limit_name_conflict)->limit\n             ? (size_t)(&_malloc_footprint_limit_name_conflict)->limit\n             : (size_t)-1;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"size_t malloc_set_footprint_limit(size_t bytes) {\n    size_t result;\n    if (bytes == 0)\n        result = (((1) + (mparams.granularity - ((size_t)1))) & ~(mparams.granularity - ((size_t)1)));\n    if (bytes == (~(size_t)0))\n        result = 0;\n    else\n        result = (((bytes) + (mparams.granularity - ((size_t)1))) & ~(mparams.granularity - ((size_t)1)));\n    return (&_gm_)->footprint_limit = result;\n}\n","function_prediction":"size_t malloc_set_footprint_limit_name_conflict(size_t limit) {\n  if (limit == (size_t)-1)\n    limit = 0;\n  else\n    limit = (limit + (((size_t)1 << (2)) - 1)) & ~(((size_t)1 << (2)) - 1);\n\n  _footprint_limit = limit;\n  return limit;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"struct mallinfo mallinfo(void) {\n    return internal_mallinfo((&_gm_));\n}\n","function_prediction":"struct mallinfo_name_conflict mallinfo_name_conflict(void *ptr) {\n  struct mallinfo_name_conflict mi;\n\n  internal_mallinfo_name_conflict(ptr, &_gm_, &mi);\n  return mi;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"int mallopt(int param_number, int value) {\n    return change_mparam(param_number, value);\n}\n","function_prediction":"int mallopt_name_conflict(int param, int value) { return change_mparam(param, value); }","pass":1,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"char *format_date_r(char *buf) {\n    struct tm *l;\n    time_t t = time(((void *)0));\n    l = localtime(&t);\n    sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", l->tm_mon + 1, l->tm_mday, l->tm_year + 1900, l->tm_hour, l->tm_min, l->tm_sec);\n    return buf;\n}\n","function_prediction":"char *format_date_r_name_conflict(char *buf) {\n  time_t t = time(NULL);\n  struct tm *tm = localtime(&t);\n  sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", tm->tm_mon + 1, tm->tm_mday,\n          tm->tm_year + 1900, tm->tm_hour, tm->tm_min, tm->tm_sec);\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/aleksey200505_dspam/src/error.c"}
{"compilable":0,"function":"char *format_date_r(char *buf) {\n    struct tm *l;\n    time_t t = time(((void *)0));\n    l = localtime(&t);\n    sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", l->tm_mon + 1, l->tm_mday, l->tm_year + 1900, l->tm_hour, l->tm_min, l->tm_sec);\n    return buf;\n}\n","function_prediction":"char *format_date_r_name_conflict(char *buf) {\n  time_t t = time(NULL);\n  struct tm *tm = localtime(&t);\n  sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", tm->tm_mon + 1, tm->tm_mday,\n          tm->tm_year + 1900, tm->tm_hour, tm->tm_min, tm->tm_sec);\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/error.c"}
{"compilable":0,"function":"char *strtok_r(char *s1, const char *s2, char **lasts) {\n    char *ret;\n    if (s1 == ((void *)0))\n        s1 = *lasts;\n    while (*s1 && strchr(s2, *s1))\n        ++s1;\n    if (*s1 == '\\x00')\n        return ((void *)0);\n    ret = s1;\n    while (*s1 && !strchr(s2, *s1))\n        ++s1;\n    if (*s1)\n        *s1++ = '\\x00';\n    *lasts = s1;\n    return ret;\n}\n","function_prediction":"char *strtok_r_name_conflict(char *s, const char *delim, char **lasts) {\n  char *spanp;\n  int c, sc;\n  char *tok;\n\n  if (s == NULL && (s = *lasts) == NULL)\n    return NULL;\n\n  for (tok = s;;) {\n    c = *s++;\n    spanp = (char *)delim;\n    if (c == '\\0')\n      s = NULL;\n    while ((sc = *spanp++) != 0)\n      if (c == sc)\n        goto found;\n    if (s == NULL) {\n\n      s = tok;\n      goto done;\n    }\n  }\n\nfound:\n  if (c == '\\0')\n    s = NULL;\n  else\n    s++;\n\n  *lasts = s;\n  if (tok == s)\n    return NULL;\n  return (char *)tok;\n\ndone:\n  *lasts = NULL;\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *strsep(char **stringp, const char *delim) {\n    char *ret = *stringp;\n    if (ret == ((void *)0))\n        return (((void *)0));\n    if ((*stringp = strpbrk(*stringp, delim)) != ((void *)0))\n        *((*stringp)++) = '\\x00';\n    return (ret);\n}\n","function_prediction":"char *strsep_name_conflict(char **stringp, const char *delim) {\n  char *s;\n\n  if ((s = *stringp) == NULL)\n    return NULL;\n  *stringp = strpbrk(s, delim);\n  if (*stringp)\n    *(*stringp)++ = '\\0';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *ltrim(char *str) {\n    char *p;\n    if (!str || !str[0])\n        return str;\n    for (p = str; ((*__ctype_b_loc())[(int)(((int)*p))] & (unsigned short)_ISspace); ++p) {\n    }\n    if (p > str)\n        strcpy(str, p);\n    return str;\n}\n","function_prediction":"char *ltrim_name_conflict(char *str) {\n  char *p;\n\n  if (str == NULL)\n    return NULL;\n\n  p = str;\n  while (*p != '\\0') {\n    if (!((*(const unsigned short *)(__ctype_b_loc()) +\n           1)[(unsigned char)(*p)] &\n          0x2000))\n      break;\n    p++;\n  }\n\n  if (p > str)\n    strcpy(str, p);\n\n  return str;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *rtrim(char *str) {\n    size_t offset;\n    char *p;\n    if (!str || !str[0])\n        return str;\n    offset = strlen(str);\n    p = str + offset - 1;\n    for (; p >= str && ((*__ctype_b_loc())[(int)(((int)*p))] & (unsigned short)_ISspace); --p) {\n        *p = 0;\n    }\n    return str;\n}\n","function_prediction":"char *rtrim_name_conflict(char *str) {\n  char *end;\n\n  if (str == NULL || *str == '\\0')\n    return str;\n\n  end = str + strlen(str) - 1;\n  while (end >= str && ((*__ctype_b_loc())[(unsigned char)(*end)] & (0x2000)))\n    *end-- = '\\0';\n\n  return str;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long strlcat(dst, src, siz)\n    char *dst;\n    const char *src;\n    size_t siz;\n {\n    register char *d = dst;\n    register const char *s = src;\n    register size_t n = siz;\n    size_t dlen;\n    while (n-- != 0 && *d != '\\x00')\n        d++;\n    dlen = d - dst;\n    n = siz - dlen;\n    if (n == 0)\n        return (dlen + strlen(s));\n    while (*s != '\\x00')\n        {\n            if (n != 1) {\n                *d++ = *s;\n                n--;\n            }\n            s++;\n        }\n    *d = '\\x00';\n    return (dlen + (s - src));\n}\n","function_prediction":"size_t strlcat_name_conflict(char *dst, const char *src, size_t size) {\n  char *d = dst;\n  const char *s = src;\n  size_t n = size;\n  size_t dlen;\n\n  while (n-- != 0 && *d != '\\0')\n    d++;\n  dlen = d - dst;\n  n = size - dlen;\n\n  if (n == 0)\n    return (dlen + strlen(s));\n  while (*s != '\\0') {\n    if (n != 1) {\n      *d++ = *s;\n      n--;\n    }\n    s++;\n  }\n  *d = '\\0';\n\n  return (dlen + (s - src));\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long strlcpy(dst, src, siz)\n    char *dst;\n    const char *src;\n    size_t siz;\n {\n    register char *d = dst;\n    register const char *s = src;\n    register size_t n = siz;\n    if (n != 0 && --n != 0) {\n        do {\n            if ((*d++ = *s++) == 0)\n                break;\n        } while (--n != 0);\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"size_t strlcpy_name_conflict(char *dst, const char *src, size_t siz) {\n  char *d = dst;\n  const char *s = src;\n  size_t n = siz;\n\n  if (n != 0) {\n    while (--n != 0) {\n      if ((*d++ = *s++) == '\\0')\n        break;\n    }\n  }\n\n  if (n == 0) {\n    if (siz != 0)\n      *d = '\\0';\n    while (*s++)\n      ;\n  }\n\n  return (s - src - 1);\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"const char *_ds_userdir_path(char *path, const char *home, const char *filename, const char *extension) {\n    char username[4096];\n    char userpath[4096];\n    if (filename == ((void *)0) || filename[0] == 0) {\n        path[0] = 0;\n        return path;\n    }\n    strlcpy(username, filename, 4096);\n    strcpy(userpath, username);\n    if (extension != ((void *)0) && (!strcmp(extension, \"nodspam\") || !strcmp(extension, \"dspam\"))) {\n        snprintf(path, 4096, \"%s/opt-%s/%s.%s\", home, (!strcmp(extension, \"nodspam\")) ? \"out\" : \"in\", userpath, extension);\n        return path;\n    }\n    if (extension == ((void *)0)) {\n        snprintf(path, 4096, \"%s/data/%s\", home, userpath);\n    } else {\n        snprintf(path, 4096, \"%s/data/%s/%s.%s\", home, userpath, username, extension);\n    }\n    return path;\n}\n","function_prediction":"char *_ds_userdir_path(char *buf, const char *prefix, const char *user,\n                       const char *type) {\n  char user_copy[4096];\n  char user_copy2[4096];\n\n  if (user == NULL || *user == '\\0') {\n    buf[0] = '\\0';\n    return buf;\n  }\n\n  strlcpy(user_copy, user, sizeof(user_copy));\n  strcpy(user_copy2, user_copy);\n\n  if (type != NULL &&\n      (strcmp(type, \"nodspam\") == 0 || strcmp(type, \"dspam\") == 0)) {\n    snprintf(buf, sizeof(user_copy), \"%s/opt-%s/%s.%s\", prefix,\n             (strcmp(type, \"nodspam\") == 0) ? \"nodspam\" : \"dspam\", user_copy2,\n             type);\n  } else if (type != NULL) {\n    snprintf(buf, sizeof(user_copy), \"%s/data/%s/%s.%s\", prefix, user_copy2,\n             user_copy, type);\n  } else {\n    snprintf(buf, sizeof(user_copy), \"%s/data/%s\", prefix, user_copy2);\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_prepare_path_for(const char *filename) {\n    char path[4096];\n    char *dir, *file;\n    char *file_buffer_start;\n    struct stat s;\n    if (!filename)\n        return 22;\n    file = strdup(filename);\n    if (!file) {\n        LOG(3, \"Memory allocation failed\");\n        return -5;\n    }\n    file_buffer_start = file;\n    path[0] = 0;\n    dir = strsep(&file, \"/\");\n    while (dir != ((void *)0))\n        {\n            strlcat(path, dir, sizeof (path));\n            dir = strsep(&file, \"/\");\n            {\n                if (dir != ((void *)0) && stat(path, &s) && path[0] != 0) {\n                    int x;\n                    ;\n                    ;\n                    x = mkdir(path, 504);\n                    if (x) {\n                        LOG(3, \"Unable to create directory: %s: %s\", path, strerror((*__errno_location())));\n                        free(file_buffer_start);\n                        return -3;\n                    }\n                }\n            }\n            strlcat(path, \"/\", sizeof (path));\n        }\n    free(file_buffer_start);\n    return 0;\n}\n","function_prediction":"int _ds_prepare_path_for_name_conflict(const char *path) {\n  if (path == NULL)\n    return 22;\n\n  char *path_copy = strdup(path);\n  if (path_copy == NULL) {\n    LOG(3, \"Memory allocation failed\");\n    return -5;\n  }\n\n  char dir[4096];\n  dir[0] = '\\0';\n\n  char *path_copy_ptr = path_copy;\n  char *dir_part = strsep(&path_copy_ptr, \"/\");\n  while (dir_part != NULL) {\n    strlcat(dir, dir_part, sizeof(dir));\n    dir_part = strsep(&path_copy_ptr, \"/\");\n\n    if (dir_part != NULL) {\n      struct stat st;\n      if (stat(dir, &st) != 0) {\n        if (dir[0] != '\\0') {\n          int ret = mkdir(dir, 0770);\n          if (ret != 0) {\n            LOG(3, \"Unable to create directory: %s: %s\", dir,\n                strerror(*__errno_location()));\n            free(path_copy);\n            return -3;\n          }\n        }\n      }\n    }\n\n    strlcat(dir, \"/\", sizeof(dir));\n  }\n\n  free(path_copy);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int lc(char *buff, const char *string) {\n    char *buffer;\n    int i, j = 0;\n    int len = strlen(string);\n    buffer = malloc(len + 1);\n    if (len == 0) {\n        buff[0] = 0;\n        free(buffer);\n        return 0;\n    }\n    for (i = 0; i < len; i++) {\n        if (((*__ctype_b_loc())[(int)(((int)string[i]))] & (unsigned short)_ISupper)) {\n            buffer[i] = tolower(string[i]);\n            j++;\n        } else {\n            buffer[i] = string[i];\n        }\n    }\n    buffer[len] = 0;\n    strcpy(buff, buffer);\n    free(buffer);\n    return j;\n}\n","function_prediction":"int lc_name_conflict(char *dest, char *src) {\n  int i, len, count = 0;\n  char *temp;\n\n  len = strlen(src);\n  temp = (char *)malloc(sizeof(char) * (len + 1));\n\n  if (len == 0) {\n    *dest = '\\0';\n    free(temp);\n    return 0;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (isupper(__ctype_b_loc().*((int *)(void *)0 + (unsigned int)(src[i])))) {\n      temp[i] = tolower(src[i]);\n      count++;\n    } else {\n      temp[i] = src[i];\n    }\n  }\n\n  temp[len] = '\\0';\n  strcpy(dest, temp);\n  free(temp);\n\n  return count;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long long _ds_getcrc64(const char *s) {\n    static unsigned long long CRCTable[256];\n    unsigned long long crc = 0;\n    static int init = 0;\n    if (!init) {\n        int i;\n        init = 1;\n        for (i = 0; i <= 255; i++) {\n            int j;\n            unsigned long long part = i;\n            for (j = 0; j < 8; j++) {\n                if (part & 1)\n                    part = (part >> 1) ^ 15564440312192434176ULL;\n                else\n                    part >>= 1;\n            }\n            CRCTable[i] = part;\n        }\n    }\n    for (; *s; s++) {\n        unsigned long long temp1 = crc >> 8;\n        unsigned long long temp2 = CRCTable[(crc ^ (unsigned long long)*s) & 255];\n        crc = temp1 ^ temp2;\n    }\n    return crc;\n}\n","function_prediction":"uint64_t _ds_getcrc64_name_conflict(const char *s) {\n  static uint64_t CRCTable[256];\n  static int init = 0;\n  uint64_t crc = 0;\n  int i, j;\n\n  if (!init) {\n    init = 1;\n    for (i = 0; i < 256; i++) {\n      crc = i;\n      for (j = 0; j < 8; j++) {\n        if (crc & 1) {\n          crc = (crc >> 1) ^ 0xD800000000000000;\n        } else {\n          crc >>= 1;\n        }\n      }\n      CRCTable[i] = crc;\n    }\n  }\n\n  while (*s) {\n    crc = (crc >> 8) ^ CRCTable[(crc & 0xff) ^ *s++];\n  }\n\n  return crc;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_weight(const char *token) {\n    int complexity = _ds_compute_complexity(token);\n    int sparse = _ds_compute_sparse(token);\n    if (complexity == 5) {\n        if (sparse == 1)\n            return 64;\n        if (sparse == 2)\n            return 16;\n        if (sparse == 3)\n            return 4;\n        if (sparse == 0)\n            return 256;\n    }\n    if (complexity == 4) {\n        if (sparse == 1)\n            return 16;\n        if (sparse == 2)\n            return 4;\n        if (sparse == 0)\n            return 64;\n    }\n    if (complexity == 3) {\n        if (sparse == 1)\n            return 4;\n        if (sparse == 0)\n            return 16;\n    }\n    if (complexity == 2) {\n        if (sparse == 0)\n            return 4;\n    }\n    if (complexity == 1) {\n        if (sparse == 0)\n            return 1;\n    }\n    LOG(4, \"_ds_compute_weight: no rule to compute markovian weight for '%s'; complexity: %d; sparse: %d\", token, complexity, sparse);\n    return 1;\n}\n","function_prediction":"int _ds_compute_weight_name_conflict(const char *s) {\n  int complexity = _ds_compute_complexity(s);\n  int sparse = _ds_compute_sparse(s);\n\n  if (complexity == 5) {\n    if (sparse == 1)\n      return 64;\n    if (sparse == 2)\n      return 16;\n    if (sparse == 3)\n      return 4;\n    if (sparse == 0)\n      return 256;\n  }\n\n  if (complexity == 4) {\n    if (sparse == 1)\n      return 16;\n    if (sparse == 2)\n      return 4;\n    if (sparse == 0)\n      return 64;\n  }\n\n  if (complexity == 3) {\n    if (sparse == 1)\n      return 4;\n    if (sparse == 0)\n      return 16;\n  }\n\n  if (complexity == 2 && sparse == 0)\n    return 4;\n  if (complexity == 1 && sparse == 0)\n    return 1;\n\n  LOG(4,\n      \"_ds_compute_weight_name_conflict: no rule to compute markovian weight for '%s'; \"\n      \"complexity: %d; sparse: %d\",\n      s, complexity, sparse);\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_sparse(const char *token) {\n    int sparse = 0, i;\n    if (!strncmp(token, \"#+\", 2))\n        sparse++;\n    if (strlen(token) >= 2 && !strncmp((token + strlen(token)) - 2, \"+#\", 2))\n        sparse++;\n    for (i = 0; token[i]; i++) {\n        if (!strncmp(token + i, \"+#+\", 3)) {\n            sparse++;\n            i++;\n        }\n    }\n    return sparse;\n}\n","function_prediction":"int _ds_compute_sparse_name_conflict(char *s) {\n  int i, n = 0;\n\n  if (!strncmp(s, \"#+\", 2))\n    n++;\n\n  if (strlen(s) > 1 && !strncmp(s + strlen(s) - 2, \"+#\", 2))\n    n++;\n\n  for (i = 0; s[i]; i++)\n    if (!strncmp(s + i, \"+#+\", 3)) {\n      n++;\n      i++;\n    }\n\n  return n;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_complexity(const char *token) {\n    int i, complexity = 1;\n    if (token == ((void *)0))\n        return 1;\n    for (i = 0; token[i]; i++) {\n        if (token[i] == '+') {\n            complexity++;\n            i++;\n        }\n    }\n    return complexity;\n}\n","function_prediction":"int _ds_compute_complexity_name_conflict(char *expr) {\n  int i, complexity = 1;\n\n  if (expr == NULL)\n    return 1;\n\n  for (i = 0; expr[i] != '\\0'; i++) {\n    if (expr[i] == '+') {\n      complexity++;\n      i++;\n    }\n  }\n\n  return complexity;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_extract_address(char *buf, const char *address, size_t len) {\n    char *str = strdup(address);\n    char *x, *y;\n    if (str == ((void *)0))\n        return -2;\n    x = strchr(str, '<');\n    if (!x) {\n        free(str);\n        return -5;\n    }\n    y = strchr(x, '>');\n    if (y)\n        y[0] = 0;\n    strlcpy(buf, x + 1, len);\n    free(str);\n    return 0;\n}\n","function_prediction":"int _ds_extract_address_name_conflict(char *address, const char *line, size_t size) {\n  char *p, *q;\n  char *buf;\n\n  buf = strdup(line);\n  if (!buf)\n    return -2;\n\n  p = strchr(buf, '<');\n  if (!p) {\n    free(buf);\n    return -5;\n  }\n\n  q = strchr(p, '>');\n  if (q)\n    *q = '\\0';\n\n  strlcpy(address, p + 1, size);\n  free(buf);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_get_fcntl_lock(int fd) {\n    struct flock f;\n    int r;\n    f.l_type = 1;\n    f.l_whence = 0;\n    f.l_start = 0;\n    f.l_len = 0;\n    signal(14, timeout);\n    alarm(300);\n    r = fcntl(fd, 7, &f);\n    alarm(0);\n    signal(14, ((__sighandler_t)0));\n    return r;\n}\n","function_prediction":"int _ds_get_fcntl_lock_name_conflict(int fd) {\n  struct flock lock;\n  int ret;\n\n  lock.l_type = 1;\n  lock.l_whence = 0;\n  lock.l_start = 0;\n  lock.l_len = 0;\n\n  signal(14, timeout);\n  alarm(300);\n  ret = fcntl(fd, 7, &lock);\n  alarm(0);\n  signal(14, SIG_DFL);\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_free_fcntl_lock(int fd) {\n    struct flock f;\n    f.l_type = 2;\n    f.l_whence = 0;\n    f.l_start = 0;\n    f.l_len = 0;\n    return fcntl(fd, 7, &f);\n}\n","function_prediction":"int _ds_free_fcntl_lock_name_conflict(int fd) {\n  struct flock fl;\n  fl.l_type = 2;\n  fl.l_whence = 0;\n  fl.l_start = 0;\n  fl.l_len = 0;\n  return fcntl(fd, 7, &fl);\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_pow(int base, unsigned int exp) {\n    int result = 1;\n    while (exp > 0)\n        {\n            if (exp & 1)\n                result *= base;\n            base *= base;\n            exp /= 2;\n        }\n    return result;\n}\n","function_prediction":"int _ds_pow2(int n) { return _ds_pow(2, n); }","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_pow2(int exp) {\n    return _ds_pow(2, exp);\n}\n","function_prediction":"double _ds_pow2_name_conflict(double x) { return _ds_pow(2, x); }","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *strcasestr(s, find)\n    const char *s;\n    const char *find;\n {\n    char c, sc;\n    size_t len;\n    if ((c = *find++) != 0) {\n        c = tolower((unsigned char)c);\n        len = strlen(find);\n        do {\n            do {\n                if ((sc = *s++) == 0)\n                    return (((void *)0));\n            } while ((char)tolower((unsigned char)sc) != c);\n        } while (strncasecmp(s, find, len) != 0);\n        s--;\n    }\n    return ((char *)s);\n}\n","function_prediction":"char *strcasestr_name_conflict(const char *haystack, const char *needle) {\n  char *h = (char *)haystack;\n  char *n = (char *)needle;\n  char c, sc;\n  size_t len;\n\n  if (!*n)\n    return (char *)haystack;\n  c = *n++;\n  sc = tolower(c);\n  len = strlen(n);\n  while ((c = *h++)) {\n    if (tolower(c) != sc)\n      continue;\n    if (!strncasecmp(h, n, len))\n      return h - 1;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *inet_ntoa_r(struct in_addr in, char *buf, int len) {\n    char b[18];\n    register char *p;\n    p = (char *)&in;\n    snprintf(b, sizeof (b), \"%d.%d.%d.%d\", (((int)p[0]) & 255), (((int)p[1]) & 255), (((int)p[2]) & 255), (((int)p[3]) & 255));\n    if (len <= strlen(b)) {\n        (*__errno_location()) = 34;\n        return (((void *)0));\n    }\n    return strcpy(buf, b);\n}\n","function_prediction":"char *inet_ntoa_r_name_conflict(struct in_addr in, char *buf, int buflen) {\n  char tmp[18];\n  snprintf(tmp, sizeof(tmp), \"%d.%d.%d.%d\", (int)((in.s_addr) & 0xff),\n           (int)((in.s_addr & 0xff00) >> 8),\n           (int)((in.s_addr & 0xff0000) >> 16),\n           (int)((in.s_addr & 0xff000000) >> 24));\n  if (strlen(tmp) >= buflen) {\n    *__errno_location() = 34;\n    return NULL;\n  }\n  return strcpy(buf, tmp);\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":1,"function":"char *strcpy(char *s, char *t) {\n    char *os;\n    os = s;\n    while ((*s++ = *t++) != 0)\n        ;\n    return os;\n}\n","function_prediction":"char *strcpy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  do {\n    *d = *s;\n  } while (*d++ = *s++);\n\n  return dest;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int strcmp(const char *p, const char *q) {\n    while (*p && *p == *q)\n        p++ , q++;\n    return (uchar)*p - (uchar)*q;\n}\n","function_prediction":"int strcmp_name_conflict(const char *s1, const char *s2) {\n  while (*s1 && *s1 == *s2) {\n    s1++;\n    s2++;\n  }\n\n  return *s1 - *s2;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"uint strlen(char *s) {\n    int n;\n    for (n = 0; s[n]; n++)\n        ;\n    return n;\n}\n","function_prediction":"size_t strlen_name_conflict(const char *s) {\n  int i;\n  for (i = 0; s[i] != '\\0'; i++)\n    ;\n  return i;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"char *strchr(const char *s, char c) {\n    for (; *s; s++)\n        if (*s == c)\n            return (char *)s;\n    return 0;\n}\n","function_prediction":"char *strchr_name_conflict(const char *s, int c) {\n  while (*s) {\n    if (*s == c)\n      return (char *)s;\n    s++;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"char *gets(char *buf, int max) {\n    int i, cc;\n    char c;\n    for (i = 0; i + 1 < max;) {\n        cc = read(0, &c, 1);\n        if (cc < 1)\n            break;\n        buf[i++] = c;\n        if (c == '\\n' || c == '\\r')\n            break;\n    }\n    buf[i] = '\\x00';\n    return buf;\n}\n","function_prediction":"char *gets_name_conflict(char *s, int size) {\n  int i = 0;\n  char c;\n\n  while (i + 1 < size) {\n    if (read(0, &c, 1) <= 0)\n      break;\n    s[i++] = c;\n    if (c == '\\n' || c == '\\r')\n      break;\n  }\n  s[i] = '\\0';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int stat(char *n, struct stat *st) {\n    int fd;\n    int r;\n    fd = open(n, 0);\n    if (fd < 0)\n        return -1;\n    r = fstat(fd, st);\n    close(fd);\n    return r;\n}\n","function_prediction":"int stat_name_conflict(const char *path, struct stat_name_conflict *st) {\n  int fd;\n  int ret;\n\n  fd = open(path, 0);\n  if (fd < 0)\n    return -1;\n\n  ret = fstat_name_conflict(fd, st);\n  close(fd);\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int atoi(const char *s) {\n    int n;\n    n = 0;\n    while ('0' <= *s && *s <= '9')\n        n = n * 10 + *s++ - '0';\n    return n;\n}\n","function_prediction":"int atoi_name_conflict(char *s) {\n  int n = 0;\n  while (*s >= '0' && *s <= '9')\n    n = n * 10 + *s++ - '0';\n  return n;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"char *strcpy(char *s, char *t) {\n    char *os;\n    os = s;\n    while ((*s++ = *t++) != 0)\n        ;\n    return os;\n}\n","function_prediction":"char *strcpy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  do {\n    *d = *s;\n  } while (*d++ = *s++);\n\n  return dest;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int strcmp(const char *p, const char *q) {\n    while (*p && *p == *q)\n        p++ , q++;\n    return (uchar)*p - (uchar)*q;\n}\n","function_prediction":"int strcmp_name_conflict(const char *s1, const char *s2) {\n  while (*s1 && *s1 == *s2) {\n    s1++;\n    s2++;\n  }\n\n  return *s1 - *s2;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"uint strlen(char *s) {\n    int n;\n    for (n = 0; s[n]; n++)\n        ;\n    return n;\n}\n","function_prediction":"size_t strlen_name_conflict(const char *s) {\n  int i;\n  for (i = 0; s[i] != '\\0'; i++)\n    ;\n  return i;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"char *strchr(const char *s, char c) {\n    for (; *s; s++)\n        if (*s == c)\n            return (char *)s;\n    return 0;\n}\n","function_prediction":"char *strchr_name_conflict(const char *s, int c) {\n  while (*s) {\n    if (*s == c)\n      return (char *)s;\n    s++;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"char *gets(char *buf, int max) {\n    int i, cc;\n    char c;\n    for (i = 0; i + 1 < max;) {\n        cc = read(0, &c, 1);\n        if (cc < 1)\n            break;\n        buf[i++] = c;\n        if (c == '\\n' || c == '\\r')\n            break;\n    }\n    buf[i] = '\\x00';\n    return buf;\n}\n","function_prediction":"char *gets_name_conflict(char *s, int size) {\n  int i = 0;\n  char c;\n\n  while (i + 1 < size) {\n    if (read(0, &c, 1) <= 0)\n      break;\n    s[i++] = c;\n    if (c == '\\n' || c == '\\r')\n      break;\n  }\n  s[i] = '\\0';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int stat(char *n, struct stat *st) {\n    int fd;\n    int r;\n    fd = open(n, 0);\n    if (fd < 0)\n        return -1;\n    r = fstat(fd, st);\n    close(fd);\n    return r;\n}\n","function_prediction":"int stat_name_conflict(const char *path, struct stat_name_conflict *st) {\n  int fd;\n  int ret;\n\n  fd = open(path, 0);\n  if (fd < 0)\n    return -1;\n\n  ret = fstat_name_conflict(fd, st);\n  close(fd);\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int atoi(const char *s) {\n    int n;\n    n = 0;\n    while ('0' <= *s && *s <= '9')\n        n = n * 10 + *s++ - '0';\n    return n;\n}\n","function_prediction":"int atoi_name_conflict(char *s) {\n  int n = 0;\n  while (*s >= '0' && *s <= '9')\n    n = n * 10 + *s++ - '0';\n  return n;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"bool check(const char *word) {\n    return 0;\n}\n","function_prediction":"int check_name_conflict(int a, int b) {\n  int c;\n  if (a > b)\n    c = a;\n  else\n    c = b;\n  return c;\n}","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"bool load(const char *dictionary) {\n    return 0;\n}\n","function_prediction":"int load_name_conflict(const char *filename) { return 0; }","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":0,"function":"unsigned int size(void) {\n    return 0;\n}\n","function_prediction":"int size_name_conflict(struct node *head) {\n  int count = 0;\n  struct node *temp = head;\n  while (temp != NULL) {\n    count++;\n    temp = temp->next;\n  }\n  return count;\n}","pass":0,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"bool unload(void) {\n    return 0;\n}\n","function_prediction":"int unload_name_conflict(void) { return 0; }","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"int open_serial(int k) {\n    if (k == 0) {\n        fd = open(\"/dev/ttyUSB0\", 2 | 256);\n        perror(\"open /dev/ttyUSB0\");\n    } else {\n        fd = open(\"/dev/ttyUSB1\", 2 | 256);\n        perror(\"open /dev/ttyUSB1\");\n    }\n    if (fd == -1)\n        return -1;\n    else\n        return 0;\n}\n","function_prediction":"int open_serial_name_conflict(int port) {\n  if (port == 0) {\n    fd = open(\"/dev/ttyUSB0\", 0x00000200 | 0x00000002);\n    perror(\"open /dev/ttyUSB0\");\n  } else {\n    fd = open(\"/dev/ttyUSB1\", 0x00000200 | 0x00000002);\n    perror(\"open /dev/ttyUSB1\");\n  }\n\n  if (fd == -1)\n    return -1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/recessburton_UartHumidSensor/src/c_conf/configure.c"}
{"compilable":0,"function":"unsigned int calc_crc16(unsigned char *snd, unsigned char num) {\n    unsigned char i, j;\n    unsigned int c, crc = 65535;\n    for (i = 0; i < num; i++) {\n        c = snd[i] & 255;\n        crc ^= c;\n        for (j = 0; j < 8; j++) {\n            if (crc & 1) {\n                crc >>= 1;\n                crc ^= 40961;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n    return (crc);\n}\n","function_prediction":"uint16_t calc_crc16_name_conflict(uint8_t *data, uint8_t len) {\n  uint8_t i, j;\n  uint16_t crc = 0xFFFF;\n\n  for (i = 0; i < len; i++) {\n    crc ^= data[i];\n    for (j = 0; j < 8; j++) {\n      if (crc & 0x01) {\n        crc = (crc >> 1) ^ 0xA001;\n      } else {\n        crc = crc >> 1;\n      }\n    }\n  }\n  return crc;\n}","pass":0,"source_file":"C_COMPILE/recessburton_UartHumidSensor/src/c_conf/configure.c"}
{"compilable":1,"function":"int read(char *name, char *permission) {\n    int buf;\n    FILE *file;\n    file = fopen(name, permission);\n    fread(&buf, sizeof (buf), 1, file);\n    fclose(file);\n    return buf;\n}\n","function_prediction":"int read_name_conflict(char *filename) {\n  FILE *fp = fopen(filename, \"r\");\n  int i;\n  fread_name_conflict(&i, sizeof(int), 1, fp);\n  fclose(fp);\n  return i;\n}","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":1,"function":"int average(int *data, int size) {\n    if (data == ((void *)0) || size == 0) {\n        return 0;\n    }\n    printf(\"size=%d\\n\", sizeof data / sizeof(int));\n    int i, average = 0;\n    for (i = 0; i < size; i++) {\n        average += data[i];\n    }\n    return average / size;\n}\n","function_prediction":"int average_name_conflict(int *array, int size) {\n  int i, sum = 0;\n  if (array == NULL || size == 0)\n    return 0;\n  printf(\"size=%d\\n\", sizeof(array));\n  for (i = 0; i < size; i++)\n    sum += array[i];\n  return sum / size;\n}","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":1,"function":"int average2(int data[], int size) {\n    int i, average = 0;\n    for (i = 0; i < size; i++) {\n        average += data[i];\n    }\n    return average / size;\n}\n","function_prediction":"int average2_name_conflict(int *array, int size) {\n  int i, sum = 0;\n  for (i = 0; i < size; i++)\n    sum += array[i];\n  return sum / size;\n}","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":1,"function":"char readchar() {\n    while (uartadr[8] & 1)\n        ;\n    return uartadr[4];\n}\n","function_prediction":"char readchar_name_conflict(void) {\n  while (!(*(volatile unsigned char *)(uartadr + 8) & 0x01))\n    ;\n  return *(volatile unsigned char *)(uartadr + 4);\n}","pass":1,"source_file":"C_COMPILE/bonfireprocessor_bonfire-soc/riscv/software/cpptest/uart.c"}
{"compilable":1,"function":"_Bool show_cmd_help(int argc, char **argv) {\n    return (argc > 0 && (0 == strcmp(argv[0], \"-h\") || 0 == strcmp(argv[0], \"--help\")));\n}\n","function_prediction":"int show_cmd_help_name_conflict(int argc, char **argv) {\n  if (argc > 0 && (!strcmp(argv[0], \"-h\") || !strcmp(argv[0], \"--help\")))\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/wfleming_c-timecard/src/punch.c"}
{"compilable":0,"function":"int in_cmd(int argc, char **argv) {\n    if (0 == argc) {\n        char *cmd = \"in\";\n        help_cmd(1, &cmd);\n        return 64;\n    }\n    int did_punch_in = with_open_log_file(argv[0], in_cmd_with_fh);\n    return (0 != did_punch_in);\n}\n","function_prediction":"int in_cmd_name_conflict(int argc, char **argv) {\n  if (argc == 0) {\n    char *args[] = {\"in\", NULL};\n    help_cmd(1, args);\n    return 64;\n  }\n\n  return with_open_log_file(argv[0], in_cmd_name_conflict_with_fh);\n}\n\nint in_cmd_name_conflict_with_fh(FILE *fh, char *project) {\n  int rc = with_parsed_log(fh, 0, in_cmd_name_conflict_with_log);\n\n  if (rc == -1) {\n    printf(\"DEBUG: in_cmd_name_conflict_with_fh  going to write_out\\n\");\n    write_out(fh);\n  }\n\n  printf(\"DEBUG: in_cmd_name_conflict_with_fh  after write_out\\n\");\n\n  struct entry e;\n  e.project = project;\n  e.date = time(NULL);\n  e.hours = 0;\n  e.next = NULL;\n\n  fseek(fh, 0, 2);\n\n  char buf[256];\n  strfentry(buf, 255, &e);\n  fputs(buf, fh);\n\n  printf(\"Punched into %s\\n\", project);\n\n  return 0;\n}\n\nint in_cmd_name_conflict_with_log(struct entry *e) {\n  struct entry *last = e;\n  while (last && last->next) {\n    last = last->next;\n  }\n\n  if (last && last->next == NULL && last->project->next) {\n    fprintf(stderr, \"You have been punched out of %s.\\n\", last->project->name);\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/in_cmd.c"}
{"compilable":1,"function":"bool ensure_data_dir_exists(void) {\n    char path[4096];\n    get_data_dir(path);\n    struct stat finfo;\n    int success = stat(path, &finfo);\n    if (-1 == success) {\n        if (2 == (*__errno_location())) {\n            success = mkdir(path, 16384 | (256 | 128 | 64) | (256 >> 3));\n            if (-1 == success) {\n                goto fail;\n            }\n        } else {\n            goto fail;\n        }\n    }\n    return 1;\n  fail:\n    fprintf(stderr, \"Error %d (%s) trying to create %s\\n\", (*__errno_location()), edesc((*__errno_location())), path);\n    return 0;\n}\n","function_prediction":"int ensure_data_dir_exists_name_conflict() {\n  char data_dir[4096];\n  struct stat st;\n  int rc;\n\n  get_data_dir(data_dir);\n  rc = stat(data_dir, &st);\n  if (rc == -1) {\n    if (*__errno_location() == 2) {\n      rc = mkdir(data_dir, 07550);\n      if (rc == -1) {\n        fprintf(stderr, \"Error %d (%s) trying to create %s\\n\",\n                *__errno_location(), edesc(*__errno_location()), data_dir);\n        return 0;\n      }\n    } else {\n      fprintf(stderr, \"Error %d (%s) trying to create %s\\n\",\n              *__errno_location(), edesc(*__errno_location()), data_dir);\n      return 0;\n    }\n  }\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/wfleming_c-timecard/src/cmd_util.c"}
{"compilable":1,"function":"char *edesc(int err) {\n    switch (err) {\n      case 2:\n        return \"file does not exist\";\n      case 20:\n        return \"is not a directory\";\n      case 13:\n        return \"access denied\";\n      case 9:\n        return \"bad file descriptor\";\n      case 17:\n        return \"the file exists\";\n      case 36:\n        return \"filename too long\";\n      case 30:\n        return \"write access requested on a read-only filesystem\";\n      case 22:\n        return \"flag is invalid\";\n      default:\n        return \"unknown error\";\n    }\n}\n","function_prediction":"char *edesc_name_conflict(int e) {\n  switch (e) {\n  case 2:\n    return \"file does not exist\";\n  case 9:\n    return \"bad file descriptor\";\n  case 13:\n    return \"access denied\";\n  case 17:\n    return \"the file exists\";\n  case 20:\n    return \"is not a directory\";\n  case 22:\n    return \"flag is invalid\";\n  case 30:\n    return \"write access requested on a read-only filesystem\";\n  case 36:\n    return \"filename too long\";\n  default:\n    return \"unknown error\";\n  }\n}","pass":1,"source_file":"C_COMPILE/wfleming_c-timecard/src/cmd_util.c"}
{"compilable":0,"function":"int out_cmd(int argc) {\n    if (argc > 0) {\n        char *cmd = \"out\";\n        help_cmd(1, &cmd);\n        return 64;\n    }\n    int did_punch_out = with_open_log_file(((void *)0), out_cmd_with_fh);\n    return (0 != did_punch_out);\n}\n","function_prediction":"int out_cmd_with_fh(FILE *fh) {\n  struct entry *e = NULL;\n  int rc;\n\n  rc = with_parsed_log(fh, &e, out_cmd_with_log);\n  if (rc == -1)\n    return -1;\n\n  if (e) {\n    write_out(fh, e);\n    entry_free(e);\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/out_cmd.c"}
{"compilable":1,"function":"size_t strfentry_time(char *buf, time_t *t) {\n    struct tm tt;\n    localtime_r(t, &tt);\n    size_t foo = strfiso8601(buf, 26, &tt);\n    return foo;\n}\n","function_prediction":"char *strfentry_time_name_conflict(char *buf, time_t *t) {\n  struct tm tm;\n\n  localtime_r(t, &tm);\n  return strfiso8601(buf, 26, &tm);\n}","pass":1,"source_file":"C_COMPILE/wfleming_c-timecard/src/entry.c"}
{"compilable":0,"function":"int summary_cmd(int argc, char **argv) {\n    t_formatter_fn formatter = print_summary_human;\n    if (argc > 0 && 0 == strncmp(\"--csv\", argv[0], 5)) {\n        formatter = print_summary_csv;\n    }\n    int exit_code = 0;\n    if (isatty(fileno(stdin))) {\n        exit_code = with_open_log_file((void *)formatter, summary_cmd_with_fh);\n    } else {\n        exit_code = summary_cmd_with_fh(stdin, (void *)formatter);\n    }\n    return exit_code;\n}\n","function_prediction":"int summary_cmd_name_conflict(int argc, char **argv) {\n  print_summary_fn print_summary = print_summary_human;\n  if (argc > 0 && !strncmp(\"--csv\", argv[0], 5))\n    print_summary = print_summary_csv;\n\n  if (isatty(fileno(stdin)))\n    return with_open_log_file(print_summary, summary_cmd_name_conflict_with_fh);\n  else\n    return summary_cmd_name_conflict_with_fh(stdin, print_summary);\n}","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/summary_cmd.c"}
{"compilable":0,"function":"static int choose_pivot(int *p, int n) {\n    int *pl, *pm, *pn;\n    int s;\n    pm = p + (n >> 1);\n    if (n > 7) {\n        pl = p;\n        pn = p + n - 1;\n        if (n > 40) {\n            s = n >> 3;\n            pl = ((V[*(pl) + (h)]) < (V[*(pl + s) + (h)]) ? ((V[*(pl + s) + (h)]) < (V[*(pl + s + s) + (h)]) ? (pl + s) : (V[*(pl) + (h)]) < (V[*(pl + s + s) + (h)]) ? (pl + s + s) : (pl)) : ((V[*(pl + s) + (h)]) > (V[*(pl + s + s) + (h)]) ? (pl + s) : (V[*(pl) + (h)]) > (V[*(pl + s + s) + (h)]) ? (pl + s + s) : (pl)));\n            pm = ((V[*(pm - s) + (h)]) < (V[*(pm) + (h)]) ? ((V[*(pm) + (h)]) < (V[*(pm + s) + (h)]) ? (pm) : (V[*(pm - s) + (h)]) < (V[*(pm + s) + (h)]) ? (pm + s) : (pm - s)) : ((V[*(pm) + (h)]) > (V[*(pm + s) + (h)]) ? (pm) : (V[*(pm - s) + (h)]) > (V[*(pm + s) + (h)]) ? (pm + s) : (pm - s)));\n            pn = ((V[*(pn - s - s) + (h)]) < (V[*(pn - s) + (h)]) ? ((V[*(pn - s) + (h)]) < (V[*(pn) + (h)]) ? (pn - s) : (V[*(pn - s - s) + (h)]) < (V[*(pn) + (h)]) ? (pn) : (pn - s - s)) : ((V[*(pn - s) + (h)]) > (V[*(pn) + (h)]) ? (pn - s) : (V[*(pn - s - s) + (h)]) > (V[*(pn) + (h)]) ? (pn) : (pn - s - s)));\n        }\n        pm = ((V[*(pl) + (h)]) < (V[*(pm) + (h)]) ? ((V[*(pm) + (h)]) < (V[*(pn) + (h)]) ? (pm) : (V[*(pl) + (h)]) < (V[*(pn) + (h)]) ? (pn) : (pl)) : ((V[*(pm) + (h)]) > (V[*(pn) + (h)]) ? (pm) : (V[*(pl) + (h)]) > (V[*(pn) + (h)]) ? (pn) : (pl)));\n    }\n    return (V[*(pm) + (h)]);\n}\n","function_prediction":"int choose_pivot_name_conflict(int *a, int n) {\n  int *p, *q, *r;\n\n  if (n < 8)\n    return V[h[*a]];\n\n  p = a;\n  q = a + (n >> 1);\n  r = a + n - 1;\n\n  if (n > 40) {\n    n >>= 3;\n\n    if (V[h[*p] + n] < V[h[*q] + n]) {\n      if (V[h[*q] + n] < V[h[*r] + n])\n        q = r;\n      else if (V[h[*p] + n] < V[h[*r] + n])\n        q = r;\n    } else {\n      if (V[h[*r] + n] < V[h[*q] + n])\n        q = r;\n      else if (V[h[*r] + n] < V[h[*p] + n])\n        q = r;\n    }\n\n    if (V[h[*p] + n] < V[h[*q] + n]) {\n      if (V[h[*q] + n] < V[h[*r] + n])\n        q = r;\n      else if (V[h[*q] + n] < V[h[*p] + n])\n        q = p;\n    } else {\n      if (V[h[*r] + n] < V[h[*q] + n])\n        q = p;\n      else if (V[h[*r] + n] < V[h[*p] + n])\n        q = p;\n    }\n\n    if (V[h[*p] + n] < V[h[*q] + n]) {\n      if (V[h[*q] + n] < V[h[*r] + n])\n        q = r;\n      else if (V[h[*q] + n] < V[h[*p] + n])\n        q = p;\n    } else {","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":0,"function":"static int transform(int *x, int *p, int n, int k, int l, int q) {\n    int b, c, d, e, i, j, m, s;\n    int *pi, *pj;\n    for (s = 0 , i = k - l; i; i >>= 1)\n        ++s;\n    e = 2147483647 >> s;\n    for (b = d = r = 0; r < n && d <= e && (c = d << s | (k - l)) <= q; ++r) {\n        b = b << s | (x[r] - l + 1);\n        d = c;\n    }\n    m = (1 << (r - 1) * s) - 1;\n    x[n] = l - 1;\n    if (d <= n) {\n        for (pi = p; pi <= p + d; ++pi)\n            *pi = 0;\n        for (pi = x + r , c = b; pi <= x + n; ++pi) {\n            p[c] = 1;\n            c = (c & m) << s | (*pi - l + 1);\n        }\n        for (i = 1; i < r; ++i) {\n            p[c] = 1;\n            c = (c & m) << s;\n        }\n        for (pi = p , j = 1; pi <= p + d; ++pi)\n            if (*pi)\n                *pi = j++;\n        for (pi = x , pj = x + r , c = b; pj <= x + n; ++pi , ++pj) {\n            *pi = p[c];\n            c = (c & m) << s | (*pj - l + 1);\n        }\n        while (pi < x + n)\n            {\n                *pi++ = p[c];\n                c = (c & m) << s;\n            }\n    } else {\n        for (pi = x , pj = x + r , c = b; pj <= x + n; ++pi , ++pj) {\n            *pi = c;\n            c = (c & m) << s | (*pj - l + 1);\n        }\n        while (pi < x + n)\n            {\n                *pi++ = c;\n                c = (c & m) << s;\n            }\n        j = d + 1;\n    }\n    x[n] = 0;\n    return j;\n}\n","function_prediction":"int transform_name_conflict(int *a, int *b, int n, int m, int min, int max) {\n  int i, j, k, l, r, s, t, u, v, w, x, y, z;\n\n  for (i = 0; m - min != 0; i++)\n    m >>= 1;\n\n  r = 0;\n  s = 0;\n  t = 0;\n  while (r < n && s <= (1 << 31) - 1 >> i && m - min <= max) {\n    t = (t << i) | (a[r] - min + 1);\n    r++;\n    s = (s << i) | (m - min);\n  }\n\n  u = (1 << (i * (r - 1))) - 1;\n\n  a[n] = min - 1;\n\n  if (s <= m - min) {\n    for (j = 0; j <= s; j++)\n      b[j] = 0;\n\n    v = t;\n    for (j = r; j <= n; j++) {\n      b[v] = 1;\n      v = (v & u) << i | (a[j] - min + 1);\n    }\n\n    for (j = 1; j < r; j++) {\n      b[v] = 1;\n      v = (v & u) << i;\n    }\n\n    w = 1;\n    for (j = 0; j <= s; j++)\n      if (b[j] != 0)\n        b[j] = w++;\n\n    v = t;\n    for (j = r; j <= n; j++) {\n      a[j] = b[v];\n      v = (v & u) << i | (a[j] - min + 1);\n    }\n\n    for (j = r; j < n; j++) {\n      a[j] = b[v];\n      v = (v & u) << i;\n    }\n  } else {\n    y = t;\n    for (j = r; j <= n; j++) {","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":0,"function":"int vcblocksortCompress(int level, const unsigned char *data, size_t avail_in, unsigned char *odata, size_t *avail_out) {\n    double result;\n    struct BlockSortCompressionInstance *bsci;\n    bsci = calloc(sizeof (*bsci), 1);\n    resetStatistics(bsci);\n    result = bs_compress(bsci, (unsigned char *)data, avail_in);\n    freeBSCI(bsci);\n    *avail_out = (int)result;\n    return 0;\n}\n","function_prediction":"int vcblocksortCompress(int argc, char **argv, int num_bytes, unsigned char *in,\n                        unsigned char **out) {\n  BSCI *bs = calloc(1096, 1);\n  resetStatistics(bs);\n  double csize = bs_compress(bs, in, num_bytes);\n  freeBSCI(bs);\n  *out = (unsigned char *)csize;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":0,"function":"int smaz_compress(const unsigned char *in, size_t inlen, unsigned char *out, size_t outlen) {\n    unsigned int h1, h2, h3 = 0;\n    int verblen = 0, _outlen = outlen;\n    unsigned char verb[256], *_out = out;\n    while (inlen)\n        {\n            int j = 7, needed;\n            unsigned char *flush = ((void *)0);\n            char *slot;\n            h1 = h2 = in[0] << 3;\n            if (inlen > 1)\n                h2 += in[1];\n            if (inlen > 2)\n                h3 = h2 ^ in[2];\n            if (j > inlen)\n                j = inlen;\n            for (; j > 0; j--) {\n                switch (j) {\n                  case 1:\n                    slot = Smaz_cb[h1 % 241];\n                    break;\n                  case 2:\n                    slot = Smaz_cb[h2 % 241];\n                    break;\n                  default:\n                    slot = Smaz_cb[h3 % 241];\n                    break;\n                }\n                while (slot[0])\n                    {\n                        if (slot[0] == j && memcmp(slot + 1, in, j) == 0) {\n                            if (verblen) {\n                                needed = (verblen == 1) ? 2 : 2 + verblen;\n                                flush = out;\n                                out += needed;\n                                outlen -= needed;\n                            }\n                            if (outlen <= 0)\n                                return _outlen + 1;\n                            out[0] = slot[slot[0] + 1];\n                            out++;\n                            outlen--;\n                            inlen -= j;\n                            in += j;\n                            goto out;\n                        } else {\n                            slot += slot[0] + 2;\n                        }\n                    }\n            }\n            verb[verblen] = in[0];\n            verblen++;\n            inlen--;\n            in++;\n          out:\n            if (!flush && (verblen == 256 || (verblen > 0 && inlen == 0))) {\n                needed = (verblen == 1) ? 2 : 2 + verblen;\n                flush = out;\n                out += needed;\n                outlen -= needed;\n                if (outlen < 0)\n                    return _outlen + 1;\n            }\n            if (flush) {\n                if (verblen == 1) {\n                    flush[0] = (signed char)254;\n                    flush[1] = verb[0];\n                } else {\n                    flush[0] = (signed char)255;\n                    flush[1] = (signed char)(verblen - 1);\n                    memcpy(flush + 2, verb, verblen);\n                }\n                flush = ((void *)0);\n                verblen = 0;\n            }\n        }\n    return out - _out;\n}\n","function_prediction":"size_t smaz_compress_name_conflict(const char *in, size_t inlen, char *out, size_t outlen) {\n  const char *in_start = in;\n  char *out_start = out;\n  char *out_end = out + outlen;\n  char *out_start_of_block = NULL;\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  char buf[256];\n  int buf_len = 0;\n\n  while (inlen > 0) {\n    i = (inlen > 6) ? 7 : inlen;\n    j = 0;\n    k = in[0] * 8;\n    l = k;\n    m = (inlen > 1) ? l + in[1] : l;\n    n = (inlen > 2) ? m ^ in[2] : m;\n    o = (inlen > 3) ? n ^ in[3] : n;\n    p = (inlen > 4) ? o ^ in[4] : o;\n    q = (inlen > 5) ? p ^ in[5] : p;\n    r = (inlen > 6) ? q ^ in[6] : q;\n    s = (inlen > 7) ? r ^ in[7] : r;\n    t = (inlen > 8) ? s ^ in[8] : s;\n    u = (inlen > 9) ? t ^ in[9] : t;\n    v = (inlen > 10) ? u ^ in[10] : u;\n    w = (inlen > 11) ? v ^ in[11] : v;\n    x = (inlen > 12) ? w ^ in[12] : w;\n    y = (inlen > 13) ? x ^ in[13] : x;\n    z = (inlen > 14) ? y ^ in[14] : y;\n\n    while (i > 0) {\n      if (i == 1) {\n                char *str = Smaz_cb[k %","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":0,"function":"int sCompress(int level, const unsigned char *in, size_t inlen, unsigned char *out, size_t *outlen) {\n    int res = smaz_compress(in, inlen, out, *outlen);\n    *outlen = res;\n    return 0;\n}\n","function_prediction":"int sCompress(lw6sys_context_t *sys_context, const char *input,\n              size_t input_len, char *output, size_t *output_len) {\n  int rc;\n\n  rc = smaz_compress(input, input_len, output, *output_len);\n  *output_len = rc;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":1,"function":"int smaz_decompress(char *in, int inlen, char *out, int outlen) {\n    unsigned char *c = (unsigned char *)in;\n    char *_out = out;\n    int _outlen = outlen;\n    while (inlen)\n        {\n            if (*c == 254) {\n                if (outlen < 1)\n                    return _outlen + 1;\n                *out = *(c + 1);\n                out++;\n                outlen--;\n                c += 2;\n                inlen -= 2;\n            } else if (*c == 255) {\n                int len = (*(c + 1)) + 1;\n                if (outlen < len)\n                    return _outlen + 1;\n                memcpy(out, c + 2, len);\n                out += len;\n                outlen -= len;\n                c += 2 + len;\n                inlen -= 2 + len;\n            } else {\n                char *s = Smaz_rcb[*c];\n                int len = strlen(s);\n                if (outlen < len)\n                    return _outlen + 1;\n                memcpy(out, s, len);\n                out += len;\n                outlen -= len;\n                c++;\n                inlen--;\n            }\n        }\n    return out - _out;\n}\n","function_prediction":"int smaz_decompress_name_conflict(const char *source, int slen, char *target, int tlen) {\n  const char *src = source;\n  char *dst = target;\n  int srem = slen;\n  int trem = tlen;\n\n  while (srem) {\n    if (*src == 0xfe) {\n      if (trem < 1)\n        return tlen + 1;\n      *dst++ = src[1];\n      src += 2;\n      srem -= 2;\n      trem--;\n    } else if (*src == 0xff) {\n      int len = src[1] + 1;\n      if (trem < len)\n        return tlen + 1;\n      memcpy(dst, src + 2, len);\n      dst += len;\n      src += len + 2;\n      srem -= len + 2;\n      trem -= len;\n    } else {\n      const char *str = Smaz_rcb[*src];\n      int len = strlen(str);\n      if (trem < len)\n        return tlen + 1;\n      memcpy(dst, str, len);\n      dst += len;\n      src++;\n      srem--;\n      trem -= len;\n    }\n  }\n\n  return dst - target;\n}","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":1,"function":"long rand() {\n    _lastRand = _lastRand * 71762886081639153L;\n    return _lastRand;\n}\n","function_prediction":"int rand_name_conflict() {\n  _lastRand = _lastRand * 0xfef3f6f4f3f2f1;\n  return (int)_lastRand;\n}","pass":1,"source_file":"C_COMPILE/zma_cc0/src/toolchain/test/srad.c"}
{"compilable":1,"function":"long rand_long() {\n    int lower_32bit, upper_32bit;\n    long rand_long;\n    lower_32bit = rand();\n    upper_32bit = rand();\n    return (((long)upper_32bit << 32) + lower_32bit);\n}\n","function_prediction":"long rand_long_name_conflict() {\n  long r = rand();\n  r = (r << 32) + rand();\n  return r;\n}","pass":0,"source_file":"C_COMPILE/zma_cc0/apps/kmeans/input-generator/gen-input.c"}
{"compilable":1,"function":"static int isAlphanum(int c) {\n    return ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$' || c == '\\\\' || c > 126);\n}\n","function_prediction":"int isAlphanum_name_conflict(int c) {\n  return (((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||\n           (c >= '0' && c <= '9') || c == '_' || c == '$' || c == '\\\\')\n              ? 1\n              : 0);\n}","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":1,"function":"static int get() {\n    int c = theLookahead;\n    theLookahead = (-1);\n    if (c == (-1)) {\n        c = getc(stdin);\n    }\n    if (c >= ' ' || c == '\\n' || c == (-1)) {\n        return c;\n    }\n    if (c == '\\r') {\n        return '\\n';\n    }\n    return ' ';\n}\n","function_prediction":"int get_name_conflict() {\n  int c;\n\n  c = theLookahead;\n  theLookahead = -1;\n  if (c == -1)\n    c = get_name_conflictc(stdin);\n  if (c == -1 || c == '\\n' || c < 32) {\n    if (c == '\\r')\n      c = '\\n';\n    else\n      c = ' ';\n  }\n  return c;\n}","pass":1,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":1,"function":"static int peek() {\n    theLookahead = get();\n    return theLookahead;\n}\n","function_prediction":"int peek_name_conflict() {\n  theLookahead = get();\n  return theLookahead;\n}","pass":1,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":1,"function":"static int next() {\n    int c = get();\n    if (c == '/') {\n        switch (peek()) {\n          case '/':\n            for (;;) {\n                c = get();\n                if (c <= '\\n') {\n                    return c;\n                }\n            }\n          case '*':\n            get();\n            for (;;) {\n                switch (get()) {\n                  case '*':\n                    if (peek() == '/') {\n                        get();\n                        return ' ';\n                    }\n                    break;\n                  case (-1):\n                    fprintf(stderr, \"Error: JSMIN Unterminated comment.\\n\");\n                    exit(1);\n                }\n            }\n          default:\n            return c;\n        }\n    }\n    return c;\n}\n","function_prediction":"int next_name_conflict() {\n  int c = get();\n  if (c == '/') {\n    switch (peek()) {\n    case '*':\n      get();\n      do {\n        c = get();\n        if (c == -1) {\n          fwrite(\"Error: JSMIN Unterminated comment.\\n\", 1, 35, stderr);\n          exit(1);\n        }\n      } while (c != '*' || peek() != '/');\n      get();\n      return ' ';\n    case '/':\n      do {\n        c = get();\n      } while (c <= '\\n');\n      return c;\n    }\n  }\n  return c;\n}","pass":1,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":1,"function":"unsigned short CheckSum(unsigned short *ptr, int nbytes) {\n    register long sum;\n    unsigned short oddbyte;\n    register short answer;\n    sum = 0;\n    while (nbytes > 1)\n        {\n            sum += *ptr++;\n            nbytes -= 2;\n        }\n    if (nbytes == 1) {\n        oddbyte = 0;\n        *((u_char *)&oddbyte) = *(u_char *)ptr;\n        sum += oddbyte;\n    }\n    sum = (sum >> 16) + (sum & 65535);\n    sum = sum + (sum >> 16);\n    answer = (short)~sum;\n    return (answer);\n}\n","function_prediction":"unsigned short CheckSum_name_conflict(unsigned short *buf, int len) {\n  unsigned long sum = 0;\n  unsigned short *w = buf;\n  unsigned short wr = 0;\n  int nleft = len;\n\n  while (nleft > 1) {\n    sum += *w++;\n    nleft -= 2;\n  }\n\n  if (nleft == 1) {\n    *(unsigned char *)&wr = *(unsigned char *)w;\n    sum += wr;\n  }\n\n  sum = (sum >> 16) + (sum & 0xffff);\n  sum += (sum >> 16);\n  return (unsigned short)(~sum);\n}","pass":1,"source_file":"C_COMPILE/2dango_Custom-UDP-packet/udp.c"}
{"compilable":1,"function":"size_t encode_string(char *dest, const char *src) {\n    char *start = dest, c;\n    while ((c = *(src++)))\n        {\n            switch (c) {\n              case '\\n':\n                *(dest++) = '\\\\';\n                *(dest++) = 'n';\n                break;\n              case '\\\\':\n                *(dest++) = '\\\\';\n                *(dest++) = '\\\\';\n                break;\n              case ':':\n                *(dest++) = '\\\\';\n              default:\n                *(dest++) = c;\n            }\n        }\n    *dest = '\\x00';\n    return dest - start;\n}\n","function_prediction":"size_t encode_string_name_conflict(char *dst, const char *src) {\n  char *d = dst;\n  const char *s = src;\n\n  while (*s) {\n    switch (*s) {\n    case '\\\\':\n      *d++ = '\\\\';\n      *d++ = '\\\\';\n      break;\n    case '\\n':\n      *d++ = '\\\\';\n      *d++ = 'n';\n      break;\n    case ':':\n      *d++ = '\\\\';\n      *d++ = ':';\n      break;\n    default:\n      *d++ = *s;\n      break;\n    }\n    s++;\n  }\n  *d = '\\0';\n\n  return d - dst;\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/DSV.c"}
{"compilable":1,"function":"static inline unsigned int digits(unsigned int n) {\n    return n ? 1 + digits(n / 10) : n;\n}\n","function_prediction":"int digits_name_conflict(unsigned int n) {\n  if (n == 0)\n    return 0;\n  return 1 + digits_name_conflict(n / 10);\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/redo.c"}
{"compilable":0,"function":"static char **parse_shebang(char *target, char *doscript, char *temp_output) {\n    FILE *fp = fopen(doscript, \"rb\");\n    if (!fp)\n        die_(\"(build.c:137): redo: failed to open %s: %s\\n\", doscript, strerror((*__errno_location())));\n    char *buf = xmalloc(1024);\n    buf[fread(buf, 1, 1023, fp)] = '\\x00';\n    if (ferror(fp))\n        die_(\"(build.c:141): redo: failed to read from %s: %s\\n\", doscript, strerror((*__errno_location())));\n    fclose(fp);\n    char **argv;\n    size_t i = 0;\n    if (buf[0] == '#' && buf[1] == '!') {\n        argv = parsecmd(&buf[2], &i, 5);\n    } else {\n        argv = xmalloc(7 * sizeof(char *));\n        argv[i++] = \"/bin/sh\";\n        argv[i++] = \"-e\";\n    }\n    argv[i++] = doscript;\n    argv[i++] = target;\n    char *__xpg_basename = remove_ext(target);\n    argv[i++] = __xpg_basename;\n    argv[i++] = temp_output;\n    argv[i] = ((void *)0);\n    return argv;\n}\n","function_prediction":"char **parse_shebang(const char *target, const char *file,\n                     const char *logfile) {\n  FILE *f;\n  char *buf;\n  size_t len;\n  char **argv;\n\n  f = fopen(file, \"rb\");\n  if (!f)\n    die_(\"(build.c:136): \"\n         \"redo: failed to open %s: %s\\n\",\n         file, strerror(*__errno_location()));\n\n  buf = xmalloc(1024);\n  len = fread(buf, 1, 1024 - 1, f);\n  buf[len] = '\\0';\n  if (ferror(f))\n    die_(\"(build.c:140): \"\n         \"redo: failed to read from %s: %s\\n\",\n         file, strerror(*__errno_location()));\n  fclose(f);\n\n  argv = xmalloc(sizeof(char *) * 10);\n  argv[0] = NULL;\n\n  if (buf[0] == '#' && buf[1] == '!')\n    argv = parsecmd(buf + 2, argv, 5);\n  else {\n    argv[argv[0]++] = \"/bin/sh\";\n    argv[argv[0]++] = \"-c\";\n  }\n\n  argv[argv[0]++] = file;\n  argv[argv[0]++] = target;\n  argv[argv[0]++] = remove_ext(target);\n  argv[argv[0]++] = logfile;\n  argv[argv[0]] = NULL;\n\n  return argv;\n}","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":1,"function":"static char **parsecmd(char *cmd, size_t *i, size_t keep_free) {\n    size_t argv_len = 16;\n    char **argv = xmalloc(argv_len * sizeof(char *));\n    size_t j = 0;\n    bool prev_space = 1;\n    for (;; ++j) {\n        switch (cmd[j]) {\n          case ' ':\n            cmd[j] = '\\x00';\n            prev_space = 1;\n            break;\n          case '\\n':\n          case '\\r':\n            cmd[j] = '\\x00';\n          case '\\x00':\n            return argv;\n          default:\n            if (!prev_space)\n                break;\n            while (*i + keep_free >= argv_len)\n                {\n                    argv_len *= 2;\n                    argv = xrealloc(argv, argv_len * sizeof(char *));\n                }\n            prev_space = 0;\n            argv[*i] = &cmd[j];\n            ++*i;\n        }\n    }\n}\n","function_prediction":"char **parsecmd_name_conflict(char *cmd, size_t *argc, size_t maxlen) {\n  size_t i, j, k;\n  char **argv;\n  int inword;\n\n  k = 16;\n  argv = xmalloc(k * sizeof(char *));\n  i = j = 0;\n  inword = 1;\n  while (1) {\n    switch (cmd[i]) {\n    case '\\0':\n    case '\\n':\n    case '\\r':\n      cmd[i] = '\\0';\n      return argv;\n    case ' ':\n      cmd[i] = '\\0';\n      inword = 1;\n      break;\n    default:\n      if (inword) {\n        while (j + i + 1 > k * maxlen) {\n          argv = xrealloc(argv, (k *= 2) * sizeof(char *));\n        }\n        inword = 0;\n        argv[j++] = &cmd[i];\n      }\n      break;\n    }\n    i++;\n  }\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":1,"function":"static char *xrealpath(const char *path) {\n    char *dirc = xstrdup(path);\n    char *dname = dirname(dirc);\n    char *absdir = realpath(dname, ((void *)0));\n    char *abstarget = ((void *)0);\n    if (absdir)\n        abstarget = concat(3, absdir, \"/\", xbasename(path));\n    free(dirc);\n    free(absdir);\n    return abstarget;\n}\n","function_prediction":"char *xrealpath_name_conflict(const char *path) {\n  char *dir, *base, *ret;\n  char *path_copy = xstrdup(path);\n\n  dir = realpath(dirname(path_copy), NULL);\n  base = NULL;\n  if (dir)\n    base = concat(3, dir, \"/\", xbasename(path));\n\n  free(path_copy);\n  free(dir);\n\n  return base;\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char *get_relpath(const char *target) {\n    char *root = getenv(\"REDO_ROOT\");\n    char *abstarget = xrealpath(target);\n    if (!abstarget)\n        return ((void *)0);\n    char *path = xstrdup(relpath(abstarget, root));\n    free(abstarget);\n    return path;\n}\n","function_prediction":"char *get_relpath_name_conflict(const char *path) {\n  char *root = getenv(\"REDO_ROOT\");\n  char *fullpath = xrealpath(path);\n  char *relpath;\n\n  if (!fullpath)\n    return NULL;\n\n  relpath = relpath(fullpath, root);\n  relpath = xstrdup(relpath);\n  free(fullpath);\n  return relpath;\n}","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":1,"function":"static char *get_dep_path(const char *target) {\n    char *root = getenv(\"REDO_ROOT\");\n    char *dep_path;\n    char *reltarget = get_relpath(target);\n    if (!reltarget)\n        return ((void *)0);\n    char *redodir = is_absolute(reltarget) ? \"/.redo/abs/\" : \"/.redo/rel/\";\n    dep_path = concat(3, root, redodir, reltarget);\n    mkpath(dep_path, 493);\n    free(reltarget);\n    return dep_path;\n}\n","function_prediction":"char *get_dep_path_name_conflict(const char *path) {\n  char *redo_root = getenv(\"REDO_ROOT\");\n  char *relpath = get_relpath(path);\n  char *dep_path;\n\n  if (!relpath)\n    return NULL;\n\n  dep_path =\n      concat(3, redo_root, is_absolute(relpath) ? \"/.redo/abs/\" : \"/.redo/rel/\",\n             relpath);\n  mkpath(dep_path, 0755);\n  free(relpath);\n  return dep_path;\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"int update_target(const char *target, int ident) {\n    dep_info dep = {.target = target, .path = get_dep_path(target)};\n    if (!dep.path)\n        return 1;\n    int retval = handle_ident(&dep, ident);\n    free(dep.path);\n    free(dep.hash);\n    return retval;\n}\n","function_prediction":"int update_target_name_conflict(char *target, int force) {\n  struct ident_info info = {\n      .target = target,\n      .path = NULL,\n      .dep_path = NULL,\n  };\n  int ret;\n\n  info.path = get_dep_path(target);\n  if (!info.path)\n    return 1;\n\n  ret = handle_ident(&info, force);\n\n  free(info.path);\n  free(info.dep_path);\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":1,"function":"bool is_absolute(const char *path) {\n    return path[0] == '/';\n}\n","function_prediction":"int is_absolute_name_conflict(char *path) { return path[0] == '/'; }","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":1,"function":"char *relpath(char *path, char *start) {\n    int i;\n    for (i = 0; path[i] && start[i]; ++i) {\n        if (path[i] != start[i])\n            return path;\n    }\n    if (!path[i] && start[i])\n        return start;\n    if (!path[i] && !start[i])\n        return \".\";\n    if (path[i] == '/')\n        ++i;\n    return &path[i];\n}\n","function_prediction":"char *relpath_name_conflict(char *path, char *base) {\n  int i;\n\n  for (i = 0; path[i] && base[i]; i++)\n    if (path[i] != base[i])\n      return path;\n\n  if (path[i] || base[i]) {\n    if (path[i] && base[i]) {\n      if (path[i] == '/')\n        i++;\n      return path + i;\n    }\n    if (path[i] == '\\0' && base[i] == '\\0')\n      return \".\";\n  }\n  return base;\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":1,"function":"off_t fsize(const char *fn) {\n    struct stat st;\n    if (stat(fn, &st)) {\n        if ((*__errno_location()) != 2)\n            die_(\"(build.c:66): redo: failed to aquire stat() information about %s: %s\\n\", fn, strerror((*__errno_location())));\n        return -1;\n    }\n    return st.st_size;\n}\n","function_prediction":"off_t fsize_name_conflict(const char *filename) {\n  struct stat st;\n\n  if (!stat(filename, &st))\n    return st.st_size;\n\n  if (*__errno_location() != 2)\n    die_(\"(build.c:65): redo: failed to aquire stat() information about %s: \"\n         \"%s\\n\",\n         filename, strerror(*__errno_location()));\n\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":1,"function":"char *make_abs(char *root, char *path) {\n    if (!is_absolute(path))\n        return concat(3, root, \"/\", path);\n    else\n        return xstrdup(path);\n}\n","function_prediction":"char *make_abs_name_conflict(const char *prefix, const char *name) {\n  if (is_absolute(name) == 1)\n    return xstrdup(name);\n  else\n    return concat(3, prefix, \":\", name);\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":1,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"off_t hash_file_name_conflict(MD5_CTX *ctx, int fd) {\n  char buf[4096];\n  off_t total = 0;\n  ssize_t n;\n\n  while ((n = read(fd, buf, sizeof(buf))) > 0) {\n    MD5Update(ctx, buf, n);\n    total += n;\n  }\n\n  buf[0] = '\\0';\n  MD5Update(ctx, buf, 1);\n\n  return total;\n}","pass":1,"source_file":"C_COMPILE/c2h2_luna-buildroot-2013.08.1/package/x11r7/mcookie/mcookie.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int file_open_name_conflict(const char *path, int flags) {\n  int fd;\n\n  fd = open(path, flags);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return fd;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"int file_write_name_conflict(int fd, const char *buf, int len) {\n  int ret;\n\n  ret = write(fd, buf, len);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_valid_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int file_close_name_conflict(int fd) {\n  if (close(fd) < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"int file_read_int_fd_name_conflict(int fd, int *i) {\n  char buf[20];\n  int r;\n\n  r = file_read(fd, buf, 20);\n  if (r < 0)\n    return 1;\n  *i = atoi(buf);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_int_path_name_conflict(const char *path, int *value) {\n  int fd;\n  int ret;\n\n  fd = file_open(path, _init);\n  if (fd < 0)\n    return 1;\n\n  ret = file_read_int_fd(fd, value);\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  if (ret == 1)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_fd_name_conflict(int fd, int value) {\n  char buffer[20];\n  sprintf(buffer, \"%d\", value);\n  if (file_write(fd, buffer, 20) < 0)\n    return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_path_name_conflict(const char *path, int value) {\n  int fd;\n  int ret;\n\n  fd = file_open(path, 0644);\n  if (fd < 0)\n    return 1;\n\n  ret = file_write_int_fd(fd, value);\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  if (ret == 1)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_str_name_conflict(char *filename, char *buf, int len) {\n  int fd;\n\n  if ((fd = file_open(filename, _init)) < 0)\n    return 1;\n\n  if (file_read(fd, buf, len) < 0)\n    return 1;\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_str_name_conflict(const char *path, const char *str, int len) {\n  int fd;\n\n  fd = file_open(path, 0644);\n  if (fd < 0)\n    return 1;\n\n  if (file_write(fd, str, len) < 0)\n    return 1;\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"char *file_read_contents_name_conflict(const char *filename) {\n  struct stat st;\n  int fd;\n  char *buf;\n\n  if (stat(filename, &st)) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  fd = file_open(filename, 0);\n  if (fd < 0)\n    return NULL;\n\n  buf = malloc(st.st_size);\n  if (!buf)\n    return NULL;\n\n  if (file_read(fd, buf, st.st_size) != st.st_size) {\n    free(buf);\n    return NULL;\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"spi *libsoc_spi_init(uint8_t spidev_device, uint8_t chip_select) {\n    spi *spi_dev;\n    libsoc_spi_debug(__func__, ((void *)0), \"initialising spidev device %d.%d\", spidev_device, chip_select);\n    spi_dev = malloc(sizeof(spi));\n    if (spi_dev == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"failed to allocate memory\");\n        return ((void *)0);\n    }\n    char path[40];\n    spi_dev->spi_dev = spidev_device;\n    spi_dev->chip_select = chip_select;\n    sprintf(path, \"/dev/spidev%d.%d\", spi_dev->spi_dev, spi_dev->chip_select);\n    if (!file_valid(path)) {\n        libsoc_spi_debug(__func__, spi_dev, \"%s not a vaild device\", path);\n        goto error;\n    }\n    spi_dev->fd = file_open(path, 1052672 | 2);\n    if (spi_dev->fd < 0) {\n        libsoc_spi_debug(__func__, spi_dev, \"%s could not be opened\", path);\n        goto error;\n    }\n    return spi_dev;\n  error:\n    free(spi_dev);\n    return ((void *)0);\n}\n","function_prediction":"libsoc_spi *libsoc_spi_init_name_conflict(unsigned int bus, unsigned int device) {\n  libsoc_spi *spi;\n  char file_name[32];\n\n  libsoc_spi_debug(\"libsoc_spi_init_name_conflict\", NULL, \"initialising spidev device %d.%d\",\n                   bus, device);\n\n  spi = malloc(sizeof(libsoc_spi));\n  if (spi == NULL) {\n    libsoc_spi_debug(\"libsoc_spi_init_name_conflict\", NULL, \"failed to allocate memory\");\n    return NULL;\n  }\n\n  spi->bus = bus;\n  spi->device = device;\n\n  sprintf(file_name, \"/dev/spidev%d.%d\", spi->bus, spi->device);\n\n  if (!file_valid(file_name)) {\n    libsoc_spi_debug(\"libsoc_spi_init_name_conflict\", spi, \"%s not a vaild device\",\n                     file_name);\n    free(spi);\n    return NULL;\n  }\n\n  spi->file_descriptor = file_open(file_name, 0666);\n  if (spi->file_descriptor < 0) {\n    libsoc_spi_debug(\"libsoc_spi_init_name_conflict\", spi, \"%s could not be opened\",\n                     file_name);\n    free(spi);\n    return NULL;\n  }\n\n  return spi;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_bits_per_word(spi *spi, spi_bpw bpw) {\n    if (bpw != BITS_8 && bpw != BITS_16) {\n        libsoc_spi_debug(__func__, spi, \"bits per word was not BITS_8 or BITS_16\", bpw);\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"setting bits per word to %d\", bpw);\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &bpw);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting bits per word\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_set_bits_per_word_name_conflict(libsoc_spi *spi, int bits_per_word) {\n  int result;\n\n  if (bits_per_word != 8 && bits_per_word != 16) {\n    libsoc_spi_debug(\"libsoc_spi_set_bits_per_word_name_conflict\", spi,\n                     \"bits per word was not BITS_8 or BITS_16\", bits_per_word);\n    return 1;\n  }\n\n  libsoc_spi_debug(\"libsoc_spi_set_bits_per_word_name_conflict\", spi,\n                   \"setting bits per word to %d\", bits_per_word);\n\n result = ioctl(spi->desc, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"spi_bpw libsoc_spi_get_bits_per_word(spi *spi) {\n    uint8_t bpw;\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &bpw);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading bits per word\");\n        return BPW_ERROR;\n    }\n    switch (bpw) {\n      case 8:\n        libsoc_spi_debug(__func__, spi, \"read bits per word as 8\");\n        return BITS_8;\n      case 16:\n        libsoc_spi_debug(__func__, spi, \"read bits per word as 16\");\n        return BITS_16;\n      default:\n        libsoc_spi_debug(__func__, spi, \"bits per word not recognised\");\n        return BPW_ERROR;\n    }\n}\n","function_prediction":"uint8_t libsoc_spi_get_bits_per_word_name_conflict(libsoc_spi *spi) {\n  uint8_t bits_per_word;\n  int result = ioctl(spi->fd, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_speed(spi *spi, uint32_t speed) {\n    libsoc_spi_debug(__func__, spi, \"setting speed to %dHz\", speed);\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(__u32)))) << ((0 + 8) + 8))), &speed);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting speed\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_set_speed_name_conflict(libsoc_spi_t *spi, uint32_t speed) {\n  int err;\n\n  libsoc_spi_debug(\"libsoc_spi_set_speed_name_conflict\", spi, \"setting speed to %dHz\", speed);\n\n err = ioctl(spi->fd, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"uint32_t libsoc_spi_get_speed(spi *spi) {\n    uint32_t speed;\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(__u32)))) << ((0 + 8) + 8))), &speed);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading speed\");\n        return -1;\n    }\n    libsoc_spi_debug(__func__, spi, \"read speed as %dHz\", speed);\n    return speed;\n}\n","function_prediction":"int libsoc_spi_get_speed_name_conflict(libsoc_spi *spi) {\n  int speed;\n  int result;\n\n result = ioctl(spi->fd, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_mode(spi *spi, spi_mode mode) {\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"setting mode to %d\", mode);\n    uint8_t new_mode;\n    switch (mode) {\n      case MODE_0:\n        new_mode = (0 | 0);\n        break;\n      case MODE_1:\n        new_mode = (0 | (((1UL)) << (0)));\n        break;\n      case MODE_2:\n        new_mode = ((((1UL)) << (1)) | 0);\n        break;\n      case MODE_3:\n        new_mode = ((((1UL)) << (1)) | (((1UL)) << (0)));\n        break;\n      default:\n        return 1;\n    }\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((1)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &new_mode);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting mode\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_set_mode_name_conflict(libsoc_spi *spi, int mode) {\n  int err;\n  uint8_t mode_byte;\n\n  if (spi == NULL) {\n    libsoc_spi_debug(\"libsoc_spi_set_mode_name_conflict\", spi, \"spi was not valid\");\n    return 1;\n  }\n\n  libsoc_spi_debug(\"libsoc_spi_set_mode_name_conflict\", spi, \"setting mode to %d\", mode);\n\n  switch (mode) {\n  case 0:\n    mode_byte = 0;\n    break;\n  case 1:\n    mode_byte = 1;\n    break;\n  case 2:\n    mode_byte = 2;\n    break;\n  case 3:\n    mode_byte = 3;\n    break;\n  default:\n    return 1;\n  }\n\n    err = ioctl(spi->desc, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"spi_mode libsoc_spi_get_mode(spi *spi) {\n    uint8_t mode;\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return MODE_ERROR;\n    }\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((1)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &mode);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading mode\");\n        return MODE_ERROR;\n    }\n    switch (mode) {\n      case (0 | 0):\n        libsoc_spi_debug(__func__, spi, \"read mode as 0\");\n        return MODE_0;\n      case (0 | (((1UL)) << (0))):\n        libsoc_spi_debug(__func__, spi, \"read mode as 1\");\n        return MODE_1;\n      case ((((1UL)) << (1)) | 0):\n        libsoc_spi_debug(__func__, spi, \"read mode as 2\");\n        return MODE_2;\n      case ((((1UL)) << (1)) | (((1UL)) << (0))):\n        libsoc_spi_debug(__func__, spi, \"read mode as 3\");\n        return MODE_3;\n      default:\n        libsoc_spi_debug(__func__, spi, \"mode not recognised\");\n        return MODE_ERROR;\n    }\n}\n","function_prediction":"int libsoc_spi_get_mode_name_conflict(libsoc_spi *spi) {\n  int ret;\n  unsigned char mode;\n\n  if (spi == NULL) {\n    libsoc_spi_debug(\"libsoc_spi_get_mode_name_conflict\", spi, \"spi was not valid\");\n    return 4;\n  }\n\n ret = ioctl(spi->fd, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_write(spi *spi, uint8_t *tx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing write transfer of %d bytes\", len);\n    if (spi == ((void *)0) || tx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi or tx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.tx_buf = (unsigned long)tx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed sending message\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_write_name_conflict(libsoc_spi *spi, uint8_t *tx, int length) {\n  int result;\n  struct spi_ioc_transfer spi_transfer;\n\n  libsoc_spi_debug(\"libsoc_spi_write_name_conflict\", spi,\n                   \"performing write transfer of %d bytes\", length);\n\n  if (spi == NULL || tx == NULL) {\n    libsoc_spi_debug(\"libsoc_spi_write_name_conflict\", spi, \"spi or tx was NULL\");\n    return 1;\n  }\n\n  if (length <= 0) {\n    libsoc_spi_debug(\"libsoc_spi_write_name_conflict\", spi, \"length was less than zero\");\n    return 1;\n  }\n\n  spi_transfer.tx_buf = (unsigned long)tx;\n  spi_transfer.rx_buf = 0;\n  spi_transfer.len = length;\n  spi_transfer.delay_usecs = 0;\n  spi_transfer.speed_hz = 0;\n  spi_transfer.bits_per_word = 0;\n\n  result = ioctl(spi->fd, 0x40206b00, &spi_transfer);\n\n  if (result <= 0) {\n    libsoc_spi_debug(\"libsoc_spi_write_name_conflict\", spi, \"failed sending message\");\n    return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_read(spi *spi, uint8_t *rx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing read transfer of %d bytes\", len);\n    if (spi == ((void *)0) || rx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi or rx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.rx_buf = (unsigned long)rx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed recieving message\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_read_name_conflict(libsoc_spi *spi, uint8_t *rx, int length) {\n  int result;\n  struct spi_ioc_transfer spi_transfer;\n\n  libsoc_spi_debug(\"libsoc_spi_read_name_conflict\", spi,\n                   \"performing read transfer of %d bytes\", length);\n\n  if (spi == NULL || rx == NULL) {\n    libsoc_spi_debug(\"libsoc_spi_read_name_conflict\", spi, \"spi or rx was NULL\");\n    return 1;\n  }\n\n  if (length <= 0) {\n    libsoc_spi_debug(\"libsoc_spi_read_name_conflict\", spi, \"length was less than zero\");\n    return 1;\n  }\n\n  spi_transfer.tx_buf = (unsigned long)NULL;\n  spi_transfer.rx_buf = (unsigned long)rx;\n  spi_transfer.len = length;\n  spi_transfer.delay_usecs = 0;\n  spi_transfer.speed_hz = 0;\n  spi_transfer.bits_per_word = 0;\n\n  result = ioctl(spi->fd, 0x40206b00, &spi_transfer);\n\n  if (result <= 0) {\n    libsoc_spi_debug(\"libsoc_spi_read_name_conflict\", spi, \"failed recieving message\");\n    return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_rw(spi *spi, uint8_t *tx, uint8_t *rx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing duplex rw transfer of %d bytes\", len);\n    if (spi == ((void *)0) || rx == ((void *)0) || tx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi | rx | tx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.rx_buf = (unsigned long)rx, .tx_buf = (unsigned long)tx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed duplex transfer\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_rw_name_conflict(libsoc_spi *spi, uint8_t *tx, uint8_t *rx, int length) {\n  int ret;\n  struct spi_ioc_transfer spi_transfer;\n\n  libsoc_spi_debug(\"libsoc_spi_rw_name_conflict\", spi,\n                   \"performing duplex rw transfer of %d bytes\", length);\n\n  if (spi == NULL || rx == NULL || tx == NULL) {\n    libsoc_spi_debug(\"libsoc_spi_rw_name_conflict\", spi, \"spi | rx | tx was NULL\");\n    return 1;\n  }\n\n  if (length <= 0) {\n    libsoc_spi_debug(\"libsoc_spi_rw_name_conflict\", spi, \"length was less than zero\");\n    return 1;\n  }\n\n  spi_transfer.tx_buf = (unsigned long)tx;\n  spi_transfer.rx_buf = (unsigned long)rx;\n  spi_transfer.len = length;\n  spi_transfer.delay_usecs = 0;\n  spi_transfer.speed_hz = 0;\n  spi_transfer.bits_per_word = 0;\n\n  ret = ioctl(spi->fd, 0x40206b00, &spi_transfer);\n\n  if (ret <= 0) {\n    libsoc_spi_debug(\"libsoc_spi_rw_name_conflict\", spi, \"failed duplex transfer\");\n    return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_free(spi *spi) {\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"freeing spi device\");\n    if (file_close(spi->fd) < 0)\n        return 1;\n    free(spi);\n    return 0;\n}\n","function_prediction":"int libsoc_spi_free_name_conflict(libsoc_spi *spi) {\n  if (spi == NULL) {\n    libsoc_spi_debug(\"libsoc_spi_free_name_conflict\", spi, \"spi was not valid\");\n    return 1;\n  }\n\n  libsoc_spi_debug(\"libsoc_spi_free_name_conflict\", spi, \"freeing spi device\");\n\n  if (file_close(spi->fd) < 0) {\n    return 1;\n  }\n\n  free(spi);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"void libsoc_get_debug_name_conflict(void) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmckaskill/libsoc/refs/heads/master/src/libsoc-debug.c\"\n  puts(\"libsoc-debug: warning debug support missing!\");\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"uint8_t read_status_register(spi *spi_dev) {\n    printf(\"Reading STATUS register\\n\");\n    tx[0] = 5;\n    tx[1] = 0;\n    rx[0] = 0;\n    rx[1] = 0;\n    libsoc_spi_rw(spi_dev, tx, rx, 2);\n    printf(\"STATUS is 0x%02x\\n\", rx[1]);\n    return rx[1];\n}\n","function_prediction":"uint8_t read_status_register_name_conflict(libsoc_spi *spi) {\n  printf(\"Reading STATUS register\\n\");\n  tx[0] = 0x05;\n  tx[1] = 0x00;\n  rx[0] = 0x00;\n  rx[1] = 0x00;\n  libsoc_spi_rw(spi, tx, rx, 2);\n  printf(\"STATUS is 0x%02x\\n\", rx[1]);\n  return rx[1];\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int write_page(spi *spi_dev, uint16_t page_address, uint8_t *data, int len) {\n    printf(\"Writing to page %d\\n\", page_address);\n    page_address = page_address * 32;\n    tx[0] = 2;\n    tx[1] = (page_address >> 8);\n    tx[2] = page_address;\n    if (len > 32) {\n        printf(\"Page size is 32 bytes\\n\");\n        return 1;\n    }\n    int i;\n    for (i = 0; i < len; i++) {\n        tx[(i + 3)] = data[i];\n    }\n    libsoc_spi_write(spi_dev, tx, (len + 3));\n    int status;\n    do {\n        status = read_status_register(spi_dev);\n        if (status & 1) {\n            printf(\"Write in progress...\\n\");\n        } else {\n            printf(\"Write finished...\\n\");\n        }\n    } while (status & 1);\n    return 0;\n}\n","function_prediction":"int write_page(libsoc_spi_t *spi, unsigned short page, unsigned char *data,\n               int size) {\n  int i;\n  unsigned char status;\n\n  printf(\"Writing to page %d\\n\", page);\n\n  tx[0] = 0x02;\n  tx[1] = (page << 5) >> 8;\n  tx[2] = page << 5;\n\n  if (size > 32) {\n    printf(\"Page size is 32 bytes\\n\");\n    return 1;\n  }\n\n  for (i = 0; i < size; i++) {\n    tx[i + 3] = data[i];\n  }\n\n  libsoc_spi_write(spi, tx, size + 3);\n\n  do {\n    status = read_status_register(spi);\n\n    if (status & 0x01) {\n      printf(\"Write in progress...\\n\");\n    } else {\n      printf(\"Write finished...\\n\");\n    }\n  } while (status & 0x01);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int read_page(spi *spi_dev, uint16_t page_address, uint8_t *data, int len) {\n    printf(\"Reading page address %d\\n\", page_address);\n    tx[0] = 3;\n    page_address = page_address * 32;\n    tx[1] = (page_address >> 8);\n    tx[2] = page_address;\n    libsoc_spi_rw(spi_dev, tx, rx, (len + 3));\n    int i;\n    for (i = 0; i < len; i++) {\n        data[i] = rx[(i + 3)];\n    }\n    return 0;\n}\n","function_prediction":"int read_page(libsoc_spi_t *spi, unsigned short page, unsigned char *data,\n              int len) {\n  int i;\n\n  printf(\"Reading page address %d\\n\", page);\n\n  tx[0] = 0x03;\n  tx[1] = (page << 5) >> 8;\n  tx[2] = page << 5;\n\n  libsoc_spi_rw(spi, tx, rx, len + 3);\n\n  for (i = 0; i < len; i++)\n    data[i] = rx[i + 3];\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int set_write_enable(spi *spi_dev) {\n    tx[0] = 6;\n    printf(\"Setting write enable bit\\n\");\n    libsoc_spi_write(spi_dev, tx, 1);\n    return 0;\n}\n","function_prediction":"int set_write_enable_name_conflict(libsoc_spi *spi) {\n\n  tx[0] = 0x06;\n  puts(\"Setting write enable bit\");\n  libsoc_spi_write(spi, tx, 1);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int file_open_name_conflict(const char *path, int flags) {\n  int fd;\n\n  fd = open(path, flags);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return fd;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"int file_write_name_conflict(int fd, const char *buf, int len) {\n  int ret;\n\n  ret = write(fd, buf, len);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_valid_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int file_close_name_conflict(int fd) {\n  if (close(fd) < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"int file_read_int_fd_name_conflict(int fd, int *i) {\n  char buf[20];\n  int r;\n\n  r = file_read(fd, buf, 20);\n  if (r < 0)\n    return 1;\n  *i = atoi(buf);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_int_path_name_conflict(const char *path, int *value) {\n  int fd;\n  int ret;\n\n  fd = file_open(path, _init);\n  if (fd < 0)\n    return 1;\n\n  ret = file_read_int_fd(fd, value);\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  if (ret == 1)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_fd_name_conflict(int fd, int value) {\n  char buffer[20];\n  sprintf(buffer, \"%d\", value);\n  if (file_write(fd, buffer, 20) < 0)\n    return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_path_name_conflict(const char *path, int value) {\n  int fd;\n  int ret;\n\n  fd = file_open(path, 0644);\n  if (fd < 0)\n    return 1;\n\n  ret = file_write_int_fd(fd, value);\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  if (ret == 1)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_str_name_conflict(char *filename, char *buf, int len) {\n  int fd;\n\n  if ((fd = file_open(filename, _init)) < 0)\n    return 1;\n\n  if (file_read(fd, buf, len) < 0)\n    return 1;\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_str_name_conflict(const char *path, const char *str, int len) {\n  int fd;\n\n  fd = file_open(path, 0644);\n  if (fd < 0)\n    return 1;\n\n  if (file_write(fd, str, len) < 0)\n    return 1;\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"char *file_read_contents_name_conflict(const char *filename) {\n  struct stat st;\n  int fd;\n  char *buf;\n\n  if (stat(filename, &st)) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  fd = file_open(filename, 0);\n  if (fd < 0)\n    return NULL;\n\n  buf = malloc(st.st_size);\n  if (!buf)\n    return NULL;\n\n  if (file_read(fd, buf, st.st_size) != st.st_size) {\n    free(buf);\n    return NULL;\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"void libsoc_get_debug_name_conflict(void) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmckaskill/libsoc/refs/heads/master/src/libsoc-debug.c\"\n  puts(\"libsoc-debug: warning debug support missing!\");\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int file_open_name_conflict(const char *path, int flags) {\n  int fd;\n\n  fd = open(path, flags);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return fd;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"int file_write_name_conflict(int fd, const char *buf, int len) {\n  int ret;\n\n  ret = write(fd, buf, len);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_valid_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int file_close_name_conflict(int fd) {\n  if (close(fd) < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"int file_read_int_fd_name_conflict(int fd, int *i) {\n  char buf[20];\n  int r;\n\n  r = file_read(fd, buf, 20);\n  if (r < 0)\n    return 1;\n  *i = atoi(buf);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_int_path_name_conflict(const char *path, int *value) {\n  int fd;\n  int ret;\n\n  fd = file_open(path, _init);\n  if (fd < 0)\n    return 1;\n\n  ret = file_read_int_fd(fd, value);\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  if (ret == 1)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_fd_name_conflict(int fd, int value) {\n  char buffer[20];\n  sprintf(buffer, \"%d\", value);\n  if (file_write(fd, buffer, 20) < 0)\n    return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_path_name_conflict(const char *path, int value) {\n  int fd;\n  int ret;\n\n  fd = file_open(path, 0644);\n  if (fd < 0)\n    return 1;\n\n  ret = file_write_int_fd(fd, value);\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  if (ret == 1)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_str_name_conflict(char *filename, char *buf, int len) {\n  int fd;\n\n  if ((fd = file_open(filename, _init)) < 0)\n    return 1;\n\n  if (file_read(fd, buf, len) < 0)\n    return 1;\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_str_name_conflict(const char *path, const char *str, int len) {\n  int fd;\n\n  fd = file_open(path, 0644);\n  if (fd < 0)\n    return 1;\n\n  if (file_write(fd, str, len) < 0)\n    return 1;\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"char *file_read_contents_name_conflict(const char *filename) {\n  struct stat st;\n  int fd;\n  char *buf;\n\n  if (stat(filename, &st)) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  fd = file_open(filename, 0);\n  if (fd < 0)\n    return NULL;\n\n  buf = malloc(st.st_size);\n  if (!buf)\n    return NULL;\n\n  if (file_read(fd, buf, st.st_size) != st.st_size) {\n    free(buf);\n    return NULL;\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"void libsoc_get_debug_name_conflict(void) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmckaskill/libsoc/refs/heads/master/src/libsoc-debug.c\"\n  puts(\"libsoc-debug: warning debug support missing!\");\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int file_open_name_conflict(const char *path, int flags) {\n  int fd;\n\n  fd = open(path, flags);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return fd;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"int file_write_name_conflict(int fd, const char *buf, int len) {\n  int ret;\n\n  ret = write(fd, buf, len);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_valid_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int file_close_name_conflict(int fd) {\n  if (close(fd) < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"int file_read_int_fd_name_conflict(int fd, int *i) {\n  char buf[20];\n  int r;\n\n  r = file_read(fd, buf, 20);\n  if (r < 0)\n    return 1;\n  *i = atoi(buf);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_int_path_name_conflict(const char *path, int *value) {\n  int fd;\n  int ret;\n\n  fd = file_open(path, _init);\n  if (fd < 0)\n    return 1;\n\n  ret = file_read_int_fd(fd, value);\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  if (ret == 1)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_fd_name_conflict(int fd, int value) {\n  char buffer[20];\n  sprintf(buffer, \"%d\", value);\n  if (file_write(fd, buffer, 20) < 0)\n    return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_path_name_conflict(const char *path, int value) {\n  int fd;\n  int ret;\n\n  fd = file_open(path, 0644);\n  if (fd < 0)\n    return 1;\n\n  ret = file_write_int_fd(fd, value);\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  if (ret == 1)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_str_name_conflict(char *filename, char *buf, int len) {\n  int fd;\n\n  if ((fd = file_open(filename, _init)) < 0)\n    return 1;\n\n  if (file_read(fd, buf, len) < 0)\n    return 1;\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_str_name_conflict(const char *path, const char *str, int len) {\n  int fd;\n\n  fd = file_open(path, 0644);\n  if (fd < 0)\n    return 1;\n\n  if (file_write(fd, str, len) < 0)\n    return 1;\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"char *file_read_contents_name_conflict(const char *filename) {\n  struct stat st;\n  int fd;\n  char *buf;\n\n  if (stat(filename, &st)) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  fd = file_open(filename, 0);\n  if (fd < 0)\n    return NULL;\n\n  buf = malloc(st.st_size);\n  if (!buf)\n    return NULL;\n\n  if (file_read(fd, buf, st.st_size) != st.st_size) {\n    free(buf);\n    return NULL;\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"pwm *libsoc_pwm_request(unsigned int chip, unsigned int pwm_num, shared_mode mode) {\n    pwm *new_pwm;\n    char tmp_str[256];\n    int shared = 0;\n    if (mode != LS_PWM_SHARED && mode != LS_PWM_GREEDY && mode != LS_PWM_WEAK) {\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"mode was not set, or invalid, setting mode to LS_PWM_SHARED\");\n        mode = LS_PWM_SHARED;\n    }\n    libsoc_pwm_debug(__func__, chip, pwm_num, \"requested PWM\");\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n    if (file_valid(tmp_str)) {\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"PWM already exported\");\n        switch (mode) {\n          case LS_PWM_WEAK:\n            {\n                return ((void *)0);\n            }\n          case LS_PWM_SHARED:\n            {\n                shared = 1;\n                break;\n            }\n          default:\n            {\n                break;\n            }\n        }\n    } else {\n        sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/export\", chip);\n        if (file_write_int_path(tmp_str, pwm_num) == 1) {\n            libsoc_pwm_debug(__func__, chip, pwm_num, \"write failed\");\n            return ((void *)0);\n        }\n        sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n        if (!file_valid(tmp_str)) {\n            libsoc_pwm_debug(__func__, chip, pwm_num, \"failed to export PWM\");\n            perror(\"libsoc-pwm-debug\");\n            return ((void *)0);\n        }\n    }\n    new_pwm = malloc(sizeof(pwm));\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n    new_pwm->enable_fd = file_open(tmp_str, 1052672 | 2);\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/period\", chip, pwm_num);\n    new_pwm->period_fd = file_open(tmp_str, 1052672 | 2);\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/duty_cycle\", chip, pwm_num);\n    new_pwm->duty_fd = file_open(tmp_str, 1052672 | 2);\n    if (new_pwm->enable_fd < 0 || new_pwm->period_fd < 0 || new_pwm->duty_fd < 0) {\n        free(new_pwm);\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"Failed to open pwm sysfs file: %d\", new_pwm->enable_fd);\n        return ((void *)0);\n    }\n    new_pwm->chip = chip;\n    new_pwm->pwm = pwm_num;\n    new_pwm->shared = shared;\n    return new_pwm;\n}\n","function_prediction":"pwm_t *libsoc_pwm_request_name_conflict(int chip, int pwm, int mode) {\n  char path[256];\n  pwm_t *pwm_handle;\n  int exported = 0;\n\n  if (mode != 0 && mode != 1 && mode != 2) {\n    libsoc_pwm_debug(\n        \"libsoc_pwm_request_name_conflict\", chip, pwm,\n        \"mode was not set, or invalid, setting mode to LS_PWM_SHARED\");\n    mode = 0;\n  }\n\n  libsoc_pwm_debug(\"libsoc_pwm_request_name_conflict\", chip, pwm, \"requested PWM\");\n\n  sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm);\n\n  if (!file_valid(path)) {\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/export\", chip);\n\n    if (file_write_int_path(path, pwm) == 1) {\n      libsoc_pwm_debug(\"libsoc_pwm_request_name_conflict\", chip, pwm, \"write failed\");\n      return NULL;\n    }\n\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm);\n\n    if (!file_valid(path)) {\n      libsoc_pwm_debug(\"libsoc_pwm_request_name_conflict\", chip, pwm, \"failed to export PWM\");\n      perror(\"libsoc-pwm-debug\");\n      return NULL;\n    }\n  } else {\n    libsoc_pwm_debug(\"libsoc_pwm_request_name_conflict\", chip, pwm, \"PWM already exported\");\n\n    if (mode == 0) {\n      exported = 1;\n    } else if (mode == 2) {\n      return NULL;\n    }\n  }\n\n    pwm_handle = malloc(size","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_free(pwm *pwm) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"freeing pwm\");\n    if (file_close(pwm->enable_fd) < 0) {\n        return 1;\n    }\n    if (file_close(pwm->period_fd) < 0) {\n        return 1;\n    }\n    if (file_close(pwm->duty_fd) < 0) {\n        return 1;\n    }\n    if (pwm->shared == 1) {\n        free(pwm);\n        return 0;\n    }\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/unexport\", pwm->chip);\n    file_write_int_path(path, pwm->pwm);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d\", pwm->chip, pwm->pwm);\n    if (file_valid(path)) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"freeing failed\");\n        return 1;\n    }\n    free(pwm);\n    return 0;\n}\n","function_prediction":"int libsoc_pwm_free_name_conflict(pwm *p) {\n  int ret;\n  char path[256];\n\n  if (p == NULL) {\n    libsoc_pwm_debug(\"libsoc_pwm_free_name_conflict\", -1, -1, \"invalid pwm pointer\");\n    return 1;\n  }\n\n  libsoc_pwm_debug(\"libsoc_pwm_free_name_conflict\", p->chip, p->channel, \"freeing pwm\");\n\n  ret = file_close(p->period_fd);\n  if (ret < 0) {\n    return 1;\n  }\n\n  ret = file_close(p->duty_fd);\n  if (ret < 0) {\n    return 1;\n  }\n\n  ret = file_close(p->polarity_fd);\n  if (ret < 0) {\n    return 1;\n  }\n\n  if (p->auto_free == 1) {\n    free(p);\n    return 0;\n  }\n\n  sprintf(path, \"/sys/class/pwm/pwmchip%d/unexport\", p->chip);\n  file_write_int_path(path, p->channel);\n\n  sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d\", p->chip, p->channel);\n  ret = file_valid(path);\n  if (ret == 0) {\n    free(p);\n    return 0;\n  }\n\n  libsoc_pwm_debug(\"libsoc_pwm_free_name_conflict\", p->chip, p->channel, \"freeing failed\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_enabled(pwm *pwm, pwm_enabled enabled) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    if (enabled != ENABLED && enabled != DISABLED) {\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting enabled to %s\", pwm_enabled_strings[enabled]);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", pwm->chip, pwm->pwm);\n    return file_write_str(path, pwm_enabled_strings[enabled], 1);\n}\n","function_prediction":"int libsoc_pwm_set_enabled_name_conflict(pwm *p, int enabled) {\n  char path[256];\n\n  if (p == NULL) {\n    libsoc_pwm_debug(\"libsoc_pwm_set_enabled_name_conflict\", -1, -1, \"invalid pwm pointer\");\n    return 1;\n  }\n\n  if (enabled != 1 && enabled != 0) {\n    return 1;\n  }\n\n  libsoc_pwm_debug(\"libsoc_pwm_set_enabled_name_conflict\", p->chip, p->channel,\n                   \"setting enabled to %s\", pwm_enabled_strings[enabled]);\n\n  sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", p->chip, p->channel);\n  return file_write_str(path, pwm_enabled_strings[enabled], 1);\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"pwm_enabled libsoc_pwm_get_enabled(pwm *pwm) {\n    int val;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return ENABLED_ERROR;\n    }\n    if (file_read_int_fd(pwm->enable_fd, &val) == 1) {\n        return ENABLED_ERROR;\n    }\n    if (val == 1) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"read as enabled\");\n        return ENABLED;\n    } else if (val == 0) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"read as disabled\");\n        return DISABLED;\n    } else {\n        return ENABLED_ERROR;\n    }\n}\n","function_prediction":"int libsoc_pwm_get_enabled_name_conflict(pwm *p) {\n  int rc;\n  int enabled;\n\n  if (p == NULL) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_enabled_name_conflict\", -1, -1, \"invalid pwm pointer\");\n    return -1;\n  }\n\n  rc = file_read_int_fd(p->fd, &enabled);\n  if (rc == 1) {\n    return -1;\n  }\n\n  if (enabled == 1) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_enabled_name_conflict\", p->debug_enable, p->debug_level,\n                     \"read as enabled\");\n    return 1;\n  } else if (enabled == 0) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_enabled_name_conflict\", p->debug_enable, p->debug_level,\n                     \"read as disabled\");\n    return 0;\n  } else {\n    return -1;\n  }\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_period(pwm *pwm, unsigned int period) {\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting period to %d\", period);\n    return file_write_int_fd(pwm->period_fd, period);\n}\n","function_prediction":"int libsoc_pwm_set_period_name_conflict(pwm *p, int period) {\n  if (p == NULL) {\n    libsoc_pwm_debug(\"libsoc_pwm_set_period_name_conflict\", -1, -1, \"invalid pwm pointer\");\n    return 1;\n  }\n\n  libsoc_pwm_debug(\"libsoc_pwm_set_period_name_conflict\", p->debug_path, p->debug_line,\n                   \"setting period to %d\", period);\n\n  return file_write_int_fd(p->period_fd, period);\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_duty_cycle(pwm *pwm, unsigned int duty) {\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting duty to %d\", duty);\n    return file_write_int_fd(pwm->duty_fd, duty);\n}\n","function_prediction":"int libsoc_pwm_set_duty_cycle_name_conflict(pwm *p, int duty) {\n  if (p == NULL) {\n    libsoc_pwm_debug(\"libsoc_pwm_set_duty_cycle_name_conflict\", -1, -1,\n                     \"invalid pwm pointer\");\n    return 1;\n  }\n\n  libsoc_pwm_debug(\"libsoc_pwm_set_duty_cycle_name_conflict\", p->debug_path, p->debug_line,\n                   \"setting duty to %d\", duty);\n\n  return file_write_int_fd(p->duty_fd, duty);\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_period(pwm *pwm) {\n    int period = -1;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return -1;\n    }\n    file_read_int_fd(pwm->period_fd, &period);\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got period as %d\", period);\n    return period;\n}\n","function_prediction":"int libsoc_pwm_get_period_name_conflict(pwm *p) {\n  int period = -1;\n\n  if (p == NULL) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_period_name_conflict\", p->debug_enabled, p->debug_level,\n                     \"invalid pwm pointer\");\n    return -1;\n  }\n\n  file_read_int_fd(p->period_fd, &period);\n\n  libsoc_pwm_debug(\"libsoc_pwm_get_period_name_conflict\", p->debug_enabled, p->debug_level,\n                   \"got period as %d\", period);\n\n  return period;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_duty_cycle(pwm *pwm) {\n    int duty = -1;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return -1;\n    }\n    file_read_int_fd(pwm->duty_fd, &duty);\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got duty as %d\", duty);\n    return duty;\n}\n","function_prediction":"int libsoc_pwm_get_duty_cycle_name_conflict(pwm *p) {\n  int duty = -1;\n\n  if (p == NULL) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_duty_cycle_name_conflict\", -1, -1,\n                     \"invalid pwm pointer\");\n    return -1;\n  }\n\n  file_read_int_fd(p->duty_fd, &duty);\n\n  libsoc_pwm_debug(\"libsoc_pwm_get_duty_cycle_name_conflict\", p->number, p->chip,\n                   \"got duty as %d\", duty);\n\n  return duty;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_polarity(pwm *pwm, pwm_polarity polarity) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    if (polarity != NORMAL && polarity != INVERSED) {\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting polarity to %s\", pwm_polarity_strings[polarity]);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", pwm->chip, pwm->pwm);\n    return file_write_str(path, pwm_polarity_strings[polarity], 256);\n}\n","function_prediction":"int libsoc_pwm_set_polarity_name_conflict(pwm *p, int polarity) {\n  char path[256];\n\n  if (p == NULL) {\n    libsoc_pwm_debug(\"libsoc_pwm_set_polarity_name_conflict\", -1, -1, \"invalid pwm pointer\");\n    return 1;\n  }\n\n  if (polarity != 0 && polarity != 1) {\n    return 1;\n  }\n\n  libsoc_pwm_debug(\"libsoc_pwm_set_polarity_name_conflict\", p->chip, p->channel,\n                   \"setting polarity to %s\", pwm_polarity_strings[polarity]);\n\n  sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", p->chip, p->channel);\n  return file_write_str(path, pwm_polarity_strings[polarity], 256);\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_polarity(pwm *pwm) {\n    int polarity;\n    char path[256];\n    char tmp_str[1];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", pwm->chip, pwm->pwm);\n    if (file_read_str(path, tmp_str, 1) == 1) {\n        return POLARITY_ERROR;\n    }\n    if (strncmp(tmp_str, \"i\", 1) == 0) {\n        polarity = INVERSED;\n    } else if (strncmp(tmp_str, \"n\", 1) == 0) {\n        polarity = NORMAL;\n    } else {\n        polarity = POLARITY_ERROR;\n    }\n    if (polarity > 0) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got polarity as %s\", pwm_polarity_strings[polarity]);\n    } else {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"getting polarity failed\");\n    }\n    return polarity;\n}\n","function_prediction":"int libsoc_pwm_get_polarity_name_conflict(pwm *p) {\n  int polarity;\n  char buf[256];\n  char polarity_str;\n\n  if (p == NULL) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_polarity_name_conflict\", -1, -1, \"invalid pwm pointer\");\n    return 1;\n  }\n\n  sprintf(buf, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", p->chip, p->channel);\n\n  if (file_read_str(buf, &polarity_str, 1) == 1) {\n    return -1;\n  }\n\n  if (polarity_str == 'i') {\n    polarity = 1;\n  } else if (polarity_str == 'o') {\n    polarity = 0;\n  } else {\n    return -1;\n  }\n\n  if (polarity > 0) {\n    libsoc_pwm_debug(\"libsoc_pwm_get_polarity_name_conflict\", p->chip, p->channel,\n                     \"got polarity as %s\", pwm_polarity_strings[polarity]);\n  } else {\n    libsoc_pwm_debug(\"libsoc_pwm_get_polarity_name_conflict\", p->chip, p->channel,\n                     \"getting polarity failed\");\n  }\n\n  return polarity;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"void libsoc_get_debug_name_conflict(void) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmckaskill/libsoc/refs/heads/master/src/libsoc-debug.c\"\n  puts(\"libsoc-debug: warning debug support missing!\");\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int file_open_name_conflict(const char *path, int flags) {\n  int fd;\n\n  fd = open(path, flags);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return fd;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"int file_write_name_conflict(int fd, const char *buf, int len) {\n  int ret;\n\n  ret = write(fd, buf, len);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_valid_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int file_close_name_conflict(int fd) {\n  if (close(fd) < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"int file_read_int_fd_name_conflict(int fd, int *i) {\n  char buf[20];\n  int r;\n\n  r = file_read(fd, buf, 20);\n  if (r < 0)\n    return 1;\n  *i = atoi(buf);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_int_path_name_conflict(const char *path, int *value) {\n  int fd;\n  int ret;\n\n  fd = file_open(path, _init);\n  if (fd < 0)\n    return 1;\n\n  ret = file_read_int_fd(fd, value);\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  if (ret == 1)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_fd_name_conflict(int fd, int value) {\n  char buffer[20];\n  sprintf(buffer, \"%d\", value);\n  if (file_write(fd, buffer, 20) < 0)\n    return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_path_name_conflict(const char *path, int value) {\n  int fd;\n  int ret;\n\n  fd = file_open(path, 0644);\n  if (fd < 0)\n    return 1;\n\n  ret = file_write_int_fd(fd, value);\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  if (ret == 1)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_str_name_conflict(char *filename, char *buf, int len) {\n  int fd;\n\n  if ((fd = file_open(filename, _init)) < 0)\n    return 1;\n\n  if (file_read(fd, buf, len) < 0)\n    return 1;\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_str_name_conflict(const char *path, const char *str, int len) {\n  int fd;\n\n  fd = file_open(path, 0644);\n  if (fd < 0)\n    return 1;\n\n  if (file_write(fd, str, len) < 0)\n    return 1;\n\n  if (file_close(fd) < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"char *file_read_contents_name_conflict(const char *filename) {\n  struct stat st;\n  int fd;\n  char *buf;\n\n  if (stat(filename, &st)) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  fd = file_open(filename, 0);\n  if (fd < 0)\n    return NULL;\n\n  buf = malloc(st.st_size);\n  if (!buf)\n    return NULL;\n\n  if (file_read(fd, buf, st.st_size) != st.st_size) {\n    free(buf);\n    return NULL;\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"void libsoc_get_debug_name_conflict(void) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmckaskill/libsoc/refs/heads/master/src/libsoc-debug.c\"\n  puts(\"libsoc-debug: warning debug support missing!\");\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":1,"function":"static int wait_for_process(pid_t pid) {\n    int rv = 70;\n    int stats = 0;\n    int i = 0;\n    struct sigaction sig_handler;\n    sig_handler.__sigaction_handler.sa_handler = caught_signal;\n    sig_handler.sa_flags = 0;\n    sigaction(14, &sig_handler, ((void *)0));\n    sigaction(1, &sig_handler, ((void *)0));\n    sigaction(2, &sig_handler, ((void *)0));\n    sigaction(15, &sig_handler, ((void *)0));\n    sigaction(13, &sig_handler, ((void *)0));\n    for (i = 0; ; i++) {\n        pid_t p = waitpid(pid, &stats, 0);\n        if (p == pid) {\n            rv = (((stats) & 127) == 0) ? (((stats) & 65280) >> 8) : (128 | ((stats) & 127));\n            break;\n        } else {\n            int sig = 0;\n            switch (i) {\n              case 0:\n                sig = caught > 0 ? caught : 15;\n                if (caught == 14) {\n                    fprintf(stderr, \"Timeout.. killing the process\\n\");\n                }\n                break;\n              case 1:\n                sig = 15;\n                break;\n              default:\n                sig = 9;\n                break;\n            }\n            if (kill(pid, sig) < 0) {\n                perror(\"lost child when trying to kill\");\n            }\n            alarm(5);\n        }\n    }\n    return rv;\n}\n","function_prediction":"int wait_for_process_name_conflict(pid_t pid) {\n  int status = 0;\n  int i = 0;\n  int ret = 0;\n  int sig = 0;\n  struct sigaction act;\n  act.sa_handler = caught_signal;\n  act.sa_flags = 0;\n  sigaction(14, &act, NULL);\n  sigaction(1, &act, NULL);\n  sigaction(2, &act, NULL);\n  sigaction(15, &act, NULL);\n  sigaction(13, &act, NULL);\n\n  for (i = 0;; i++) {\n    ret = waitpid(pid, &status, 0);\n    if (ret == pid)\n      break;\n    if (i == 0)\n      sig = caught;\n    else if (i == 1)\n      sig = 15;\n    else\n      sig = 9;\n    if (sig < 1)\n      sig = 15;\n    if (sig == 14)\n      fprintf(stderr, \"Timeout.. killing the process\\n\");\n    if (kill(pid, sig) < 0)\n      perror(\"lost child when trying to kill\");\n    alarm(5);\n  }\n\n  if (status & 0x7F)\n    ret = (status & 0x7F) | 0x80;\n  else\n    ret = (status >> 8) & 0xFF;\n\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/shelsonjava_memcached/timedrun.c"}
{"compilable":0,"function":"unsigned int hamdist(unsigned int x, unsigned int y) {\n    unsigned int dist = 0, val = x ^ y;\n    while (val)\n        {\n            ++dist;\n            val &= val - 1;\n        }\n    return dist;\n}\n","function_prediction":"int hamdist_name_conflict(uint32_t a, uint32_t b) {\n  int dist = 0;\n  uint32_t val = a ^ b;\n\n  while (val) {\n    dist++;\n    val &= val - 1;\n  }\n\n  return dist;\n}","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Hamming_Distance/C/Arpan-Patel/HammingDistance.c"}
{"compilable":1,"function":"int partition(int a[], int lo, int hi) {\n    int i = lo, j = hi + 1, temp;\n    while (1)\n        {\n            while (a[++i] < a[lo])\n                {\n                    if (i == hi)\n                        break;\n                }\n            ;\n            while (a[lo] < a[--j])\n                {\n                    if (j == lo)\n                        break;\n                }\n            if (i >= j)\n                break;\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n        }\n    temp = a[lo];\n    a[lo] = a[j];\n    a[j] = temp;\n    return j;\n}\n","function_prediction":"int partition_name_conflict(int *a, int left, int right) {\n  int i = left, j = right + 1;\n  int pivot = a[left];\n  int temp;\n\n  while (1) {\n    while (a[++i] < pivot) {\n      if (i == right)\n        break;\n    }\n\n    while (a[--j] > pivot) {\n      if (j == left)\n        break;\n    }\n\n    if (i >= j)\n      break;\n\n    temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n  }\n\n  temp = a[left];\n  a[left] = a[j];\n  a[j] = temp;\n\n  return j;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Quick_Sort/C/jonathanlebron/quick_sort.c"}
{"compilable":1,"function":"int parent(int i) {\n    return (int)((i + 1) / 2) - 1;\n}\n","function_prediction":"int parent_name_conflict(int i) { return (i + 1) / 2 - 1; }","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":1,"function":"int left(int i) {\n    return i * 2 + 1;\n}\n","function_prediction":"int left_name_conflict(int i) { return 2 * i + 1; }","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":1,"function":"int right(int i) {\n    return 2 * i + 2;\n}\n","function_prediction":"int right_name_conflict(int i) { return (i + 1) * 2; }","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":1,"function":"int test_sorted_array(int *array, int size) {\n    int i;\n    for (i = 0; i < size - 2; i++) {\n        if (array[i] > array[i + 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"int test_sorted_array_name_conflict(int *array, int size) {\n  int i;\n\n  for (i = 0; i < size - 2; i++) {\n    if (array[i] > array[i + 1])\n      return 0;\n  }\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":0,"function":"int BinarySearch(TypeArray a[], TypeArray key, int first, int last) {\n    if (first > last)\n        return -1;\n    ;\n    int length = last - first + 1;\n    int midIndex = (first + last) / 2;\n    TypeArray midValue = a[midIndex];\n    if (key > midValue) {\n        return BinarySearch(a, key, midIndex + 1, last);\n    } else if (key < midValue) {\n        return BinarySearch(a, key, first, midIndex - 1);\n    } else\n        return midIndex;\n}\n","function_prediction":"void BinarySearchTest() {\n  int array[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n  int array2[] = {-1, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  int array3[] = {1, 4, 100, 1138};\n  int array4[] = {1, 2, 3, 4};\n  int array5[] = {1, 2, 3, 4};\n  int array6[] = {1, 2, 3, 4};\n  int array7[] = {1, 2, 3, 4};\n  int array8[] = {1, 2, 3, 4};\n  int array9[] = {1, 2, 3, 4};\n  int array10[] = {1, 2, 3, 4};\n  int array11[] = {1, 2, 3, 4};\n  int array12[] = {1, 2, 3, 4};\n  int array13[] = {1, 2, 3, 4};\n  int array14[] = {1, 2, 3, 4};\n  int array15[] = {1, 2, 3, 4};\n  int array16[] = {1, 2, 3, 4};\n  int array17[] = {1, 2, 3, 4};\n  int array18[] = {1, 2, 3, 4};\n  int array19[] = {1, 2, 3, 4};\n  int array20[] = {1, 2, 3, 4};\n  int array21[] = {1, 2, 3, 4};\n  int array22[] = {1, 2, 3, 4};\n  int array23[] = {1, 2, 3, 4};\n  int array24[] = { 1, 2,","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Binary_Search/C/mariolamacchia/binarysearch.c"}
{"compilable":1,"function":"int gcd_division(int a, int b) {\n    while (b != 0)\n        {\n            int tmp = a;\n            a = b;\n            b = tmp % b;\n        }\n    return a;\n}\n","function_prediction":"int gcd_division_name_conflict(int a, int b) {\n  int r;\n  while (b != 0) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":1,"function":"int gcd_substraction(int a, int b) {\n    while (a != b)\n        {\n            if (a > b) {\n                a = a - b;\n            } else {\n                b = b - a;\n            }\n        }\n    return a;\n}\n","function_prediction":"int gcd_substraction_name_conflict(int a, int b) {\n  while (a != b) {\n    if (a > b) {\n      a -= b;\n    } else {\n      b -= a;\n    }\n  }\n  return a;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":1,"function":"int gcd_recursive(int a, int b) {\n    return (b == 0) ? a : gcd_recursive(b, a % b);\n}\n","function_prediction":"int gcd_recursive_name_conflict(int a, int b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd_recursive_name_conflict(b, a % b);\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":1,"function":"bool test_doors(int doors[]) {\n    for (int i = 0; i <= 99; ++i) {\n        if (doors[i] && (int)sqrt(doors[i]) % 1 != 0)\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"int test_doors_name_conflict(int *doors) {\n  int i;\n  for (i = 0; i < 100; i++) {\n    if (doors[i]) {\n      sqrt(doors[i]);\n    }\n  }\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/100_Doors_Problem/C/kennyledet/100-Doors.c"}
{"compilable":1,"function":"int length(char *string) {\n    int count = 0;\n    while (string[count++] != '\\x00')\n        ;\n    return --count;\n}\n","function_prediction":"int length_name_conflict(char *s) {\n  int i = 0;\n  while (s[i] != '\\0')\n    i++;\n  return i;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":1,"function":"int exponentiation(int base, int exp) {\n    if (!exp) {\n        return 1;\n    }\n    int total = base;\n    int i = 1;\n    while (i++ < exp)\n        {\n            total *= base;\n        }\n    return total;\n}\n","function_prediction":"int exponentiation_name_conflict(int base, int exponent) {\n  int result = 1;\n  int i;\n\n  for (i = 1; i <= exponent; i++) {\n    result *= base;\n  }\n\n  return result;\n}","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":1,"function":"int parse(char *number) {\n    int size = length(number);\n    int exp = size - 1;\n    int total = 0;\n    int i;\n    for (i = 0; i < size; i++) {\n        if (number[i] >= '0' && number[i] <= '9') {\n            total += (number[i] - 48) * exponentiation(10, exp--);\n        }\n    }\n    return total;\n}\n","function_prediction":"int parse_name_conflict(char *str) {\n  int len = length(str);\n  int i, j, result = 0;\n  for (i = 0, j = len - 1; i < len; i++) {\n    if (str[i] >= '0' && str[i] <= '9') {\n      result += (str[i] - '0') * exponentiation(10, j);\n      j--;\n    }\n  }\n  return result;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":0,"function":"int linear_search(int arr[], int size, int element) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == element) {\n            return i;\n        }\n    }\n    return -1;\n}\n","function_prediction":"void linear_search_test() {\n  int a[] = {1, 3, 4, 8, 6, 5};\n  int a_size = sizeof(a) / sizeof(a[0]);\n  int empty[] = {};\n  int empty_size = sizeof(empty) / sizeof(empty[0]);\n\n  do {\n    if (!(linear_search(empty, empty_size, 3) == -1)) {\n      __assert_fail(\"linear_search(empty, empty_size, 3) == -1\",\n                    \"C_COMPILE/movb_Algorithm-Implementations/Linear_Search/C/\"\n                    \"jay754/linear_search.c\",\n                    19, \"linear_search_test\");\n    }\n  } while (0);\n  do {\n    if (!(linear_search(a, a_size, 3) == 1)) {\n      __assert_fail(\"linear_search(a, a_size, 3) == 1\",\n                    \"C_COMPILE/movb_Algorithm-Implementations/Linear_Search/C/\"\n                    \"jay754/linear_search.c\",\n                    20, \"linear_search_test\");\n    }\n  } while (0);\n  printf(\"Should return -1 = %d\\n\", linear_search(empty, empty_size, 3));\n  printf(\"Should return 1 = %d\\n\", linear_search(a, a_size, 3));\n}","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Linear_Search/C/jay754/linear_search.c"}
{"compilable":1,"function":"unsigned long long factorial(int number) {\n    if (0 == number)\n        return 1;\n    else\n        return number * factorial(number - 1);\n}\n","function_prediction":"long factorial_name_conflict(int n) {\n  if (n == 0)\n    return 1;\n  else\n    return n * factorial_name_conflict(n - 1);\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Factorial/C/harshasrisri/factorial.c"}
{"compilable":1,"function":"int fibo_r() {\n    static int a = 0, b = 1, count = 0;\n    if (0 == count) {\n        count++;\n        return a;\n    }\n    if (1 == count) {\n        count++;\n        return b;\n    }\n    return (b > a) ? (a += b) : (b += a);\n}\n","function_prediction":"int fibo_r_name_conflict(void) {\n  static int a = 0;\n  static int b = 1;\n  static int count = 0;\n\n  if (count == 0) {\n    count++;\n    return a;\n  }\n  if (count == 1) {\n    count++;\n    return b;\n  }\n  if (a < b) {\n    a = a + b;\n    return a;\n  } else {\n    b = a + b;\n    return b;\n  }\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Fibonacci_series/C/harshasrisri/fibo_r.c"}
{"compilable":1,"function":"bool isSorted(int a[], int size) {\n    for (int i = 1; i < size; i++) {\n        if (a[i] < a[i - 1])\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"int isSorted_name_conflict(int *arr, int size) {\n  int i;\n  for (i = 1; i < size; i++) {\n    if (arr[i] < arr[i - 1]) {\n      return 0;\n    }\n  }\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Bogosort/C/jonathanlebron/bogo_sort.c"}
{"compilable":1,"function":"bool test_insertion_sort(int *sequence, int sequence_length) {\n    for (int i = 1; i < sequence_length; i++) {\n        if (sequence[i] < sequence[i - 1])\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"int test_insertion_sort_name_conflict(int *array, int size) {\n  int i;\n\n  for (i = 1; i < size; i++)\n    if (array[i] < array[i - 1])\n      return 0;\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Insertion_Sort/C/kennyledet/insertion_sort.c"}
{"compilable":1,"function":"in_port_t get_port(struct sockaddr *sa) {\n    switch (sa->sa_family) {\n      case 2:\n        return ntohs(((struct sockaddr_in *)sa)->sin_port);\n      case 10:\n        return ntohs(((struct sockaddr_in6 *)sa)->sin6_port);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"uint16_t get_port_name_conflict(struct sockaddr *sa) {\n  if (sa->sa_family == 2)\n    return ntohs(((struct sockaddr_in *)sa)->sin_port);\n  else if (sa->sa_family == 10)\n    return ntohs(((struct sockaddr_in6 *)sa)->sin6_port);\n  else\n    return 0;\n}","pass":1,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":1,"function":"int is_addr_any(struct sockaddr *sa) {\n    switch (sa->sa_family) {\n      case 2:\n        return (((struct sockaddr_in *)sa)->sin_addr.s_addr == htonl(((in_addr_t)0)));\n      case 10:\n        return !memcmp(&((struct sockaddr_in6 *)sa)->sin6_addr, &in6addr_any, sizeof (in6addr_any));\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int is_addr_any_name_conflict(struct sockaddr *sa) {\n  if (sa->sa_family == 2) {\n    return sa->sa_data[0] == htonl(0);\n  } else if (sa->sa_family == 10) {\n    return !memcmp(&((struct sockaddr_in6 *)sa)->sin6_addr, &in6addr_any, 16);\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":0,"function":"int sed_the_buffer(int size, int *live) {\n    int i;\n    memmove(b2, buf, size);\n    for (i = 0; i < rules;) {\n        if (rule_live[i] == 0) {\n            i++;\n            break;\n        }\n        if (replace(b2, size, &rule[i].expression, rule[i].torig)) {\n            printf(\"\\033[32m[+] Replacing %s with %s\\n\\033[0m\", rule[i].forig, rule[i].torig);\n            rule_live[i]--;\n        }\n        i++;\n    }\n    return size;\n}\n","function_prediction":"int sed_the_buffer(int size, char *filename, char *search, char *replace,\n                   char *search_regex, char *replace_regex) {\n  int i;\n\n  memcpy(b2, buf, size);\n\n  for (i = 0; i < rules; i++) {\n    if (!rule_live[i])\n      continue;\n\n    if (replace(b2, size, &rule[i].search, rule[i].replace, search_regex,\n                replace_regex, filename)) {\n      printf(\"\\x1B[32m\"\n             \"[+] Replacing %s with %s\\n\"\n             \"\\x1B[0m\",\n             rule[i].search, rule[i].replace);\n      rule_live[i]--;\n    }\n  }\n\n  return size;\n}","pass":0,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int xpmem_init_name_conflict(void) {\n  struct stat st;\n\n  if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000 ||\n      (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_remove_name_conflict(void *addr) {\n  int ret;\n\n  ret = xpmem_ioctl(0x7802, &addr);\n  if (ret == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_release_name_conflict(void *ptr) {\n  int ret;\n\n  ret = xpmem_ioctl(0x7804, &ptr);\n  if (ret == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"int xpmem_version_name_conflict(void) { return xpmem_ioctl(0x7800, 0); }","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int xpmem_init_name_conflict(void) {\n  struct stat st;\n\n  if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000 ||\n      (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_remove_name_conflict(void *addr) {\n  int ret;\n\n  ret = xpmem_ioctl(0x7802, &addr);\n  if (ret == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_release_name_conflict(void *ptr) {\n  int ret;\n\n  ret = xpmem_ioctl(0x7804, &ptr);\n  if (ret == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"int xpmem_version_name_conflict(void) { return xpmem_ioctl(0x7800, 0); }","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int xpmem_init_name_conflict(void) {\n  struct stat st;\n\n  if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000 ||\n      (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_remove_name_conflict(void *addr) {\n  int ret;\n\n  ret = xpmem_ioctl(0x7802, &addr);\n  if (ret == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_release_name_conflict(void *ptr) {\n  int ret;\n\n  ret = xpmem_ioctl(0x7804, &ptr);\n  if (ret == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"int xpmem_version_name_conflict(void) { return xpmem_ioctl(0x7800, 0); }","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":1,"function":"int RateStatement(char *question, int *score) {\n    int response = 0;\n    printf(\"1. Agree\\n2. Nuetral\\n3. Disagree\\n\");\n    printf(\"%s: \", question);\n    scanf(\"%d\", &response);\n    switch (response) {\n      case 1:\n        *score += agree;\n        return 1;\n      case 2:\n        *score += neutral;\n        return 1;\n      case 3:\n        *score += disagree;\n      default:\n        return 0;\n    }\n    printf(\"\\n\\n\");\n}\n","function_prediction":"int RateStatement_name_conflict(char *statement, int *score) {\n  int rate = 0;\n\n  printf(\"1. Agree\\n2. Nuetral\\n3. Disagree\\n\");\n  printf(\"%s: \", statement);\n  __isoc99_scanf(\"%d\", &rate);\n\n  if (rate == 3) {\n    *score -= 5;\n  } else if (rate == 1) {\n    *score += 10;\n    return 1;\n  } else if (rate == 2) {\n    *score += 5;\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/UnrealDesign_HW1/main.c"}
{"compilable":1,"function":"int AskQuestion(char *question, int *score) {\n    int response = 0;\n    printf(\"1. Yes\\n2. No\\n\");\n    printf(\"%s: \", question);\n    scanf(\"%d\", &response);\n    switch (response) {\n      case 1:\n        *score += yes;\n        printf(\"\\n\\n\");\n        return 1;\n      case 2:\n        *score += no;\n        printf(\"\\n\\n\");\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int AskQuestion_name_conflict(char *question, int *score) {\n  int answer = 0;\n\n  printf(\"1. Yes\\n2. No\\n\");\n  printf(\"%s: \", question);\n  __isoc99_scanf(\"%d\", &answer);\n\n  if (answer == 1) {\n    *score += 15;\n    printf(\"\\n\\n\");\n    return 1;\n  } else if (answer == 2) {\n    *score -= 5;\n    printf(\"\\n\\n\");\n    return 0;\n  }\n}","pass":1,"source_file":"C_COMPILE/UnrealDesign_HW1/main.c"}
{"compilable":0,"function":"static int beenhere(int syms, int len, int left, int mem, int rem) {\n    size_t index;\n    size_t offset;\n    int bit;\n    size_t length;\n    char *vector;\n    index = (((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) + (left >> 1) - 1) * (max - 1) + len - 1);\n    mem -= 1 << root;\n    offset = (mem >> 3) + rem;\n    offset = ((offset * (offset + 1)) >> 1) + rem;\n    bit = 1 << (mem & 7);\n    length = done[index].len;\n    if (offset < length && (done[index].vec[offset] & bit) != 0)\n        return 1;\n    if (length <= offset) {\n        if (length) {\n            do {\n                length <<= 1;\n            } while (length <= offset);\n            vector = realloc(done[index].vec, length);\n            if (vector != ((void *)0))\n                memset(vector + done[index].len, 0, length - done[index].len);\n        } else {\n            length = 1 << (len - root);\n            while (length <= offset)\n                length <<= 1;\n            vector = calloc(length, sizeof(char));\n        }\n        if (vector == ((void *)0)) {\n            fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n            cleanup();\n            exit(1);\n        }\n        done[index].len = length;\n        done[index].vec = vector;\n    }\n    done[index].vec[offset] |= bit;\n    return 0;\n}\n","function_prediction":"int beenhere_name_conflict(int x, int y, int z, int w, int h) {\n  unsigned long long int i, j, k, l, m, n, o, p, q, r, s, t, u, v, ww, xx, yy,\n      zz;\n  char *x1;\n\n  i = x - 1;\n  j = y - 1;\n  k = z - 1;\n  l = w - (1 << root);\n  m = h + (l >> 3);\n  n = h + (m * (m + 1)) >> 1;\n  o = 1 << (l & 7);\n\n  p = (((i * (i - 1)) >> 1) + ((j * (j - 1)) >> 1) + ((k * (k - 1)) >> 1)) +\n      (max - 1);\n  q = done[p].size;\n  if (n < q && (done[p].data[n] & o))\n    return 1;\n  if (n >= q) {\n    if (q) {\n      while (n >= q)\n        q <<= 1;\n      x1 = realloc(done[p].data, q);\n      if (x1) {\n        memset(x1 + done[p].size, 0, q - done[p].size);\n      }\n    } else {\n      q = 1 << (y - root);\n      while (n >= q)\n        q <<= 1;\n      x1 = calloc(q, 1);\n    }\n    if (!x1) {\n      fwrite(\"abort: unable to allocate enough memory\\n\", 1, 40, stderr);\n      cleanup();\n      exit(1);\n    }\n    done[p].size = q;\n    done[p].data = x1;\n  }\n  done[p].data[n] |= o;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Sigil-Ebook_Sigil/3rdparty/zlib/examples/enough.c"}
{"compilable":1,"function":"int generateRandom(int min, int max) {\n    return rand() % (max - min + 1) + min;\n}\n","function_prediction":"int generateRandom_name_conflict(int min, int max) { return rand() % (max - min + 1) + min; }","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int getEmptyCells(struct Pos empty[], struct Square m[][4]) {\n    int i, j;\n    int n = 0;\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 4; j++)\n            if (!m[i][j].value) {\n                struct Pos temp;\n                temp.x = i;\n                temp.y = j;\n                empty[n++] = temp;\n            }\n    return n;\n}\n","function_prediction":"int getEmptyCells_name_conflict(struct cell empty[], int board[][4]) {\n  int i, j, k = 0;\n  for (i = 0; i < 4; i++) {\n    for (j = 0; j < 4; j++) {\n      if (board[i][j] == 0) {\n        empty[k].x = i;\n        empty[k].y = j;\n        k++;\n      }\n    }\n  }\n  return k;\n}","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int playerWon(struct Square m[][4]) {\n    int i, j;\n    for (i = 0; i < 4; i++) {\n        for (j = 0; j < 4; j++) {\n            if (m[i][j].value == 2048)\n                return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int playerWon_name_conflict(int board[4][4]) {\n  int i, j;\n  for (i = 0; i < 4; i++) {\n    for (j = 0; j < 4; j++) {\n      if (board[i][j] == 2048) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":1,"function":"int readMove() {\n    int move, validMove = 0;\n    while (!validMove)\n        {\n            printf(\"Make a move: moves right %d, down %d, left %d, up %d \\n\", RIGHT, DOWN, LEFT, UP);\n            scanf(\"%d\", &move);\n            if (move >= 0 && move < 3)\n                validMove = 1;\n        }\n    return move;\n}\n","function_prediction":"int readMove_name_conflict() {\n  int move;\n  int valid = 0;\n  while (!valid) {\n    printf(\"Make a move: moves right %d, down %d, left %d, up %d \\n\", 0, 1, 2,\n           3);\n    __isoc99_scanf(\"%d\", &move);\n    if (move >= 0 && move <= 2) {\n      valid = 1;\n    }\n  }\n  return move;\n}","pass":1,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":1,"function":"int gpio_export(unsigned int gpio) {\n    int fd, len;\n    char buf[64];\n    fd = open(\"/sys/class/gpio/export\", 1);\n    if (fd < 0) {\n        perror(\"gpio/export\");\n        return fd;\n    }\n    len = snprintf(buf, sizeof (buf), \"%d\", gpio);\n    write(fd, buf, len);\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_export_name_conflict(int gpio) {\n  char buffer[64];\n  ssize_t bytes_written;\n  int fd;\n\n  fd = open(\"/sys/class/gpio/export\", 1);\n  if (fd < 0) {\n    perror(\"gpio/export\");\n    return fd;\n  }\n\n  bytes_written = snprintf(buffer, 64, \"%d\", gpio);\n  write(fd, buffer, bytes_written);\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_unexport(unsigned int gpio) {\n    int fd, len;\n    char buf[64];\n    fd = open(\"/sys/class/gpio/unexport\", 1);\n    if (fd < 0) {\n        perror(\"gpio/export\");\n        return fd;\n    }\n    len = snprintf(buf, sizeof (buf), \"%d\", gpio);\n    write(fd, buf, len);\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_unexport_name_conflict(int gpio) {\n  char buffer[64];\n  ssize_t bytes_written;\n  int fd;\n\n  fd = open(\"/sys/class/gpio/unexport\", 1);\n  if (fd < 0) {\n    perror(\"gpio/export\");\n    return fd;\n  }\n\n  bytes_written = snprintf(buffer, 64, \"%d\", gpio);\n  write(fd, buffer, bytes_written);\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_set_dir(unsigned int gpio, char *ident, unsigned int out_flag) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/direction\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/direction\");\n        return fd;\n    }\n    if (out_flag)\n        write(fd, \"out\", 4);\n    else\n        write(fd, \"in\", 3);\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_set_dir_name_conflict(int pin, const char *name, int dir) {\n  char path[64];\n  int len = snprintf(path, sizeof(path), \"/sys/class/gpio/gpio%d_%s/direction\",\n                     pin, name);\n  int fd = open(path, 1);\n  if (fd < 0) {\n    perror(\"gpio/direction\");\n    return fd;\n  }\n  if (dir)\n    write(fd, \"out\", 4);\n  else\n    write(fd, \"in\", 3);\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_set_value(unsigned int gpio, char *ident, unsigned int value) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/set-value\");\n        return fd;\n    }\n    if (value)\n        write(fd, \"1\", 2);\n    else\n        write(fd, \"0\", 2);\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_set_value_name_conflict(int gpio, const char *dir, int value) {\n  char filename[64];\n  int len = snprintf(filename, sizeof(filename),\n                     \"/sys/class/gpio/gpio%d_%s/value\", gpio, dir);\n\n  int fd = open(filename, 1);\n  if (fd < 0) {\n    perror(\"gpio/set-value\");\n    return fd;\n  }\n\n  if (value)\n    write(fd, \"1\", 2);\n  else\n    write(fd, \"0\", 2);\n\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_get_value(unsigned int gpio, char *ident, unsigned int *value) {\n    int fd, len;\n    char buf[64];\n    char ch;\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 0);\n    if (fd < 0) {\n        perror(\"gpio/get-value\");\n        return fd;\n    }\n    read(fd, &ch, 1);\n    if (ch != '0') {\n        *value = 1;\n    } else {\n        *value = 0;\n    }\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_get_value_name_conflict(int gpio, const char *edge, int *value) {\n  char buf[64];\n  int len = snprintf(buf, sizeof(buf),\n                     \"/sys/class/gpio\"\n                     \"/gpio%d_%s/value\",\n                     gpio, edge);\n  char ch;\n  int fd = open(buf, 0);\n  if (fd < 0) {\n    perror(\"gpio/get-value\");\n    return fd;\n  }\n\n  read(fd, &ch, 1);\n  if (ch != '0')\n    *value = 1;\n  else\n    *value = 0;\n\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_set_edge(unsigned int gpio, char *ident, char *edge) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/edge\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/set-edge\");\n        return fd;\n    }\n    write(fd, edge, strlen(edge) + 1);\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_set_edge_name_conflict(unsigned gpio, const char *edge, const char *dir) {\n  char path[64];\n  int len = snprintf(path, sizeof(path), \"/sys/class/gpio/gpio%d_%s/edge\", gpio,\n                     edge);\n\n  int fd = open(path, 1);\n  if (fd < 0) {\n    perror(\"gpio/set-edge\");\n    return fd;\n  }\n\n  write(fd, dir, strlen(dir) + 1);\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_fd_open(unsigned int gpio, char *ident) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 0 | 2048);\n    if (fd < 0) {\n        perror(\"gpio/fd_open\");\n    }\n    return fd;\n}\n","function_prediction":"int gpio_fd_open_name_conflict(int gpio, const char *dir) {\n  char buf[64];\n  int len =\n      snprintf(buf, sizeof(buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, dir);\n  int fd = open(buf, 02000);\n  if (fd < 0)\n    perror(\"gpio/fd_open\");\n  return fd;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int gpio_fd_close(int fd) {\n    return close(fd);\n}\n","function_prediction":"void gpio_fd_close_name_conflict(int fd) { close(fd); }","pass":0,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int hello(void) {\n    return 1;\n}\n","function_prediction":"int hello_name_conflict(void) { return 1; }","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/src/hello.c"}
{"compilable":0,"function":"int UnityEnd(void) {\n    {\n        putchar('\\n');\n    }\n    ;\n    UnityPrint(UnityStrBreaker);\n    {\n        putchar('\\n');\n    }\n    ;\n    UnityPrintNumber((_U_SINT)(Unity.NumberOfTests));\n    UnityPrint(UnityStrResultsTests);\n    UnityPrintNumber((_U_SINT)(Unity.TestFailures));\n    UnityPrint(UnityStrResultsFailures);\n    UnityPrintNumber((_U_SINT)(Unity.TestIgnores));\n    UnityPrint(UnityStrResultsIgnored);\n    {\n        putchar('\\n');\n    }\n    ;\n    if (Unity.TestFailures == 0U) {\n        UnityPrintOk();\n    } else {\n        UnityPrintFail();\n    }\n    {\n        putchar('\\n');\n    }\n    ;\n    ;\n    return (int)(Unity.TestFailures);\n}\n","function_prediction":"UNITY_INT UnityEnd_name_conflict(void) {\n  putchar('\\n');\n  UnityPrint(\"-----------------------\");\n  putchar('\\n');\n  UnityPrintNumber(test_count);\n  UnityPrint(\" Tests \");\n  UnityPrintNumber(test_fail_count);\n  UnityPrint(\" Failures \");\n  UnityPrintNumber(test_ignore_count);\n  UnityPrint(\" Ignored \");\n  putchar('\\n');\n  if (test_fail_count == 0) {\n    UnityPrintOk();\n  } else {\n    UnityPrintFail();\n  }\n  putchar('\\n');\n  return test_fail_count;\n}","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity.c"}
{"compilable":0,"function":"static int selected(const char *filter, const char *name) {\n    if (filter == 0)\n        return 1;\n    return strstr(name, filter) ? 1 : 0;\n}\n","function_prediction":"int selected_name_conflict(char *name, char *selected_name_conflict_names) {\n  if (name == NULL)\n    return 1;\n  if (strstr(selected_name_conflict_names, name) != NULL)\n    return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"static int testSelected(const char *test) {\n    return selected(UnityFixture.NameFilter, test);\n}\n","function_prediction":"void testSelected_name_conflict(char *str) { selected(\"1234567890\", str); }","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"static int groupSelected(const char *group) {\n    return selected(UnityFixture.GroupFilter, group);\n}\n","function_prediction":"int groupSelected_name_conflict(char *group) { return selected(\"group\", group); }","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int UnityFailureCount(void) {\n    return Unity.TestFailures;\n}\n","function_prediction":"int UnityFailureCount_name_conflict(void) { return 0; }","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int UnityGetCommandLineOptions(int argc, const char *argv[]) {\n    int i;\n    UnityFixture.Verbose = 0;\n    UnityFixture.GroupFilter = 0;\n    UnityFixture.NameFilter = 0;\n    UnityFixture.RepeatCount = 1;\n    if (argc == 1)\n        return 0;\n    for (i = 1; i < argc;) {\n        if (strcmp(argv[i], \"-v\") == 0) {\n            UnityFixture.Verbose = 1;\n            i++;\n        } else if (strcmp(argv[i], \"-g\") == 0) {\n            i++;\n            if (i >= argc)\n                return 1;\n            UnityFixture.GroupFilter = argv[i];\n            i++;\n        } else if (strcmp(argv[i], \"-n\") == 0) {\n            i++;\n            if (i >= argc)\n                return 1;\n            UnityFixture.NameFilter = argv[i];\n            i++;\n        } else if (strcmp(argv[i], \"-r\") == 0) {\n            UnityFixture.RepeatCount = 2;\n            i++;\n            if (i < argc) {\n                if (*(argv[i]) >= '0' && *(argv[i]) <= '9') {\n                    UnityFixture.RepeatCount = atoi(argv[i]);\n                    i++;\n                }\n            }\n        } else {\n            i++;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int UnityGetCommandLineOptions_name_conflict(int argc, const char **argv) {\n  int i;\n\n  UnityFixture.Verbose = 0;\n  UnityFixture.GroupFilter = NULL;\n  UnityFixture.NameFilter = NULL;\n  UnityFixture.RunMode = 1;\n\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(argv[i], \"-v\")) {\n      UnityFixture.Verbose = 1;\n    } else if (!strcmp(argv[i], \"-g\")) {\n      if (i + 1 < argc) {\n        UnityFixture.GroupFilter = argv[i + 1];\n        ++i;\n      } else {\n        return 1;\n      }\n    } else if (!strcmp(argv[i], \"-n\")) {\n      if (i + 1 < argc) {\n        UnityFixture.NameFilter = argv[i + 1];\n        ++i;\n      } else {\n        return 1;\n      }\n    } else if (!strcmp(argv[i], \"-r\")) {\n      UnityFixture.RunMode = 2;\n      if (i + 1 < argc && argv[i + 1][0] >= '0' && argv[i + 1][0] <= '9') {\n        UnityFixture.RunMode = atoi(argv[i + 1]);\n        ++i;\n      }\n    }\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int print_jpeg_metadata(char *filename) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n        return (*__errno_location());\n    }\n    int c;\n    int lsb = 0;\n    int err = 1;\n    int offset = 0;\n    long metadata_size = 0;\n    while ((c = fgetc(f)) != (-1))\n        {\n            buf[offset++] = c;\n            if (offset >= bufsize)\n                buf_resize(0);\n            if (lsb) {\n                int pos = ftell(f) - 2;\n                int length;\n                int d;\n                if (c != 216) {\n                    if ((c & 240) != 224) {\n                        metadata_size = offset - 2;\n                        if (metadata_size != ftell(f) - 2 || metadata_size < 0) {\n                            fprintf(stderr, \"unexpected error while processing %s\\n\", filename);\n                            exit(1);\n                        }\n                        err = 0;\n                        fprintf(stderr, \"%li %s\\n\", metadata_size, filename);\n                        break;\n                    }\n                    length = 0;\n                    if ((d = fgetc(f)) == (-1)) {\n                        fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n                        exit(1);\n                    }\n                    buf[offset++] = d;\n                    if (offset >= bufsize)\n                        buf_resize(0);\n                    length += d << 8;\n                    if ((d = fgetc(f)) == (-1)) {\n                        fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n                        exit(1);\n                    }\n                    buf[offset++] = d;\n                    if (offset >= bufsize)\n                        buf_resize(0);\n                    length += d;\n                    if (length < 2) {\n                        fprintf(stderr, \"error: invalid segment length in %s\\n\", filename);\n                        exit(1);\n                    }\n                    length -= 2;\n                    if (offset + length > bufsize) {\n                        buf_resize(length);\n                    }\n                    uint16_t segment = *((uint16_t *)(buf + offset - 4));\n                    fprintf(stderr, \"segment: %02X%02X, length: %d\\n\", segment & 255, segment >> 8, length);\n                    if (length) {\n                        if (fread(buf + offset, 1, length, f) != length) {\n                            fprintf(stderr, \"error: read error while processing %s\\n\", filename);\n                            exit(1);\n                        }\n                        offset += length;\n                    }\n                }\n                lsb = 0;\n            } else if (c == 255) {\n                lsb = 1;\n            }\n        }\n    fclose(f);\n    long file_offset = ftell(output_file);\n    if (file_offset < 0) {\n        fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n        exit(1);\n    }\n    uint32_t file_offset32 = (uint32_t)file_offset;\n    if (fwrite(&file_offset32, 1, sizeof (file_offset32), index_file) != sizeof (file_offset32)) {\n        fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n        exit(1);\n    }\n    if (metadata_size) {\n        if (fwrite(buf, 1, metadata_size, output_file) != metadata_size) {\n            fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n            exit(1);\n        }\n    }\n    fflush(output_file);\n    return err;\n}\n","function_prediction":"int print_jpeg_metadata_name_conflict(char *filename) {\n  FILE *file;\n  int c, i, j, k, l, m, n, s, t, u, v, w, x, y, z;\n  long int p, q, r, size;\n  unsigned short int segment;\n\n  file = fopen(filename, \"r\");\n  if (file == NULL) {\n    fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n    return *__errno_location();\n  }\n\n  i = 0;\n  j = 1;\n  k = 0;\n  l = 0;\n  while ((c = fgetc(file)) != -1) {\n    buf[i++] = c;\n    if (i >= bufsize)\n      buf_resize(0);\n    if (k == 0) {\n      if (c == 0xFF)\n        k = 1;\n    } else {\n      p = ftell(file) - 2;\n      if (c == 0xD8) {\n        k = 0;\n      } else if ((c & 0xF0) == 0xE0) {\n        m = 0;\n        n = fgetc(file);\n        if (n == -1) {\n          fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n          exit(1);\n        }\n        buf[i++] = n;\n        if (i >= bufsize)\n          buf_resize(0);\n        m += n << 8;\n        n = fgetc(file);\n        if (n == -1) {\n          fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n          exit(1);\n        }\n        buf[i++] = n;\n        if (i >= bufsize)\n          buf_resize(0);\n        m += n;\n        if (m < 2) {\n          fprintf(stderr, \"error: invalid segment length in %s\\n\", filename);\n          exit(1);\n        }\n        m -= 2;\n                if (i + m >","pass":0,"source_file":"C_COMPILE/bugdanov_jpeg_metadata_size/jpeg_metadata.c"}
{"compilable":1,"function":"int print_jpeg_metadata_size(char *filename) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n        return (*__errno_location());\n    }\n    int c;\n    int lsb = 0;\n    int err = 0;\n    while ((c = fgetc(f)) != (-1))\n        {\n            if (lsb) {\n                int pos = ftell(f) - 2;\n                int length;\n                int d;\n                if (c != 216) {\n                    if ((c & 240) != 224) {\n                        printf(\"%d %s\\n\", ftell(f) - 2, filename);\n                        break;\n                    }\n                    length = 0;\n                    if ((d = fgetc(f)) == (-1))\n                        break;\n                    length += d << 8;\n                    if ((d = fgetc(f)) == (-1))\n                        break;\n                    length += d;\n                    if (length < 2) {\n                        fprintf(stderr, \"error: invalid segment length in %s\\n\", filename);\n                        err = 1;\n                        break;\n                    }\n                    if (length && fseek(f, length - 2, 1) < 0) {\n                        fprintf(stderr, \"error: i/o error with %s\\n\", filename);\n                        err = (*__errno_location());\n                        break;\n                    }\n                }\n                lsb = 0;\n            } else if (c == 255) {\n                lsb = 1;\n            }\n        }\n    fclose(f);\n    return err;\n}\n","function_prediction":"int print_jpeg_metadata_size_name_conflict(const char *filename) {\n  FILE *fp;\n  int c, c1, c2, len, ret;\n  int found_sof;\n\n  fp = fopen(filename, \"r\");\n  if (!fp) {\n    fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n    return errno;\n  }\n\n  found_sof = 0;\n  ret = 0;\n  while ((c = fgetc(fp)) != -1) {\n    if (found_sof) {\n      if (c == 0xd8) {\n        found_sof = 0;\n      } else if ((c & 0xf0) == 0xe0) {\n        c1 = fgetc(fp);\n        if (c1 == -1)\n          break;\n        c2 = fgetc(fp);\n        if (c2 == -1)\n          break;\n        len = c1 * 256 + c2;\n        if (len <= 1) {\n          fprintf(stderr, \"error: invalid segment length in %s\\n\", filename);\n          ret = 1;\n          break;\n        }\n        if (len > 0) {\n          if (fseek(fp, len - 2, 1) < 0) {\n            fprintf(stderr, \"error: i/o error with %s\\n\", filename);\n            return errno;\n          }\n        }\n      } else {\n        printf(\"%d %s\\n\", (int)ftell(fp) - 2, filename);\n        break;\n      }\n    } else if (c == 0xff) {\n      found_sof = 1;\n    }\n  }\n\n  fclose(fp);\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/bugdanov_jpeg_metadata_size/jpeg_metadata_size.c"}
{"compilable":0,"function":"int mread(int s, char *bufp, unsigned int n) {\n    register unsigned int count = 0;\n    register int nread;\n    do {\n        nread = read(s, bufp, n - count);\n        numCalls++;\n        if (nread < 0) {\n            perror(\"ttcp_mread\");\n            return (-1);\n        }\n        if (nread == 0)\n            return ((int)count);\n        count += (unsigned int)nread;\n        bufp += nread;\n    } while (count < n);\n    return ((int)count);\n}\n","function_prediction":"int mread_name_conflict(int fd, char *buf, int len) {\n  int nread = 0;\n  int n;\n\n  while (nread < len) {\n    n = read(fd, buf, len - nread);\n    numCalls++;\n    if (n < 0) {\n      perror(\"ttcp_mread_name_conflict\");\n      return -1;\n    }\n    if (n == 0)\n      break;\n    nread += n;\n    buf += n;\n  }\n  return nread;\n}","pass":0,"source_file":"C_COMPILE/hynnet_openwrt-mt7620/feeds/packages/net/ttcp/ttcp.c"}
{"compilable":0,"function":"int testfunction(int arg1, int *arg2) {\n    return arg2[arg1];\n}\n","function_prediction":"int testfunction_name_conflict(int i, int *a) { return a[i]; }","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int test2function(void) {\n    return 0;\n}\n","function_prediction":"int test2function_name_conflict(int a) {\n  int b = 0;\n  int c = 0;\n  int d = 0;\n  int e = 0;\n  int f = 0;\n  int g = 0;\n  int h = 0;\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u = 0;\n  int v = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n  int aa = 0;\n  int ab = 0;\n  int ac = 0;\n  int ad = 0;\n  int ae = 0;\n  int af = 0;\n  int ag = 0;\n  int ah = 0;\n  int ai = 0;\n  int aj = 0;\n  int ak = 0;\n  int al = 0;\n  int am = 0;\n  int an = 0;\n  int ao = 0;\n  int ap = 0;\n  int aq = 0;\n  int ar = 0;\n  int as = 0;\n  int at = 0;\n  int au = 0;\n  int av = 0;\n  int aw = 0;\n  int ax = 0;\n  int ay = 0;\n  int az = 0;\n  int ba = 0;\n  int bb = 0;\n  int bc = 0;\n  int bd = 0;\n  int be = 0;\n  int bf = 0;\n  int bg = 0;\n  int bh = 0;\n  int bi = 0;\n  int bj = 0;\n  int bk = 0;\n  int bl = 0;\n  int bm = 0;\n  int bn = 0;\n  int bo = 0;\n  int bp = 0;\n  int bq = 0;\n  int br = 0;\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int test4function(const int arg1) {\n    return carray[arg1];\n}\n","function_prediction":"int test4function_name_conflict(int i) { return carray[i]; }","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int possibly_duplicate_function() {\n    return 0;\n}\n","function_prediction":"int possibly_duplicate_function_name_conflict(void) { return 0; }","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int possibly_dupli_function() {\n    return 1;\n}\n","function_prediction":"int possibly_dupli_function_name_conflict(void) { return 1; }","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int is_char_signed(int arg) {\n    if (arg == 189) {\n        return 0;\n    } else if (arg != -67) {\n        printf(\"Hmm, it seems 'char' is not eight bits wide on your machine.\\n\");\n        printf(\"I fear the JPEG software will not work at all.\\n\\n\");\n    }\n    return 1;\n}\n","function_prediction":"boolean is_char_signed_name_conflict(void) {\n  if (sizeof(char) == 127)\n    return 0;\n  if (sizeof(char) == 191)\n    return 0;\n  puts(\"Hmm, it seems 'char' is not eight bits wide on your machine.\");\n  puts(\"I fear the JPEG software will not work at all.\\n\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int is_shifting_signed(long arg) {\n    long res = arg >> 4;\n    if (res == -133687308L) {\n        return 1;\n    }\n    res |= (~0L) << (32 - 4);\n    if (res == -133687308L) {\n        return 0;\n    }\n    printf(\"Right shift isn't acting as I expect it to.\\n\");\n    printf(\"I fear the JPEG software will not work at all.\\n\\n\");\n    return 0;\n}\n","function_prediction":"int is_shifting_signed_name_conflict(void) {\n  int i;\n  unsigned int j;\n\n  i = -1;\n  j = i >> 4;\n  if (j == 0xfffffffff80817f4)\n    return 1;\n\n  i = 0;\n  j = i >> 4;\n  if (j == 0xfffffffff80817f4)\n    return 0;\n\n  puts(\"Right shift isn't acting as I expect it to.\");\n  puts(\"I fear the JPEG software will not work at all.\\n\");\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":1,"function":"static int pmu_can_sleep(const int fd) {\n    unsigned long arg = 0;\n    if (ioctl(fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('B')) << (0 + 8)) | (((5)) << 0) | ((((sizeof(size_t)))) << ((0 + 8) + 8))), &arg) < 0 || arg != 1)\n        return 1;\n    return 0;\n}\n","function_prediction":"int pmu_can_sleep_name_conflict(int fd) {\n  int ret;\n  unsigned long val = 0;\n\n  ret = ioctl(fd, 0x80084205, &val);\n  if (ret < 0 || val != 1)\n    return 1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-pmu.c"}
{"compilable":1,"function":"static int pmu_sleep(const int fd) {\n    unsigned long arg = 0;\n    if (ioctl(fd, (((0U) << (((0 + 8) + 8) + 14)) | ((('B')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), arg) < 0)\n        return 1;\n    return 0;\n}\n","function_prediction":"int pmu_sleep_name_conflict(int fd) {\n  int ret;\n\n  ret = ioctl(fd, 0x4200, 0);\n  if (ret < 0)\n    return 1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-pmu.c"}
{"compilable":1,"function":"off_t get_sig_offset(int orig) {\n    int pagesize = sysconf(_SC_PAGESIZE);\n    return (off_t)((sizeof(char) * pagesize) - (orig ? 20 : 10));\n}\n","function_prediction":"int get_sig_offset_name_conflict(int is_32bit) {\n  return sysconf(_SC_PAGESIZE) - (is_32bit ? 20 : 10);\n}","pass":1,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-reset-swap.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 1;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 500000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  int hash = GetWordHash(word);\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 500000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int i;\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(str, argv[i])) {\n      if (i == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      } else\n        return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 0;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 30000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  unsigned int hash;\n\n  len = strlen(word) + 1;\n  if (len > 100)\n    len = 100;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1) {\n      vocab_hash[hash] = vocab_size - 1;\n      break;\n    }\n    hash = (hash + 1) % 30000000;\n  }\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int i;\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(str, argv[i])) {\n      if (i == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      } else\n        return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro_ArvoreB(char *arquivo, uint32_t id) {\n    FILE *arq_arv;\n    uint16_t raiz;\n    uint16_t offset;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0)\n        return 0;\n    Busca_Recursiva_ArvoreB(arq_arv, raiz, id, &offset);\n    return offset;\n}\n","function_prediction":"short Buscar_Registro_ArvoreB_name_conflict(char *nome_arquivo, int chave) {\n  FILE *arquivo;\n  short raiz;\n  short resultado;\n\n  arquivo = fopen(nome_arquivo, \"r+\");\n\n  fseek(arquivo, 2, 0);\n  fread(&raiz, 2, 1, arquivo);\n\n  if (raiz == 0)\n    return 0;\n\n  Busca_Recursiva_ArvoreB(arquivo, raiz, chave, &resultado);\n\n  return resultado;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Inserir_No_ArvoreB(char *arquivo, uint32_t id, uint16_t offset) {\n    uint16_t raiz;\n    uint16_t raiz_pos;\n    uint16_t nova_rrn;\n    uint16_t promo_r_child;\n    uint32_t promo_key_id;\n    uint16_t promo_key_offset;\n    uint8_t flag;\n    FILE *arq_arv;\n    no_arvore_b_t nova;\n    no_arvore_b_t raiz_a;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0) {\n        nova.n = 1;\n        nova.id[0] = id;\n        nova.offset[0] = offset;\n        nova.filhas[0] = 0;\n        nova.filhas[1] = 0;\n        nova_rrn = (Criar_Pagina(arq_arv, nova));\n        fseek(arq_arv, 2, 0);\n        fwrite(&nova_rrn, sizeof(uint16_t), 1, arq_arv);\n    } else {\n        flag = Recursive_Insertion(arq_arv, raiz, id, offset, &promo_r_child, &promo_key_id, &promo_key_offset);\n        switch (flag) {\n          case 2:\n            raiz_a.filhas[0] = raiz;\n            raiz_a.id[0] = promo_key_id;\n            raiz_a.offset[0] = promo_key_offset;\n            raiz_a.filhas[1] = promo_r_child;\n            raiz_a.n = 1;\n            raiz = Criar_Pagina(arq_arv, raiz_a);\n            fseek(arq_arv, 2, 0);\n            fwrite(&raiz, sizeof(uint16_t), 1, arq_arv);\n            break;\n          case 1:\n            break;\n          case 0:\n            break;\n        }\n    }\n    fclose(arq_arv);\n    return nova_rrn;\n}\n","function_prediction":"short Inserir_No_ArvoreB_name_conflict(char *nome_arquivo, int chave, short valor) {\n  FILE *arquivo;\n  short raiz, novo_no, novo_no_pai, novo_no_irmao;\n  char resultado;\n\n  arquivo = fopen(nome_arquivo, \"r+\");\n\n  fseek(arquivo, 2, 0);\n  fread(&raiz, 2, 1, arquivo);\n\n  if (raiz == 0) {\n    novo_no = Criar_Pagina(arquivo);\n\n    fseek(arquivo, 2, 0);\n    fwrite(&novo_no, 2, 1, arquivo);\n  } else {\n    resultado = Recursive_Insertion(arquivo, raiz, chave, valor, &novo_no,\n                                    &novo_no_pai, &novo_no_irmao);\n\n    if (resultado == 2) {\n      raiz = Criar_Pagina(arquivo);\n\n      fseek(arquivo, 2, 0);\n      fwrite(&raiz, 2, 1, arquivo);\n    }\n  }\n\n  fclose(arquivo);\n\n  return novo_no;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint8_t Inicializar_ArvoreB(char *arquivo) {\n    FILE *nova;\n    uint16_t ped = 0;\n    uint16_t raiz = 0;\n    nova = fopen(arquivo, \"r\");\n    if (nova == ((void *)0)) {\n        nova = fopen(arquivo, \"w\");\n        if (nova == ((void *)0))\n            return 0;\n        fwrite(&ped, sizeof(uint16_t), 1, nova);\n        fwrite(&raiz, sizeof(uint16_t), 1, nova);\n        fclose(nova);\n        return 2;\n    }\n    fclose(nova);\n    return 1;\n}\n","function_prediction":"int Inicializar_ArvoreB_name_conflict(char *nome_arquivo) {\n  FILE *arquivo;\n  unsigned short raiz = 0;\n  unsigned short folhas = 0;\n\n  arquivo = fopen(nome_arquivo, \"r\");\n  if (arquivo != NULL) {\n    fclose(arquivo);\n    return 1;\n  }\n\n  arquivo = fopen(nome_arquivo, \"w\");\n  if (arquivo == NULL)\n    return 0;\n\n  fwrite(&raiz, sizeof(unsigned short), 1, arquivo);\n  fwrite(&folhas, sizeof(unsigned short), 1, arquivo);\n\n  fclose(arquivo);\n  return 2;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t POS_to_RRN(uint16_t POS) {\n    POS -= 4;\n    POS /= sizeof(no_arvore_b_t);\n    POS += 1;\n    return POS;\n}\n","function_prediction":"short POS_to_RRN_name_conflict(short POS) { return (short)((POS - 4) / 40 + 1); }","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t RRN_to_POS(uint16_t RRN) {\n    --RRN;\n    RRN *= sizeof(no_arvore_b_t);\n    RRN += 4;\n    return RRN;\n}\n","function_prediction":"short RRN_to_POS_name_conflict(short RRN) { return (RRN - 1) * 40 + 4; }","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Remocao_Arvore_B(char *arquivo, uint32_t id) {\n    FILE *arq_arv;\n    uint16_t raiz;\n    uint16_t offset;\n    uint16_t rrn;\n    no_arvore_b_t pagina;\n    int i;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0)\n        return 0;\n    rrn = Busca_Recursiva_ArvoreB(arq_arv, raiz, id, &offset);\n    if (rrn == 0)\n        return 0;\n    fseek(arq_arv, RRN_to_POS(rrn), 0);\n    Carregar_Pagina(arq_arv, &pagina);\n    i = 0;\n    while (pagina.id[i] != id)\n        ++i;\n    pagina.offset[i] = 0;\n    fseek(arq_arv, RRN_to_POS(rrn), 0);\n    Escrever_Pagina(arq_arv, pagina);\n    fclose(arq_arv);\n    return rrn;\n}\n","function_prediction":"short Remocao_Arvore_B_name_conflict(char *nome_arquivo, int chave) {\n  FILE *arquivo;\n  Pagina pagina;\n  short raiz, rrn, pos, i;\n  short folha;\n\n  arquivo = fopen(nome_arquivo, \"r+\");\n\n  fseek(arquivo, 2, 0);\n  fread(&raiz, sizeof(short), 1, arquivo);\n\n  if (raiz == 0)\n    return 0;\n\n  rrn = Busca_Recursiva_ArvoreB(arquivo, raiz, chave, &folha);\n\n  if (rrn == 0)\n    return 0;\n\n  pos = RRN_to_POS(rrn);\n  fseek(arquivo, pos, 0);\n  Carregar_Pagina(arquivo, &pagina);\n\n  for (i = 0; pagina.chaves[i] != chave; i++)\n    ;\n\n  pagina.chaves[i] = 0;\n\n  pos = RRN_to_POS(rrn);\n  fseek(arquivo, pos, 0);\n  Escrever_Pagina(arquivo, &pagina);\n\n  fclose(arquivo);\n\n  return rrn;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro_Com_Indice(char *caminho_registro, uint32_t id, registro_t *registro) {\n    FILE *arq_reg;\n    char caminho_indice[128];\n    uint16_t pos;\n    int i;\n    char c;\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    pos = Buscar_Registro_ArvoreB(caminho_indice, id);\n    if (pos != 0 && registro != ((void *)0)) {\n        arq_reg = fopen(caminho_registro, \"r\");\n        fseek(arq_reg, pos + 2, 0);\n        fread(&(registro->id), sizeof(uint32_t), 1, arq_reg);\n        fgetc(arq_reg);\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->autor[i] = c;\n                ++i;\n            }\n        registro->autor[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->titulo[i] = c;\n                ++i;\n            }\n        registro->titulo[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->curso[i] = c;\n                ++i;\n            }\n        registro->curso[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->tipo[i] = c;\n                ++i;\n            }\n        registro->tipo[i] = '\\x00';\n        fclose(arq_reg);\n    }\n    return pos;\n}\n","function_prediction":"unsigned short Buscar_Registro_Com_Indice(char *nome_arquivo,\n                                          unsigned int chave,\n                                          Registro *registro) {\n  char caminho_indice[140];\n  unsigned short posicao;\n  char c;\n  int i;\n  FILE *arquivo;\n\n  Get_Caminho_Indice(nome_arquivo, caminho_indice);\n\n  posicao = Buscar_Registro_ArvoreB(caminho_indice, chave);\n\n  if (posicao == 0 || registro == NULL)\n    return posicao;\n\n  arquivo = fopen(nome_arquivo, \"r\");\n\n  fseek(arquivo, posicao + 2, 0);\n\n  fread(&registro->chave, sizeof(unsigned int), 1, arquivo);\n\n  c = fgetc(arquivo);\n\n  i = 0;\n  while (c != '|') {\n    registro->nome[i] = c;\n    c = fgetc(arquivo);\n    i++;\n  }\n  registro->nome[i] = '\\0';\n\n  i = 0;\n  c = '|';\n  while (c != '|') {\n    registro->endereco[i] = c;\n    c = fgetc(arquivo);\n    i++;\n  }\n  registro->endereco[i] = '\\0';\n\n  i = 0;\n  c = '|';\n  while (c != '|') {\n    registro->telefone[i] = c;\n    c = fgetc(arquivo);\n    i++;\n  }\n  registro->telefone[i] = '\\0';\n\n  i = 0;\n  c = '|';\n  while (c != '|') {\n    registro->email[i] = c;\n    c = fgetc(arquivo);\n    i++;\n  }\n  registro->email[i] = '\\","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro(char *caminho_registro, uint32_t id, registro_t *registro) {\n    FILE *arq_reg;\n    uint32_t id_c;\n    uint16_t tamanho_c;\n    int tamanho_arq;\n    uint16_t retorno = 2;\n    char is_vazio;\n    int i;\n    char c;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r\");\n    fseek(arq_reg, 0, 2);\n    tamanho_arq = ftell(arq_reg);\n    fseek(arq_reg, 2, 0);\n    fread(&tamanho_c, sizeof(uint16_t), 1, arq_reg);\n    fread(&id_c, sizeof(uint32_t), 1, arq_reg);\n    fseek(arq_reg, tamanho_c - 4, 1);\n    while (id_c != id && ftell(arq_reg) < tamanho_arq)\n        {\n            retorno = ftell(arq_reg);\n            fread(&tamanho_c, sizeof(uint16_t), 1, arq_reg);\n            is_vazio = fgetc(arq_reg);\n            if (is_vazio == '*') {\n                id_c = id + 1;\n                fseek(arq_reg, tamanho_c - 1, 1);\n            } else {\n                fseek(arq_reg, -1, 1);\n                fread(&id_c, sizeof(uint32_t), 1, arq_reg);\n                fseek(arq_reg, tamanho_c - 4, 1);\n            }\n        }\n    if (id_c != id)\n        retorno = 0;\n    else if (registro != ((void *)0)) {\n        fseek(arq_reg, retorno + 7, 0);\n        registro->id = id_c;\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->autor[i] = c;\n                ++i;\n            }\n        registro->autor[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->titulo[i] = c;\n                ++i;\n            }\n        registro->titulo[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->curso[i] = c;\n                ++i;\n            }\n        registro->curso[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->tipo[i] = c;\n                ++i;\n            }\n        registro->tipo[i] = '\\x00';\n    }\n    fclose(arq_reg);\n    return retorno;\n}\n","function_prediction":"unsigned short Buscar_Registro_name_conflict(char *nome_arquivo, int chave, Registro *reg) {\n  unsigned short pos_arvore, pos_registro, pos_inicio, pos_fim, pos_chave;\n  int chave_registro;\n  char c;\n  FILE *arquivo;\n\n  pos_inicio = 2;\n  arquivo = Abrir_arquivo(nome_arquivo, \"r\");\n\n  fseek(arquivo, 0, 2);\n  pos_fim = ftell(arquivo);\n\n  fseek(arquivo, 2, 0);\n  fread(&pos_arvore, 2, 1, arquivo);\n  fread(&pos_registro, 4, 1, arquivo);\n\n  fseek(arquivo, pos_arvore - 4, 1);\n\n  while (chave != chave_registro) {\n    if (ftell(arquivo) >= pos_fim)\n      break;\n\n    pos_inicio = ftell(arquivo);\n\n    fread(&pos_arvore, 2, 1, arquivo);\n    c = fgetc(arquivo);\n\n    if (c == '*') {\n      chave_registro = chave + 1;\n      fseek(arquivo, pos_arvore - 1, 1);\n    } else {\n      fseek(arquivo, -1, 1);\n      fread(&chave_registro, 4, 1, arquivo);\n      fseek(arquivo, pos_arvore - 4, 1);\n    }\n  }\n\n  if (chave == chave_registro) {\n    if (reg != NULL) {\n      fseek(arquivo, pos_inicio + 7, 0);\n      reg->chave = chave_registro;\n\n      pos_chave = 0;\n            while((c = fgetc(arqu","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Calcular_Tamanho(registro_t registro) {\n    uint16_t retorno = 0;\n    retorno += 5;\n    retorno += sizeof(uint32_t);\n    retorno += strlen(registro.autor);\n    retorno += strlen(registro.titulo);\n    retorno += strlen(registro.curso);\n    retorno += strlen(registro.tipo);\n    return retorno;\n}\n","function_prediction":"short Calcular_Tamanho_name_conflict(void) {\n  return (short)(strlen(\"int\") + strlen(\"float\") + strlen(\"char\") +\n                 strlen(\"double\") + sizeof(short));\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"int Inserir_Registro(char *caminho_registro, registro_t registro) {\n    FILE *arq_reg;\n    uint16_t first_led;\n    uint16_t nova_first_led;\n    uint16_t tamanho, tamanho_first_led, tamanho_novo_branco;\n    int retorno;\n    char caminho_indice[128];\n    tamanho = Calcular_Tamanho(registro);\n    tamanho_first_led = 0;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r+\");\n    fseek(arq_reg, 0, 0);\n    fread(&first_led, sizeof(uint16_t), 1, arq_reg);\n    if (first_led != 0) {\n        fseek(arq_reg, first_led, 0);\n        fread(&tamanho_first_led, sizeof(uint16_t), 1, arq_reg);\n    }\n    if (first_led == 0 || tamanho_first_led < tamanho)\n        retorno = Inserir_Registro_Final(arq_reg, registro);\n    else {\n        fgetc(arq_reg);\n        fread(&nova_first_led, sizeof(uint16_t), 1, arq_reg);\n        fseek(arq_reg, 0, 0);\n        fwrite(&nova_first_led, sizeof(uint16_t), 1, arq_reg);\n        fseek(arq_reg, first_led, 0);\n        tamanho_novo_branco = tamanho_first_led - tamanho - 2;\n        if (tamanho_novo_branco > 8) {\n            fwrite(&tamanho_novo_branco, sizeof(uint16_t), 1, arq_reg);\n            Inserir_ED(arq_reg, first_led);\n            fseek(arq_reg, first_led + 2 + tamanho_novo_branco, 0);\n        } else\n            tamanho = tamanho_first_led;\n        retorno = ftell(arq_reg);\n        fwrite(&tamanho, sizeof(uint16_t), 1, arq_reg);\n        fwrite(&(registro.id), sizeof(uint32_t), 1, arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.autor, sizeof(char), strlen(registro.autor), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.titulo, sizeof(char), strlen(registro.titulo), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.curso, sizeof(char), strlen(registro.curso), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.tipo, sizeof(char), strlen(registro.tipo), arq_reg);\n        fputc('|', arq_reg);\n    }\n    fclose(arq_reg);\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    Inserir_No_ArvoreB(caminho_indice, registro.id, (uint16_t)(retorno));\n    return retorno;\n}\n","function_prediction":"int Inserir_Registro_name_conflict(char *nome_arquivo) {\n  FILE *arquivo;\n  unsigned short tamanho_registro, tamanho_registro_atual,\n      tamanho_registro_final, tamanho_registro_final_atual,\n      tamanho_registro_final_atual_2, tamanho_registro_final_atual_3,\n      tamanho_registro_final_atual_4, tamanho_registro_final_atual_5,\n      tamanho_registro_final_atual_6, tamanho_registro_final_atual_7,\n      tamanho_registro_final_atual_8, tamanho_registro_final_atual_9,\n      tamanho_registro_final_atual_10, tamanho_registro_final_atual_11,\n      tamanho_registro_final_atual_12, tamanho_registro_final_atual_13,\n      tamanho_registro_final_atual_14, tamanho_registro_final_atual_15,\n      tamanho_registro_final_atual_16, tamanho_registro_final_atual_17,\n      tamanho_registro_final_atual_18, tamanho_registro_final_atual_19,\n      tamanho_registro_final_atual_20, tamanho_registro_final_atual_21,\n      tamanho_registro_final_atual_22, tamanho_registro_final_atual_23,\n      tamanho_registro_final_atual_24, tamanho_registro_final_atual_25,\n      tamanho_registro_final_atual_26, tamanho_registro_final_atual_27,\n      tamanho_registro_final_atual_28, tamanho_registro_final_atual_29,\n      tamanho_registro_final_atual_30, tamanho_registro_final_atual_31, taman","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Remover_Registro(char *caminho_registro, uint32_t id) {\n    FILE *arq_reg;\n    uint16_t posicao;\n    char asteristico = '*';\n    char caminho_indice[128];\n    posicao = Buscar_Registro_Com_Indice(caminho_registro, id, ((void *)0));\n    if (posicao == 0)\n        return 0;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r+\");\n    fseek(arq_reg, posicao + 2, 0);\n    fwrite(&asteristico, sizeof(char), 1, arq_reg);\n    Inserir_ED(arq_reg, posicao);\n    fclose(arq_reg);\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    Remocao_Arvore_B(caminho_indice, id);\n    return posicao;\n}\n","function_prediction":"unsigned short Remover_Registro_name_conflict(char *nome_arquivo, unsigned int chave) {\n  unsigned short indice;\n  FILE *arquivo;\n  char *caminho;\n  char marcador = '*';\n\n  indice = Buscar_Registro_Com_Indice(nome_arquivo, chave, 0);\n\n  if (indice == 0)\n    return 0;\n\n  arquivo = Abrir_arquivo(nome_arquivo, \"r+b\");\n\n  fseek(arquivo, indice + 2, 0);\n  fwrite(&marcador, sizeof(char), 1, arquivo);\n\n  Inserir_ED(arquivo, indice);\n\n  fclose(arquivo);\n\n  caminho = (char *)malloc(sizeof(char) * 140);\n  Get_Caminho_Indice(nome_arquivo, caminho);\n\n  Remocao_Arvore_B(caminho, chave);\n\n  return indice;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"registro_t String_to_reg(char *cadeia) {\n    registro_t retorno;\n    char *campo;\n    if (cadeia == ((void *)0)) {\n        printf(\"Erro ao converter arquivo de catalogo: linha vazia!\\n\");\n        retorno.id = 0;\n        return retorno;\n    }\n    campo = strtok(cadeia, \";\");\n    retorno.id = (uint32_t)(atoi(campo));\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.autor, campo + 1);\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.titulo, campo + 1);\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.curso, campo + 1);\n    campo = strtok(((void *)0), \"\\r\");\n    strcpy(retorno.tipo, campo + 1);\n    return retorno;\n}\n","function_prediction":"registro String_to_reg_name_conflict(char *str) {\n  registro reg;\n  char *token;\n\n  if (str == NULL) {\n    printf(\"Erro ao converter arquivo de catalogo: linha vazia!\\n\");\n    return reg;\n  }\n\n  token = strtok(str, \";\");\n  reg.key = atoi(token);\n\n  token = strtok(NULL, \";\");\n  strcpy(reg.name, token + 1);\n\n  token = strtok(NULL, \";\");\n  strcpy(reg.author, token + 1);\n\n  token = strtok(NULL, \";\");\n  strcpy(reg.publisher, token + 1);\n\n  token = strtok(NULL, \"\\r\");\n  strcpy(reg.date, token + 1);\n\n  return reg;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"int Importar_arquivo_catalogo(char *caminho_catalogo, char *caminho_registro) {\n    char leitura[1024];\n    char c;\n    int i;\n    int n_reg = 0;\n    registro_t lido;\n    FILE *catalogo;\n    catalogo = Abrir_arquivo(caminho_catalogo, \"r\");\n    while (1)\n        {\n            i = 0;\n            while ((c = fgetc(catalogo)) != '\\n' && c != (-1))\n                {\n                    leitura[i] = c;\n                    ++i;\n                }\n            leitura[i] = '\\x00';\n            if (strlen(leitura) < 4)\n                break;\n            lido = String_to_reg(leitura);\n            i = Inserir_Registro(caminho_registro, lido);\n            printf(\"Inserido registro na posicao %d do arquivo.\\n\", i);\n            ++n_reg;\n        }\n    fclose(catalogo);\n    return n_reg;\n}\n","function_prediction":"int Importar_arquivo_catalogo_name_conflict(char *nome_arquivo, Catalogo *catalogo) {\n  FILE *arquivo;\n  int i, j, k, contador = 0;\n  char linha[1024], caractere;\n  Registro reg;\n  Registro reg_aux;\n\n  arquivo = Abrir_arquivo(nome_arquivo, \"r\");\n\n  while (1) {\n    i = 0;\n    while (1) {\n      caractere = fgetc(arquivo);\n      if (caractere == '\\n' || caractere == EOF)\n        break;\n      linha[i] = caractere;\n      i++;\n    }\n    linha[i] = '\\0';\n\n    if (strlen(linha) < 4)\n      break;\n\n    String_to_reg(reg, linha);\n\n    for (j = 0, k = 0; j < 60; j++, k++)\n      reg_aux.chave[k] = reg.chave[j];\n    reg_aux.chave[k] = reg.chave[j];\n\n    i = Inserir_Registro(catalogo, reg_aux);\n\n    printf(\"Inserido registro na posicao %d do arquivo.\\n\", i);\n\n    contador++;\n  }\n\n  fclose(arquivo);\n\n  return contador;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"static unsigned char *option_find1(unsigned char *p, unsigned char *end, int opt, int minsize) {\n    while (*p != 255)\n        {\n            if (p >= end)\n                return ((void *)0);\n            else if (*p == 0)\n                p++;\n            else {\n                int opt_len;\n                if (p >= end - 2)\n                    return ((void *)0);\n                opt_len = ((int)(((unsigned char *)(p))[1]));\n                if (p >= end - (2 + opt_len))\n                    return ((void *)0);\n                if (*p == opt && opt_len >= minsize)\n                    return p;\n                p += opt_len + 2;\n            }\n        }\n    return opt == 255 ? p : ((void *)0);\n}\n","function_prediction":"const uint8_t *option_find1(const uint8_t *p, const uint8_t *end, uint8_t type,\n                            uint8_t min_len) {\n  while (*p != 0xff) {\n    if (p >= end)\n      return NULL;\n    if (*p == 0) {\n      p++;\n      continue;\n    }\n    if (p + 2 >= end)\n      return NULL;\n    uint8_t len = p[1];\n    if (p + 2 + len >= end)\n      return NULL;\n    if (*p == type && len >= min_len)\n      return p;\n    p += 2 + len;\n  }\n  if (type != 0xff)\n    return NULL;\n  return p;\n}","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":0,"function":"static unsigned char *option_find(struct dhcp_packet *mess, size_t size, int opt_type, int minsize) {\n    unsigned char *ret, *overload;\n    if ((ret = option_find1(&mess->options[0], ((unsigned char *)mess) + size, opt_type, minsize)))\n        return ret;\n    if (!(overload = option_find1(&mess->options[0], ((unsigned char *)mess) + size, 52, 1)))\n        return ((void *)0);\n    if ((overload[2] & 1) && (ret = option_find1(&mess->file[0], &mess->file[128], opt_type, minsize)))\n        return ret;\n    if ((overload[2] & 2) && (ret = option_find1(&mess->sname[0], &mess->sname[64], opt_type, minsize)))\n        return ret;\n    return ((void *)0);\n}\n","function_prediction":"unsigned char *option_find(unsigned char *buf, unsigned long len,\n                           unsigned int type, unsigned int minlen) {\n  unsigned char *p;\n\n  p = option_find1(buf + 240, buf + len, type, minlen);\n  if (p)\n    return p;\n\n  p = option_find1(buf + 240, buf + len, 52, 1);\n  if (!p)\n    return 0;\n\n  if (!(p[2] & 1) || (p = option_find1(buf + 108, buf + 240, type, minlen)))\n    return p;\n\n  if (!(p[2] & 2) || (p = option_find1(buf + 44, buf + 108, type, minlen)))\n    return p;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":1,"function":"static unsigned int option_uint(unsigned char *opt, int size) {\n    unsigned int ret = 0;\n    int i;\n    unsigned char *p = ((void *)&(((unsigned char *)(opt))[2]));\n    for (i = 0; i < size; i++)\n        ret = (ret << 8) | *p++;\n    return ret;\n}\n","function_prediction":"uint32_t option_uint_name_conflict(const uint8_t *data, int len) {\n  uint32_t val = 0;\n  int i;\n\n  for (i = 0; i < len; i++)\n    val = (val << 8) | data[i + 2];\n\n  return val;\n}","pass":1,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":1,"function":"static ssize_t netlink_recv(int fd) {\n    struct msghdr msg;\n    ssize_t rc;\n    msg.msg_control = ((void *)0);\n    msg.msg_controllen = 0;\n    msg.msg_name = ((void *)0);\n    msg.msg_namelen = 0;\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    while (1)\n        {\n            msg.msg_flags = 0;\n            while ((rc = recvmsg(fd, &msg, MSG_PEEK)) == -1 && (*__errno_location()) == 4)\n                ;\n            if (rc == -1 && (*__errno_location()) == 95) {\n                if (!expand_buf(&iov, 2000))\n                    return -1;\n                break;\n            }\n            if (rc == -1 || !(msg.msg_flags & MSG_TRUNC))\n                break;\n            if (!expand_buf(&iov, iov.iov_len + 100))\n                return -1;\n        }\n    while ((rc = recvmsg(fd, &msg, 0)) == -1 && (*__errno_location()) == 4)\n        ;\n    return rc;\n}\n","function_prediction":"ssize_t netlink_recv_name_conflict(int sock) {\n  struct msghdr msg = {\n      .msg_name = NULL,\n      .msg_namelen = 0,\n      .msg_iov = &iov,\n      .msg_iovlen = 1,\n      .msg_control = NULL,\n      .msg_controllen = 0,\n  };\n  ssize_t ret;\n\n  do {\n    msg.msg_flags = 0;\n    do {\n      ret = recvmsg(sock, &msg, 2);\n    } while (ret == -1 && *__errno_location() == 4);\n\n    if (ret == -1 && *__errno_location() == 95) {\n      if (!expand_buf(&iov, 2000))\n        return -1;\n    }\n\n    if (ret == -1 || !(msg.msg_flags & 0x20))\n      break;\n\n    if (!expand_buf(&iov, 100 + sizeof(struct nlmsghdr)))\n      return -1;\n  } while (1);\n\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":1,"function":"static int parse_hex(char *in, unsigned char *out, int maxlen, int *mac_type) {\n    int i = 0;\n    char *r;\n    if (mac_type)\n        *mac_type = 0;\n    while (maxlen == -1 || i < maxlen)\n        {\n            for (r = in; *r != 0 && *r != ':' && *r != '-'; r++)\n                ;\n            if (*r == 0)\n                maxlen = i;\n            if (r != in) {\n                if (*r == '-' && i == 0 && mac_type) {\n                    *r = 0;\n                    *mac_type = strtol(in, ((void *)0), 16);\n                    mac_type = ((void *)0);\n                } else {\n                    *r = 0;\n                    out[i] = strtol(in, ((void *)0), 16);\n                    i++;\n                }\n            }\n            in = r + 1;\n        }\n    return i;\n}\n","function_prediction":"int parse_hex_name_conflict(char *str, char *buf, int max, int *first) {\n  int i = 0;\n  char *p, *q;\n\n  if (first)\n    *first = 0;\n\n  while (max == -1 || i < max) {\n    for (p = str; *p && *p != ':' && *p != '-'; p++)\n      ;\n    if (!*p)\n      max = i;\n    if (p != str) {\n      if (*p == '-' && !i && first) {\n        *p = '\\0';\n        *first = strtol(str, NULL, 16);\n        first = NULL;\n      } else {\n        *p = '\\0';\n        buf[i++] = strtol(str, NULL, 16);\n      }\n    }\n    str = p + 1;\n  }\n  return i;\n}","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"static int is_same_net(struct in_addr a, struct in_addr b, struct in_addr mask) {\n    return (a.s_addr & mask.s_addr) == (b.s_addr & mask.s_addr);\n}\n","function_prediction":"int is_same_net_name_conflict(uint32_t ip1, uint32_t ip2, uint32_t mask) {\n  return !(ip1 ^ ip2) || !(ip1 ^ ip2 & mask);\n}","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"static struct in_addr find_interface(struct in_addr client, int fd, unsigned int index) {\n    struct sockaddr_nl addr;\n    struct nlmsghdr *h;\n    ssize_t len;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg g;\n    } req;\n    addr.nl_family = 16;\n    addr.nl_pad = 0;\n    addr.nl_groups = 0;\n    addr.nl_pid = 0;\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETADDR;\n    req.nlh.nlmsg_flags = 256 | 512 | 1 | 4;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = 1;\n    req.g.rtgen_family = 2;\n    if (sendto(fd, (void *)&req, sizeof (req), 0, (struct sockaddr *)&addr, sizeof (addr)) == -1) {\n        perror(\"sendto failed\");\n        exit(1);\n    }\n    while (1)\n        {\n            if ((len = netlink_recv(fd)) == -1) {\n                perror(\"netlink\");\n                exit(1);\n            }\n            for (h = (struct nlmsghdr *)iov.iov_base; (((size_t)len) >= (int)sizeof(struct nlmsghdr) && (h)->nlmsg_len >= sizeof(struct nlmsghdr) && (h)->nlmsg_len <= ((size_t)len)); h = ((len) -= ((((h)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(h)) + ((((h)->nlmsg_len) + 4U - 1) & ~(4U - 1)))))\n                if (h->nlmsg_type == 3)\n                    exit(0);\n                else if (h->nlmsg_type == RTM_NEWADDR) {\n                    struct ifaddrmsg *ifa = ((void *)(((char *)h) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    struct rtattr *rta;\n                    unsigned int len1 = h->nlmsg_len - ((sizeof (*ifa)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))));\n                    if (ifa->ifa_index == index && ifa->ifa_family == 2) {\n                        struct in_addr netmask, addr;\n                        netmask.s_addr = htonl(4294967295U << (32 - ifa->ifa_prefixlen));\n                        addr.s_addr = 0;\n                        for (rta = ((struct rtattr *)(((char *)(ifa)) + (((sizeof(struct ifaddrmsg)) + 4U - 1) & ~(4U - 1)))); ((len1) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len1)); rta = ((len1) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n                            if (rta->rta_type == IFA_LOCAL)\n                                addr = *((struct in_addr *)(rta + 1));\n                        if (addr.s_addr && is_same_net(addr, client, netmask))\n                            return addr;\n                    }\n                }\n        }\n    exit(0);\n}\n","function_prediction":"uint32_t find_interface_name_conflict(uint32_t net, int sock, uint32_t ifindex) {\n  struct sockaddr_nl nladdr = {\n      .nl_family = AF_NETLINK,\n      .nl_pad = 0,\n      .nl_pid = 0,\n      .nl_groups = 0,\n  };\n\n  struct ndmsg ndm = {\n    .ndm_family = 2,\n    .ndm_pad1 = 0,\n    .ndm_pad2 = 0,\n    .ndm_pad3 = 0,\n    .ndm_pad4 = 0,\n    .ndm_pad5 = 0,\n    .ndm_pad6 = 0,\n    .ndm_pad7 = 0,\n    .ndm_pad8 = 0,\n    .ndm_pad9 = 0,\n    .ndm_pad10 = 0,\n    .ndm_pad11 = 0,\n    .ndm_pad12 = 0,\n    .ndm_pad13 = 0,\n    .ndm_pad14 = 0,\n    .ndm_pad15 = 0,\n    .ndm_pad16 = 0,\n    .ndm_pad17 = 0,\n    .ndm_pad18 = 0,\n    .ndm_pad19 = 0,\n    .ndm_pad20 = 0,\n    .ndm_pad21 = 0,\n    .ndm_pad22 = 0,\n    .ndm_pad23 = 0,\n    .ndm_pad24 = 0,\n    .ndm_pad25 = 0,\n    .ndm_pad26 = 0,\n    .ndm_pad27 = 0,\n    .ndm_pad28 = 0,\n    .ndm_pad29 = 0,\n    .ndm_pad30 = 0,\n    .ndm_pad31 = 0,\n    .ndm_pad32 = 0,\n    .ndm_pad33 = 0,\n    .ndm_pad34 = 0,\n    .ndm_pad35","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":1,"function":"int output(char *filename) {\n    FILE *fp;\n    char str[64];\n    if ((fp = fopen(filename, \"r\")) == ((void *)0)) {\n        printf(\"Cannot open file %s.\\n\", filename);\n        return 1;\n    }\n    while (!feof(fp))\n        {\n            if (fgets(str, 128, fp)) {\n                printf(\"%s\", str);\n            }\n        }\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int output_name_conflict(char *filename) {\n  FILE *fp;\n  char line[128];\n\n  fp = fopen(filename, \"r\");\n  if (fp == NULL) {\n    printf(\"Cannot open file %s.\\n\", filename);\n    return 1;\n  }\n\n  while (!feof(fp)) {\n    if (fgets(line, 128, fp) != NULL)\n      printf(\"%s\", line);\n  }\n\n  fclose(fp);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/lazyparser_honggfuzz/examples/targets/badcode1.c"}
{"compilable":0,"function":"int askCharQuestion(char *question) {\n    char answer = 0;\n    printf(\"%s\\n> \", question);\n    scanf(\" %c\", &answer);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"char askCharQuestion_name_conflict(char *question) {\n  char answer = '\\0';\n  printf(\"%s\\n> \", question);\n  __isoc99_scanf(\"%c\", &answer);\n  fflush(stdin);\n  return answer;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int askIntQuestion(char *question) {\n    int answer = 0;\n    printf(\"%s\\n> \", question);\n    scanf(\" %i\", &answer);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"int askIntQuestion_name_conflict(char *question) {\n  int answer = 0;\n  printf(\"%s\\n> \", question);\n  __isoc99_scanf(\"%d\", &answer);\n  fflush(stdin);\n  return answer;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"short askBoolQuestion(char *question) {\n    int response = -1;\n    do {\n        printf(\"%s\\n> \", question);\n        scanf(\" %i\", &response);\n        fflush(stdin);\n        if (response < 0 || response > 1) {\n            printf(\"\\t\\tERROR: Input must be either a 0 (false) or 1 (true)!\\n\");\n        }\n    } while (response < 0 || response > 1);\n    return response;\n}\n","function_prediction":"int askBoolQuestion_name_conflict(char *question) {\n  int answer = -1;\n  do {\n    printf(\"%s\\n> \", question);\n    __isoc99_scanf(\"%d\", &answer);\n    fflush(stdin);\n    if (answer < 0 || answer > 1) {\n      printf(\"\\t\\tERROR: Input must be either a 0 (false) or 1 (true)!\\n\");\n    }\n  } while (answer < 0 || answer > 1);\n  return answer;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"char *askStringQuestion(char *question, int maxLength) {\n    char *answer = calloc(maxLength + 1, sizeof(char));\n    printf(\"%s\\n> \", question);\n    fgets(answer, maxLength, stdin);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"char *askStringQuestion_name_conflict(char *question, int maxLength) {\n  char *answer = calloc(maxLength + 1, sizeof(char));\n  printf(\"%s\\n> \", question);\n  fgets(answer, maxLength, stdin);\n  fflush(stdin);\n  return answer;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int multiprobabilisticRand(int probabilities[], int arraySize) {\n    int i, winner = -1, total = 0, choice = 0, currentTick = 0;\n    for (i = 0; i < arraySize; i++) {\n        total += probabilities[i];\n    }\n    choice = rand() % total;\n    for (i = 0; i < arraySize; i++) {\n        currentTick += probabilities[i];\n        if (choice < currentTick) {\n            winner = i;\n            break;\n        }\n    }\n    return winner;\n}\n","function_prediction":"int multiprobabilisticRand_name_conflict(int *probabilities, int size) {\n  int i, sum = 0, sum2 = 0;\n  int randNum = rand() % (sum + probabilities[size - 1]);\n\n  for (i = 0; i < size; i++)\n    sum += probabilities[i];\n\n  for (i = 0; i < size; i++) {\n    sum2 += probabilities[i];\n    if (sum2 > randNum)\n      return i;\n  }\n\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int randMinMax(int minimum, int maximum) {\n    return (rand() % (maximum - minimum)) + minimum;\n}\n","function_prediction":"int randMinMax_name_conflict(int min, int max) { return rand() % (max - min) + min; }","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"char cycleChar(char original, int ticks) {\n    char alphabet[26] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int min = alphabet[0];\n    int max = alphabet[25];\n    if (isMutable(original))\n        return min + ((original + ticks - min) % 26);\n    return original;\n}\n","function_prediction":"char cycleChar_name_conflict(char c, int n) {\n  if (isMutable(c)) {\n    return (c - 'A' + n) % 26 + 'A';\n  } else {\n    return c;\n  }\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"bool isMutable(char c) {\n    int i;\n    char mutables[26] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for (i = 0; i < 26; i++) {\n        if (mutables[i] == c)\n            return 1;\n    }\n    return 0;\n}\n","function_prediction":"int isMutable_name_conflict(char c) {\n  char mutable[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  int i;\n  for (i = 0; i < 25; i++) {\n    if (c == mutable[i]) {\n      return 1;\n    }\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"char *loadFileToDecode(char *fileName) {\n    int length = 0;\n    FILE *file = fopen(fileName, \"rb\");\n    char *buffer = ((void *)0);\n    if (file) {\n        fseek(file, 0, 2);\n        length = ftell(file);\n        fseek(file, 0, 0);\n        buffer = calloc(length + 1, sizeof(char));\n        fread(buffer, 1, length, file);\n        fclose(file);\n        return buffer;\n    } else {\n        error(\"Couldn't read input file\");\n    }\n    return ((void *)0);\n}\n","function_prediction":"char *loadFileToDecode_name_conflict(char *filename) {\n  FILE *file;\n  char *buffer;\n  long fileLen;\n\n  file = fopen(filename, \"rb\");\n  if (!file) {\n    error(\"Couldn't read input file\");\n    return NULL;\n  }\n\n  fseek(file, 0, 2);\n  fileLen = ftell(file);\n  fseek(file, 0, 0);\n\n  buffer = calloc(fileLen + 1, 1);\n  fread(buffer, 1, fileLen, file);\n  fclose(file);\n\n  return buffer;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"long timediff(clock_t t1, clock_t t2) {\n    long elapsed;\n    elapsed = ((double)t2 - t1) / ((__clock_t)1000000) * 1000;\n    return elapsed;\n}\n","function_prediction":"long timediff_name_conflict(struct timeval start, struct timeval end) {\n  return (long)((end.tv_sec - start.tv_sec) * 1000.0 +\n                (end.tv_usec - start.tv_usec) / 1000.0);\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/main.c"}
{"compilable":0,"function":"inline Limit init_limit(unsigned int h, struct Limit lim) {\n    double WSd = (double)sizeof(WORD) * 8;\n    unsigned int WSi = (unsigned int)sizeof(WORD) * 8;\n    lim.h = h;\n    WORD yWord = (9223372036854775807L * 2UL + 1UL);\n    unsigned int shift_places = (WSi - (h % WSi)) % WSi;\n    yWord = yWord >> shift_places;\n    lim.yWord = yWord;\n    lim.words = (unsigned int)ceil((double)lim.h / WSd);\n    lim.yIndex = 0;\n    return lim;\n}\n","function_prediction":"limit_t init_limit_name_conflict(unsigned int n) {\n  limit_t limit;\n  limit.n = n;\n  limit.m = (unsigned int)ceil((double)n / 64);\n  limit.mask = ~(((unsigned long)1 << (64 - n % 64)) - 1);\n  return limit;\n}","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int popcount_words(WORD *words, int length) {\n    unsigned int count = 0;\n    unsigned int i;\n    for (i = 0; i < length; i++) {\n        count += __builtin_popcountl(words[i]);\n    }\n    return count;\n}\n","function_prediction":"unsigned int popcount_words_name_conflict(const uint64_t *words, unsigned int nwords) {\n  unsigned int i, count = 0;\n\n  for (i = 0; i < nwords; i++)\n    count += __builtin_popcountll(words[i]);\n\n  return count;\n}","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD *shift_words(WORD *words, int length) {\n    WORD mask = (WORD)1 << ((int)sizeof(WORD) * 8 - 1);\n    WORD carried_bit = 0;\n    WORD temp;\n    int i;\n    for (i = length - 1; i > -1; i--) {\n        temp = words[i];\n        words[i] = (WORD)((words[i] << 1) | carried_bit);\n        carried_bit = (WORD)((temp & mask) != 0);\n    }\n    return words;\n}\n","function_prediction":"uint64_t *shift_words_name_conflict(uint64_t *words, int n) {\n  uint64_t carry = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    uint64_t word = words[i];\n    words[i] = (word << 1) | carry;\n    carry = (word & 0x8000000000000000) ? 1 : 0;\n  }\n  return words;\n}","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD *shiftc_words(WORD *words, struct Limit lim) {\n    words = shift_words(words, lim.words);\n    words[lim.yIndex] = words[lim.yIndex] & lim.yWord;\n    return words;\n}\n","function_prediction":"uint64_t *shiftc_words_name_conflict(uint64_t *words, int n, int m, uint64_t mask) {\n  words = shift_words(words, n, m);\n  words[m] &= mask;\n  return words;\n}","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD delta(char a, char b) {\n    return (WORD)(a != b);\n}\n","function_prediction":"int delta_name_conflict(char a, char b) { return a != b; }","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int maxshiftm_hd(unsigned char *p, unsigned int m, unsigned char *t, unsigned int n, unsigned int h, unsigned int *ii, unsigned int *jj, unsigned int *dd) {\n    unsigned int i, j, k, err, min_err;\n    min_err = (2147483647 * 2U + 1U);\n    Limit lim;\n    lim = init_limit(h, lim);\n    WORD *ones;\n    if ((ones = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n        fprintf(stderr, \" Error: ow could not be allocated!\\n\");\n        return (0);\n    }\n    WORD ***M;\n    if ((M = (WORD ***)calloc((m + 1), sizeof(WORD **))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M1 could not be allocated!\\n\");\n        return (0);\n    }\n    for (i = 0; i < m + 1; i++) {\n        if ((M[i] = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M2 could not be allocated!\\n\");\n            return (0);\n        }\n    }\n    for (i = 0; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if ((M[i][j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n                fprintf(stderr, \" Error: M3 could not be allocated!\\n\");\n                return (0);\n            }\n        }\n    }\n    for (i = 1; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if (j == 0) {\n                if (i <= lim.h) {\n                    ones = shift_words(ones, lim.words);\n                    ones[lim.words - 1] = ones[lim.words - 1] + 1;\n                }\n                memcpy(M[i][j], ones, lim.words * sizeof(WORD));\n            } else {\n                for (k = 0; k < lim.words; k++) {\n                    M[i][j][k] = M[i - 1][j - 1][k];\n                }\n                M[i][j] = shiftc_words(M[i][j], lim);\n                M[i][j][lim.words - 1] = M[i][j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n            }\n            if (j >= lim.h && i >= lim.h) {\n                err = popcount_words(M[i][j], lim.words);\n                if (err < min_err) {\n                    min_err = err;\n                    (*dd) = min_err;\n                    (*ii) = i - 1;\n                    (*jj) = j - 1;\n                }\n            }\n        }\n    }\n    for (i = 0; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            free(M[i][j]);\n        }\n        free(M[i]);\n    }\n    free(M);\n    free(ones);\n    return 1;\n}\n","function_prediction":"int maxshiftm_hd_ls(char *s, int n, char *t, int m, int limit, int *i, int *j,\n                    int *max) {\n  int i1, j1, k, l, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14,\n      l15, l16, l17, l18, l19, l20, l21, l22, l23, l24, l25, l26, l27, l28, l29,\n      l30, l31, l32, l33, l34, l35, l36, l37, l38, l39, l40, l41, l42, l43, l44,\n      l45, l46, l47, l48, l49, l50, l51, l52, l53, l54, l55, l56, l57, l58, l59,\n      l60, l61, l62, l63, l64, l65, l66, l67, l68, l69, l70, l71, l72, l73, l74,\n      l75, l76, l77, l78, l79, l80, l81, l82, l83, l84, l85, l86, l87, l88, l89,\n      l90, l91, l92, l93, l94, l95, l96, l97, l98, l99, l100, l101, l102, l103,\n      l104, l105, l106, l107, l108, l109, l110, l111, l112, l113, l1","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int maxshiftm_hd_ls(unsigned char *p, unsigned int m, unsigned char *t, unsigned int n, unsigned int h, unsigned int *ii, unsigned int *jj, unsigned int *dd) {\n    unsigned int i, j, k, err, min_err;\n    min_err = (2147483647 * 2U + 1U);\n    Limit lim;\n    lim = init_limit(h, lim);\n    WORD *ones;\n    if ((ones = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n        fprintf(stderr, \" Error: ow could not be allocated!\\n\");\n        return (0);\n    }\n    WORD **M0;\n    WORD **M1;\n    if ((M0 = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M0 could not be allocated!\\n\");\n        return (0);\n    }\n    if ((M1 = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M1 could not be allocated!\\n\");\n        return (0);\n    }\n    for (j = 0; j < n + 1; j++) {\n        if ((M0[j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M0J could not be allocated!\\n\");\n            return (0);\n        }\n        if ((M1[j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M1J could not be allocated!\\n\");\n            return (0);\n        }\n    }\n    for (i = 1; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if (j == 0 && i <= lim.h) {\n                ones = shift_words(ones, lim.words);\n                ones[lim.words - 1] = ones[lim.words - 1] + 1;\n            }\n            switch (i % 2) {\n              case 0:\n                if (j == 0) {\n                    memcpy(M1[j], ones, lim.words * sizeof(WORD));\n                } else {\n                    for (k = 0; k < lim.words; k++) {\n                        M1[j][k] = M0[j - 1][k];\n                    }\n                    M1[j] = shiftc_words(M1[j], lim);\n                    M1[j][lim.words - 1] = M1[j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n                }\n                if (j >= lim.h && i >= lim.h) {\n                    err = popcount_words(M1[j], lim.words);\n                    if (err < min_err) {\n                        min_err = err;\n                        (*dd) = min_err;\n                        (*ii) = i - 1;\n                        (*jj) = j - 1;\n                    }\n                }\n                break;\n              case 1:\n                if (j == 0) {\n                    memcpy(M0[j], ones, lim.words * sizeof(WORD));\n                } else {\n                    for (k = 0; k < lim.words; k++) {\n                        M0[j][k] = M1[j - 1][k];\n                    }\n                    M0[j] = shiftc_words(M0[j], lim);\n                    M0[j][lim.words - 1] = M0[j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n                }\n                if (j >= lim.h && i >= lim.h) {\n                    err = popcount_words(M0[j], lim.words);\n                    if (err < min_err) {\n                        min_err = err;\n                        (*dd) = min_err;\n                        (*ii) = i - 1;\n                        (*jj) = j - 1;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    for (j = 0; j < n + 1; j++) {\n        free(M0[j]);\n        free(M1[j]);\n    }\n    free(M0);\n    free(M1);\n    free(ones);\n    return 1;\n}\n","function_prediction":"int maxshiftm_hd_ls(char *T, unsigned int n, char *P, unsigned int m,\n                    unsigned int w, unsigned int *max_i, unsigned int *max_j,\n                    unsigned int *max_d) {\n  unsigned int i, j, k, l, d, w_words, min_d = -1;\n  unsigned int *ow, **M0, **M1, *M0J, *M1J;\n\n  init_limit(&w_words, w);\n\n  ow = (unsigned int *)calloc(w_words, sizeof(unsigned int));\n  if (ow == NULL) {\n    fwrite(\" Error: ow could not be allocated!\\n\", 1, 35, stderr);\n    return 0;\n  }\n\n  M0 = (unsigned int **)calloc(m + 1, sizeof(unsigned int *));\n  if (M0 == NULL) {\n    fwrite(\" Error: M0 could not be allocated!\\n\", 1, 35, stderr);\n    return 0;\n  }\n\n  M1 = (unsigned int **)calloc(m + 1, sizeof(unsigned int *));\n  if (M1 == NULL) {\n    fwrite(\" Error: M1 could not be allocated!\\n\", 1, 35, stderr);\n    return 0;\n  }\n\n  for (j = 0; j < m + 1; j++) {\n    M0[j] = (unsigned int *)calloc(w_words, sizeof(unsigned int));\n    if (M0[j] == NULL) {\n      fwrite(\" Error: M0J could not be allocated!\\n\", 1, 36, stderr);\n      return 0;\n    }\n\n    M1[j] = (unsigned int *)calloc(w_words, sizeof(unsigned int));\n    if (M1[j] == NULL) {\n      fwrite(\" Error: M1J could not be allocated!\\n\", 1, 36, stderr);\n      return 0;\n    }\n  }\n\n    for(","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"static int buf_prepare(size_t require) {\n    if (buf->size >= require) {\n        return 0;\n    }\n    buf->size = require * 2;\n    if (buf->size < 4096) {\n        buf->size = 4096;\n    }\n    if (buf->data == ((void *)0)) {\n        buf->data = malloc(buf->size);\n    } else {\n        buf->data = realloc(buf->data, buf->size);\n    }\n    if (buf->data == ((void *)0)) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int buf_prepare_name_conflict(size_t size) {\n  if (buf->size >= size)\n    return 0;\n\n  buf->size = size * 2;\n  if (buf->size < 4096)\n    buf->size = 4096;\n\n  if (buf->data)\n    buf->data = realloc(buf->data, buf->size);\n  else\n    buf->data = malloc(buf->size);\n\n  if (!buf->data)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_connect(const char *addrstr) {\n    int fd;\n    struct sockaddr_un addr;\n    fd = socket(1, SOCK_STREAM, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    memset(&addr, 0, sizeof(struct sockaddr_un));\n    addr.sun_family = 1;\n    strncpy(addr.sun_path, addrstr, sizeof (addr.sun_path) - 1);\n    if (connect(fd, (struct sockaddr *)&addr, sizeof (addr)) == -1) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int pt_comm_connect_name_conflict(const char *path) {\n  int sock;\n  struct sockaddr_un addr;\n\n  sock = socket(1, 1, 0);\n  if (sock == -1)\n    return -1;\n\n  memset(&addr, 0, sizeof(addr));\n  addr.sun_family = 1;\n  strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1)\n    return -1;\n\n  return sock;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_listen(const char *addrstr) {\n    int fd;\n    struct sockaddr_un addr;\n    fd = socket(1, SOCK_STREAM, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    memset(&addr, 0, sizeof(struct sockaddr_un));\n    addr.sun_family = 1;\n    strncpy(addr.sun_path, addrstr, sizeof (addr.sun_path) - 1);\n    if (unlink(addr.sun_path) == -1 && (*__errno_location()) != 2) {\n        return -1;\n    }\n    if (bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) == -1) {\n        return -1;\n    }\n    if (chmod(addr.sun_path, (2048 | 1024 | 512 | (256 | 128 | 64) | ((256 | 128 | 64) >> 3) | (((256 | 128 | 64) >> 3) >> 3))) == 0) {\n        (*__errno_location()) = 0;\n    }\n    if (listen(fd, 128) == -1) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int pt_comm_listen_name_conflict(const char *path) {\n  int sock;\n  struct sockaddr_un addr;\n\n  sock = socket(1, 1, 0);\n  if (sock == -1)\n    return -1;\n\n  memset(&addr, 0, sizeof(addr));\n  addr.sun_family = 1;\n  strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n\n  if (unlink(addr.sun_path) == -1 && *__errno_location() != 2)\n    return -1;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1)\n    return -1;\n\n  if (!chmod(addr.sun_path, 07777))\n    *__errno_location() = 0;\n\n  if (listen(sock, 128) == -1)\n    return -1;\n\n  return sock;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_accept(int fd) {\n    struct sockaddr_un addr;\n    socklen_t addrlen = sizeof (addr);\n    return accept(fd, (struct sockaddr *)&addr, &addrlen);\n}\n","function_prediction":"int pt_comm_accept_name_conflict(int sock) {\n  struct sockaddr_un addr;\n  socklen_t addrlen = sizeof(addr);\n  return accept(sock, (struct sockaddr *)&addr, &addrlen);\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_recv_msg(int fd, pt_comm_message_t **msg_ptr) {\n    int i;\n    ssize_t retval, recvlen;\n    pt_comm_message_t *msg;\n    if (buf_prepare(sizeof(pt_comm_message_t)) == -1) {\n        return PT_MSG_ERR_BUF;\n    }\n    msg = *msg_ptr = buf->data;\n    retval = recv(fd, msg, sizeof(pt_comm_message_t), MSG_DONTWAIT);\n    if (retval == -1) {\n        if ((*__errno_location()) == 11 || (*__errno_location()) == 11) {\n            return PT_MSG_EMPTY;\n        } else {\n            return PT_MSG_ERR_SOCK;\n        }\n    } else if (retval == 0) {\n        return PT_MSG_PEERDOWN;\n    } else if (retval != sizeof(pt_comm_message_t)) {\n        return PT_MSG_INVALID;\n    } else if (msg->len > 1024 * 1024 || msg->len < 0) {\n        return PT_MSG_INVALID;\n    }\n    if (msg->len == 0) {\n        return msg->type;\n    }\n    if (buf_prepare(sizeof(pt_comm_message_t) + msg->len) == -1) {\n        return PT_MSG_ERR_BUF;\n    }\n    msg = *msg_ptr = buf->data;\n    for (i = 0 , recvlen = 0; i < 10; i++) {\n        retval = recv(fd, msg->data + recvlen, msg->len - recvlen, 0);\n        if (retval == -1) {\n            return PT_MSG_ERR_SOCK;\n        } else if (retval == 0) {\n            return PT_MSG_PEERDOWN;\n        }\n        recvlen += retval;\n        if (recvlen == msg->len) {\n            break;\n        }\n    }\n    if (recvlen != msg->len) {\n        return PT_MSG_INVALID;\n    }\n    return msg->type;\n}\n","function_prediction":"int pt_comm_recv_msg_name_conflict(int sock, struct pt_comm_msg **msg) {\n  int i, rc;\n  size_t len;\n\n  rc = buf_prepare(12);\n  if (rc == -1)\n    return 3;\n\n  *msg = (struct pt_comm_msg *)buf->data;\n\n  len = recv(sock, (*msg)->data, 12, 0x40);\n  if (len == -1) {\n    if (((*__errno_location()) == 11) || ((*__errno_location()) == 11))\n      return 0;\n    return 2;\n  }\n  if (len == 0)\n    return 1;\n  if (len != 12)\n    return 4;\n\n  if (((*msg)->len) > (1024 * 1024 * 1024))\n    return 4;\n  if (((*msg)->len) < 0)\n    return 4;\n\n  if (((*msg)->len) == 0)\n    return (*msg)->type;\n\n  rc = buf_prepare((*msg)->len + 12);\n  if (rc == -1)\n    return 3;\n\n  *msg = (struct pt_comm_msg *)buf->data;\n\n  len = 0;\n  for (i = 0; i < 10; i++) {\n    size_t l;\n\n    l = recv(sock, (*msg)->data + len + 12, (*msg)->len - len, 0);\n    if (l == -1)\n      return 2;\n    if (l == 0)\n      return 1;\n\n    len += l;\n    if (len == (*msg)->len)\n      break;\n  }\n\n  if (len != (*msg)->len)\n    return 4;\n\n  return (*msg)->type;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_build_msg(pt_comm_message_t **msg_ptr, size_t size, int type) {\n    pt_comm_message_t *msg;\n    if (buf_prepare(sizeof(pt_comm_message_t) + size) == -1) {\n        return -1;\n    }\n    msg = *msg_ptr = buf->data;\n    msg->len = size;\n    msg->type = type;\n    return 0;\n}\n","function_prediction":"int pt_comm_build_msg_name_conflict(pt_comm_msg_t *msg, uint8_t type, uint8_t len) {\n  if (buf_prepare(sizeof(pt_comm_msg_t) + len) == -1)\n    return -1;\n\n  msg->buf = buf->data;\n  msg->buf[0] = type;\n  msg->buf[1] = len;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_send_type(int fd, int type) {\n    pt_comm_message_t *msg;\n    if (pt_comm_build_msg(&msg, 0, type) == -1) {\n        return -1;\n    }\n    return pt_comm_send_msg(fd, msg);\n}\n","function_prediction":"int pt_comm_send_type_name_conflict(int fd, int type) {\n  struct pt_comm_msg *msg;\n  int ret;\n\n  ret = pt_comm_build_msg(&msg, NULL, type);\n  if (ret == -1)\n    return -1;\n\n  return pt_comm_send_msg(fd, msg);\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_send_msg(int fd, pt_comm_message_t *msg) {\n    ssize_t retval;\n    retval = send(fd, msg, sizeof(pt_comm_message_t), 0);\n    if (retval == -1) {\n        return -1;\n    }\n    if (msg->len == 0) {\n        return 0;\n    }\n    retval = send(fd, msg->data, msg->len, 0);\n    if (retval == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int pt_comm_send_msg_name_conflict(int sock, struct pt_comm_msg *msg) {\n  if (send(sock, msg, sizeof(struct pt_comm_msg), 0) == -1)\n    return -1;\n\n  if (msg->len == 0)\n    return 0;\n\n  if (send(sock, msg->data, msg->len, 0) == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_close(int fd, const char *addrstr) {\n    if (addrstr != ((void *)0)) {\n        unlink(addrstr);\n    }\n    return close(fd);\n}\n","function_prediction":"void pt_comm_close_name_conflict(int fd, const char *fifo) {\n  if (fifo)\n    unlink(fifo);\n  close(fd);\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"static int has_color(void) {\n    if (output_is_tty == -1) {\n        output_is_tty = isatty(1);\n    }\n    return output_is_tty == 1 ? 1 : 0;\n}\n","function_prediction":"int has_color_name_conflict(void) {\n  if (output_is_tty == -1)\n    output_is_tty = isatty(1);\n  return output_is_tty == 1;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_type.c"}
{"compilable":0,"function":"static int pt_send_msg(int fd) {\n    if (clictx.pft.type != (1 << 0)) {\n        pt_comm_message_t *msg;\n        if (pt_comm_build_msg(&msg, sizeof(pt_filter_t), PT_MSG_DO_FILTER) == -1) {\n            return -1;\n        }\n        pt_filter_pack_filter_msg(&clictx.pft, msg->data);\n        if (pt_comm_send_msg(fd, msg) == -1) {\n            return -1;\n        }\n    }\n    if (clictx.pft.type != (1 << 1)) {\n        return pt_comm_send_type(fd, PT_MSG_DO_TRACE);\n    }\n    return 0;\n}\n","function_prediction":"int pt_send_msg_name_conflict(int fd) {\n  int ret;\n  char *msg;\n\n  if (DAT_0010c4a8 != 1) {\n    ret = pt_comm_build_msg(&msg, 16, 0x80000003);\n    if (ret == -1)\n      return -1;\n\n    pt_filter_pack_filter_msg(&DAT_0010c4a8, msg + 12);\n\n    ret = pt_comm_send_msg(fd, msg);\n    if (ret == -1)\n      return -1;\n  }\n\n  if (DAT_0010c4a8 != 2)\n    ret = pt_comm_send_type(fd, 0x80000001);\n  else\n    ret = 0;\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/src/trace.c"}
{"compilable":0,"function":"int pt_status_main(void) {\n    int ret, try_ptrace;\n    try_ptrace = 0;\n    if (!clictx.ptrace) {\n        ret = status_ext();\n        if (ret == -1) {\n            printf(\"Fetch status error\\n\");\n            try_ptrace = 1;\n        } else if (ret == -2) {\n            printf(\"Operation timed out, no response received, make sure PHP process is active and extension already installed.\\n\");\n            try_ptrace = 1;\n        }\n    }\n    try_ptrace = 0;\n    if (clictx.ptrace || try_ptrace) {\n        ret = status_ptrace();\n    }\n    return ret;\n}\n","function_prediction":"int pt_status_main_name_conflict(void) {\n  int ret;\n\n  if (0 == DAT_0010c28c) {\n    ret = status_ext();\n    if (-1 == ret) {\n      puts(\"Fetch status error\");\n    } else if (-2 == ret) {\n      puts(\"Operation timed out, no response received, make sure PHP process \"\n           \"is active and extension already installed.\");\n    }\n  }\n\n  if (0 != DAT_0010c28c) {\n    ret = status_ptrace();\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/src/status.c"}
{"compilable":0,"function":"sds sdsempty(void) {\n    return sdsnewlen(\"\", 0);\n}\n","function_prediction":"sds sdsempty_name_conflict(void) { return sdsnewlen(\"\", 0); }","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsnew(const char *init) {\n    size_t initlen = (init == ((void *)0)) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n","function_prediction":"sds sdsnewlen(const void *init, size_t initlen) {\n  struct sdshdr *sh;\n\n  if (init) {\n    sh = malloc(sizeof(struct sdshdr) + initlen + 1);\n  } else {\n    sh = calloc(sizeof(struct sdshdr) + initlen + 1, 1);\n  }\n  if (sh == NULL)\n    return NULL;\n\n  sh->len = initlen;\n  sh->free = 0;\n  if (initlen && init)\n    memcpy(sh + 1, init, initlen);\n  sh->buf[initlen] = '\\0';\n  return (char *)sh + 2;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}\n","function_prediction":"sds sdsdup_name_conflict(const sds s) { return sdsnewlen(s, sdslen(s)); }","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsMakeRoomFor(sds s, size_t addlen) {\n    struct sdshdr *sh, *newsh;\n    size_t free = sdsavail(s);\n    size_t len, newlen;\n    if (free >= addlen)\n        return s;\n    len = sdslen(s);\n    sh = (void *)(s - sizeof *sh);\n    ;\n    newlen = (len + addlen);\n    if (newlen < (1024 * 1024))\n        newlen *= 2;\n    else\n        newlen += (1024 * 1024);\n    newsh = realloc(sh, sizeof *newsh + newlen + 1);\n    if (newsh == ((void *)0))\n        return ((void *)0);\n    newsh->free = newlen - len;\n    return newsh->buf;\n}\n","function_prediction":"sds sdsMakeRoomFor_name_conflict(sds s, size_t addlen) {\n  struct sdshdr *sh, *newsh;\n  size_t free = sdsavail(s);\n  size_t len, newlen;\n\n  if (free >= addlen)\n    return s;\n  len = sdslen(s);\n  sh = (void *)(s - (sizeof(struct sdshdr)));\n  newlen = (len + addlen);\n  if (newlen < (1 << 16))\n    newlen *= 2;\n  else\n    newlen += (1 << 16);\n  newsh = realloc(sh, sizeof(struct sdshdr) + newlen + 1);\n  if (newsh == NULL)\n    return NULL;\n  newsh->free = newlen - len;\n  return newsh->buf;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsRemoveFreeSpace(sds s) {\n    struct sdshdr *sh;\n    sh = (void *)(s - sizeof *sh);\n    ;\n    sh = realloc(sh, sizeof *sh + sh->len + 1);\n    sh->free = 0;\n    return sh->buf;\n}\n","function_prediction":"sds sdsRemoveFreeSpace_name_conflict(sds s) {\n  struct sdshdr *sh = (void *)(s - (sizeof(struct sdshdr)));\n  s = (sds)realloc(sh, sizeof(struct sdshdr) + sh->free + 1);\n  sh = (void *)(s - (sizeof(struct sdshdr)));\n  sh->free = 0;\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"size_t sdsAllocSize(sds s) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    ;\n    return sizeof (*sh) + sh->len + sh->free + 1;\n}\n","function_prediction":"size_t sdsAllocSize_name_conflict(sds s) {\n  return ((size_t)(((sds)(((char *)s) - (long)(((sds)s)->buf)))->len +\n                   ((sds)(((char *)s) - (long)(((sds)s)->buf)))->free + 1));\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsgrowzero(sds s, size_t len) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    size_t totlen, curlen = sh->len;\n    if (len <= curlen)\n        return s;\n    s = sdsMakeRoomFor(s, len - curlen);\n    if (s == ((void *)0))\n        return ((void *)0);\n    sh = (void *)(s - sizeof *sh);\n    memset(s + curlen, 0, (len - curlen + 1));\n    totlen = sh->len + sh->free;\n    sh->len = len;\n    sh->free = totlen - sh->len;\n    return s;\n}\n","function_prediction":"sds sdsgrowzero_name_conflict(sds s, size_t len) {\n  struct sdshdr *sh = (void *)(s - (sizeof(struct sdshdr)));\n  size_t totlen;\n\n  if (sh->free >= (len - sh->len))\n    return s;\n\n  s = sdsMakeRoomFor(s, len - sh->len);\n  if (s == NULL)\n    return NULL;\n  sh = (void *)(s - (sizeof(struct sdshdr)));\n  memset(s + sh->len, 0, (len - sh->len) + 1);\n  totlen = sh->len + (len - sh->len);\n  sh->len = len;\n  sh->free = totlen - sh->len;\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n","function_prediction":"sds sdscatlen(sds s, const void *t, size_t len) {\n  struct sdshdr *sh = (void *)(s - (sizeof(struct sdshdr)));\n  size_t curlen = sdslen(s);\n  s = sdsMakeRoomFor(s, len);\n  if (s == NULL)\n    return NULL;\n  sh = (void *)(s - (sizeof(struct sdshdr)));\n  memcpy(s + curlen, t, len);\n  sh->len = curlen + len;\n  sh->free = sh->free - len;\n  s[curlen + len] = '\\0';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n","function_prediction":"sds sdscatsds_name_conflict(sds s, const sds t) { return sdscatlen(s, t, sdslen(t)); }","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscpylen(sds s, const char *t, size_t len) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    ;\n    size_t totlen = sh->free + sh->len;\n    if (totlen < len) {\n        s = sdsMakeRoomFor(s, len - sh->len);\n        if (s == ((void *)0))\n            return ((void *)0);\n        sh = (void *)(s - sizeof *sh);\n        ;\n        totlen = sh->free + sh->len;\n    }\n    memcpy(s, t, len);\n    s[len] = '\\x00';\n    sh->len = len;\n    sh->free = totlen - len;\n    return s;\n}\n","function_prediction":"sds sdscpylen_name_conflict(sds s, const char *t, size_t len) {\n  struct sdshdr *sh = (void *)(s - (sizeof(struct sdshdr)));\n  size_t totlen = sh->len + sh->free;\n\n  if (len <= totlen) {\n    memcpy(s, t, len);\n    s[len] = '\\0';\n    sh->len = len;\n    sh->free = totlen - len;\n    return s;\n  } else {\n    s = sdsMakeRoomFor(s, len - sh->len);\n    if (s == NULL)\n      return NULL;\n    sh = (void *)(s - (sizeof(struct sdshdr)));\n    totlen = sh->len + sh->free;\n    memcpy(s, t, len);\n    s[len] = '\\0';\n    sh->len = len;\n    sh->free = totlen - len;\n    return s;\n  }\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscpy(sds s, const char *t) {\n    return sdscpylen(s, t, strlen(t));\n}\n","function_prediction":"sds sdscpy_name_conflict(sds s, const char *t) {\n  size_t len = strlen(t);\n  return sdscpy_name_conflictlen(s, t, len);\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatprintf(sds s, const char *fmt, ...) {\n    va_list ap;\n    char *t;\n    __builtin_va_start(ap, fmt);\n    t = sdscatvprintf(s, fmt, ap);\n    __builtin_va_end(ap);\n    return t;\n}\n","function_prediction":"sds sdscatprintf_name_conflict(sds s, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  s = sdscatvprintf(s, fmt, ap);\n  va_end(ap);\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int sdscmp(const sds s1, const sds s2) {\n    size_t l1, l2, minlen;\n    int cmp;\n    l1 = sdslen(s1);\n    l2 = sdslen(s2);\n    minlen = (l1 < l2) ? l1 : l2;\n    cmp = memcmp(s1, s2, minlen);\n    if (cmp == 0)\n        return l1 - l2;\n    return cmp;\n}\n","function_prediction":"int sdscmp_name_conflict(const sds s1, const sds s2) {\n  size_t l1, l2, minlen;\n  int cmp;\n\n  l1 = sdslen(s1);\n  l2 = sdslen(s2);\n  minlen = (l1 < l2) ? l1 : l2;\n  cmp = memcmp(s1, s2, minlen);\n  if (cmp == 0)\n    return (int)(l1 - l2);\n  return cmp;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {\n    int elements = 0, slots = 5, start = 0, j;\n    sds *tokens;\n    if (seplen < 1 || len < 0)\n        return ((void *)0);\n    tokens = malloc(sizeof(sds) * slots);\n    if (tokens == ((void *)0))\n        return ((void *)0);\n    if (len == 0) {\n        *count = 0;\n        return tokens;\n    }\n    for (j = 0; j < (len - (seplen - 1)); j++) {\n        if (slots < elements + 2) {\n            sds *newtokens;\n            slots *= 2;\n            newtokens = realloc(tokens, sizeof(sds) * slots);\n            if (newtokens == ((void *)0))\n                goto cleanup;\n            tokens = newtokens;\n        }\n        if ((seplen == 1 && *(s + j) == sep[0]) || (memcmp(s + j, sep, seplen) == 0)) {\n            tokens[elements] = sdsnewlen(s + start, j - start);\n            if (tokens[elements] == ((void *)0))\n                goto cleanup;\n            elements++;\n            start = j + seplen;\n            j = j + seplen - 1;\n        }\n    }\n    tokens[elements] = sdsnewlen(s + start, len - start);\n    if (tokens[elements] == ((void *)0))\n        goto cleanup;\n    elements++;\n    *count = elements;\n    return tokens;\n  cleanup:\n    {\n        int i;\n        for (i = 0; i < elements; i++)\n            sdsfree(tokens[i]);\n        free(tokens);\n        *count = 0;\n        return ((void *)0);\n    }\n}\n","function_prediction":"sds *sdssplitlen_name_conflict(char *s, int len, char *sep, int seplen, int *count) {\n  int elements = 0, slots = 5, start = 0, j;\n  sds *tokens = NULL;\n\n  if (len < 1 || seplen < 1)\n    return NULL;\n  tokens = malloc(sizeof(sds) * slots);\n  if (tokens == NULL)\n    return NULL;\n  if (len == 0) {\n    *count = 0;\n    return tokens;\n  }\n  for (j = 0; j < (len - (seplen - 1)); j++) {\n    if (slots < elements + 2) {\n      slots *= 2;\n      tokens = realloc(tokens, sizeof(sds) * slots);\n      if (tokens == NULL)\n        goto cleanup;\n    }\n    if ((seplen == 1 && *(s + j) == sep[0]) ||\n        (memcmp(s + j, sep, seplen) == 0)) {\n      tokens[elements] = sdsnewlen(s + start, j - start);\n      if (tokens[elements] == NULL)\n        goto cleanup;\n      elements++;\n      start = j + seplen;\n      j = j + seplen - 1;\n    }\n  }\n  tokens[elements] = sdsnewlen(s + start, len - start);\n  if (tokens[elements] == NULL)\n    goto cleanup;\n  elements++;\n  *count = elements;\n  return tokens;\ncleanup: {\n  int i;\n  for (i = 0; i < elements; i++)\n    sdsfree(tokens[i]);\n  free(tokens);\n}\n  *count = 0;\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsfromlonglong(long long value) {\n    char buf[32], *p;\n    unsigned long long v;\n    v = (value < 0) ? -value : value;\n    p = buf + 31;\n    do {\n        *p-- = '0' + (v % 10);\n        v /= 10;\n    } while (v);\n    if (value < 0)\n        *p-- = '-';\n    p++;\n    return sdsnewlen(p, 32 - (p - buf));\n}\n","function_prediction":"sds sdsfromlonglong_name_conflict(long long value) {\n  char buf[32], *p;\n  int neg = 0;\n  unsigned long long v;\n\n  if (value == 0) {\n    buf[0] = '0';\n    buf[1] = '\\0';\n    return sdsnewlen(buf, 1);\n  }\n\n  if (value < 0) {\n    neg = 1;\n    v = -value;\n  } else {\n    v = (unsigned long long)value;\n  }\n\n  p = buf + 32;\n  *--p = '\\0';\n  while (v > 0) {\n    *--p = '0' + (v % 10);\n    v /= 10;\n  }\n  if (neg)\n    *--p = '-';\n  return sdsnewlen(p, ((char *)buf + 32) - p);\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatrepr(sds s, const char *p, size_t len) {\n    s = sdscatlen(s, \"\\\"\", 1);\n    while (len--)\n        {\n            switch (*p) {\n              case '\\\\':\n              case '\"':\n                s = sdscatprintf(s, \"\\\\%c\", *p);\n                break;\n              case '\\n':\n                s = sdscatlen(s, \"\\\\n\", 2);\n                break;\n              case '\\r':\n                s = sdscatlen(s, \"\\\\r\", 2);\n                break;\n              case '\\t':\n                s = sdscatlen(s, \"\\\\t\", 2);\n                break;\n              case '\\a':\n                s = sdscatlen(s, \"\\\\a\", 2);\n                break;\n              case '\\b':\n                s = sdscatlen(s, \"\\\\b\", 2);\n                break;\n              default:\n                if (((*__ctype_b_loc())[(int)((*p))] & (unsigned short)_ISprint))\n                    s = sdscatprintf(s, \"%c\", *p);\n                else\n                    s = sdscatprintf(s, \"\\\\x%02x\", (unsigned char)*p);\n                break;\n            }\n            p++;\n        }\n    return sdscatlen(s, \"\\\"\", 1);\n}\n","function_prediction":"sds sdscatrepr_name_conflict(sds s, const char *p, size_t len) {\n  s = sdscatlen(s, \"\\\"\", 1);\n  while (len--) {\n    switch (*p) {\n    case '\\\\':\n      s = sdscatprintf(s, \"\\\\\\\\\");\n      break;\n    case '\"':\n      s = sdscatprintf(s, \"\\\\\\\"\");\n      break;\n    case '\\n':\n      s = sdscatprintf(s, \"\\\\n\");\n      break;\n    case '\\r':\n      s = sdscatprintf(s, \"\\\\r\");\n      break;\n    case '\\t':\n      s = sdscatprintf(s, \"\\\\t\");\n      break;\n    default:\n      if ((*__ctype_b_loc()[(unsigned char)(*p)]) & 0x00004000)\n        s = sdscatprintf(s, \"\\\\x%02x\", (unsigned char)*p);\n      else\n        s = sdscatprintf(s, \"%c\", *p);\n      break;\n    }\n    p++;\n  }\n  return sdscatlen(s, \"\\\"\", 1);\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int is_hex_digit(char c) {\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}\n","function_prediction":"int is_hex_digit_name_conflict(char c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n         (c >= 'A' && c <= 'F');\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int hex_digit_to_int(char c) {\n    switch (c) {\n      case '0':\n        return 0;\n      case '1':\n        return 1;\n      case '2':\n        return 2;\n      case '3':\n        return 3;\n      case '4':\n        return 4;\n      case '5':\n        return 5;\n      case '6':\n        return 6;\n      case '7':\n        return 7;\n      case '8':\n        return 8;\n      case '9':\n        return 9;\n      case 'a':\n      case 'A':\n        return 10;\n      case 'b':\n      case 'B':\n        return 11;\n      case 'c':\n      case 'C':\n        return 12;\n      case 'd':\n      case 'D':\n        return 13;\n      case 'e':\n      case 'E':\n        return 14;\n      case 'f':\n      case 'F':\n        return 15;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int hex_digit_to_int_name_conflict(char c) {\n  switch (c) {\n  case '0':\n  case '0':\n    return 0;\n  case '1':\n  case '1':\n    return 1;\n  case '2':\n  case '2':\n    return 2;\n  case '3':\n  case '3':\n    return 3;\n  case '4':\n  case '4':\n    return 4;\n  case '5':\n  case '5':\n    return 5;\n  case '6':\n  case '6':\n    return 6;\n  case '7':\n  case '7':\n    return 7;\n  case '8':\n  case '8':\n    return 8;\n  case '9':\n  case '9':\n    return 9;\n  case 'a':\n  case 'A':\n    return 10;\n  case 'b':\n  case 'B':\n    return 11;\n  case 'c':\n  case 'C':\n    return 12;\n  case 'd':\n  case 'D':\n    return 13;\n  case 'e':\n  case 'E':\n    return 14;\n  case 'f':\n  case 'F':\n    return 15;\n  default:\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds *sdssplitargs(const char *line, int *argc) {\n    const char *p = line;\n    char *current = ((void *)0);\n    char **vector = ((void *)0);\n    *argc = 0;\n    while (1)\n        {\n            while (*p && ((*__ctype_b_loc())[(int)((*p))] & (unsigned short)_ISspace))\n                p++;\n            if (*p) {\n                int inq = 0;\n                int insq = 0;\n                int done = 0;\n                if (current == ((void *)0))\n                    current = sdsempty();\n                while (!done)\n                    {\n                        if (inq) {\n                            if (*p == '\\\\' && *(p + 1) == 'x' && is_hex_digit(*(p + 2)) && is_hex_digit(*(p + 3))) {\n                                unsigned char byte;\n                                byte = (hex_digit_to_int(*(p + 2)) * 16) + hex_digit_to_int(*(p + 3));\n                                current = sdscatlen(current, (char *)&byte, 1);\n                                p += 3;\n                            } else if (*p == '\\\\' && *(p + 1)) {\n                                char c;\n                                p++;\n                                switch (*p) {\n                                  case 'n':\n                                    c = '\\n';\n                                    break;\n                                  case 'r':\n                                    c = '\\r';\n                                    break;\n                                  case 't':\n                                    c = '\\t';\n                                    break;\n                                  case 'b':\n                                    c = '\\b';\n                                    break;\n                                  case 'a':\n                                    c = '\\a';\n                                    break;\n                                  default:\n                                    c = *p;\n                                    break;\n                                }\n                                current = sdscatlen(current, &c, 1);\n                            } else if (*p == '\"') {\n                                if (*(p + 1) && !((*__ctype_b_loc())[(int)((*(p + 1)))] & (unsigned short)_ISspace))\n                                    goto err;\n                                done = 1;\n                            } else if (!*p) {\n                                goto err;\n                            } else {\n                                current = sdscatlen(current, p, 1);\n                            }\n                        } else if (insq) {\n                            if (*p == '\\\\' && *(p + 1) == '\\'') {\n                                p++;\n                                current = sdscatlen(current, \"'\", 1);\n                            } else if (*p == '\\'') {\n                                if (*(p + 1) && !((*__ctype_b_loc())[(int)((*(p + 1)))] & (unsigned short)_ISspace))\n                                    goto err;\n                                done = 1;\n                            } else if (!*p) {\n                                goto err;\n                            } else {\n                                current = sdscatlen(current, p, 1);\n                            }\n                        } else {\n                            switch (*p) {\n                              case ' ':\n                              case '\\n':\n                              case '\\r':\n                              case '\\t':\n                              case '\\x00':\n                                done = 1;\n                                break;\n                              case '\"':\n                                inq = 1;\n                                break;\n                              case '\\'':\n                                insq = 1;\n                                break;\n                              default:\n                                current = sdscatlen(current, p, 1);\n                                break;\n                            }\n                        }\n                        if (*p)\n                            p++;\n                    }\n                vector = realloc(vector, ((*argc) + 1) * sizeof(char *));\n                vector[*argc] = current;\n                (*argc)++;\n                current = ((void *)0);\n            } else {\n                if (vector == ((void *)0))\n                    vector = malloc(sizeof(void *));\n                return vector;\n            }\n        }\n  err:\n    while ((*argc)--)\n        sdsfree(vector[*argc]);\n    free(vector);\n    if (current)\n        sdsfree(current);\n    *argc = 0;\n    return ((void *)0);\n}\n","function_prediction":"char **sdssplitargs_name_conflict(char *s, int *argc) {\n  char **argv = NULL;\n  sds cur = NULL;\n  *argc = 0;\n  while (1) {\n    while (*s && (__ctype_b_loc()[(unsigned char)(*s)] & (0x2000)))\n      s++;\n    if (*s == '\\0') {\n      if (argv == NULL)\n        argv = malloc(sizeof(char *));\n      return argv;\n    }\n    int in_escape = 0, in_quote = 0, in_arg = 0;\n    if (cur == NULL)\n      cur = sdsempty();\n    while (!in_arg) {\n      if (in_escape) {\n        if (*s == '\\\\' && s[1] == 'x' && is_hex_digit(s[2]) &&\n            is_hex_digit(s[3])) {\n          char c = hex_digit_to_int(s[2]) << 4;\n          c += hex_digit_to_int(s[3]);\n          cur = sdscatlen(cur, &c, 1);\n          s += 3;\n        } else if (*s == '\\\\' && s[1] != '\\0') {\n          char c;\n          s++;\n          switch (*s) {\n          case 'a':\n            c = '\\a';\n            break;\n          case 'b':\n            c = '\\b';\n            break;\n          case 'f':\n            c = '\\f';\n            break;\n          case 'n':\n            c = '\\n';\n            break;\n          case 'r':\n            c = '\\r';\n            break;\n          case 't':\n            c = '\\t';\n            break;\n          case 'v':\n            c = '\\v';\n            break;\n          default:\n            c = *s;\n            break;\n          }\n          cur = sdscatlen(cur, &c, 1);\n        } else if (*s == '\"' &&\n                   (s[1] == '\\0' ||\n                    (__ctype_b_loc()[(unsigned char)(s[1])] & (0x2000)))) {\n          in_arg = 1;\n        } else if (*s == '\\0') {","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {\n    size_t j, i, l = sdslen(s);\n    for (j = 0; j < l; j++) {\n        for (i = 0; i < setlen; i++) {\n            if (s[j] == from[i]) {\n                s[j] = to[i];\n                break;\n            }\n        }\n    }\n    return s;\n}\n","function_prediction":"char *sdsmapchars_name_conflict(char *s, const char *from, const char *to, size_t fromlen) {\n  size_t i, j;\n  size_t len = sdslen(s);\n  for (i = 0; i < len; ++i) {\n    for (j = 0; j < fromlen; ++j) {\n      if (s[i] == from[j]) {\n        s[i] = to[j];\n        break;\n      }\n    }\n  }\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsjoin(char **argv, int argc, char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n    for (j = 0; j < argc; j++) {\n        join = sdscat(join, argv[j]);\n        if (j != argc - 1)\n            join = sdscatlen(join, sep, seplen);\n    }\n    return join;\n}\n","function_prediction":"sds sdsjoinsds(const sds *sdss, int numsdss, const char *sep, size_t seplen) {\n  int j;\n  sds str = sdsempty();\n  for (j = 0; j < numsdss; j++) {\n    str = sdscatsds(str, sdss[j]);\n    if (j != numsdss - 1)\n      str = sdscatlen(str, sep, seplen);\n  }\n  return str;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n    for (j = 0; j < argc; j++) {\n        join = sdscatsds(join, argv[j]);\n        if (j != argc - 1)\n            join = sdscatlen(join, sep, seplen);\n    }\n    return join;\n}\n","function_prediction":"sds sdsjoinsds_name_conflict(const sds *argv, int argc, const char *sep, size_t seplen) {\n  int j;\n  sds str = sdsempty();\n\n  for (j = 0; j < argc; j++) {\n    str = sdscatsds(str, argv[j]);\n    if (j != argc - 1)\n      str = sdscatlen(str, sep, seplen);\n  }\n  return str;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"uint64_t jbg_ceil_half_name_conflict(uint64_t x, int64_t n) {\n  uint64_t mask = (1ULL << n) - 1;\n  return x >> n + ((x & mask) != 0);\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"uint32_t jbg_stripes_name_conflict(uint32_t stripes, uint32_t size, uint32_t stripe_size) {\n  uint32_t stripe_count = jbg_ceil_half(size, stripe_size) / stripes;\n  if (jbg_ceil_half(size, stripe_size) % stripes)\n    stripe_count++;\n  return stripe_count;\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg_strerror_name_conflict(int err) {\n  int i = err >> 4;\n  if (i < 0 || i >= 9)\n    return \"Unknown error code passed to jbg_strerror_name_conflict()\";\n  return errmsg[i];\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"const unsigned char *jbg_next_pscdms_name_conflict(const unsigned char *buf, size_t len) {\n  size_t n;\n\n  if (len < 2)\n    return NULL;\n\n  if (buf[0] == 0xff && buf[1] != 0x00) {\n    switch (buf[1]) {\n    case 0x05:\n      if (len < 6)\n        return NULL;\n      return buf + 6;\n    case 0x06:\n      if (len < 8)\n        return NULL;\n      return buf + 8;\n    case 0x07:\n      if (len < 6)\n        return NULL;\n      n = (buf[2] << 24) | (buf[3] << 16) | (buf[4] << 8) | buf[5];\n      if (n > len - 6)\n        return NULL;\n      return buf + 6 + n;\n    }\n    return NULL;\n  }\n\n  while (buf[0] == 0xff && buf[1] == 0x00) {\n    buf += 2;\n    len -= 2;\n    if (len < 2)\n      return NULL;\n  }\n\n  buf = (const unsigned char *)memchr(buf, 0xff, len - 1);\n  if (!buf)\n    return NULL;\n  n = buf - (const unsigned char *)buf;\n  buf += n;\n  len -= n;\n\n  if (buf[1] == 0x00)\n    return buf;\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"int jbg_newlen_name_conflict(unsigned char *buf, size_t len) {\n  unsigned char *p;\n  int i;\n\n  p = buf + 20;\n  if (len < 20)\n    return 32;\n  if ((buf[20 - 1] & 7) == 6)\n    p = buf + 1772;\n  if (p >= buf + len)\n    return 32;\n  while (1) {\n    p = jbg_next_pscdms(p, len - (p - buf));\n    if (p == NULL)\n      return 96;\n    if (p == buf + len)\n      return 0;\n    if (p[0] == 0xff)\n      continue;\n    if (p[1] == 0x04)\n      return 64;\n    if (p[1] == 0x05) {\n      for (i = 0; i < 4; i++)\n        buf[8 + i] = p[2 + i];\n      return 0;\n    }\n  }\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg85_strerror_name_conflict(int err) {\n  int i = err >> 4;\n  if (i < 0 || i >= 8)\n    return \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n  return errmsg[i];\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"uint64_t jbg_ceil_half_name_conflict(uint64_t x, int64_t n) {\n  uint64_t mask = (1ULL << n) - 1;\n  return x >> n + ((x & mask) != 0);\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"uint32_t jbg_stripes_name_conflict(uint32_t stripes, uint32_t size, uint32_t stripe_size) {\n  uint32_t stripe_count = jbg_ceil_half(size, stripe_size) / stripes;\n  if (jbg_ceil_half(size, stripe_size) % stripes)\n    stripe_count++;\n  return stripe_count;\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg_strerror_name_conflict(int err) {\n  int i = err >> 4;\n  if (i < 0 || i >= 9)\n    return \"Unknown error code passed to jbg_strerror_name_conflict()\";\n  return errmsg[i];\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"const unsigned char *jbg_next_pscdms_name_conflict(const unsigned char *buf, size_t len) {\n  size_t n;\n\n  if (len < 2)\n    return NULL;\n\n  if (buf[0] == 0xff && buf[1] != 0x00) {\n    switch (buf[1]) {\n    case 0x05:\n      if (len < 6)\n        return NULL;\n      return buf + 6;\n    case 0x06:\n      if (len < 8)\n        return NULL;\n      return buf + 8;\n    case 0x07:\n      if (len < 6)\n        return NULL;\n      n = (buf[2] << 24) | (buf[3] << 16) | (buf[4] << 8) | buf[5];\n      if (n > len - 6)\n        return NULL;\n      return buf + 6 + n;\n    }\n    return NULL;\n  }\n\n  while (buf[0] == 0xff && buf[1] == 0x00) {\n    buf += 2;\n    len -= 2;\n    if (len < 2)\n      return NULL;\n  }\n\n  buf = (const unsigned char *)memchr(buf, 0xff, len - 1);\n  if (!buf)\n    return NULL;\n  n = buf - (const unsigned char *)buf;\n  buf += n;\n  len -= n;\n\n  if (buf[1] == 0x00)\n    return buf;\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"int jbg_newlen_name_conflict(unsigned char *buf, size_t len) {\n  unsigned char *p;\n  int i;\n\n  p = buf + 20;\n  if (len < 20)\n    return 32;\n  if ((buf[20 - 1] & 7) == 6)\n    p = buf + 1772;\n  if (p >= buf + len)\n    return 32;\n  while (1) {\n    p = jbg_next_pscdms(p, len - (p - buf));\n    if (p == NULL)\n      return 96;\n    if (p == buf + len)\n      return 0;\n    if (p[0] == 0xff)\n      continue;\n    if (p[1] == 0x04)\n      return 64;\n    if (p[1] == 0x05) {\n      for (i = 0; i < 4; i++)\n        buf[8 + i] = p[2 + i];\n      return 0;\n    }\n  }\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg85_strerror_name_conflict(int err) {\n  int i = err >> 4;\n  if (i < 0 || i >= 8)\n    return \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n  return errmsg[i];\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"static int test_cycle(unsigned char **orig_image, int width, int height, int options, int order, int layers, int planes, unsigned long l0, int mx, long correct_length, const char *test_id) {\n    struct jbg_enc_state sje;\n    struct jbg_dec_state sjd;\n    int trouble = 0;\n    long l;\n    size_t plane_size;\n    int i, result;\n    unsigned char **image;\n    plane_size = ((width + 7) / 8) * height;\n    image = (unsigned char **)checkedmalloc(planes * sizeof(unsigned char *));\n    for (i = 0; i < planes; i++) {\n        image[i] = (unsigned char *)checkedmalloc(plane_size);\n        memcpy(image[i], orig_image[i], plane_size);\n    }\n    printf(\"\\nTest %s.1: Encoding ...\\n\", test_id);\n    testbuf_len = 0;\n    jbg_enc_init(&sje, width, height, planes, image, testbuf_writel, ((void *)0));\n    jbg_enc_layers(&sje, layers);\n    jbg_enc_options(&sje, order, options, l0, mx, 0);\n    jbg_enc_out(&sje);\n    jbg_enc_free(&sje);\n    for (i = 0; i < planes; i++)\n        free(image[i]);\n    free(image);\n    printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n    if (correct_length >= 0)\n        if (testbuf_len == correct_length)\n            puts(\"PASSED\");\n        else {\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\", correct_length);\n        }\n    else\n        puts(\"\");\n    printf(\"Test %s.2: Decoding whole chunk ...\\n\", test_id);\n    jbg_dec_init(&sjd);\n    result = jbg_dec_in(&sjd, testbuf, testbuf_len, ((void *)0));\n    if (result != (0 << 4)) {\n        printf(\"Decoder complained with return value %d: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg_strerror(result));\n        trouble++;\n    } else {\n        printf(\"Image comparison: \");\n        result = 1;\n        for (i = 0; i < planes; i++) {\n            if (memcmp(orig_image[i], sjd.lhp[layers & 1][i], ((width + 7) / 8) * height)) {\n                result = 0;\n                trouble++;\n                printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD for plane %d\\n\", i);\n            }\n        }\n        if (result)\n            puts(\"PASSED\");\n    }\n    jbg_dec_free(&sjd);\n    printf(\"Test %s.3: Decoding with single-byte feed ...\\n\", test_id);\n    jbg_dec_init(&sjd);\n    result = (2 << 4);\n    for (l = 0; l < testbuf_len; l++) {\n        result = jbg_dec_in(&sjd, testbuf + l, 1, ((void *)0));\n        if (l < testbuf_len - 1 && result != (2 << 4)) {\n            printf(\"Decoder complained with return value %d at byte %ld: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, l, jbg_strerror(result));\n            trouble++;\n            break;\n        }\n    }\n    if (l == testbuf_len) {\n        if (result != (0 << 4)) {\n            printf(\"Decoder complained with return value %d at final byte: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg_strerror(result));\n            trouble++;\n        } else {\n            printf(\"Image comparison: \");\n            result = 1;\n            for (i = 0; i < planes; i++) {\n                if (memcmp(orig_image[i], sjd.lhp[layers & 1][i], ((width + 7) / 8) * height)) {\n                    result = 0;\n                    trouble++;\n                    printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD for plane %d\\n\", i);\n                }\n            }\n            if (result)\n                puts(\"PASSED\");\n        }\n    }\n    jbg_dec_free(&sjd);\n    puts(\"\");\n    return trouble != 0;\n}\n","function_prediction":"int test_cycle(unsigned char **img, int w, int h, int q, int opt, int l, int p,\n               int *qtab, int qtab_len, long correct_len, char *name) {\n  int i, j, ret, err = 0;\n  size_t img_size = (((w + 7) / 8) * h) * p;\n  unsigned char **img_copy =\n      (unsigned char **)checkedmalloc(p * sizeof(unsigned char *));\n  unsigned char *buf;\n  struct jbg_enc_state enc;\n  struct jbg_dec_state dec[1];\n\n  for (i = 0; i < p; i++) {\n    img_copy[i] = (unsigned char *)checkedmalloc(img_size);\n    memcpy(img_copy[i], img[i], img_size);\n  }\n\n  printf(\"\\nTest %s.1: Encoding ...\\n\", name);\n  testbuf_len = 0;\n  jbg_enc_init(&enc, w, h, p, img_copy, testbuf_writel, 0);\n  jbg_enc_layers(&enc, l);\n  jbg_enc_options(&enc, opt, q, qtab, qtab_len, 0);\n  jbg_enc_out(&enc);\n  jbg_enc_free(&enc);\n\n  for (i = 0; i < p; i++)\n    free(img_copy[i]);\n  free(img_copy);\n\n  printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n  if (correct_len >= 0) {\n    if (testbuf_len != correct_len) {\n      err++;\n      printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\",\n             correct_len);\n    } else\n      printf(\"PASSED\\n\");\n  } else\n    printf(\"\\n\");\n\n  printf(\"Test %s.2: Decoding whole chunk ...\\n\", name);\n  jbg_dec_init(dec);\n  ret = jbg_dec_in(","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/tstcodec.c"}
{"compilable":0,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"uint64_t jbg_ceil_half_name_conflict(uint64_t x, int64_t n) {\n  uint64_t mask = (1ULL << n) - 1;\n  return x >> n + ((x & mask) != 0);\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"uint32_t jbg_stripes_name_conflict(uint32_t stripes, uint32_t size, uint32_t stripe_size) {\n  uint32_t stripe_count = jbg_ceil_half(size, stripe_size) / stripes;\n  if (jbg_ceil_half(size, stripe_size) % stripes)\n    stripe_count++;\n  return stripe_count;\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":1,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg_strerror_name_conflict(int err) {\n  int i = err >> 4;\n  if (i < 0 || i >= 9)\n    return \"Unknown error code passed to jbg_strerror_name_conflict()\";\n  return errmsg[i];\n}","pass":1,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":1,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"const unsigned char *jbg_next_pscdms_name_conflict(const unsigned char *buf, size_t len) {\n  size_t n;\n\n  if (len < 2)\n    return NULL;\n\n  if (buf[0] == 0xff && buf[1] != 0x00) {\n    switch (buf[1]) {\n    case 0x05:\n      if (len < 6)\n        return NULL;\n      return buf + 6;\n    case 0x06:\n      if (len < 8)\n        return NULL;\n      return buf + 8;\n    case 0x07:\n      if (len < 6)\n        return NULL;\n      n = (buf[2] << 24) | (buf[3] << 16) | (buf[4] << 8) | buf[5];\n      if (n > len - 6)\n        return NULL;\n      return buf + 6 + n;\n    }\n    return NULL;\n  }\n\n  while (buf[0] == 0xff && buf[1] == 0x00) {\n    buf += 2;\n    len -= 2;\n    if (len < 2)\n      return NULL;\n  }\n\n  buf = (const unsigned char *)memchr(buf, 0xff, len - 1);\n  if (!buf)\n    return NULL;\n  n = buf - (const unsigned char *)buf;\n  buf += n;\n  len -= n;\n\n  if (buf[1] == 0x00)\n    return buf;\n\n  return NULL;\n}","pass":1,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":1,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"int jbg_newlen_name_conflict(unsigned char *buf, size_t len) {\n  unsigned char *p;\n  int i;\n\n  p = buf + 20;\n  if (len < 20)\n    return 32;\n  if ((buf[20 - 1] & 7) == 6)\n    p = buf + 1772;\n  if (p >= buf + len)\n    return 32;\n  while (1) {\n    p = jbg_next_pscdms(p, len - (p - buf));\n    if (p == NULL)\n      return 96;\n    if (p == buf + len)\n      return 0;\n    if (p[0] == 0xff)\n      continue;\n    if (p[1] == 0x04)\n      return 64;\n    if (p[1] == 0x05) {\n      for (i = 0; i < 4; i++)\n        buf[8 + i] = p[2 + i];\n      return 0;\n    }\n  }\n}","pass":1,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":1,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg85_strerror_name_conflict(int err) {\n  int i = err >> 4;\n  if (i < 0 || i >= 8)\n    return \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n  return errmsg[i];\n}","pass":1,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"static int test_cycle(unsigned char *orig_image, int width, int height, int options, unsigned long l0, int mx, long correct_length, const char *test_id) {\n    struct jbg85_enc_state sje;\n    struct jbg85_dec_state sjd;\n    int trouble = 0;\n    long l;\n    size_t plane_size, buffer_len;\n    int i, result;\n    unsigned char *image, *buffer;\n    size_t bpl;\n    size_t cnt;\n    bpl = (width + 7) / 8;\n    plane_size = bpl * height;\n    image = (unsigned char *)checkedmalloc(plane_size);\n    memcpy(image, orig_image, plane_size);\n    printf(\"\\nTest-85 %s.1: Encoding ...\\n\", test_id);\n    testbuf_len = 0;\n    jbg85_enc_init(&sje, width, height, testbuf_writel, ((void *)0));\n    jbg85_enc_options(&sje, options, l0, mx);\n    for (i = 0; i < height; i++)\n        jbg85_enc_lineout(&sje, image + i * bpl, image + (i - 1) * bpl, image + (i - 2) * bpl);\n    free(image);\n    printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n    if (correct_length >= 0)\n        if (testbuf_len == correct_length)\n            puts(\"PASSED\");\n        else {\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\", correct_length);\n        }\n    else\n        puts(\"\");\n    buffer_len = ((width >> 3) + !!(width & 7)) * 3;\n    buffer = (unsigned char *)checkedmalloc(buffer_len);\n    image = (unsigned char *)checkedmalloc(plane_size);\n    printf(\"Test-85 %s.2: Decoding whole chunk ...\\n\", test_id);\n    jbg85_dec_init(&sjd, buffer, buffer_len, line_out, image);\n    result = jbg85_dec_in(&sjd, testbuf, testbuf_len, &cnt);\n    if (result != (0 << 4)) {\n        printf(\"Decoder complained with return value 0x%02x: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg85_strerror(result));\n        printf(\"%ld bytes of BIE read, %lu lines decoded.\\n\", (long)cnt, sjd.y);\n        trouble++;\n    } else {\n        printf(\"Image comparison: \");\n        result = 1;\n        if (memcmp(orig_image, image, plane_size)) {\n            result = 0;\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\");\n        }\n        if (result)\n            puts(\"PASSED\");\n    }\n    free(image);\n    image = (unsigned char *)checkedmalloc(plane_size);\n    printf(\"Test-85 %s.3: Decoding with single-byte feed ...\\n\", test_id);\n    jbg85_dec_init(&sjd, buffer, buffer_len, line_out, image);\n    result = (2 << 4);\n    for (l = 0; l < testbuf_len; l++) {\n        result = jbg85_dec_in(&sjd, testbuf + l, 1, ((void *)0));\n        if (l < testbuf_len - 1 && result != (2 << 4)) {\n            printf(\"Decoder complained with return value 0x%02x at byte %ld: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, l, jbg85_strerror(result));\n            trouble++;\n            break;\n        }\n    }\n    if (l == testbuf_len) {\n        if (result != (0 << 4)) {\n            printf(\"Decoder complained with return value 0x%02x at final byte: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg85_strerror(result));\n            trouble++;\n        } else {\n            printf(\"Image comparison: \");\n            result = 1;\n            if (memcmp(orig_image, image, plane_size)) {\n                result = 0;\n                trouble++;\n                printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\");\n            }\n            if (result)\n                puts(\"PASSED\");\n        }\n    }\n    free(image);\n    puts(\"\");\n    return trouble != 0;\n}\n","function_prediction":"int test_cycle(unsigned char *img, int w, int h, int flags, int level,\n               int nbits, long bie_len, char *name) {\n  int i, ret, errs = 0;\n  long bie_len_calc;\n  unsigned char *img_dec, *img_dec_buf, *img_dec_buf_buf;\n  unsigned char *img_enc, *img_enc_buf;\n  unsigned char *line_buf;\n  long line_buf_len;\n  jbg85_dec_t dec;\n  jbg85_enc_t enc;\n\n  line_buf_len = (w / 8 + (w % 8 ? 1 : 0)) * 3;\n  img_enc = checkedmalloc(w * h);\n  memcpy(img_enc, img, w * h);\n\n  printf(\"\\nTest-85 %s.1: Encoding ...\\n\", name);\n  testbuf_len = 0;\n  jbg85_enc_init(&enc, (unsigned char *)img_enc, w, h, testbuf_writel, NULL);\n  jbg85_enc_options(&enc, flags, level, nbits);\n  for (i = 0; i < h; i++)\n    jbg85_enc_lineout(&enc, img_enc + i * w, img_enc + (i - 1) * w,\n                      img_enc + (i - 2) * w);\n  free(img_enc);\n\n  printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n  if (bie_len < 0)\n    printf(\"\\n\");\n  else if (bie_len == testbuf_len)\n    printf(\"PASSED\\n\");\n  else {\n    printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\", bie_len);\n    errs++;\n  }\n\n  line_buf = checkedmalloc(line_buf_len);\n  img_enc_buf = checkedmalloc(w * h);\n\n  printf(\"Test-","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/tstcodec85.c"}
{"compilable":1,"function":"int discovery() {\n    DIR *dir;\n    struct dirent *ent;\n    bool comma = 0;\n    if ((dir = opendir(\"/sys/kernel/debug/ieee80211/\")) != ((void *)0)) {\n        printf(\"{\\\"data\\\":[\");\n        while ((ent = readdir(dir)) != ((void *)0))\n            {\n                if (strcmp(\".\", ent->d_name) && strcmp(\"..\", ent->d_name)) {\n                    if (comma)\n                        printf(\",\");\n                    printf(\"{\\\"{#PHY}\\\":\\\"%s\\\"}\", ent->d_name);\n                    comma = 1;\n                }\n            }\n        printf(\"]}\\n\");\n        closedir(dir);\n    } else {\n        perror(\"\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int discovery_name_conflict() {\n  DIR *dir;\n  struct dirent *ent;\n  int first = 0;\n\n  if ((dir = opendir(\"/sys/kernel/debug/ieee80211/\")) == NULL) {\n    perror(\"\");\n    return 1;\n  }\n\n  printf(\"{\\\"data\\\":[\");\n\n  while ((ent = readdir(dir)) != NULL) {\n    if (!strcmp(\".\", ent->d_name) || !strcmp(\"..\", ent->d_name))\n      continue;\n\n    if (first)\n      printf(\",\");\n    printf(\"{\\\"{#PHY}\\\":\\\"%s\\\"}\", ent->d_name);\n    first = 1;\n  }\n\n  printf(\"]}\\n\");\n\n  closedir(dir);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":1,"function":"int get_param(char *phy, char *stat) {\n    char *filename = ((void *)0);\n    FILE *f = ((void *)0);\n    phy = basename(phy);\n    stat = basename(stat);\n    if (asprintf(&filename, \"/sys/kernel/debug/ieee80211/%s/statistics/%s\", phy, stat) > 0)\n        f = fopen(filename, \"r\");\n    if (f != ((void *)0)) {\n        char temp[256];\n        while (fgets(temp, 256, f) != ((void *)0))\n            printf(\"%s\", temp);\n        fclose(f);\n    } else {\n        perror(\"\");\n        return 1;\n    }\n    free(filename);\n    return 0;\n}\n","function_prediction":"int get_param_name_conflict(char *ifname, char *param) {\n  FILE *fp = NULL;\n  char *path = NULL;\n  char buf[256];\n\n  if (asprintf(&path, \"/sys/kernel/debug/ieee80211/%s/statistics/%s\",\n               basename(ifname), basename(param)) > 0)\n    fp = fopen(path, \"r\");\n\n  if (!fp) {\n    perror(\"\");\n    return 1;\n  }\n\n  while (fgets(buf, sizeof(buf), fp))\n    printf(\"%s\", buf);\n\n  fclose(fp);\n  free(path);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":1,"function":"int usage(char *name) {\n    fprintf(stderr, \"Usage:\\n\");\n    fprintf(stderr, \" %s discovery\\n\", name);\n    fprintf(stderr, \" => print mac80211.phydiscovery discovery rule\\n\");\n    fprintf(stderr, \" %s PHY STAT\\n\", name);\n    fprintf(stderr, \" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as root\\n\");\n    return 1;\n}\n","function_prediction":"int usage_name_conflict(char *progname) {\n  fprintf(stderr, \"Usage:\\n\");\n  fprintf(stderr, \" %s discovery\\n\", progname);\n  fprintf(stderr, \" => print mac80211.phydiscovery discovery rule\\n\");\n  fprintf(stderr, \" %s PHY STAT\\n\", progname);\n  fprintf(stderr,\n          \" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as root\\n\");\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":0,"function":"static char *xasprintf(const char *fmt, ...) {\n    va_list ap;\n    char *ret;\n    __builtin_va_start(ap, fmt);\n    ret = xvasprintf(fmt, ap);\n    __builtin_va_end(ap);\n    return ret;\n}\n","function_prediction":"char *xasprintf_name_conflict(const char *fmt, ...) {\n  va_list ap;\n  char buf[1];\n\n  ap = (va_list)(size_t)&fmt;\n  return xvasprintf(buf, &ap);\n}","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":0,"function":"static char *fieldcpy(char *dst, char *fld) {\n    while (*fld && *fld != ':')\n        fld++;\n    if (!*(fld++))\n        return ((void *)0);\n    while (((*__ctype_b_loc())[(int)((*fld))] & (unsigned short)_ISspace))\n        fld++;\n    return strcpy(dst, fld);\n}\n","function_prediction":"char *fieldcpy_name_conflict(char *dest, char *src) {\n  char *p;\n\n  for (p = src; *p && *p != ':'; p++)\n    ;\n  if (*p == '\\0')\n    return NULL;\n  p++;\n  while (__ctype_b_loc()[*p] & 0x2000)\n    p++;\n  return strcpy(dest, p);\n}","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":0,"function":"static int dotranslatewgetpercent(int low, int high, int end, char *str) {\n    int ch;\n    int val, lastval;\n    lastval = val = 0;\n    while ((ch = getchar()) != (-1))\n        {\n            if (((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISdigit)) {\n                val *= 10;\n                val += ch - '0';\n            } else if (ch == '%') {\n                float f = (float)val / 100. * (high - low) + low;\n                if (str) {\n                    printf(\"P: %d %d %s\\n\", (int)f, end, str);\n                } else {\n                    printf(\"P: %d %d\\n\", (int)f, end);\n                }\n                lastval = val;\n            } else {\n                val = 0;\n            }\n        }\n    return lastval == 100;\n}\n","function_prediction":"int dotranslatewgetpercent_name_conflict(int min, int max, int maxval, char *name) {\n  int c, percent = 0, percentval = 0;\n  double percentd;\n\n  while ((c = getchar()) != -1) {\n    if (__ctype_b_loc()[(unsigned char)(c)] & 0x0800) {\n      percent = percent * 10 + c - '0';\n    } else if (c == '%') {\n      percentd = (double)min + (double)percent / 100.0 * (double)(max - min);\n      if (name)\n        printf(\"P: %d %d %s\\n\", (int)percentd, maxval, name);\n      else\n        printf(\"P: %d %d\\n\", (int)percentd, maxval);\n      percentval = percent;\n      percent = 0;\n    } else {\n      percent = 0;\n    }\n  }\n\n  return percentval == 100;\n}","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":1,"function":"static int luaO_int2fb(unsigned int x) {\n    int e = 0;\n    while (x >= 16)\n        {\n            x = (x + 1) >> 1;\n            e++;\n        }\n    if (x < 8)\n        return x;\n    else\n        return ((e + 1) << 3) | (((int)((x))) - 8);\n}\n","function_prediction":"int luaO_int2fb_name_conflict(int x) {\n  int e = 0;\n  while (x > 15) {\n    x = (x + 1) >> 1;\n    e++;\n  }\n  if (x >= 8)\n    return (((e + 1) << 3) | (x - 8));\n  else\n    return x;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static int luaO_fb2int(int x) {\n    int e = (x >> 3) & 31;\n    if (e == 0)\n        return x;\n    else\n        return ((x & 7) + 8) << (e - 1);\n}\n","function_prediction":"int luaO_fb2int_name_conflict(int x) {\n  int e = (x >> 3) & 0x1F;\n  if (e == 0)\n    return x;\n  else\n    return (((x & 7) + 8) << (e - 1));\n}","pass":1,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int luaO_log2(unsigned int x) {\n    static const lu_byte log_2[256] = {0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};\n    int l = -1;\n    while (x >= 256)\n        {\n            l += 8;\n            x >>= 8;\n        }\n    return l + log_2[x];\n}\n","function_prediction":"int luaO_log2_name_conflict(unsigned int x) {\n  int l = -1;\n  while (x >= 256) {\n    x >>= 8;\n    l += 8;\n  }\n  return l + log_2_1[x];\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static int computesizes(int nums[], int *narray) {\n    int i;\n    int twotoi;\n    int a = 0;\n    int na = 0;\n    int n = 0;\n    for (i = 0 , twotoi = 1; twotoi / 2 < *narray; i++ , twotoi *= 2) {\n        if (nums[i] > 0) {\n            a += nums[i];\n            if (a > twotoi / 2) {\n                n = twotoi;\n                na = a;\n            }\n        }\n        if (a == *narray)\n            break;\n    }\n    *narray = n;\n    return na;\n}\n","function_prediction":"int computesizes_name_conflict(int *sizes, int *maxsize) {\n  int i, max, sum, maxi;\n\n  max = sum = maxi = 0;\n  for (i = 1; i / 2 < *maxsize; i *= 2) {\n    if (sizes[maxi] > 0) {\n      sum += sizes[maxi];\n      if (sum > i / 2) {\n        max = sum;\n        *maxsize = i;\n      }\n    }\n    if (sum == *maxsize)\n      break;\n    maxi++;\n  }\n  return max;\n}","pass":1,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static UnOpr getunopr(int op) {\n    switch (op) {\n      case TK_NOT:\n        return OPR_NOT;\n      case '-':\n        return OPR_MINUS;\n      case '#':\n        return OPR_LEN;\n      default:\n        return OPR_NOUNOPR;\n    }\n}\n","function_prediction":"int getunopr_name_conflict(int token) {\n  switch (token) {\n  case 263:\n    return 1;\n  case 35:\n    return 2;\n  case 45:\n    return 0;\n  default:\n    return 3;\n  }\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static BinOpr getbinopr(int op) {\n    switch (op) {\n      case '+':\n        return OPR_ADD;\n      case '-':\n        return OPR_SUB;\n      case '*':\n        return OPR_MUL;\n      case '/':\n        return OPR_DIV;\n      case '%':\n        return OPR_MOD;\n      case '^':\n        return OPR_POW;\n      case TK_CONCAT:\n        return OPR_CONCAT;\n      case TK_NE:\n        return OPR_NE;\n      case TK_EQ:\n        return OPR_EQ;\n      case '<':\n        return OPR_LT;\n      case TK_LE:\n        return OPR_LE;\n      case '>':\n        return OPR_GT;\n      case TK_GE:\n        return OPR_GE;\n      case TK_AND:\n        return OPR_AND;\n      case TK_OR:\n        return OPR_OR;\n      default:\n        return OPR_NOBINOPR;\n    }\n}\n","function_prediction":"int getbinopr_name_conflict(int op) {\n  switch (op) {\n  case '+':\n    return 0;\n  case '-':\n    return 1;\n  case '*':\n    return 2;\n  case '/':\n    return 3;\n  case '^':\n    return 5;\n  case '%':\n    return 4;\n  case '<':\n    return 9;\n  case '>':\n    return 11;\n  case 257:\n    return 13;\n  case 271:\n    return 14;\n  case 278:\n    return 6;\n  case 280:\n    return 8;\n  case 281:\n    return 12;\n  case 282:\n    return 10;\n  case 283:\n    return 7;\n  default:\n    return 15;\n  }\n}","pass":1,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int block_follow(int token) {\n    switch (token) {\n      case TK_ELSE:\n      case TK_ELSEIF:\n      case TK_END:\n      case TK_UNTIL:\n      case TK_EOS:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int block_follow_name_conflict(int c) {\n  switch (c) {\n  case 260:\n  case 261:\n  case 262:\n  case 263:\n  case 264:\n  case 265:\n  case 266:\n  case 267:\n  case 268:\n  case 269:\n  case 270:\n  case 271:\n  case 272:\n  case 273:\n  case 274:\n  case 275:\n  case 276:\n  case 277:\n  case 278:\n  case 279:\n  case 280:\n  case 281:\n  case 282:\n  case 283:\n  case 284:\n  case 285:\n  case 286:\n  case 287:\n  case 288:\n  case 289:\n  case 290:\n  case 291:\n  case 292:\n  case 293:\n  case 294:\n  case 295:\n  case 296:\n  case 297:\n  case 298:\n  case 299:\n  case 300:\n  case 301:\n  case 302:\n  case 303:\n  case 304:\n  case 305:\n  case 306:\n  case 307:\n  case 308:\n  case 309:\n  case 310:\n  case 311:\n  case 312:\n  case 313:\n  case 314:\n  case 315:\n  case 316:\n  case 317:\n  case 318:\n  case 319:\n  case 320:\n  case 321","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static ptrdiff_t posrelat(ptrdiff_t pos, size_t len) {\n    if (pos < 0)\n        pos += (ptrdiff_t)len + 1;\n    return (pos >= 0) ? pos : 0;\n}\n","function_prediction":"long posrelat_name_conflict(long pos, long len) {\n  if (pos < 0)\n    pos += len + 1;\n  if (pos < 0)\n    pos = 0;\n  return pos;\n}","pass":1,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static int match_class(int c, int cl) {\n    int res;\n    switch (tolower(cl)) {\n      case 'a':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha);\n        break;\n      case 'c':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_IScntrl);\n        break;\n      case 'd':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit);\n        break;\n      case 'l':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISlower);\n        break;\n      case 'p':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISpunct);\n        break;\n      case 's':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISspace);\n        break;\n      case 'u':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISupper);\n        break;\n      case 'w':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalnum);\n        break;\n      case 'x':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISxdigit);\n        break;\n      case 'z':\n        res = (c == 0);\n        break;\n      default:\n        return (cl == c);\n    }\n    return (((*__ctype_b_loc())[(int)((cl))] & (unsigned short)_ISlower) ? res : !res);\n}\n","function_prediction":"int match_class_name_conflict(int c, int class) {\n  int r;\n\n  switch (tolower(class)) {\n  case 'a':\n    r = (__ctype_b_loc()[0][c] & 0x0400);\n    break;\n  case 'c':\n    r = (__ctype_b_loc()[0][c] & 0x0002);\n    break;\n  case 'd':\n    r = (__ctype_b_loc()[0][c] & 0x0800);\n    break;\n  case 'l':\n    r = (__ctype_b_loc()[0][c] & 0x0200);\n    break;\n  case 'p':\n    r = (__ctype_b_loc()[0][c] & 0x0004);\n    break;\n  case 's':\n    r = (__ctype_b_loc()[0][c] & 0x2000);\n    break;\n  case 'u':\n    r = (__ctype_b_loc()[0][c] & 0x0100);\n    break;\n  case 'w':\n    r = (__ctype_b_loc()[0][c] & 0x0008);\n    break;\n  case 'x':\n    r = (__ctype_b_loc()[0][c] & 0x1000);\n    break;\n  case 'z':\n    r = (c == 0);\n    break;\n  default:\n    r = (c == class);\n    break;\n  }\n\n  if (__ctype_b_loc()[0][class] & 0x0200)\n    return r;\n  else\n    return !r;\n}","pass":1,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static int matchbracketclass(int c, const char *p, const char *ec) {\n    int sig = 1;\n    if (*(p + 1) == '^') {\n        sig = 0;\n        p++;\n    }\n    while (++p < ec)\n        {\n            if (*p == '%') {\n                p++;\n                if (match_class(c, ((unsigned char)(*p))))\n                    return sig;\n            } else if ((*(p + 1) == '-') && (p + 2 < ec)) {\n                p += 2;\n                if (((unsigned char)(*(p - 2))) <= c && c <= ((unsigned char)(*p)))\n                    return sig;\n            } else if (((unsigned char)(*p)) == c)\n                return sig;\n        }\n    return !sig;\n}\n","function_prediction":"int matchbracketclass_name_conflict(int c, const char *p, const char *end) {\n  int negate = 1;\n  int match = 1;\n\n  if (*p == '^') {\n    negate = 0;\n    match = 0;\n    p++;\n  }\n\n  for (;;) {\n    if (p + 1 >= end)\n      return !negate;\n    if (*p == '%') {\n      p++;\n      if (match_class(c, *p))\n        return match;\n      p++;\n    } else if (*p == '-' && p + 2 < end) {\n      p++;\n      if (c >= *p && c <= *(p + 1))\n        return match;\n      p += 2;\n    } else if (*p == c)\n      return match;\n    else\n      p++;\n  }\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static int singlematch(int c, const char *p, const char *ep) {\n    switch (*p) {\n      case '.':\n        return 1;\n      case '%':\n        return match_class(c, ((unsigned char)(*(p + 1))));\n      case '[':\n        return matchbracketclass(c, p, ep - 1);\n      default:\n        return (((unsigned char)(*p)) == c);\n    }\n}\n","function_prediction":"int singlematch_name_conflict(int c, const char *p, size_t len) {\n  if (*p == '[')\n    return matchbracketclass(c, p, len - 1);\n  if (*p == '%')\n    return match_class(c, *(p + 1));\n  if (*p == '.')\n    return 1;\n  return c == *p;\n}","pass":1,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static const char *lmemfind(const char *s1, size_t l1, const char *s2, size_t l2) {\n    if (l2 == 0)\n        return s1;\n    else if (l2 > l1)\n        return ((void *)0);\n    else {\n        const char *init;\n        l2--;\n        l1 = l1 - l2;\n        while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != ((void *)0))\n            {\n                init++;\n                if (memcmp(init, s2 + 1, l2) == 0)\n                    return init - 1;\n                else {\n                    l1 -= init - s1;\n                    s1 = init;\n                }\n            }\n        return ((void *)0);\n    }\n}\n","function_prediction":"void *lmemfind_name_conflict(void *haystack, size_t hlen, const void *needle, size_t nlen) {\n  if (nlen == 0)\n    return haystack;\n  if (hlen < nlen)\n    return NULL;\n  size_t hpos = hlen - nlen + 1;\n  while (hpos > 0) {\n    void *p = memchr(haystack, *(const char *)needle, hpos);\n    if (p == NULL)\n      return NULL;\n    p++;\n    if (!memcmp(p, needle + 1, nlen - 1))\n      return p - 1;\n    hpos -= p - (char *)haystack;\n    haystack = p;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":1,"function":"static inline char base64_encode_value(char value_in) {\n    static const char *encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    return value_in > 63 ? '=' : encoding[(int)value_in];\n}\n","function_prediction":"char base64_encode_value_name_conflict(char c) {\n  if (c >= 'A' && c <= 'Z')\n    return c - 'A';\n  if (c >= 'a' && c <= 'z')\n    return c - 'a' + 26;\n  if (c >= '0' && c <= '9')\n    return c - '0' + 52;\n  if (c == '+' || c == '/')\n    return c - 61;\n  return '=';\n}","pass":1,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":0,"function":"size_t base64_encode_block(const char *plaintext_in, size_t length_in, char *code_out, base64_encodestate *state_in) {\n    const char *plainchar = plaintext_in;\n    const char *const plaintextend = plaintext_in + length_in;\n    char *codechar = code_out;\n    char result;\n    char fragment;\n    result = state_in->result;\n    switch (state_in->step) {\n        while (1)\n            {\n              case step_A:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_A;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)((fragment & 252) >> 2);\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 3) << 4);\n              case step_B:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_B;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)(result | ((fragment & 240) >> 4));\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 15) << 2);\n              case step_C:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_C;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)(result | ((fragment & 192) >> 6));\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 63) >> 0);\n                *codechar++ = base64_encode_value(result);\n                ++(state_in->stepcount);\n            }\n    }\n    return (size_t)(codechar - code_out);\n}\n","function_prediction":"long base64_encode_blockend(char *code_out, base64_encodestate *state_in) {\n  char *codechar = code_out;\n\n  switch (state_in->step) {\n  case 0:\n    break;\n\n  case 1:\n    *codechar++ = base64_encode_value((char)((unsigned char)state_in->result));\n    *codechar++ = '=';\n    *codechar++ = '=';\n    break;\n\n  case 2:\n    *codechar++ =\n        base64_encode_value((char)((unsigned char)(state_in->result) >> 2));\n    *codechar++ =\n        base64_encode_value((char)((unsigned char)(state_in->result) << 4));\n    *codechar++ = '=';\n    break;\n\n  default:\n    return 0;\n  }\n\n  return (long)(codechar - code_out);\n}","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":0,"function":"size_t base64_encode_blockend(char *code_out, base64_encodestate *state_in) {\n    char *codechar = code_out;\n    switch (state_in->step) {\n      case step_B:\n        *codechar++ = base64_encode_value(state_in->result);\n        *codechar++ = '=';\n        *codechar++ = '=';\n        break;\n      case step_C:\n        *codechar++ = base64_encode_value(state_in->result);\n        *codechar++ = '=';\n        break;\n      case step_A:\n        break;\n    }\n    return (size_t)(codechar - code_out);\n}\n","function_prediction":"int base64_encode_blockend(char *code_out,\n                           const struct base64_encode_block *block) {\n  char *code_ptr = code_out;\n  if (block->len == 2) {\n    *code_ptr++ = base64_encode_value((uint32_t)(block->data[0]));\n    *code_ptr++ = base64_encode_value((uint32_t)(block->data[1]));\n    *code_ptr++ = '=';\n    *code_ptr++ = '=';\n  } else if (block->len == 1) {\n    *code_ptr++ = base64_encode_value((uint32_t)(block->data[0]));\n    *code_ptr++ = '=';\n    *code_ptr++ = '=';\n    *code_ptr++ = '=';\n  }\n  return (int)(code_ptr - code_out);\n}","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":1,"function":"static inline char base64_decode_value(char value_in) {\n    static const char decoding[] = {62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51};\n    static const char decoding_size = (char)sizeof (decoding);\n    value_in -= 43;\n    return (value_in < 0 || value_in >= decoding_size) ? -1 : decoding[(int)value_in];\n}\n","function_prediction":"int base64_decode_value_name_conflict(char value) {\n  static const char decoding[] = {\n      62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1,\n      -1, -1, -1, -1, -1, -1, 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n      10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n      -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,\n      36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51};\n  static const size_t decoding_size = sizeof(decoding);\n  ssize_t result = value - '+';\n  if (result < 0 || (size_t)result >= decoding_size) {\n    return -1;\n  }\n  return decoding[result];\n}","pass":1,"source_file":"C_COMPILE/holke_libsc/libb64/cdecode.c"}
{"compilable":0,"function":"size_t base64_decode_block(const char *code_in, size_t length_in, char *plaintext_out, base64_decodestate *state_in) {\n    const char *codechar = code_in;\n    char *plainchar = plaintext_out;\n    char fragment;\n    *plainchar = state_in->plainchar;\n    switch (state_in->step) {\n        while (1)\n            {\n              case step_a:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_a;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)((fragment & 63) << 2);\n              case step_b:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_b;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | ((fragment & 48) >> 4));\n                ++plainchar;\n                *plainchar = (char)((fragment & 15) << 4);\n              case step_c:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_c;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | ((fragment & 60) >> 2));\n                ++plainchar;\n                *plainchar = (char)((fragment & 3) << 6);\n              case step_d:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_d;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | (fragment & 63));\n                ++plainchar;\n            }\n    }\n    return (size_t)(plainchar - plaintext_out);\n}\n","function_prediction":"size_t base64_decode_block(const char *code_in, size_t length_in,\n                           char *plaintext_out, base64_decodestate *state_in) {\n  const char *codechar = code_in;\n  char *code = (char *)code_in;\n  char *plainchar = plaintext_out;\n\n  state_in->result = state_in->result64;\n\n  switch (state_in->step) {\n    while (codechar != code_in + length_in) {\n      int64_t value;\n\n      do {\n        value = base64_decode_value(*codechar++);\n      } while (value < 0);\n\n      state_in->result = (uint32_t)(state_in->result << 6);\n      state_in->result += (uint32_t)value;\n      state_in->bits_left += 6;\n      if (state_in->bits_left >= 8) {\n        *plainchar++ = (uint8_t)((state_in->result >> 16) & 0xff);\n        *plainchar++ = (uint8_t)((state_in->result >> 8) & 0xff);\n        *plainchar++ = (uint8_t)((state_in->result) & 0xff);\n        state_in->bits_left -= 8;\n      }\n    }\n\n  case 0:\n    break;\n\n  case 1:\n    do {\n      int64_t value;\n\n      do {\n        value = base64_decode_value(*codechar++);\n      } while (value < 0);\n\n      state_in->result = (uint32_t)(state_in->result << 6);\n      state_in->result += (uint32_t)(value >> 2);\n      state_in->bits_left += 4;\n      if (state_in->bits_left >= 8) {\n     *plainchar++ = (uint8_t)((state_in-","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cdecode.c"}
{"compilable":0,"function":"static int argindex(int n) {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int argindex_name_conflict(int n) {\n  int i;\n  int found = 0;\n\n  if (argv == NULL || argv[0] == NULL)\n    return -1;\n\n  for (i = 1; argv[i] != NULL; i++) {\n    if (found || (argv[i][0] != '-' && argv[i][0] != '+' &&\n                  strchr(argv[i], '=') == NULL)) {\n      if (n-- == 0)\n        return i;\n    }\n    if (!strcmp(argv[i], \"--\"))\n      found = 1;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":1,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"int OptNArgs_name_conflict(void) {\n  int i, n;\n  int flag;\n\n  n = 0;\n  flag = 0;\n  if (argv) {\n    if (argv[0]) {\n      for (i = 1; argv[i]; i++) {\n        if (flag || argv[i][0] == '-' || argv[i][0] == '+' ||\n            strchr(argv[i], '=')) {\n          n++;\n        }\n        if (!strcmp(argv[i], \"--\")) {\n          flag = 1;\n        }\n      }\n    }\n  }\n  return n;\n}","pass":1,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *OptArg(int n) {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"char *OptArg_name_conflict(int opt) {\n  int i;\n\n  i = argindex(opt);\n  if (i < 0)\n    return NULL;\n  else\n    return argv[i];\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *pathsearch(char *argv0, char *name, int modemask) {\n    const char *pathlist;\n    char *pathbufptr;\n    char *pathbuf;\n    char *path, *cp;\n    char c;\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(((int)strlen(argv0)) + ((int)strlen(name)) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        pathbuf = (char *)malloc(((int)strlen(pathlist)) + 1);\n        path = (char *)malloc(((int)strlen(pathlist)) + ((int)strlen(name)) + 2);\n        if ((pathbuf != 0) && (path != 0)) {\n            pathbufptr = pathbuf;\n            strcpy(pathbuf, pathlist);\n            while (*pathbuf)\n                {\n                    cp = strchr(pathbuf, ':');\n                    if (cp == 0)\n                        cp = &pathbuf[((int)strlen(pathbuf))];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathbuf, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathbuf[0] = 0;\n                    else\n                        pathbuf = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n            free(pathbufptr);\n        }\n    }\n    return path;\n}\n","function_prediction":"char *pathsearch_name_conflict(char *name, char *file, int mode) {\n  char *p, *q, *r, *s, *t;\n  int c;\n\n  if ((p = strrchr(name, '/')) != NULL) {\n    c = *p;\n    *p = '\\0';\n    if ((s = malloc(strlen(name) + strlen(file) + 2)) != NULL) {\n      sprintf(s, \"%s/%s\", name, file);\n    }\n    *p = c;\n    return s;\n  }\n  if ((t = getenv(\"PATH\")) == NULL) {\n    t = \".:/bin:/usr/bin\";\n  }\n  if ((q = malloc(strlen(t) + 1)) == NULL) {\n    return NULL;\n  }\n  if ((s = malloc(strlen(t) + strlen(file) + 2)) == NULL) {\n    return NULL;\n  }\n  strcpy(q, t);\n  for (r = q; *r != '\\0'; r = q) {\n    if ((p = strchr(r, ':')) == NULL) {\n      p = r + strlen(r);\n    }\n    c = *p;\n    *p = '\\0';\n    sprintf(s, \"%s/%s\", r, file);\n    *p = c;\n    if (c != '\\0') {\n      r = p + 1;\n    } else {\n      *r = '\\0';\n    }\n    if (!access(s, mode)) {\n      break;\n    }\n  }\n  free(q);\n  return s;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"const char *minimum_size_type_name_conflict(int min, int max) {\n  if (min >= 0) {\n    if (max <= 255)\n      return \"unsigned char\";\n    else if (max <= 65535)\n      return \"unsigned short int\";\n    else\n      return \"unsigned int\";\n  } else {\n    if (min >= -127 && max <= 127)\n      return \"signed char\";\n    else if (min >= -32767 && max <= 32767)\n      return \"short\";\n    else\n      return \"int\";\n  }\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    s = (char *)calloc(size, 1);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    return s;\n}\n","function_prediction":"Set SetNew_name_conflict(void) {\n  Set s = calloc(size, sizeof(struct set));\n  if (s == NULL)\n    memory_error();\n  return s;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":1,"function":"int SetUnion(char *s1, char *s2) {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"int SetUnion_name_conflict(char *a, char *b) {\n  int i, changed = 0;\n\n  for (i = 0; i < size; i++)\n    if (b[i] && !a[i]) {\n      changed = 1;\n      a[i] = 1;\n    }\n  return changed;\n}","pass":1,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":1,"function":"int strhash(const char *x) {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"int strhash_name_conflict(char *str) {\n  int hash = 0;\n  while (*str)\n    hash = hash * 13 + *str++;\n  return hash;\n}","pass":1,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"const char *Strsafe(const char *y) {\n    const char *z;\n    char *cpy;\n    if (y == 0)\n        return 0;\n    z = Strsafe_find(y);\n    if (z == 0 && (cpy = (char *)malloc(((int)strlen(y)) + 1)) != 0) {\n        strcpy(cpy, y);\n        z = cpy;\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"char *Strsafe_name_conflict(char *s) {\n  int i;\n  struct Strsafe_name_conflict_node *p;\n  char *t;\n\n  if (s == NULL)\n    return NULL;\n\n  t = Strsafe_name_conflict_find(s);\n  if (t != NULL)\n    return t;\n\n  t = (char *)malloc(strlen(s) + 1);\n  if (t == NULL)\n    return NULL;\n\n  strcpy(t, s);\n  if (!Strsafe_name_conflict_insert(t))\n    return NULL;\n\n  return t;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(const char *data) {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"int Strsafe_insert_name_conflict(char *s) {\n  int h, i, n;\n  struct strsafe_entry *p;\n  struct strsafe_entry *new_table;\n  struct strsafe_entry **new_hash;\n\n  if (x1a == NULL)\n    return 0;\n\n  h = strhash(s);\n  for (p = x1a->table[h & (x1a->size - 1)]; p != NULL; p = p->next)\n    if (!strcmp(p->s, s))\n      return 0;\n\n  if (x1a->count >= x1a->size) {\n    n = x1a->size * 2;\n    new_table =\n        (struct strsafe_entry *)malloc(n * sizeof(struct strsafe_entry));\n    if (new_table == NULL)\n      return 0;\n    new_hash = (struct strsafe_entry **)&new_table[n];\n    for (i = 0; i < n; i++)\n      new_hash[i] = NULL;\n    for (i = 0; i < x1a->count; i++) {\n      p = &x1a->table[i];\n      h = strhash(p->s) & (n - 1);\n      if (new_hash[h] != NULL)\n        new_hash[h]->next = &new_table[i + 1];\n      new_table[i + 1].next = new_hash[h];\n      new_table[i + 1].s = p->s;\n      new_table[i + 1].prev = &new_table[h];\n      new_hash[h] = &new_table[i + 1];\n    }\n    free(x1a->table);\n    x1a->size = n;\n    x1a->table = new_table;\n    x1a->hash = new_hash;\n  }\n\n  h = h & (x1a->size - 1);\n  p = &x1a->table[x1a-","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"const char *Strsafe_find(const char *key) {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"char *Strsafe_find_name_conflict(char *s) {\n  int h;\n  struct strsafe_entry *e;\n\n  if (x1a == NULL)\n    return NULL;\n\n  h = strhash(s) & (x1a->size - 1);\n  e = x1a->table[h];\n  while (e != NULL) {\n    if (!strcmp(e->s, s))\n      return e->s;\n    e = e->next;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":1,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"int Symbol_count_name_conflict() {\n  if (x2a == NULL)\n    return 0;\n  return x2a->count;\n}","pass":1,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int Configcmp(const char *_a, const char *_b) {\n    const struct config *a = (struct config *)_a;\n    const struct config *b = (struct config *)_b;\n    int x;\n    x = a->rp->index - b->rp->index;\n    if (x == 0)\n        x = a->dot - b->dot;\n    return x;\n}\n","function_prediction":"int Configcmp_name_conflict(const void *a, const void *b) {\n  int diff;\n  const struct config *ca = a;\n  const struct config *cb = b;\n\n  diff = ca->data[13] - cb->data[13];\n  if (diff == 0)\n    diff = ca->id - cb->id;\n  return diff;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":1,"function":"static int check_path(char *path) {\n    if (!path)\n        return 0;\n    return access(path, 4) != -1;\n}\n","function_prediction":"int check_path_name_conflict(const char *path) {\n  if (path == NULL)\n    return 0;\n\n  return access(path, 4) != -1;\n}","pass":1,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":1,"function":"char *get_config_path(char *default_path, char *pbuf, size_t bufsize) {\n    char buf[512];\n    char *path = default_path;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"PROXYCHAINS_CONF_FILE\");\n    if (check_path(path))\n        goto have;\n    path = getcwd(buf, sizeof (buf));\n    snprintf(pbuf, bufsize, \"%s/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"HOME\");\n    snprintf(pbuf, bufsize, \"%s/.proxychains/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    perror(\"couldnt find configuration file\");\n    exit(1);\n    return ((void *)0);\n  have:\n    return path;\n}\n","function_prediction":"char *get_config_path_name_conflict(char *path, char *buf, size_t buf_size) {\n  char cwd[512];\n\n  if (!check_path(path))\n    path = getenv(\"PROXYCHAINS_CONF_FILE\");\n  if (!check_path(path)) {\n    path = getcwd(cwd, sizeof(cwd));\n    snprintf(buf, buf_size, \"%s/%s\", path, \"proxychains.conf\");\n    path = buf;\n  }\n  if (!check_path(path)) {\n    path = getenv(\"HOME\");\n    snprintf(buf, buf_size, \"%s/.proxychains/%s\", path, \"proxychains.conf\");\n    path = buf;\n  }\n  if (!check_path(path))\n    path = \"/etc/proxychains.conf\";\n  if (!check_path(path))\n    path = \"/etc/proxychains.conf\";\n  if (!check_path(path)) {\n    perror(\"couldnt find configuration file\");\n    exit(1);\n  }\n\n  return path;\n}","pass":1,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":1,"function":"static int check_path(char *path) {\n    if (!path)\n        return 0;\n    return access(path, 4) != -1;\n}\n","function_prediction":"int check_path_name_conflict(const char *path) {\n  if (path == NULL)\n    return 0;\n\n  return access(path, 4) != -1;\n}","pass":1,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":1,"function":"char *get_config_path(char *default_path, char *pbuf, size_t bufsize) {\n    char buf[512];\n    char *path = default_path;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"PROXYCHAINS_CONF_FILE\");\n    if (check_path(path))\n        goto have;\n    path = getcwd(buf, sizeof (buf));\n    snprintf(pbuf, bufsize, \"%s/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"HOME\");\n    snprintf(pbuf, bufsize, \"%s/.proxychains/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    perror(\"couldnt find configuration file\");\n    exit(1);\n    return ((void *)0);\n  have:\n    return path;\n}\n","function_prediction":"char *get_config_path_name_conflict(char *path, char *buf, size_t buf_size) {\n  char cwd[512];\n\n  if (!check_path(path))\n    path = getenv(\"PROXYCHAINS_CONF_FILE\");\n  if (!check_path(path)) {\n    path = getcwd(cwd, sizeof(cwd));\n    snprintf(buf, buf_size, \"%s/%s\", path, \"proxychains.conf\");\n    path = buf;\n  }\n  if (!check_path(path)) {\n    path = getenv(\"HOME\");\n    snprintf(buf, buf_size, \"%s/.proxychains/%s\", path, \"proxychains.conf\");\n    path = buf;\n  }\n  if (!check_path(path))\n    path = \"/etc/proxychains.conf\";\n  if (!check_path(path))\n    path = \"/etc/proxychains.conf\";\n  if (!check_path(path)) {\n    perror(\"couldnt find configuration file\");\n    exit(1);\n  }\n\n  return path;\n}","pass":1,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":0,"function":"int info(int level, const char *fmt, ...) {\n    va_list ap;\n    int length;\n    if (level > verbose)\n        return 0;\n    __builtin_va_start(ap, fmt);\n    length = vfprintf(stdout, fmt, ap);\n    __builtin_va_end(ap);\n    return length;\n}\n","function_prediction":"int info_name_conflict(int verbose, const char *fmt, ...) {\n  va_list ap;\n\n  if (verbose > ::verbose)\n    return 0;\n\n  ap = (va_list)&fmt;\n  return vfprintf(stdout, fmt, ap);\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"unsigned short CALC_CRC1a(unsigned short crc, uint8_t byte) {\n    int i = 8;\n    unsigned short b = byte << 8;\n    while (i--)\n        {\n            crc = (crc << 1) ^ (((crc ^ b) & 32768) ? 4129 : 0);\n            b <<= 1;\n        }\n    return crc;\n}\n","function_prediction":"unsigned short CALC_CRC1a_name_conflict(unsigned short crc, unsigned char data) {\n  int i;\n  unsigned short data_shifted;\n\n  data_shifted = data << 8;\n\n  for (i = 8; i; i--) {\n    if ((crc ^ data_shifted) & 0x8000)\n      crc = (crc << 1) ^ 0x1021;\n    else\n      crc <<= 1;\n\n    data_shifted <<= 1;\n  }\n\n  return crc;\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"const char *detokenize(uint8_t *src, int maxsize) {\n    static char buff[8192];\n    char *dst = buff;\n    int string = 0;\n    while (0 != *src && maxsize-- > 0)\n        {\n            if (string) {\n                if ('\"' == *src)\n                    string = 0;\n                if (*src >= 32 && *src < 127)\n                    *dst++ = *src;\n                else\n                    dst += sprintf(dst, \"\\\\%03o\", *src);\n            } else {\n                if (255 == *src) {\n                    src++;\n                    if (*src < 128 + 26)\n                        dst += sprintf(dst, \"%s\", token[*src]);\n                    else\n                        dst += sprintf(dst, \"<ff%02x>\", *src);\n                } else if (*src > 127) {\n                    dst += sprintf(dst, \"%s\", token[*src & 127]);\n                } else {\n                    *dst++ = *src;\n                    if ('\"' == *src)\n                        string = 1;\n                }\n            }\n            src++;\n        }\n    *dst = '\\x00';\n    return buff;\n}\n","function_prediction":"char *detokenize_name_conflict(char *s, int len) {\n  static char buff[1024];\n  char *p = buff;\n  int in_quote = 0;\n\n  while (*s && len > 0) {\n    if (in_quote) {\n      if (*s == '\"')\n        in_quote = 0;\n      if (*s < 32 || *s > 126)\n        p += sprintf(p, \"\\\\%03o\", *s);\n      else\n        *p++ = *s;\n    } else if (*s == 0xff) {\n      s++;\n      if (*s < 0x9a)\n        p += sprintf(p, \"%s\", token[*s]);\n      else\n        p += sprintf(p, \"<ff%02x>\", *s);\n    } else if (*s & 0x80)\n      p += sprintf(p, \"%s\", token[*s & 0x7f]);\n    else\n      *p++ = *s;\n    if (*s == '\"')\n      in_quote = 1;\n    s++;\n    len--;\n  }\n  *p = 0;\n  return buff;\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int dmk_scan_sectors(track_stat_t *ts) {\n    uint8_t *p;\n    int ip;\n    unsigned long dp;\n    unsigned long dd;\n    unsigned long len;\n    unsigned short crc, c;\n    dam_t *dam;\n    memset(ts, 0, sizeof (*ts));\n    for (ip = 0; ip < 128; ip += 2) {\n        p = dmk.track;\n        dam = &ts->sector[ip / 2];\n        dp = p[ip + 0] + 256 * p[ip + 1];\n        if (0 == dp)\n            break;\n        dd = dp & 32768;\n        dp = dp & ~32768;\n        info(1, \"#%02x @%04x\", ip / 2, dp);\n        crc = 65535;\n        if (32768 == dd) {\n            dam->flags |= 1;\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n        }\n        if (p[dp] != 254) {\n            info(1, \" - not pointing to AM (0xfe)\\n\");\n            dam->flags |= 2;\n            ts->am_bad += 1;\n            continue;\n        }\n        ts->am_good += 1;\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->c = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->h = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->r = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->n = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        len = 1 << (7 + (dam->n & 3));\n        info(1, \" C:%02x H:%02x R:%02x N:%02x\", dam->c, dam->h, dam->r, dam->n);\n        c = 256 * p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        c = c | p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        if (c == crc) {\n            info(1, \" AM-CRC:good\");\n            dam->flags &= ~4;\n        } else {\n            info(1, \" AM-CRC:bad (%04x != %04x)\", c, crc);\n            dam->flags |= 4;\n            ts->am_crc_bad += 1;\n        }\n        for (; dp < (256UL * dmk.trklen[1] + dmk.trklen[0]); dp++) {\n            if (p[dp] >= 248 && p[dp] <= 251)\n                break;\n        }\n        if (dp >= (256UL * dmk.trklen[1] + dmk.trklen[0])) {\n            info(1, \" no DAM!\\n\");\n            dam->flags |= 8;\n            ts->dam_missing += 1;\n            continue;\n        }\n        crc = 65535;\n        if (32768 == dd) {\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n        }\n        switch (p[dp]) {\n          case 248:\n          case 249:\n          case 250:\n            dam->flags |= 32;\n            break;\n          case 251:\n            dam->flags &= ~32;\n            break;\n        }\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        info(1, \" DAM:%02x\", p[dp]);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->dp = dp;\n        dam->flags |= 128;\n        while (len-- > 0)\n            {\n                if (0 != (dam->flags & 128) && 229 != p[dp])\n                    dam->flags &= ~128;\n                crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n                dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n            }\n        c = 256 * p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        c = c | p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        if (c == crc) {\n            info(1, \" DAM-CRC:good\");\n            dam->flags &= ~16;\n        } else {\n            info(1, \" DAM-CRC:bad (%04x != %04x)\", c, crc);\n            dam->flags |= 16;\n            ts->dam_crc_bad += 1;\n        }\n        if (dam->flags & 128)\n            info(1, \" empty\");\n        info(1, \"\\n\");\n    }\n    ts->sector_count = ip / 2;\n    info(1, \"\\n\");\n    if (0 == ts->am_bad && 0 == ts->am_crc_bad && 0 == ts->dam_crc_bad)\n        ts->perfect = 1;\n    return 0;\n}\n","function_prediction":"int dmk_scan_sectors_name_conflict(struct dmk_image *dmk) {\n  int i, j, k, l, m, n, s, t, u, v, w, x, y, z;\n  unsigned short crc;\n\n  memset(dmk, 0, sizeof(struct dmk_image));\n\n  for (i = 0; i < 128; i += 2) {\n    j = i / 2;\n    k = dmk->sector_table[i] + (dmk->sector_table[i + 1] << 8);\n    if (k == 0)\n      break;\n    l = k & 0x8000;\n    k &= ~0x8000;\n    info(1, \"#%02x @%04x\", j, k);\n    crc = 0xffff;\n    if (l) {\n      dmk->sector[j].flags |= 0x01;\n      crc =\n          crc16[crc16[crc16[crc ^ 0xa1] ^ dmk->sector_table[k] ^ 0x5e] ^\n                (crc16[crc16[crc ^ 0xa1] ^ dmk->sector_table[k] ^ 0x5e] >> 8)] ^\n          (crc16[crc16[crc ^ 0xa1] ^ dmk->sector_table[k] ^ 0x5e] << 8);\n    }\n    if (dmk->sector_table[k] != 0xfe) {\n      info(1, \" - not pointing to AM (0xfe)\\n\");\n      dmk->sector[j].flags |= 0x02;\n      dmk->sector_table_errors++;\n      continue;\n    }\n    dmk->sector[j].flags |= 0x01;\n    dmk->sector[j].cylinder++;\n    crc = crc16[crc ^ dmk->sector_table[k]];\n  k += (","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int dmk_sort_by_sector(track_stat_t *ts) {\n    qsort(ts->sector, ts->sector_count, sizeof(dam_t), qsort_sector);\n    return 0;\n}\n","function_prediction":"int dmk_sort_by_sector_name_conflict(struct dmk_header *h) {\n  qsort(&h->sector_table[1], h->sector_table[0], sizeof(struct dmk_sector),\n        qsort_sector);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"const char *newdos_flags_str(newdos_dirent_t *de) {\n    static char flags[13];\n    flags[0] = de->fl0 & 64 ? 'S' : '.';\n    flags[1] = de->fl0 & 8 ? 'I' : '.';\n    flags[2] = de->fl0 & 16 ? 'U' : '.';\n    if (de->fl0 & 64) {\n        flags[3] = de->fl1 & 128 ? 'E' : '.';\n        flags[4] = de->fl1 & 64 ? 'C' : '.';\n        flags[5] = de->fl1 & 1 ? '0' : '.';\n        flags[6] = de->fl1 & 2 ? '1' : '.';\n        flags[7] = de->fl1 & 4 ? '2' : '.';\n        flags[8] = de->fl0 & 8 ? '3' : '.';\n        flags[9] = de->fl0 & 32 ? 'U' : '.';\n        flags[10] = de->fl0 & 64 ? 'A' : '.';\n    } else {\n        flags[3] = '.';\n        flags[4] = '.';\n        flags[5] = '.';\n        flags[6] = '.';\n        flags[7] = '.';\n        flags[8] = '.';\n        flags[9] = '.';\n        flags[10] = '.';\n    }\n    flags[11] = '0' + (de->fl0 & 7);\n    flags[12] = '\\x00';\n    return flags;\n}\n","function_prediction":"char *newdos_flags_str_name_conflict(unsigned char *flags) {\n  static char flags_2[13];\n\n  if (flags[0] & 0x40)\n    flags_2[0] = 'S';\n  else\n    flags_2[0] = '.';\n\n  if (flags[0] & 0x08)\n    flags_2[1] = 'I';\n  else\n    flags_2[1] = '.';\n\n  if (flags[0] & 0x10)\n    flags_2[2] = 'U';\n  else\n    flags_2[2] = '.';\n\n  if (flags[0] & 0x40) {\n    if (flags[1] & 0x80)\n      flags_2[3] = 'E';\n    else\n      flags_2[3] = '.';\n\n    if (flags[1] & 0x40)\n      flags_2[4] = 'C';\n    else\n      flags_2[4] = '.';\n\n    if (flags[1] & 0x01)\n      flags_2[5] = '0';\n    else\n      flags_2[5] = '.';\n\n    if (flags[1] & 0x02)\n      flags_2[6] = '1';\n    else\n      flags_2[6] = '.';\n\n    if (flags[1] & 0x04)\n      flags_2[7] = '2';\n    else\n      flags_2[7] = '.';\n\n    if (flags[0] & 0x08)\n      flags_2[8] = '3';\n    else\n      flags_2[8] = '.';\n\n    if (flags[0] & 0x20)\n      flags_2[9] = 'U';\n    else\n      flags_2[9] = '.';\n\n    if (flags[0] & 0x40)\n      flags_2[10] = 'A';\n    else\n      flags_2[10] = '.';\n  } else {\n    flags_2[3] =","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"const char *binstr(int val, int bits) {\n    static char buff[33];\n    int i;\n    if (bits > 32)\n        bits = 32;\n    for (i = 0; i < bits; i++ , val >>= 1)\n        buff[i] = '0' + (val & 1);\n    buff[bits] = '\\x00';\n    return buff;\n}\n","function_prediction":"char *binstr_name_conflict(int n, int len) {\n  static char buff[33];\n  int i;\n\n  if (len > 32)\n    len = 32;\n  for (i = 0; i < len; i++) {\n    buff[i] = (n & 1) + '0';\n    n >>= 1;\n  }\n  buff[len] = '\\0';\n  return buff;\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"const char *dmk_filename_ext(newdos_dirent_t *de, char delim) {\n    static char name[13];\n    char *dst, *src;\n    int i;\n    dst = name;\n    for (i = 0 , src = de->filename; i < 8; i++) {\n        if (*src == ' ')\n            break;\n        *dst++ = *src++;\n    }\n    if (*de->extension != ' ') {\n        *dst++ = delim;\n        for (i = 0 , src = de->extension; i < 3; i++) {\n            if (*src == ' ')\n                break;\n            *dst++ = *src++;\n        }\n    }\n    *dst = '\\x00';\n    return name;\n}\n","function_prediction":"char *dmk_filename_ext_name_conflict(char *name, char ext) {\n  static char name_[12];\n  char *p = name_ + 5;\n  int i;\n\n  for (i = 0; i < 8 && *name != ' '; i++)\n    *p++ = *name++;\n\n  if (*name != ' ') {\n    *p++ = ext;\n    for (i = 0; i < 3 && *name != ' '; i++)\n      *p++ = *name++;\n  }\n\n  *p = '\\0';\n\n  return name_;\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"int verify_bas(uint8_t *buff, int *psize) {\n    int state, offs;\n    int addr = 0;\n    int line = 0;\n    int blen = 0;\n    int lcnt = 0;\n    if (255 != *buff) {\n        info(0, \"BASIC data does not start with 0xff (0x%02x)\\n\", *buff);\n        return -1;\n    }\n    info(2, \"*** verify BAS\\n\");\n    state = 0;\n    for (offs = 0; offs < *psize; offs++) {\n        switch (state) {\n          case 0:\n            state = 1;\n            break;\n          case 1:\n            addr = buff[offs];\n            state = 2;\n            break;\n          case 2:\n            addr = 256 * buff[offs] + addr;\n            state = 3;\n            if (0 == addr) {\n                if (offs + 1 < *psize) {\n                    info(1, \"  data after program (0x%x)\\n\", *psize - 1 - offs);\n                }\n                *psize = offs + 1;\n            }\n            break;\n          case 3:\n            line = buff[offs];\n            state = 4;\n            break;\n          case 4:\n            line = 256 * buff[offs] + line;\n            state = 5;\n            info(2, \"  line %5d at 0x%04x\", line, addr);\n            blen = 0;\n            break;\n          case 5:\n            blen += 1;\n            if (0 != buff[offs])\n                break;\n            info(2, \" - 0x%02x bytes\\n\", blen);\n            state = 1;\n            lcnt++;\n            break;\n        }\n    }\n    info(2, \"  %d lines\\n\", lcnt);\n    return 0;\n}\n","function_prediction":"int verify_bas_name_conflict(unsigned char *bas, int *lines) {\n  if (*bas != 0xff) {\n    info(0, \"BASIC data does not start with 0xff (0x%02x)\\n\", *bas);\n    return -1;\n  }\n\n  info(2, \"*** verify BAS\\n\");\n\n  switch (*lines) {\n  case 0:\n    info(2, \"  %d lines\\n\", *lines);\n    break;\n  case 1:\n    info(2, \"  %d line\\n\", *lines);\n    break;\n  default:\n    info(2, \"  %d lines\\n\", *lines);\n    break;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int verify_cmd(uint8_t *buff, int *psize) {\n    int state, offs;\n    int blen = 0;\n    int addr = 0;\n    int chain = 0;\n    int badr = 0;\n    info(2, \"*** verify CMD\\n\");\n    state = 0;\n    chain = 0;\n    for (offs = 0; offs < *psize; offs++) {\n        switch (state) {\n          case 0:\n            switch (buff[offs]) {\n              case 1:\n                state = 1;\n                break;\n              case 2:\n                state = 2;\n                break;\n              default:\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  comment block type 0x%02x\\n\", buff[offs]);\n                state = 3;\n                break;\n            }\n            break;\n          case 1:\n            blen = buff[offs];\n            state = 4;\n            break;\n          case 2:\n            blen = buff[offs];\n            state = 5;\n            if (2 != blen) {\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  bogus entry block length (%02x)\\n\", blen);\n                blen = 2;\n                buff[offs] = 2;\n            }\n            break;\n          case 3:\n            blen = buff[offs];\n            state = 6;\n            break;\n          case 4:\n            blen--;\n            addr = buff[offs];\n            state = 7;\n            break;\n          case 5:\n            blen--;\n            badr = buff[offs];\n            state = 8;\n            break;\n          case 6:\n            if (--blen <= 0)\n                state = 0;\n            break;\n          case 7:\n            blen--;\n            addr = 256 * buff[offs] + addr;\n            state = 9;\n            if (blen <= 0)\n                blen += 256;\n            if (addr != chain) {\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  data at %04x\", addr);\n            }\n            chain = addr;\n            break;\n          case 8:\n            blen--;\n            badr = 256 * buff[offs] + badr;\n            if (chain)\n                info(2, \" - %04x\\n\", chain - 1);\n            chain = 0;\n            info(1, \"  entry point at 0x%04x\\n\", badr);\n            if (offs + 1 < *psize)\n                info(1, \"  data after entry point (0x%x)\\n\", *psize - 1 - offs);\n            *psize = offs + 1;\n            break;\n          case 9:\n            chain += 1;\n            if (--blen <= 0)\n                state = 0;\n            break;\n        }\n    }\n    if (chain)\n        info(2, \" - %04x\\n\", chain - 1);\n    return 0;\n}\n","function_prediction":"int verify_cmd_name_conflict(struct cmd_info *cmd, struct cmd_info *parent) {\n  info(2, \"*** verify CMD\\n\");\n\n  switch (parent->type) {\n  case CMD_TYPE_ROOT:\n    return 0;\n  case CMD_TYPE_GROUP:\n    return 0;\n  case CMD_TYPE_COMMAND:\n    return 0;\n  case CMD_TYPE_OPTION:\n    return 0;\n  case CMD_TYPE_ARGUMENT:\n    return 0;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int verify_txt(uint8_t *buff, int *psize) {\n    int offs;\n    uint8_t *dst;\n    dst = memchr(buff, '\\x03', *psize);\n    offs = dst ? (int)(dst - buff) : *psize;\n    if (offs + 1 < *psize) {\n        info(1, \"  data after end-of-file code ^C (0x%x)\\n\", *psize - 1 - offs);\n        *psize = offs + 1;\n    }\n    dst = memchr(buff, '\\x00', *psize);\n    offs = dst ? (int)(dst - buff) : *psize;\n    if (offs + 1 < *psize) {\n        info(1, \"  data after end-of-file code ^@ (0x%x)\\n\", *psize - 1 - offs);\n        *psize = offs + 1;\n    }\n    return 0;\n}\n","function_prediction":"int verify_txt_name_conflict(const unsigned char *buf, int *len) {\n  int i;\n\n  i = memchr(buf, 0x03, *len) ? memchr(buf, 0x03, *len) - buf : *len;\n  if (i + 1 < *len) {\n    info(1, \"  data after end-of-file code ^C (0x%x)\\n\", *len - 1 - i);\n    *len = i + 1;\n  }\n\n  i = memchr(buf, 0x00, *len) ? memchr(buf, 0x00, *len) - buf : *len;\n  if (i + 1 < *len) {\n    info(1, \"  data after end-of-file code ^@ (0x%x)\\n\", *len - 1 - i);\n    *len = i + 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"int hexdump_bas(uint8_t *buff, int size) {\n    int state, offs;\n    int addr = 0;\n    int line = 0;\n    int blen = 0;\n    int lcnt = 0;\n    state = 0;\n    for (offs = 0; offs < size; offs++) {\n        switch (state) {\n          case 0:\n            state = 1;\n            break;\n          case 1:\n            addr = buff[offs];\n            state = 2;\n            break;\n          case 2:\n            addr = 256 * buff[offs] + addr;\n            state = 3;\n            if (0 == addr)\n                offs = size;\n            break;\n          case 3:\n            line = buff[offs];\n            state = 4;\n            break;\n          case 4:\n            line = 256 * buff[offs] + line;\n            info(0, \"%05x:(%04x) %5d\", offs, addr, line);\n            blen = 0;\n            state = 5;\n            break;\n          case 5:\n            blen += 1;\n            if (0 != buff[offs])\n                break;\n            info(0, \" %s\\n\", detokenize(buff + offs - blen + 1, blen));\n            state = 1;\n            lcnt++;\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int hexdump_bas_name_conflict(FILE *fp, int n) {\n  int i;\n  int c;\n\n  for (i = 0; i < n; i++) {\n    c = fgetc(fp);\n    switch (c) {\n    case EOF:\n      return i;\n    case '\\n':\n      fprintf(fp, \"0A\");\n      break;\n    case '\\r':\n      fprintf(fp, \"0D\");\n      break;\n    case '\\t':\n      fprintf(fp, \"09\");\n      break;\n    default:\n      fprintf(fp, \"%02X\", c);\n      break;\n    }\n  }\n  return i;\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"int hexdump_cmd(uint8_t *buff, int size) {\n    int state, offs;\n    int blen = 0;\n    int addr = 0;\n    int chain = 0;\n    int badr = 0;\n    int bcnt = 0;\n    int i;\n    state = 0;\n    chain = 0;\n    for (offs = 0; offs < size; offs++) {\n        switch (state) {\n          case 0:\n            switch (buff[offs]) {\n              case 1:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 1;\n                break;\n              case 2:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 2;\n                break;\n              default:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 3;\n                break;\n            }\n            break;\n          case 1:\n            blen = buff[offs];\n            state = 4;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 2:\n            blen = buff[offs];\n            state = 5;\n            if (2 != blen) {\n                blen = 2;\n            }\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 3:\n            blen = buff[offs];\n            bcnt = 0;\n            state = 6;\n            info(0, \" %02x (comment length %03x)\\n\", buff[offs], blen);\n            break;\n          case 4:\n            blen--;\n            addr = buff[offs];\n            state = 7;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 5:\n            blen--;\n            badr = buff[offs];\n            state = 8;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 6:\n            if (0 == (bcnt & 15))\n                info(0, \"%05x:(%04x)\", offs, bcnt);\n            info(0, \" %02x\", buff[offs]);\n            bcnt++;\n            if (0 == (bcnt & 15))\n                info(0, \"\\n\");\n            if (--blen <= 0) {\n                if (0 != (bcnt & 15))\n                    info(0, \"\\n\");\n                state = 0;\n            }\n            break;\n          case 7:\n            blen--;\n            addr = 256 * buff[offs] + addr;\n            state = 9;\n            bcnt = 0;\n            if (blen <= 0)\n                blen += 256;\n            info(0, \" %02x (data length %03x @ %04x)\\n\", buff[offs], blen, addr);\n            break;\n          case 8:\n            blen--;\n            badr = 256 * buff[offs] + badr;\n            bcnt = 0;\n            info(0, \" %02x (entry point %04x)\\n\", buff[offs], badr);\n            offs = size;\n            break;\n          case 9:\n            if (0 == (bcnt & 15))\n                info(0, \"%05x:(%04x)\", offs, addr + bcnt);\n            info(0, \" %02x\", buff[offs]);\n            bcnt++;\n            if (0 == (bcnt & 15)) {\n                info(0, \" - \");\n                for (i = -15; i <= 0; i++)\n                    info(0, \"%c\", ((buff[offs + i]) < 32 || (buff[offs + i]) > 126 ? '.' : (buff[offs + i])));\n                info(0, \"\\n\");\n            }\n            if (--blen <= 0) {\n                if (0 != (bcnt & 15)) {\n                    info(0, \"%-*s - \", 3 * (16 - (bcnt & 15)), \"\");\n                    for (i = -(bcnt & 15); i <= 0; i++)\n                        info(0, \"%c\", ((buff[offs + i]) < 32 || (buff[offs + i]) > 126 ? '.' : (buff[offs + i])));\n                    info(0, \"\\n\");\n                }\n                state = 0;\n            }\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int hexdump_cmd_name_conflict(int argc, char **argv) {\n  int i;\n  int ret = 0;\n\n  for (i = 0; i < argc; i++) {\n    switch (argv[i][0]) {\n    case 'h':\n      ret = hexdump_help();\n      break;\n    case 's':\n      ret = hexdump_size(argv[i]);\n      break;\n    case 'f':\n      ret = hexdump_file(argv[i]);\n      break;\n    case 'd':\n      ret = hexdump_data(argv[i]);\n      break;\n    default:\n      break;\n    }\n  }\n\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"int hexdump_raw(uint8_t *buff, int size) {\n    int y, x;\n    for (y = 0; y < size; y += 16) {\n        info(0, \"%05x:\", y);\n        for (x = 0; x < 16; x++)\n            info(0, \" %02x\", buff[y + x]);\n        info(0, \" - \");\n        for (x = 0; x < 16; x++)\n            info(0, \"%c\", ((buff[y + x]) < 32 || (buff[y + x]) > 126 ? '.' : (buff[y + x])));\n        info(0, \"\\n\");\n    }\n    return 0;\n}\n","function_prediction":"int hexdump_raw_name_conflict(const char *buf, int len) {\n  int i, j;\n\n  for (i = 0; i < len; i += 16) {\n    info(0, \"%05x:\", i);\n    for (j = 0; j < 16; j++)\n      info(0, \" %02x\", buf[i + j]);\n    info(0, \"  \");\n    for (j = 0; j < 16; j++)\n      info(0, \"%c\",\n           (buf[i + j] >= 0x20 && buf[i + j] < 0x7f) ? buf[i + j] : '.');\n    info(0, \"\\n\");\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"unsigned long HTcopy(char *ul) {\n    unsigned long retval;\n    memcpy(&retval, ul, sizeof (retval));\n    return retval;\n}\n","function_prediction":"HT *HTcopy_name_conflict(HT *ht) { return ht->copy; }","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long SparseMemory(u_long cBuckets, u_long cOccupied) {\n    return (cOccupied * sizeof(HTItem) + ((((cBuckets) - 1) >> (0 + 6)) + 1) * sizeof(SparseBin));\n}\n","function_prediction":"void *SparseMemory_name_conflict(size_t size, size_t index) {\n  return (void *)((index * 16) + ((size / 64 + 1) * 24));\n}","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long DenseMemory(u_long cBuckets, u_long cOccupied) {\n    return cBuckets * sizeof(HTItem);\n}\n","function_prediction":"size_t DenseMemory_name_conflict(size_t n) { return n * sizeof(Dense); }","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long NextPow2(u_long x) {\n    if (((x << 1) >> 1) != x)\n        x >>= 1;\n    while ((x & (x - 1)) != 0)\n        x &= (x - 1);\n    return x << 1;\n}\n","function_prediction":"size_t NextPow2_name_conflict(size_t n) {\n  if (n & (((size_t)1 << (sizeof(size_t) * 8 - 1))))\n    n >>= 1;\n\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n  n++;\n\n  return n << 1;\n}","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":1,"function":"int sendAll(SOCKET s, char *buf, int len) {\n    int total = 0;\n    int bytesleft = len;\n    int n = 0;\n    while (total < len)\n        {\n            n = send(s, buf + total, bytesleft, MSG_NOSIGNAL);\n            if (n == -1) {\n                break;\n            }\n            total += n;\n            bytesleft -= n;\n        }\n    return n == -1 ? 0 : total;\n}\n","function_prediction":"int sendAll_name_conflict(int sock, char *buf, int len) {\n  int total = 0;\n  int bytesleft = len;\n  int n;\n\n  while (total < len) {\n    n = send(sock, buf + total, bytesleft, 0x4000);\n    if (n == -1)\n      break;\n    total += n;\n    bytesleft -= n;\n  }\n\n  return n == -1 ? 0 : total;\n}","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"int sendFileArg(char *filename) {\n    int i, f;\n    if ((f = open(filename, 0)) < 0) {\n        perror(\"--nailgun-filearg\");\n        return 1;\n    }\n    i = read(f, buf, (2048));\n    while (i > 0)\n        {\n            sendChunk(i, 'L', buf);\n            i = read(f, buf, (2048));\n        }\n    if (i < 0) {\n        perror(\"--nailgun-filearg\");\n        return 1;\n    }\n    sendChunk(0, 'L', buf);\n    close(f);\n    return 0;\n}\n","function_prediction":"int sendFileArg_name_conflict(char *file) {\n  int fd = open(file, 0);\n  if (fd < 0) {\n    perror(\"--nailgun-filearg\");\n    return 1;\n  }\n  int n = read(fd, buf, 2048);\n  while (n > 0) {\n    sendChunk(n, 76, buf);\n    n = read(fd, buf, 2048);\n  }\n  if (n < 0) {\n    perror(\"--nailgun-filearg\");\n    return 1;\n  }\n  sendChunk(0, 76, buf);\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"unsigned long recvToBuffer(unsigned long len) {\n    unsigned long bytesRead = 0;\n    while (bytesRead < len)\n        {\n            int thisPass = recv(nailgunsocket, buf + bytesRead, len - bytesRead, MSG_WAITALL);\n            if (thisPass == 0 || thisPass == -1) {\n                perror(\"recv\");\n                handleSocketClose();\n            }\n            bytesRead += thisPass;\n        }\n    return bytesRead;\n}\n","function_prediction":"size_t recvToBuffer_name_conflict(size_t size) {\n  size_t total = 0;\n  int r;\n  while (total < size) {\n    r = recv(nailgunsocket, buf + total, size - total, 0x100);\n    if (r == 0 || r == -1) {\n      perror(\"recv\");\n      handleSocketClose();\n    }\n    total += r;\n  }\n  return total;\n}","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"int processStdin() {\n    int bytesread = read(0, buf, (2048));\n    if (bytesread > 0) {\n        sendStdin(buf, bytesread);\n    } else if (bytesread == 0) {\n        processEof();\n    }\n    return (bytesread);\n}\n","function_prediction":"int processStdin_name_conflict() {\n  int n = read(0, buf, 2048);\n  if (n > 0)\n    sendStdin(buf, n);\n  else if (n == 0)\n    processEof();\n  return n;\n}","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"int intervalMillis(struct timeval end, struct timeval start) {\n    return ((end.tv_sec - start.tv_sec) * 1000) + ((end.tv_usec - start.tv_usec) / 1000);\n}\n","function_prediction":"int intervalMillis_name_conflict(struct timeval start, struct timeval end) {\n  return (end.tv_sec - start.tv_sec) * 1000 +\n         (end.tv_usec - start.tv_usec) / 1000;\n}","pass":0,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"char *shortClientName(char *s) {\n    char *result = strrchr(s, '/');\n    return ((result == ((void *)0)) ? s : result + 1);\n}\n","function_prediction":"char *shortClientName_name_conflict(char *name) {\n  char *p = strrchr(name, '/');\n  if (p)\n    return p + 1;\n  else\n    return name;\n}","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"int isNailgunClientName(char *s) {\n    return (!(strcmp(s, \"ng\")));\n}\n","function_prediction":"int isNailgunClientName_name_conflict(const char *name) { return !strcmp(name, \"ng\"); }","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"pid_t do_driver(char *driver) {\n    pid_t child;\n    int pipe[2];\n    if (socketpair(1, SOCK_STREAM, 0, pipe) < 0)\n        err_sys(\"can't create socketpair\");\n    if ((child = fork()) < 0)\n        err_sys(\"fork error\");\n    else if (child == 0) {\n        close(pipe[1]);\n        if (dup2(1, 2) != 2)\n            err_sys(\"dup2 error to sterr\");\n        if (dup2(pipe[0], 0) != 0)\n            err_sys(\"dup2 error to stdin\");\n        if (dup2(pipe[0], 1) != 1)\n            err_sys(\"dup2 error to stdout\");\n        close(pipe[0]);\n        execlp(driver, driver, (char *)0);\n        err_sys(\"execlp error for: %s\", driver);\n    }\n    close(pipe[0]);\n    if (dup2(pipe[1], 0) != 0)\n        err_sys(\"dup2 error to stdin\");\n    if (dup2(pipe[1], 1) != 1)\n        err_sys(\"dup2 error to stdout\");\n    close(pipe[1]);\n    return child;\n}\n","function_prediction":"pid_t do_driver_name_conflict(const char *cmd) {\n  int fd[2];\n  pid_t pid;\n\n  if (socketpair(1, 1, 0, fd) < 0)\n    err_sys(\"can't create socketpair\");\n\n  if ((pid = fork()) < 0)\n    err_sys(\"fork error\");\n  else if (pid == 0) {\n    close(fd[0]);\n    if (dup2(1, 2) != 2)\n      err_sys(\"dup2 error to sterr\");\n    if (dup2(fd[1], 0) != 0)\n      err_sys(\"dup2 error to stdin\");\n    if (dup2(fd[1], 1) != 1)\n      err_sys(\"dup2 error to stdout\");\n    close(fd[1]);\n    execlp(cmd, cmd, (char *)0);\n    err_sys(\"execlp error for: %s\", cmd);\n  }\n\n  close(fd[1]);\n  if (dup2(fd[0], 0) != 0)\n    err_sys(\"dup2 error to stdin\");\n  if (dup2(fd[0], 1) != 1)\n    err_sys(\"dup2 error to stdout\");\n  close(fd[0]);\n\n  return pid;\n}","pass":1,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/driver.c"}
{"compilable":1,"function":"int tty_cbreak(int fd) {\n    struct termios buf;\n    if (tcgetattr(fd, &save_termios) < 0)\n        return (-1);\n    buf = save_termios;\n    buf.c_lflag &= ~(8 | 2);\n    buf.c_cc[6] = 1;\n    buf.c_cc[5] = 0;\n    if (tcsetattr(fd, 2, &buf) < 0)\n        return (-1);\n    ttystate = CBREAK;\n    ttysavefd = fd;\n    return (0);\n}\n","function_prediction":"int tty_cbreak_name_conflict(int fd) {\n  struct termios t;\n\n  if (tcgetattr(fd, &save_termios) < 0)\n    return -1;\n\n  t = save_termios;\n\n  t.c_lflag &= ~(ECHO | ICANON);\n  t.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n  t.c_cflag &= ~(CSIZE | PARENB);\n  t.c_cflag |= CS8;\n\n  t.c_oflag &= ~(OPOST);\n\n  t.c_cc[VMIN] = 1;\n  t.c_cc[VTIME] = 0;\n\n  if (tcsetattr(fd, 2, &t) < 0)\n    return -1;\n\n  ttystate = 2;\n  ttysavefd = fd;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":1,"function":"int tty_raw(int fd) {\n    struct termios buf;\n    if (tcgetattr(fd, &save_termios) < 0)\n        return (-1);\n    buf = save_termios;\n    buf.c_lflag &= ~(8 | 2 | 32768 | 1);\n    buf.c_iflag &= ~(2 | 256 | 16 | 32 | 1024);\n    buf.c_cflag &= ~(48 | 256);\n    buf.c_cflag |= 48;\n    buf.c_oflag &= ~(1);\n    buf.c_cc[6] = 1;\n    buf.c_cc[5] = 0;\n    if (tcsetattr(fd, 2, &buf) < 0)\n        return (-1);\n    ttystate = RAW;\n    ttysavefd = fd;\n    return (0);\n}\n","function_prediction":"int tty_raw_name_conflict(int fd) {\n  struct termios tty;\n\n  if (tcgetattr(fd, &save_termios) < 0)\n    return -1;\n\n  tty = save_termios;\n\n  tty.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n  tty.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n  tty.c_cflag &= ~(CSIZE | PARENB);\n  tty.c_cflag |= CS8;\n  tty.c_oflag &= ~(OPOST);\n  tty.c_cc[VMIN] = 1;\n  tty.c_cc[VTIME] = 0;\n\n  if (tcsetattr(fd, TCSAFLUSH, &tty) < 0)\n    return -1;\n\n  ttystate = 1;\n  ttysavefd = fd;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":1,"function":"int tty_reset(int fd) {\n    if (ttystate != CBREAK && ttystate != RAW)\n        return (0);\n    if (tcsetattr(fd, 2, &save_termios) < 0)\n        return (-1);\n    ttystate = RESET;\n    return (0);\n}\n","function_prediction":"int tty_reset_name_conflict(int fd) {\n  if (ttystate != 1 && ttystate != 2)\n    return 0;\n\n  if (tcsetattr(fd, 2, &save_termios) < 0)\n    return -1;\n\n  ttystate = 0;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":0,"function":"struct termios *tty_termios(void) {\n    return (&save_termios);\n}\n","function_prediction":"struct termios *tty_termios_name_conflict(void) { return &save_termios; }","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":1,"function":"int func1(void) {\n    return 42;\n}\n","function_prediction":"int func1_name_conflict(void) { return 42; }","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/exclusion/hello.c"}
{"compilable":1,"function":"int hello2() {\n    printf(\"Hello, two!\\n\");\n    return 0;\n}\n","function_prediction":"int hello2_name_conflict(void) {\n  puts(\"Hello, two!\");\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/msvs/uldi2010/hello2.c"}
{"compilable":1,"function":"int asm_function() {\n    return 41;\n}\n","function_prediction":"int asm_function_name_conflict(void) {\n  int a = 10;\n  int b = 15;\n  int c = 0;\n\n  c = a + b;\n\n  return c;\n}","pass":0,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/rules/src/subdir4/program.c"}
{"compilable":1,"function":"int func1(void) {\n    return 42;\n}\n","function_prediction":"int func1_name_conflict(void) { return 42; }","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/product/hello.c"}
{"compilable":1,"function":"int hello2() {\n    printf(\"Hello, two!\\n\");\n    return 0;\n}\n","function_prediction":"int hello2_name_conflict(void) {\n  puts(\"Hello, two!\");\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/msvs/uldi2010/hello2.c"}
{"compilable":1,"function":"int funcB() {\n    return 3;\n}\n","function_prediction":"int funcB_name_conflict(void) { return 3; }","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/dependencies/b/b3.c"}
{"compilable":0,"function":"int funcA() {\n    return funcB();\n}\n","function_prediction":"void funcA_name_conflict(void) { funcB(); }","pass":0,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/dependencies/a.c"}
{"compilable":0,"function":"char *create_pkt(char *ip) {\n    char *ptr;\n    char *adr;\n    char *token;\n    int fd;\n    int arp_proto = htons(2054);\n    int hw_tp = htons(1);\n    int pro_type = htons(2048);\n    int hw_size = 6;\n    int pr_size = 4;\n    int opcode = htons(1);\n    int i;\n    unsigned char seq;\n    struct ifreq buffer;\n    struct sockaddr_in *ipadd;\n    ptr = malloc(sizeof(char[44]));\n    memset(ptr, 0, sizeof(char[44]));\n    fd = socket(2, SOCK_DGRAM, IPPROTO_IP);\n    memset(&buffer, 0, sizeof (buffer));\n    strcpy(buffer.ifr_ifrn.ifrn_name, \"wlan0\");\n    ioctl(fd, 35111, &buffer);\n    close(fd);\n    memcpy(ptr, \"\\377\\377\\377\\377\\377\\377\", 6);\n    memcpy(ptr + 6, buffer.ifr_ifru.ifru_addr.sa_data, 6);\n    memcpy(ptr + (2 * 6), &arp_proto, 2);\n    memcpy(ptr + 14, &hw_tp, 2);\n    memcpy(ptr + 14 + 2, &pro_type, 2);\n    memcpy(ptr + 14 + 4, &hw_size, 1);\n    memcpy(ptr + 14 + 5, &pr_size, 1);\n    memcpy(ptr + 14 + 6, &opcode, 2);\n    memcpy(ptr + 14 + 8, buffer.ifr_ifru.ifru_addr.sa_data, 6);\n    memset(&buffer, 0, sizeof buffer);\n    strcpy(buffer.ifr_ifrn.ifrn_name, \"wlan0\");\n    fd = socket(2, SOCK_DGRAM, 0);\n    if (ioctl(fd, 35093, &buffer) == -1)\n        printf(\"ioctl ip checking error\\n\");\n    close(fd);\n    ipadd = (struct sockaddr_in *)&(buffer.ifr_ifru.ifru_addr);\n    adr = inet_ntoa(ipadd->sin_addr);\n    printf(\"alamat ipmu adalah : %s\\n\", adr);\n    token = strtok(adr, \".\");\n    while (token != ((void *)0))\n        {\n            seq = atoi(token);\n            memcpy(ptr + 14 + 8 + 6 + i, &seq, 1);\n            token = strtok(((void *)0), \".\");\n            i++;\n        }\n    i = 0;\n    token = strtok(ip, \".\");\n    while (token != ((void *)0))\n        {\n            seq = atoi(token);\n            memcpy(ptr + 14 + 8 + (2 * 6) + 4 + i, &seq, 1);\n            token = strtok(((void *)0), \".\");\n            i++;\n        }\n    return ptr;\n}\n","function_prediction":"unsigned char *create_pkt_name_conflict(char *ip_dest) {\n\n  unsigned short eth_type = htons(0x0806);\n  unsigned short arp_type = htons(0x0001);\n  unsigned short eth_proto = htons(0x0800);\n  unsigned char eth_hlen = 6;\n  unsigned char eth_plen = 4;\n  unsigned short arp_op = htons(0x0001);\n\n  unsigned char *pkt;\n  int sock;\n  struct ifreq ifr;\n  char *ip_addr;\n  char *token;\n  char *ip_addr_temp;\n  int i;\n\n  pkt = (unsigned char *)malloc(42);\n  memset(pkt, 0, 42);\n\n  sock = socket(2, 2, 0);\n\n  memset(&ifr, 0, sizeof(ifr));\n  ifr.ifr_ifru.ifru_data = \"wlan0\";\n  ifr.ifr_addr.sa_data[1] = 0x30;\n  ioctl(sock, 0x8927, &ifr);\n  close(sock);\n\n  memcpy(pkt, \"\\x00\\x0c\\x29\\x6f\\x00\\x00\", 6);\n  memcpy(pkt + 6, ifr.ifr_hwaddr.sa_data, 6);\n\n  *(unsigned short *)(pkt + 12) = eth_type;\n  *(unsigned short *)(pkt + 14) = arp_type;\n  *(unsigned short *)(pkt + 16) = eth_proto;\n  *(unsigned char *)(pkt + 18) = eth_hlen;\n  *(unsigned char *)(pkt + 19) = eth_plen;\n  *(unsigned short *)(pkt + 20) = arp_op;\n\n  memcpy(pkt + 22, ifr.ifr_hwaddr.sa_data, 6);\n\n  memset(&ifr, 0, sizeof(ifr));\n  ifr.ifr_","pass":0,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":1,"function":"int are_equal(const unsigned char *str1, const unsigned char *str2, int len) {\n    int i;\n    for (i = 0; i < len; i++) {\n        if (!(*(str1 + i) & *(str2 + i)))\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"int are_equal_name_conflict(const unsigned char *a, const unsigned char *b, int len) {\n  int i;\n  for (i = 0; i < len; i++)\n    if ((a[i] & b[i]) != 0)\n      return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":1,"function":"int create_socket() {\n    int fd;\n    fd = socket(17, SOCK_RAW, htons(2054));\n    if (fd == -1)\n        printf(\"socket error\\n\");\n    return fd;\n}\n","function_prediction":"int create_socket_name_conflict() {\n  int sockfd;\n\n  if ((sockfd = socket(17, 3, htons(2054))) == -1) {\n    puts(\"socket error\");\n    return -1;\n  }\n\n  return sockfd;\n}","pass":1,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":1,"function":"int examine_addr(char *addr) {\n    char *ex;\n    char sec_addr[3];\n    char *token;\n    unsigned int tes;\n    int chk_ip = 0;\n    ex = strchr(addr, ' ');\n    if (ex != ((void *)0)) {\n        printf(\"alamat yang di masukkan salah, mohon jangan ada spasi\\n\");\n        return 0;\n    }\n    token = strtok(addr, \".\");\n    while (token != ((void *)0))\n        {\n            chk_ip++;\n            tes = atoi(token);\n            if (tes > 255) {\n                printf(\"alamat ip tidak ada yang lebih dari 255\\n\");\n                return 0;\n            }\n            token = strtok(((void *)0), \".\");\n        }\n    if (chk_ip != 4) {\n        printf(\"alamat tidak valid\\n\");\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"int examine_addr_name_conflict(char *addr) {\n  int count = 0;\n  char *token;\n  if (strchr(addr, ' ') != NULL) {\n    puts(\"alamat yang di masukkan salah, mohon jangan ada spasi\");\n    return 0;\n  }\n  token = strtok(addr, \".\");\n  while (token != NULL) {\n    count++;\n    if (atoi(token) > 255) {\n      puts(\"alamat ip tidak ada yang lebih dari 255\");\n      return 0;\n    }\n    token = strtok(NULL, \".\");\n  }\n  if (count != 4) {\n    puts(\"alamat tidak valid\");\n    return 0;\n  }\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":0,"function":"static int make_user_test(void) {\n    struct user *user = psylbm_make_user();\n    psylbm_free_user(user);\n    return 0;\n}\n","function_prediction":"int make_user_test_name_conflict(void) {\n  psylbm_user_t *user = psylbm_make_user();\n  psylbm_free_user(user);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/test/domain_test.c"}
{"compilable":0,"function":"static int make_bookmark_test(void) {\n    struct bookmark *bookmark = psylbm_make_bookmark();\n    psylbm_free_bookmark(bookmark);\n    return 0;\n}\n","function_prediction":"int make_bookmark_test_name_conflict(void) {\n  psylbm_bookmark_t *bookmark = psylbm_make_bookmark();\n  psylbm_free_bookmark(bookmark);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/test/domain_test.c"}
{"compilable":0,"function":"static int parse_insert_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_INSERT;\n    const char *curr = &buffer[4];\n    {\n        char *dst = &message->message.insert.name[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.title[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.volume_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.chapter_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.page_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.token[0];\n        while (*curr != 0 && *curr != '|')\n            *(dst++) = *(curr++);\n    }\n    if (*curr != 0) {\n        curr++;\n        char *dst = &message->message.insert.book_id_str[0];\n        while (*curr != 0)\n            *(dst++) = *(curr++);\n    }\n    message->message.insert.volume = atoi(message->message.insert.volume_str);\n    message->message.insert.chapter = atoi(message->message.insert.chapter_str);\n    message->message.insert.page = atoi(message->message.insert.page_str);\n    message->message.insert.book_id = atoi(message->message.insert.book_id_str);\n    return 0;\n  error:\n    return 1;\n}\n","function_prediction":"int parse_insert_message_name_conflict(char *message, struct insert_message *insert_message) {\n  char *p = message + 4;\n  char *q;\n\n  insert_message->type = 1;\n\n  q = (char *)insert_message + sizeof(struct insert_message);\n  while (*p != '|')\n    *q++ = *p++;\n\n  if (*(p + 1) == '\\0')\n    return 1;\n\n  p++;\n  q = (char *)insert_message + sizeof(struct insert_message) + 100;\n  while (*p != '|')\n    *q++ = *p++;\n\n  if (*(p + 1) == '\\0')\n    return 1;\n\n  p++;\n  q = (char *)insert_message + sizeof(struct insert_message) + 200;\n  while (*p != '|')\n    *q++ = *p++;\n\n  if (*(p + 1) == '\\0')\n    return 1;\n\n  p++;\n  q = (char *)insert_message + sizeof(struct insert_message) + 300;\n  while (*p != '|')\n    *q++ = *p++;\n\n  if (*(p + 1) == '\\0')\n    return 1;\n\n  p++;\n  q = (char *)insert_message + sizeof(struct insert_message) + 400;\n  while (*p != '\\0' && *p != '|')\n    *q++ = *p++;\n\n  if (*p == '\\0')\n    return 1;\n\n  p++;\n  q = (char *)insert_message + sizeof(struct insert_message) + 500;\n  while (*p != '\\0')\n    *q++ = *p++;\n\n  insert_message->data.insert.id =\n      atoi((char *)insert_message + sizeof(struct insert_message) + 100);\n  insert_message->data.insert.x =\n      atoi((char *)insert_message + sizeof(struct insert_message) + 200);\n  insert_message","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_auth_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_AUTH;\n    const char *curr = &buffer[5];\n    char *username = &message->message.auth.username[0];\n    while (*curr != '|')\n        *(username++) = *(curr++);\n    curr++;\n    char *password = &message->message.auth.password[0];\n    while (*curr != 0)\n        *(password++) = *(curr++);\n    return 0;\n}\n","function_prediction":"int parse_auth_message_name_conflict(char *message, struct auth_message *auth_msg) {\n  char *p = message + 5;\n  char *q = (char *)auth_msg;\n  char *r;\n\n  auth_msg->type = 0;\n\n  while (*p != '|')\n    *q++ = *p++;\n\n  r = (char *)auth_msg + sizeof(struct auth_message);\n  while (*++p != '\\0')\n    *r++ = *p;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_register_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_REGISTER;\n    struct received_message recv_mess = {0};\n    const size_t max_username_len = sizeof (recv_mess.message.regist.username) - 1;\n    const char *curr = &buffer[4];\n    char *username = &message->message.regist.username[0];\n    size_t count = 0;\n    while (*curr != '|')\n        {\n            if (count == max_username_len)\n                break;\n            *(username++) = *(curr++);\n            count++;\n        }\n    curr++;\n    char *password = &message->message.regist.password[0];\n    while (*curr != 0)\n        *(password++) = *(curr++);\n    return 0;\n}\n","function_prediction":"int parse_register_message_name_conflict(char *message, char *parsed_message) {\n  char *p_message = message;\n  char *p_parsed_message = parsed_message;\n  char *p_parsed_message_end = parsed_message + 255;\n  char *p_parsed_message_end_2 = parsed_message + 255;\n  char *p_parsed_message_end_3 = parsed_message + 255;\n  char *p_parsed_message_end_4 = parsed_message + 255;\n  char *p_parsed_message_end_5 = parsed_message + 255;\n  char *p_parsed_message_end_6 = parsed_message + 255;\n  char *p_parsed_message_end_7 = parsed_message + 255;\n  char *p_parsed_message_end_8 = parsed_message + 255;\n  char *p_parsed_message_end_9 = parsed_message + 255;\n  char *p_parsed_message_end_10 = parsed_message + 255;\n  char *p_parsed_message_end_11 = parsed_message + 255;\n  char *p_parsed_message_end_12 = parsed_message + 255;\n  char *p_parsed_message_end_13 = parsed_message + 255;\n  char *p_parsed_message_end_14 = parsed_message + 255;\n  char *p_parsed_message_end_15 = parsed_message + 255;\n  char *p_parsed_message_end_16 = parsed_message + 255;\n  char *p_parsed_message_end_17 = parsed_message + 255;\n  char *p_parsed_message_end_18 = parsed_message + 255;\n  char *p_parsed_message_end_19 = parsed_message + 255;\n  char *p_parsed_message_end_20 = parsed_message + 25","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_delete_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_DELETE;\n    const char *curr = &buffer[4];\n    char *bookmark_id_str = &message->message.delete.bookmark_id_str[0];\n    while (*curr != '|')\n        *(bookmark_id_str++) = *(curr++);\n    curr++;\n    char *token = &message->message.delete.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    message->message.delete.bookmark_id = atoi(message->message.delete.bookmark_id_str);\n    return 0;\n}\n","function_prediction":"int parse_delete_message_name_conflict(char *message, struct message *msg) {\n  char *p = message + 4;\n  char *q = (char *)msg + sizeof(struct message);\n  msg->type = 3;\n  while (*p != '|')\n    *q++ = *p++;\n  p++;\n  q = (char *)msg + sizeof(struct message) + 8;\n  while (*p)\n    *q++ = *p++;\n  msg->data.delete.id = atoi((char *)msg + sizeof(struct message));\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_purge_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_PURGE;\n    const char *curr = &buffer[6];\n    char *token = &message->message.purge.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"int parse_purge_message_name_conflict(char *message, char *parsed_message) {\n  int i = 0;\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '4';\n  while (message[i] != '\\0') {\n    parsed_message[i] = message[i];\n    i++;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_sync_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_SYNC;\n    const char *curr = &buffer[5];\n    char *token = &message->message.sync.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"int parse_sync_message_name_conflict(char *message, char *parsed_message) {\n  int i = 0;\n  int j = 0;\n\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '5';\n\n  while (message[j] != '\\0') {\n    parsed_message[i++] = message[j++];\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_syncdata_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_SYNCDATA;\n    const char *curr = &buffer[9];\n    char *token = &message->message.syncdata.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"int parse_syncdata_message_name_conflict(char *message, char *parsed_message) {\n  int i = 0;\n  int j = 0;\n\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '0';\n  parsed_message[i++] = '6';\n\n  while (message[j] != '\\0') {\n    parsed_message[i++] = message[j++];\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"char *psylbm_strndup(const unsigned char *src, size_t len) {\n    const size_t c_str_len = len + 1;\n    char *ret = calloc(1, sizeof(char) * c_str_len);\n    memcpy(ret, src, len);\n    ret[len] = 0;\n    return ret;\n}\n","function_prediction":"char *psylbm_strndup_name_conflict(const char *s, size_t n) {\n  char *p = calloc(1, n + 1);\n  memcpy(p, s, n);\n  p[n] = '\\0';\n  return p;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/common.c"}
{"compilable":0,"function":"char *get_executable() {\n    char buffer[4096];\n    snprintf(buffer, 4096, \"/proc/%u/exe\", getpid());\n    char *filename = malloc(4096);\n    ssize_t len = readlink(buffer, filename, 4096);\n    if (len == -1) {\n        fprintf(stderr, \"Can't get executable name from %s - %s\\n\", buffer, strerror((*__errno_location())));\n        exit(-1);\n    } else if (len >= 4096) {\n        fprintf(LOGFILE, \"Executable name %.*s is longer than %d characters.\\n\", 4096, filename, 4096);\n        exit(-1);\n    }\n    filename[len] = '\\x00';\n    return filename;\n}\n","function_prediction":"char *get_executable_name_conflict() {\n  char path[4096];\n  char *buf;\n  ssize_t len;\n\n  snprintf(path, 4096, \"/proc/%u/exe\", getpid());\n  buf = malloc(4096);\n  len = readlink(path, buf, 4096);\n  if (len == -1) {\n    fprintf(stderr, \"Can't get executable name from %s - %s\\n\", path,\n            strerror(*__errno_location()));\n    exit(-1);\n  }\n  if (len >= 4096) {\n    fprintf(LOGFILE, \"Executable name %.*s is longer than %d characters.\\n\",\n            4096, buf, 4096);\n    exit(-1);\n  }\n  buf[len] = '\\0';\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int check_taskcontroller_permissions(char *executable_file) {\n    (*__errno_location()) = 0;\n    char *resolved_path = realpath(executable_file, ((void *)0));\n    if (resolved_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Error resolving the canonical name for the executable : %s!\", strerror((*__errno_location())));\n        return -1;\n    }\n    struct stat filestat;\n    (*__errno_location()) = 0;\n    if (stat(resolved_path, &filestat) != 0) {\n        fprintf(LOGFILE, \"Could not stat the executable : %s!.\\n\", strerror((*__errno_location())));\n        return -1;\n    }\n    uid_t binary_euid = filestat.st_uid;\n    gid_t binary_gid = filestat.st_gid;\n    if (binary_euid != 0) {\n        fprintf(LOGFILE, \"The task-controller binary should be user-owned by root.\\n\");\n        return -1;\n    }\n    if (binary_gid != getgid()) {\n        fprintf(LOGFILE, \"The configured tasktracker group %d is different from the group of the executable %d\\n\", getgid(), binary_gid);\n        return -1;\n    }\n    if ((filestat.st_mode & ((256 >> 3) >> 3)) == ((256 >> 3) >> 3) || (filestat.st_mode & ((128 >> 3) >> 3)) == ((128 >> 3) >> 3) || (filestat.st_mode & ((64 >> 3) >> 3)) == ((64 >> 3) >> 3)) {\n        fprintf(LOGFILE, \"The task-controller binary should not have read or write or execute for others.\\n\");\n        return -1;\n    }\n    if ((filestat.st_mode & 2048) == 0) {\n        fprintf(LOGFILE, \"The task-controller binary should be set setuid.\\n\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int check_taskcontroller_permissions_name_conflict(char *path) {\n  char *real_path;\n  struct stat statbuf;\n  int ret;\n\n  *__errno_location() = 0;\n  real_path = realpath(path, NULL);\n  if (real_path == NULL) {\n    fprintf(LOGFILE,\n            \"Error resolving the canonical name for the executable : %s!\",\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  *__errno_location() = 0;\n  ret = stat(real_path, &statbuf);\n  if (ret != 0) {\n    fprintf(LOGFILE, \"Could not stat the executable : %s!.\\n\",\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  if (statbuf.st_uid != 0) {\n    fprintf(LOGFILE,\n            \"The task-controller binary should be user-owned by root.\\n\");\n    return -1;\n  }\n\n  if (statbuf.st_gid != getgid()) {\n    fprintf(LOGFILE,\n            \"The configured tasktracker group %d is different from the group \"\n            \"of the executable %d\\n\",\n            getgid(), statbuf.st_gid);\n    return -1;\n  }\n\n  if (statbuf.st_mode & 0004 || statbuf.st_mode & 0002 ||\n      statbuf.st_mode & 0001) {\n    fprintf(LOGFILE, \"The task-controller binary should not have read or write \"\n                     \"or execute for others.\\n\");\n    return -1;\n  }\n\n  if (!(statbuf.st_mode & 001000)) {\n    fprintf(LOGFILE, \"The task-controller binary should be set setuid.\\n\");\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int change_effective_user(uid_t user, gid_t group) {\n    if (geteuid() == user) {\n        return 0;\n    }\n    if (seteuid(0) != 0) {\n        return -1;\n    }\n    if (setegid(group) != 0) {\n        fprintf(LOGFILE, \"Failed to set effective group id %d - %s\\n\", group, strerror((*__errno_location())));\n        return -1;\n    }\n    if (seteuid(user) != 0) {\n        fprintf(LOGFILE, \"Failed to set effective user id %d - %s\\n\", user, strerror((*__errno_location())));\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int change_effective_user_name_conflict(uid_t uid, gid_t gid) {\n  if (uid == geteuid())\n    return 0;\n\n  if (seteuid(0))\n    return -1;\n\n  if (setegid(gid)) {\n    fprintf(LOGFILE, \"Failed to set effective group id %d - %s\\n\", gid,\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  if (seteuid(uid)) {\n    fprintf(LOGFILE, \"Failed to set effective user id %d - %s\\n\", uid,\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int change_user(uid_t user, gid_t group) {\n    if (user == getuid() && user == geteuid() && group == getgid() && group == getegid()) {\n        return 0;\n    }\n    if (seteuid(0) != 0) {\n        fprintf(LOGFILE, \"unable to reacquire root - %s\\n\", strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    if (setgid(group) != 0) {\n        fprintf(LOGFILE, \"unable to set group to %d - %s\\n\", group, strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    if (setuid(user) != 0) {\n        fprintf(LOGFILE, \"unable to set user to %d - %s\\n\", user, strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    return 0;\n}\n","function_prediction":"int change_user_name_conflict(uid_t uid, gid_t gid) {\n  if (uid == getuid() && uid == geteuid() && gid == getgid() &&\n      gid == getegid())\n    return 0;\n\n  if (!seteuid(0)) {\n    if (!setgid(gid)) {\n      if (!setuid(uid))\n        return 0;\n      else {\n        fprintf(LOGFILE, \"unable to set user to %d - %s\\n\", uid,\n                strerror(*__errno_location()));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(),\n                geteuid(), getegid());\n        return 6;\n      }\n    } else {\n      fprintf(LOGFILE, \"unable to set group to %d - %s\\n\", gid,\n              strerror(*__errno_location()));\n      fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(),\n              geteuid(), getegid());\n      return 6;\n    }\n  } else {\n    fprintf(LOGFILE, \"unable to reacquire root - %s\\n\",\n            strerror(*__errno_location()));\n    fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(),\n            geteuid(), getegid());\n    return 6;\n  }\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char **get_mapred_local_dirs(const char *good_local_dirs) {\n    return extract_values(strdup(good_local_dirs));\n}\n","function_prediction":"char **get_mapred_local_dirs_name_conflict(char *mapred_local_dirs) {\n  char *mapred_local_dirs_copy = strdup(mapred_local_dirs);\n  return extract_values(mapred_local_dirs_copy);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *concatenate(char *concat_pattern, char *return_path_name, int numArgs, ...) {\n    va_list ap;\n    __builtin_va_start(ap, numArgs);\n    int strlen_args = 0;\n    char *arg = ((void *)0);\n    int j;\n    for (j = 0; j < numArgs; j++) {\n        arg = __builtin_va_arg(ap, char *);\n        if (arg == ((void *)0)) {\n            fprintf(LOGFILE, \"One of the arguments passed for %s in null.\\n\", return_path_name);\n            return ((void *)0);\n        }\n        strlen_args += strlen(arg);\n    }\n    __builtin_va_end(ap);\n    char *return_path = ((void *)0);\n    int str_len = strlen(concat_pattern) + strlen_args + 1;\n    return_path = (char *)malloc(str_len);\n    if (return_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Unable to allocate memory for %s.\\n\", return_path_name);\n        return ((void *)0);\n    }\n    __builtin_va_start(ap, numArgs);\n    vsnprintf(return_path, str_len, concat_pattern, ap);\n    __builtin_va_end(ap);\n    return return_path;\n}\n","function_prediction":"char *concatenate_name_conflict(char *format, char *function, int argc, ...) {\n  va_list ap;\n  char *result = NULL;\n  int i, len = 0;\n  char *argv[10];\n\n  ap = (va_list)(&argc);\n  for (i = 0; i < argc; i++) {\n    argv[i] = va_arg(ap, char *);\n    if (argv[i] == NULL) {\n      fprintf(LOGFILE, \"One of the arguments passed for %s in null.\\n\",\n              function);\n      return NULL;\n    }\n    len += strlen(argv[i]);\n  }\n\n  len += strlen(format) + 1;\n  result = (char *)malloc(len);\n  if (result == NULL) {\n    fprintf(LOGFILE, \"Unable to allocate memory for %s.\\n\", function);\n    return NULL;\n  }\n\n  ap = (va_list)(&argc);\n  vsnprintf(result, len, format, ap);\n\n  return result;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_directory(const char *tt_root, const char *user, const char *jobid) {\n    return concatenate(\"%s/taskTracker/%s/jobcache/%s\", \"job_dir_path\", 3, tt_root, user, jobid);\n}\n","function_prediction":"char *get_job_directory_name_conflict(char *user, char *job_id, char *job_dir_path) {\n  return concatenate(\"%s/taskTracker/%s/jobcache/%s\", \"job_dir_path\", 3, user,\n                     job_id, job_dir_path);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_user_directory(const char *tt_root, const char *user) {\n    return concatenate(\"%s/taskTracker/%s\", \"user_dir_path\", 2, tt_root, user);\n}\n","function_prediction":"char *get_user_directory_name_conflict(char *user_name, char *user_dir_path) {\n  return concatenate(\"%s/taskTracker/%s\", \"user_dir_path\", 2, user_name,\n                     user_dir_path);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_work_directory(const char *job_dir) {\n    return concatenate(\"%s/work\", \"job work\", 1, job_dir);\n}\n","function_prediction":"char *get_job_work_directory_name_conflict(char *job_id) {\n  return concatenate(\"%s/work\", \"job work\", 1, job_id);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_attempt_work_directory(const char *tt_root, const char *user, const char *job_id, const char *attempt_id) {\n    return concatenate(\"%s/taskTracker/%s/jobcache/%s/%s/work\", \"attempt_dir_path\", 4, tt_root, user, job_id, attempt_id);\n}\n","function_prediction":"char *get_attempt_work_directory(char *task_id, char *job_id, char *attempt_id,\n                                 char *user_name) {\n  return concatenate(\"%s/taskTracker/%s/jobcache/%s/%s/work\",\n                     \"attempt_dir_path\", 4, task_id, job_id, attempt_id,\n                     user_name);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_task_launcher_file(const char *work_dir) {\n    return concatenate(\"%s/%s\", \"task launcher\", 2, work_dir, \"taskjvm.sh\");\n}\n","function_prediction":"char *get_task_launcher_file_name_conflict(char *path) {\n  return concatenate(\"%s/%s\", 2, path, \"taskjvm.sh\", \"task launcher\");\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_log_directory(const char *jobid) {\n    char *log_dir = get_value(\"hadoop.log.dir\");\n    if (log_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Log directory %s is not configured.\\n\", \"hadoop.log.dir\");\n        return ((void *)0);\n    }\n    char *result = concatenate(\"%s/userlogs/%s\", \"job log dir\", 2, log_dir, jobid);\n    if (result == ((void *)0)) {\n        fprintf(LOGFILE, \"failed to get memory in get_job_log_directory for %s and %s\\n\", log_dir, jobid);\n    }\n    free(log_dir);\n    return result;\n}\n","function_prediction":"char *get_job_log_directory_name_conflict(char *job_id) {\n  char *job_log_dir = NULL;\n  char *log_dir = get_value(\"hadoop.log.dir\");\n  if (log_dir == NULL) {\n    fprintf(LOGFILE, \"Log directory %s is not configured.\\n\", \"hadoop.log.dir\");\n    return NULL;\n  }\n\n  job_log_dir =\n      concatenate(\"%s/userlogs/%s\", \"job log dir\", 2, log_dir, job_id);\n  if (job_log_dir == NULL) {\n    fprintf(LOGFILE,\n            \"failed to get memory in get_job_log_directory_name_conflict for %s and %s\\n\",\n            log_dir, job_id);\n  }\n  free(log_dir);\n  return job_log_dir;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_user_subdirectory(const char *tt_root, const char *user, const char *subdir) {\n    char *user_dir = get_user_directory(tt_root, user);\n    char *result = concatenate(\"%s/%s\", \"user subdir\", 2, user_dir, subdir);\n    free(user_dir);\n    return result;\n}\n","function_prediction":"char *get_user_subdirectory_name_conflict(char *user, char *subdir, char *subdir_name) {\n  char *user_dir = get_user_directory(user, subdir);\n  char *user_subdir =\n      concatenate(\"%s/%s\", \"user subdir\", 2, user_dir, subdir_name);\n  free(user_dir);\n  return user_subdir;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int mkdirs(const char *path, mode_t perm) {\n    char *buffer = strdup(path);\n    char *token;\n    int cwd = open(\"/\", 0);\n    if (cwd == -1) {\n        fprintf(LOGFILE, \"Can't open / in %s - %s\\n\", path, strerror((*__errno_location())));\n        free(buffer);\n        return -1;\n    }\n    for (token = strtok(buffer, \"/\"); token != ((void *)0); token = strtok(((void *)0), \"/\")) {\n        if (mkdirat(cwd, token, perm) != 0) {\n            if ((*__errno_location()) != 17) {\n                fprintf(LOGFILE, \"Can't create directory %s in %s - %s\\n\", token, path, strerror((*__errno_location())));\n                close(cwd);\n                free(buffer);\n                return -1;\n            }\n        }\n        int new_dir = openat(cwd, token, 0);\n        close(cwd);\n        cwd = new_dir;\n        if (cwd == -1) {\n            fprintf(LOGFILE, \"Can't open %s in %s - %s\\n\", token, path, strerror((*__errno_location())));\n            free(buffer);\n            return -1;\n        }\n    }\n    free(buffer);\n    close(cwd);\n    return 0;\n}\n","function_prediction":"int mkdirs_name_conflict(const char *path, mode_t mode) {\n  char *path_copy = strdup(path);\n  char *dir;\n  int fd, rc;\n\n  fd = open(\"/\", 0);\n  if (fd == -1) {\n    fprintf(LOGFILE, \"Can't open / in %s - %s\\n\", path,\n            strerror(*__errno_location()));\n    free(path_copy);\n    return -1;\n  }\n\n  dir = strtok(path_copy, \"/\");\n  while (dir) {\n    rc = mkdirat(fd, dir, mode);\n    if (rc && *__errno_location() != 17) {\n      fprintf(LOGFILE, \"Can't create directory %s in %s - %s\\n\", dir, path,\n              strerror(*__errno_location()));\n      close(fd);\n      free(path_copy);\n      return 0;\n    }\n\n    fd = openat(fd, dir, 0);\n    close(fd);\n    if (fd == -1) {\n      fprintf(LOGFILE, \"Can't open %s in %s - %s\\n\", dir, path,\n              strerror(*__errno_location()));\n      free(path_copy);\n      return -1;\n    }\n\n    dir = strtok(NULL, \"/\");\n  }\n\n  free(path_copy);\n  close(fd);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static short get_current_local_dir_count(char **local_dir) {\n    char **local_dir_ptr;\n    short count = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        ++count;\n    }\n    return count;\n}\n","function_prediction":"short get_current_local_dir_count_name_conflict(char **local_dirs) {\n  short count = 0;\n  while (*local_dirs++)\n    count++;\n  return count;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static char *get_nth_local_dir(char **local_dir, int nth) {\n    char **local_dir_ptr;\n    short count = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        if (count == nth) {\n            return strdup(*local_dir_ptr);\n        }\n        ++count;\n    }\n    fprintf(LOGFILE, \"Invalid index %d for %d local directories\\n\", nth, count);\n    return ((void *)0);\n}\n","function_prediction":"char *get_nth_local_dir_name_conflict(char **local_dirs, int n) {\n  int i;\n\n  for (i = 0; local_dirs[i]; i++) {\n    if (i == n)\n      return strdup(local_dirs[i]);\n  }\n\n  fprintf(LOGFILE, \"Invalid index %d for %d local directories\\n\", n, i);\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static char *get_random_local_dir(char **local_dir) {\n    struct timeval tv;\n    short nth;\n    gettimeofday(&tv, ((void *)0));\n    srand((long)tv.tv_sec * 1000000 + tv.tv_usec);\n    short cnt = get_current_local_dir_count(local_dir);\n    if (cnt == 0) {\n        fprintf(LOGFILE, \"No valid local directories\\n\");\n        return ((void *)0);\n    }\n    nth = rand() % cnt;\n    return get_nth_local_dir(local_dir, nth);\n}\n","function_prediction":"char *get_random_local_dir_name_conflict(char *local_dirs) {\n  struct timeval tv;\n  short count, rand_dir;\n  char *dir;\n\n  gettimeofday(&tv, NULL);\n  srand(tv.tv_sec * 1000000 + tv.tv_usec);\n\n  count = get_current_local_dir_count(local_dirs);\n  if (count == 0) {\n    fprintf(LOGFILE, \"No valid local directories\\n\");\n    return NULL;\n  }\n\n  rand_dir = rand() % count;\n  dir = get_nth_local_dir(local_dirs, rand_dir);\n\n  return dir;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int create_attempt_directories(const char *user, const char *good_local_dirs, const char *job_id, const char *task_id) {\n    const mode_t perms = (256 | 128 | 64) | (256 >> 3) | (64 >> 3);\n    if (job_id == ((void *)0) || task_id == ((void *)0) || user == ((void *)0)) {\n        fprintf(LOGFILE, \"Either task_id is null or the user passed is null.\\n\");\n        return -1;\n    }\n    int result = 0;\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    if (local_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could not be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    char **local_dir_ptr;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        char *task_dir = get_attempt_work_directory(*local_dir_ptr, user, job_id, task_id);\n        if (task_dir == ((void *)0)) {\n            free_values(local_dir);\n            return -1;\n        }\n        if (mkdirs(task_dir, perms) != 0) {\n            free(task_dir);\n        } else {\n            free(task_dir);\n        }\n    }\n    char *job_task_name = malloc(strlen(job_id) + strlen(task_id) + 2);\n    char *real_task_dir = ((void *)0);\n    char *real_job_dir = ((void *)0);\n    char *random_local_dir = ((void *)0);\n    char *link_task_log_dir = ((void *)0);\n    if (job_task_name == ((void *)0)) {\n        fprintf(LOGFILE, \"Malloc of job task name failed\\n\");\n        result = -1;\n    } else {\n        sprintf(job_task_name, \"%s/%s\", job_id, task_id);\n        link_task_log_dir = get_job_log_directory(job_task_name);\n        random_local_dir = get_random_local_dir(local_dir);\n        if (random_local_dir == ((void *)0)) {\n            result = -1;\n            goto cleanup;\n        }\n        real_job_dir = malloc(strlen(random_local_dir) + strlen(\"userlogs\") + strlen(job_id) + 3);\n        if (real_job_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc of real job directory failed\\n\");\n            result = -1;\n            goto cleanup;\n        }\n        real_task_dir = malloc(strlen(random_local_dir) + strlen(\"userlogs\") + strlen(job_id) + strlen(task_id) + 4);\n        if (real_task_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc of real task directory failed\\n\");\n            result = -1;\n            goto cleanup;\n        }\n        sprintf(real_job_dir, \"%s/userlogs/%s\", random_local_dir, job_id);\n        result = create_directory_for_user(real_job_dir);\n        if (result != 0) {\n            result = -1;\n            goto cleanup;\n        }\n        sprintf(real_task_dir, \"%s/userlogs/%s/%s\", random_local_dir, job_id, task_id);\n        result = mkdirs(real_task_dir, perms);\n        if (result != 0) {\n            result = -1;\n            goto cleanup;\n        }\n        result = symlink(real_task_dir, link_task_log_dir);\n        if (result != 0) {\n            fprintf(LOGFILE, \"Failed to create symlink %s to %s - %s\\n\", link_task_log_dir, real_task_dir, strerror((*__errno_location())));\n            result = -1;\n        }\n    }\n  cleanup:\n    free(random_local_dir);\n    free(job_task_name);\n    free(link_task_log_dir);\n    free(real_job_dir);\n    free(real_task_dir);\n    free_values(local_dir);\n    return result;\n}\n","function_prediction":"int create_attempt_directories(char *task_id, char **mapred_local_dirs,\n                               char *user, char *task) {\n  char **local_dirs;\n  char *job_log_dir;\n  char *real_job_dir;\n  char *real_task_dir;\n  char *job_task_name;\n  char *random_local_dir;\n  int ret;\n\n  if (task_id == NULL || user == NULL || mapred_local_dirs == NULL) {\n    fprintf(LOGFILE, \"Either task_id is null or the user passed is null.\\n\");\n    return -1;\n  }\n\n  local_dirs = get_mapred_local_dirs(mapred_local_dirs);\n  if (local_dirs == NULL) {\n    fprintf(LOGFILE, \"Good mapred local directories could not be obtained.\\n\");\n    return 5;\n  }\n\n  char **local_dir = local_dirs;\n  while (*local_dir != NULL) {\n    char *attempt_work_dir =\n        get_attempt_work_directory(*local_dir, task_id, user, task);\n    if (attempt_work_dir == NULL) {\n      free_values(local_dirs);\n      return -1;\n    }\n\n    ret = mkdirs(attempt_work_dir, 0750);\n    if (ret != 0) {\n      free(attempt_work_dir);\n    } else {\n      free(attempt_work_dir);\n    }\n\n    local_dir++;\n  }\n\n  job_task_name = (char *)malloc(strlen(user) + strlen(task) + 2);\n  real_task_dir = NULL;\n  real_job_dir = NULL;\n  job_log_dir = NULL;\n  random_local_dir = NULL;\n  if (job_task_name == NULL) {\n    fprintf(LOGFILE, \"Malloc of job task name failed\\n\");\n  return","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int set_user(const char *user) {\n    if (user_detail != ((void *)0)) {\n        free(user_detail);\n        user_detail = ((void *)0);\n    }\n    user_detail = check_user(user);\n    if (user_detail == ((void *)0)) {\n        return -1;\n    }\n    return change_effective_user(user_detail->pw_uid, user_detail->pw_gid);\n}\n","function_prediction":"int set_user_name_conflict(char *user) {\n  if (user_detail) {\n    free(user_detail);\n    user_detail = NULL;\n  }\n\n  user_detail = check_user(user);\n  if (!user_detail)\n    return -1;\n\n  return change_effective_user(user_detail->uid, user_detail->gid);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int change_owner(const char *path, uid_t user, gid_t group) {\n    if (geteuid() == user && getegid() == group) {\n        return 0;\n    } else {\n        uid_t old_user = geteuid();\n        gid_t old_group = getegid();\n        if (change_effective_user(0, group) != 0) {\n            return -1;\n        }\n        if (chown(path, user, group) != 0) {\n            fprintf(LOGFILE, \"Can't chown %s to %d:%d - %s\\n\", path, user, group, strerror((*__errno_location())));\n            return -1;\n        }\n        return change_effective_user(old_user, old_group);\n    }\n}\n","function_prediction":"int change_owner_name_conflict(const char *path, uid_t uid, gid_t gid) {\n  uid_t orig_uid;\n  gid_t orig_gid;\n\n  if (uid == geteuid() && gid == getegid())\n    return 0;\n\n  orig_uid = geteuid();\n  orig_gid = getegid();\n\n  if (!change_effective_user(0, gid)) {\n    if (!chown(path, uid, gid)) {\n      if (change_effective_user(orig_uid, orig_gid))\n        return -1;\n      return 0;\n    }\n    fprintf(LOGFILE, \"Can't chown %s to %d:%d - %s\\n\", path, uid, gid,\n            strerror(*__errno_location()));\n    return -1;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int create_directory_for_user(const char *path) {\n    mode_t permissions = (256 | 128 | 64) | (256 >> 3) | (64 >> 3) | 1024;\n    uid_t user = geteuid();\n    gid_t group = getegid();\n    int ret = 0;\n    uid_t root = 0;\n    if (getuid() == root) {\n        ret = change_effective_user(root, tt_gid);\n    }\n    if (ret == 0) {\n        if (mkdir(path, permissions) == 0 || (*__errno_location()) == 17) {\n            if (chmod(path, permissions) != 0) {\n                fprintf(LOGFILE, \"Can't chmod %s to add the sticky bit - %s\\n\", path, strerror((*__errno_location())));\n                ret = -1;\n            } else if (change_owner(path, user, tt_gid) != 0) {\n                ret = -1;\n            }\n        } else {\n            fprintf(LOGFILE, \"Failed to create directory %s - %s\\n\", path, strerror((*__errno_location())));\n            ret = -1;\n        }\n    }\n    if (change_effective_user(user, group) != 0) {\n        ret = -1;\n    }\n    return ret;\n}\n","function_prediction":"int create_directory_for_user_name_conflict(char *dir) {\n  int ret = 0;\n  uid_t uid = geteuid();\n  gid_t gid = getegid();\n\n  if (getuid() == 0)\n    ret = change_effective_user(0, tt_gid);\n\n  if (ret == 0) {\n    if (mkdir(dir, 0750)) {\n      if (errno != 17) {\n        fprintf(LOGFILE, \"Failed to create directory %s - %s\\n\", dir,\n                strerror(errno));\n        ret = -1;\n      }\n    }\n\n    if (ret == 0) {\n      if (chmod(dir, 0750)) {\n        fprintf(LOGFILE, \"Can't chmod %s to add the sticky bit - %s\\n\", dir,\n                strerror(errno));\n        ret = -1;\n      } else {\n        if (change_owner(dir, uid, tt_gid))\n          ret = -1;\n      }\n    }\n  }\n\n  if (change_effective_user(uid, gid))\n    ret = -1;\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int open_file_as_task_tracker(const char *filename) {\n    uid_t user = geteuid();\n    gid_t group = getegid();\n    if (change_effective_user(tt_uid, tt_gid) != 0) {\n        return -1;\n    }\n    int result = open(filename, 0);\n    if (result == -1) {\n        fprintf(LOGFILE, \"Can't open file %s as task tracker - %s\\n\", filename, strerror((*__errno_location())));\n    }\n    if (change_effective_user(user, group)) {\n        result = -1;\n    }\n    return result;\n}\n","function_prediction":"int open_file_as_task_tracker_name_conflict(const char *filename) {\n  int fd;\n  uid_t old_uid = geteuid();\n  gid_t old_gid = getegid();\n\n  if (!change_effective_user(tt_uid, tt_gid)) {\n    fd = open(filename, 0);\n    if (fd == -1)\n      fprintf(LOGFILE, \"Can't open file %s as task tracker - %s\\n\", filename,\n              strerror(*__errno_location()));\n    if (!change_effective_user(old_uid, old_gid))\n      return fd;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int copy_file(int input, const char *in_filename, const char *out_filename, mode_t perm) {\n    const int buffer_size = 128 * 1024;\n    char buffer[buffer_size];\n    int out_fd = open(out_filename, 1 | 64 | 128 | 131072, perm);\n    if (out_fd == -1) {\n        fprintf(LOGFILE, \"Can't open %s for output - %s\\n\", out_filename, strerror((*__errno_location())));\n        return -1;\n    }\n    ssize_t len = read(input, buffer, buffer_size);\n    while (len > 0)\n        {\n            ssize_t pos = 0;\n            while (pos < len)\n                {\n                    ssize_t write_result = write(out_fd, buffer + pos, len - pos);\n                    if (write_result <= 0) {\n                        fprintf(LOGFILE, \"Error writing to %s - %s\\n\", out_filename, strerror((*__errno_location())));\n                        close(out_fd);\n                        return -1;\n                    }\n                    pos += write_result;\n                }\n            len = read(input, buffer, buffer_size);\n        }\n    if (len < 0) {\n        fprintf(LOGFILE, \"Failed to read file %s - %s\\n\", in_filename, strerror((*__errno_location())));\n        close(out_fd);\n        return -1;\n    }\n    if (close(out_fd) != 0) {\n        fprintf(LOGFILE, \"Failed to close file %s - %s\\n\", out_filename, strerror((*__errno_location())));\n        return -1;\n    }\n    close(input);\n    return 0;\n}\n","function_prediction":"int copy_file_name_conflict(int in_fd, char *in_name, char *out_name, mode_t mode) {\n  int out_fd;\n  ssize_t bytes_read, bytes_written, total_written;\n  char buffer[131072];\n\n  out_fd = open(out_name, 060000 | 000001 | 000002, mode);\n  if (out_fd == -1) {\n    fprintf(LOGFILE, \"Can't open %s for output - %s\\n\", out_name,\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  bytes_read = read(in_fd, buffer, 131072);\n  while (bytes_read > 0) {\n    total_written = 0;\n    while (total_written < bytes_read) {\n      bytes_written =\n          write(out_fd, buffer + total_written, bytes_read - total_written);\n      if (bytes_written <= 0) {\n        fprintf(LOGFILE, \"Error writing to %s - %s\\n\", out_name,\n                strerror(*__errno_location()));\n        close(out_fd);\n        return -1;\n      }\n      total_written += bytes_written;\n    }\n    bytes_read = read(in_fd, buffer, 131072);\n  }\n\n  if (bytes_read < 0) {\n    fprintf(LOGFILE, \"Failed to read file %s - %s\\n\", in_name,\n            strerror(*__errno_location()));\n    close(out_fd);\n    return -1;\n  }\n\n  if (close(out_fd)) {\n    fprintf(LOGFILE, \"Failed to close file %s - %s\\n\", out_name,\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  close(in_fd);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int initialize_user(const char *user, const char *good_local_dirs) {\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    if (local_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could ot be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    char *user_dir;\n    char **local_dir_ptr = local_dir;\n    int failed = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != 0; ++local_dir_ptr) {\n        user_dir = get_user_directory(*local_dir_ptr, user);\n        if (user_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Couldn't get userdir directory for %s.\\n\", user);\n            failed = 1;\n            break;\n        }\n        if (create_directory_for_user(user_dir) != 0) {\n            failed = 1;\n        }\n        free(user_dir);\n    }\n    free_values(local_dir);\n    return failed ? INITIALIZE_USER_FAILED : 0;\n}\n","function_prediction":"int initialize_user_name_conflict(char *user, char *mapred_local_dirs) {\n  char **mapred_local_dirs_array = get_mapred_local_dirs(mapred_local_dirs);\n  if (mapred_local_dirs_array == NULL) {\n    fprintf(LOGFILE, \"Good mapred local directories could ot be obtained.\\n\");\n    return 5;\n  }\n\n  int error = 0;\n  char *userdir;\n  for (int i = 0; mapred_local_dirs_array[i] != NULL; i++) {\n    userdir = get_user_directory(mapred_local_dirs_array[i], user);\n    if (userdir == NULL) {\n      fprintf(LOGFILE, \"Couldn't get userdir directory for %s.\\n\", user);\n      error = 1;\n      break;\n    }\n    if (!create_directory_for_user(userdir)) {\n      error = 1;\n    }\n    free(userdir);\n  }\n  free_values(mapred_local_dirs_array);\n  if (error) {\n    return 20;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int initialize_job(const char *user, const char *good_local_dirs, const char *jobid, const char *credentials, const char *job_xml, char *const *args) {\n    if (jobid == ((void *)0) || user == ((void *)0)) {\n        fprintf(LOGFILE, \"Either jobid is null or the user passed is null.\\n\");\n        return INVALID_ARGUMENT_NUMBER;\n    }\n    int result = initialize_user(user, good_local_dirs);\n    if (result != 0) {\n        return result;\n    }\n    char *job_log_dir = get_job_log_directory(jobid);\n    if (job_log_dir == ((void *)0)) {\n        return -1;\n    }\n    result = create_directory_for_user(job_log_dir);\n    free(job_log_dir);\n    if (result != 0) {\n        return -1;\n    }\n    int cred_file = open_file_as_task_tracker(credentials);\n    if (cred_file == -1) {\n        return -1;\n    }\n    int job_file = open_file_as_task_tracker(job_xml);\n    if (job_file == -1) {\n        return -1;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return -1;\n    }\n    mode_t permissions = (256 | 128 | 64) | (256 >> 3) | (64 >> 3);\n    char **tt_roots = get_mapred_local_dirs(good_local_dirs);\n    if (tt_roots == ((void *)0)) {\n        return INVALID_TT_ROOT;\n    }\n    char **tt_root;\n    char *primary_job_dir = ((void *)0);\n    for (tt_root = tt_roots; *tt_root != ((void *)0); ++tt_root) {\n        char *job_dir = get_job_directory(*tt_root, user, jobid);\n        if (job_dir == ((void *)0)) {\n        } else if (mkdirs(job_dir, permissions) != 0) {\n            free(job_dir);\n        } else if (primary_job_dir == ((void *)0)) {\n            primary_job_dir = job_dir;\n        } else {\n            free(job_dir);\n        }\n    }\n    free_values(tt_roots);\n    if (primary_job_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Did not create any job directories\\n\");\n        return -1;\n    }\n    char *cred_file_name = concatenate(\"%s/%s\", \"cred file\", 2, primary_job_dir, \"jobToken\");\n    if (cred_file_name == ((void *)0)) {\n        return -1;\n    }\n    if (copy_file(cred_file, credentials, cred_file_name, 256 | 128) != 0) {\n        return -1;\n    }\n    char *job_file_name = concatenate(\"%s/%s\", \"job file\", 2, primary_job_dir, \"job.xml\");\n    if (job_file_name == ((void *)0)) {\n        return -1;\n    }\n    if (copy_file(job_file, job_xml, job_file_name, 256 | 128 | (256 >> 3)) != 0) {\n        return -1;\n    }\n    fclose(stdin);\n    fflush(LOGFILE);\n    if (LOGFILE != stdout) {\n        fclose(stdout);\n    }\n    fclose(stderr);\n    chdir(primary_job_dir);\n    execvp(args[0], args);\n    fprintf(LOGFILE, \"Failure to exec job initialization process - %s\\n\", strerror((*__errno_location())));\n    return -1;\n}\n","function_prediction":"int initialize_job(char *jobid, char *user, char *job_dir, char *cred_file,\n                   char *job_file, char **argv) {\n  int ret = 0;\n  char *job_log_dir = NULL;\n  char *job_dir_path = NULL;\n  char *cred_file_path = NULL;\n  char *job_file_path = NULL;\n  char *job_dir_path_to_free = NULL;\n  char **mapred_local_dirs = NULL;\n  char **mapred_local_dirs_ptr = NULL;\n  int task_tracker_fd = 0;\n  int job_tracker_fd = 0;\n\n  if (jobid == NULL || user == NULL) {\n    fprintf(LOGFILE, \"Either jobid is null or the user passed is null.\\n\");\n    return 1;\n  }\n\n  ret = initialize_user(jobid, user);\n  if (ret != 0) {\n    return ret;\n  }\n\n  job_log_dir = get_job_log_directory(job_dir);\n  if (job_log_dir == NULL) {\n    return -1;\n  }\n\n  ret = create_directory_for_user(job_log_dir);\n  free(job_log_dir);\n  if (ret != 0) {\n    return -1;\n  }\n\n  task_tracker_fd = open_file_as_task_tracker(cred_file);\n  if (task_tracker_fd == -1) {\n    return -1;\n  }\n\n  job_tracker_fd = open_file_as_task_tracker(job_file);\n  if (job_tracker_fd == -1) {\n    return -1;\n  }\n\n  ret = change_user(user_detail->user, user_detail->group);\n  if (ret != 0) {\n    return -1;\n  }\n\n  mapred_local_dirs = get_mapred_local_dirs(user);","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int run_task_as_user(const char *user, const char *good_local_dirs, const char *job_id, const char *task_id, const char *work_dir, const char *script_name) {\n    int exit_code = -1;\n    char *task_script_path = ((void *)0);\n    if (create_attempt_directories(user, good_local_dirs, job_id, task_id) != 0) {\n        goto cleanup;\n    }\n    int task_file_source = open_file_as_task_tracker(script_name);\n    if (task_file_source == -1) {\n        goto cleanup;\n    }\n    task_script_path = get_task_launcher_file(work_dir);\n    if (task_script_path == ((void *)0)) {\n        exit_code = OUT_OF_MEMORY;\n        goto cleanup;\n    }\n    if (copy_file(task_file_source, script_name, task_script_path, (256 | 128 | 64)) != 0) {\n        goto cleanup;\n    }\n    fcloseall();\n    umask(23);\n    if (chdir(work_dir) != 0) {\n        fprintf(LOGFILE, \"Can't change directory to %s -%s\\n\", work_dir, strerror((*__errno_location())));\n        goto cleanup;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        exit_code = SETUID_OPER_FAILED;\n        goto cleanup;\n    }\n    if (execlp(task_script_path, task_script_path, ((void *)0)) != 0) {\n        fprintf(LOGFILE, \"Couldn't execute the task jvm file %s - %s\", task_script_path, strerror((*__errno_location())));\n        exit_code = UNABLE_TO_EXECUTE_TASK_SCRIPT;\n        goto cleanup;\n    }\n    exit_code = 0;\n  cleanup:\n    free(task_script_path);\n    return exit_code;\n}\n","function_prediction":"int run_task_as_user(char *task_name, char *task_id, char *task_type,\n                     char *task_version, char *task_dir, char *task_file) {\n  int ret = -1;\n  char *task_jvm_file = NULL;\n  int task_file_fd = -1;\n\n  ret = create_attempt_directories(task_name, task_id, task_type, task_version);\n  if (ret != 0)\n    goto cleanup;\n\n  task_file_fd = open_file_as_task_tracker(task_file);\n  if (task_file_fd == -1)\n    goto cleanup;\n\n  task_jvm_file = get_task_launcher_file(task_dir);\n  if (task_jvm_file == NULL) {\n    ret = 18;\n    goto cleanup;\n  }\n\n  ret = copy_file(task_file_fd, task_file, task_jvm_file, 448);\n  if (ret != 0)\n    goto cleanup;\n\n  fcloseall();\n\n  umask(027);\n\n  ret = chdir(task_dir);\n  if (ret != 0) {\n    fprintf(LOGFILE, \"Can't change directory to %s -%s\\n\", task_dir,\n            strerror(*__errno_location()));\n    goto cleanup;\n  }\n\n  ret = change_user(user_detail.user_name, user_detail.group_name);\n  if (ret != 0) {\n    ret = 6;\n    goto cleanup;\n  }\n\n  ret = execlp(task_jvm_file, task_jvm_file, NULL);\n  if (ret != 0) {\n    fprintf(LOGFILE, \"Couldn't execute the task jvm file %s - %s\",\n            task_jvm_file, strerror(*__errno_location()));\n    ret = 7;\n    goto cleanup;\n  }\n\n  ret = 0;\n\ncleanup:\n  free(task_jvm_file);\n  return","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int signal_user_task(const char *user, int pid, int sig) {\n    if (pid <= 0) {\n        return INVALID_TASK_PID;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return SETUID_OPER_FAILED;\n    }\n    int has_group = 1;\n    if (kill(-pid, 0) < 0) {\n        if (kill(pid, 0) < 0) {\n            if ((*__errno_location()) == 3) {\n                return INVALID_TASK_PID;\n            }\n            fprintf(LOGFILE, \"Error signalling task %d with %d - %s\\n\", pid, sig, strerror((*__errno_location())));\n            return -1;\n        } else {\n            has_group = 0;\n        }\n    }\n    if (kill((has_group ? -1 : 1) * pid, sig) < 0) {\n        if ((*__errno_location()) != 3) {\n            fprintf(LOGFILE, \"Error signalling process group %d with signal %d - %s\\n\", -pid, sig, strerror((*__errno_location())));\n            return UNABLE_TO_KILL_TASK;\n        } else {\n            return INVALID_TASK_PID;\n        }\n    }\n    fprintf(LOGFILE, \"Killing process %s%d with %d\\n\", (has_group ? \"group \" : \"\"), pid, sig);\n    return 0;\n}\n","function_prediction":"int signal_user_task_name_conflict(char *user, int pid, int signal) {\n  int group;\n\n  if (pid <= 0)\n    return 9;\n\n  if (change_user(user_detail[2], user_detail[3]))\n    return 6;\n\n  if (kill(-pid, 0) < 0)\n    group = 0;\n  else if (kill(pid, 0) < 0)\n    group = 1;\n  else\n    return 9;\n\n  if (kill(group * pid, signal) < 0) {\n    if (*__errno_location() == 3)\n      return 9;\n    fprintf(LOGFILE, \"Error signalling process group %d with signal %d - %s\\n\",\n            -pid, signal, strerror(*__errno_location()));\n    return 8;\n  }\n\n  fprintf(LOGFILE, \"Killing process %s%d with %d\\n\", group ? \"group \" : \"\", pid,\n          signal);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int rmdir_as_tasktracker(const char *path) {\n    int user_uid = geteuid();\n    int user_gid = getegid();\n    int ret = change_effective_user(tt_uid, tt_gid);\n    if (ret == 0) {\n        if (rmdir(path) != 0) {\n            fprintf(LOGFILE, \"rmdir of %s failed - %s\\n\", path, strerror((*__errno_location())));\n            ret = -1;\n        }\n    }\n    if (change_effective_user(user_uid, user_gid) != 0) {\n        ret = -1;\n    }\n    return ret;\n}\n","function_prediction":"int rmdir_as_tasktracker_name_conflict(char *dir) {\n  int ret = 0;\n  int old_euid = geteuid();\n  int old_egid = getegid();\n\n  ret = change_effective_user(tt_uid, tt_gid);\n  if (ret)\n    return ret;\n\n  ret = rmdir(dir);\n  if (ret) {\n    fprintf(LOGFILE, \"rmdir of %s failed - %s\\n\", dir,\n            strerror(*__errno_location()));\n    ret = -1;\n  }\n\n  ret = change_effective_user(old_euid, old_egid);\n  if (ret)\n    return -1;\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int delete_path(const char *full_path, int needs_tt_user) {\n    int exit_code = 0;\n    if (full_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Path is null\\n\");\n        exit_code = UNABLE_TO_BUILD_PATH;\n    } else {\n        char *(paths[]) = {strdup(full_path), 0};\n        if (paths[0] == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc failed in delete_path\\n\");\n            return -1;\n        }\n        if (access(full_path, 0) != 0) {\n            if ((*__errno_location()) == 2) {\n                free(paths[0]);\n                return 0;\n            }\n        }\n        FTS *tree = fts_open(paths, 16 | 64, ((void *)0));\n        FTSENT *entry = ((void *)0);\n        int ret = 0;\n        if (tree == ((void *)0)) {\n            fprintf(LOGFILE, \"Cannot open file traversal structure for the path %s:%s.\\n\", full_path, strerror((*__errno_location())));\n            free(paths[0]);\n            return -1;\n        }\n        while (((entry = fts_read(tree)) != ((void *)0)) && exit_code == 0)\n            {\n                switch (entry->fts_info) {\n                  case 6:\n                    if (!needs_tt_user || strcmp(entry->fts_path, full_path) != 0) {\n                        if (rmdir(entry->fts_accpath) != 0) {\n                            fprintf(LOGFILE, \"Couldn't delete directory %s - %s\\n\", entry->fts_path, strerror((*__errno_location())));\n                            exit_code = -1;\n                        }\n                    }\n                    break;\n                  case 8:\n                  case 12:\n                  case 13:\n                  case 3:\n                    if (unlink(entry->fts_accpath) != 0) {\n                        fprintf(LOGFILE, \"Couldn't delete file %s - %s\\n\", entry->fts_path, strerror((*__errno_location())));\n                        exit_code = -1;\n                    }\n                    break;\n                  case 4:\n                    fprintf(LOGFILE, \"Unreadable directory %s. Skipping..\\n\", entry->fts_path);\n                    break;\n                  case 1:\n                    if ((entry->fts_statp->st_mode & 128) == 0) {\n                        fprintf(LOGFILE, \"Unreadable directory %s, chmoding.\\n\", entry->fts_path);\n                        if (chmod(entry->fts_accpath, 448) != 0) {\n                            fprintf(LOGFILE, \"Error chmoding %s - %s, continuing\\n\", entry->fts_path, strerror((*__errno_location())));\n                        }\n                    }\n                    break;\n                  case 10:\n                    fprintf(LOGFILE, \"Directory not found %s\\n\", entry->fts_path);\n                    break;\n                  case 2:\n                  case 5:\n                  case 11:\n                    break;\n                  case 7:\n                    fprintf(LOGFILE, \"Error traversing directory %s - %s\\n\", entry->fts_path, strerror(entry->fts_errno));\n                    exit_code = -1;\n                    break;\n                    break;\n                  default:\n                    exit_code = -1;\n                    break;\n                }\n            }\n        ret = fts_close(tree);\n        if (exit_code == 0 && ret != 0) {\n            fprintf(LOGFILE, \"Error in fts_close while deleting %s\\n\", full_path);\n            exit_code = -1;\n        }\n        if (needs_tt_user) {\n            exit_code = rmdir_as_tasktracker(full_path);\n        }\n        free(paths[0]);\n    }\n    return exit_code;\n}\n","function_prediction":"int delete_path_name_conflict(char *path, int is_tasktracker) {\n  int ret = 0;\n  FTS *fts;\n  FTSENT *curr;\n  char *paths[2];\n\n  if (path == NULL) {\n    fprintf(LOGFILE, \"Path is null\\n\");\n    return 21;\n  }\n\n  paths[0] = strdup(path);\n  paths[1] = NULL;\n\n  if (paths[0] == NULL) {\n    fprintf(LOGFILE, \"Malloc failed in delete_path_name_conflict\\n\");\n    return -1;\n  }\n\n  if (access(path, 0) != 0 && *(__errno_location()) == 2) {\n    free(paths[0]);\n    return 0;\n  }\n\n  fts = fts_open(paths, 0x00000050, NULL);\n  curr = NULL;\n\n  if (fts == NULL) {\n    fprintf(LOGFILE,\n            \"Cannot open file traversal structure for the path %s:%s.\\n\", path,\n            strerror(*__errno_location()));\n    free(paths[0]);\n    return -1;\n  }\n\n  while ((curr = fts_read(fts)) != NULL && ret == 0) {\n    switch (curr->fts_info) {\n    case FTS_D:\n      if (((curr->fts_number) & (1 << 7)) == 0) {\n        fprintf(LOGFILE, \"Unreadable directory %s, chmoding.\\n\",\n                curr->fts_path);\n        if (chmod(curr->fts_accpath, 0700) != 0) {\n          fprintf(LOGFILE, \"Error chmoding %s - %s, continuing\\n\",\n                  curr->fts_path, strerror(*__errno_location()));\n        }\n      }\n      break;\n    case FTS_DP:\n      if (is_tasktracker && strcmp(curr->fts_path, path) == 0) {\n        break;\n      }\n   if (rmdir(curr->ft","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int delete_as_user(const char *user, const char *good_local_dirs, const char *subdir) {\n    int ret = 0;\n    char **tt_roots = get_mapred_local_dirs(good_local_dirs);\n    char **ptr;\n    if (tt_roots == ((void *)0) || *tt_roots == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could ot be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    for (ptr = tt_roots; *ptr != ((void *)0); ++ptr) {\n        char *full_path = get_user_subdirectory(*ptr, user, subdir);\n        if (full_path == ((void *)0)) {\n            return -1;\n        }\n        int this_ret = delete_path(full_path, strlen(subdir) == 0);\n        free(full_path);\n        if (this_ret != 0) {\n            ret = this_ret;\n        }\n    }\n    free_values(tt_roots);\n    return ret;\n}\n","function_prediction":"int delete_as_user_name_conflict(char *user, char *mapred_local_dir, char *mapred_job_id) {\n  int ret = 0;\n  char *path;\n  char **mapred_local_dirs;\n  char **p;\n\n  mapred_local_dirs = get_mapred_local_dirs(mapred_local_dir);\n  if (mapred_local_dirs == NULL || mapred_local_dirs[0] == NULL) {\n    fwrite(\"Good mapred local directories could ot be obtained.\\n\", 1, 52,\n           LOGFILE);\n    return 5;\n  }\n\n  for (p = mapred_local_dirs; *p != NULL; p++) {\n    path = get_user_subdirectory(*p, user, mapred_job_id);\n    if (path == NULL) {\n      return -1;\n    }\n    ret = delete_path(path, mapred_job_id[0] == '\\0');\n    free(path);\n    if (ret != 0) {\n      break;\n    }\n  }\n\n  free_values(mapred_local_dirs);\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int delete_log_directory(const char *subdir, const char *good_local_dirs) {\n    char *job_log_dir = get_job_log_directory(subdir);\n    int ret = -1;\n    if (job_log_dir == ((void *)0))\n        return ret;\n    delete_path(job_log_dir, 1);\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    char **local_dir_ptr;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        char *mapred_local_log_dir = concatenate(\"%s/userlogs/%s\", \"mapred local job log dir\", 2, *local_dir_ptr, subdir);\n        if (mapred_local_log_dir != ((void *)0)) {\n            delete_path(mapred_local_log_dir, 1);\n            free(mapred_local_log_dir);\n        } else\n            fprintf(LOGFILE, \"Failed to delete mapred local log dir for jobid %s\\n\", subdir);\n    }\n    free(job_log_dir);\n    free_values(local_dir);\n    return 0;\n}\n","function_prediction":"int delete_log_directory_name_conflict(char *jobid, char *user) {\n  char *job_log_dir = get_job_log_directory(jobid);\n  if (job_log_dir == NULL)\n    return -1;\n  delete_path(job_log_dir, 1);\n\n  char **mapred_local_dirs = get_mapred_local_dirs(user);\n  char **mapred_local_dirs_ptr = mapred_local_dirs;\n  while (*mapred_local_dirs_ptr) {\n    char *mapred_local_dir =\n        concatenate(\"%s/userlogs/%s\", \"mapred local job log dir\", 2,\n                    *mapred_local_dirs_ptr, jobid);\n    if (mapred_local_dir) {\n      delete_path(mapred_local_dir, 1);\n      free(mapred_local_dir);\n    } else {\n      fprintf(LOGFILE, \"Failed to delete mapred local log dir for jobid %s\\n\",\n              jobid);\n    }\n    mapred_local_dirs_ptr++;\n  }\n  free(job_log_dir);\n  free_values(mapred_local_dirs);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int run_command_as_user(const char *user, char *const *args) {\n    if (user == ((void *)0)) {\n        fprintf(LOGFILE, \"The user passed is null.\\n\");\n        return INVALID_ARGUMENT_NUMBER;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return -1;\n    }\n    execvp(args[0], args);\n    fprintf(LOGFILE, \"Failure to exec command - %s\\n\", strerror((*__errno_location())));\n    return -1;\n}\n","function_prediction":"int run_command_as_user_name_conflict(user_t *user, char **argv) {\n  if (user == NULL) {\n    fprintf(LOGFILE, \"The user passed is null.\\n\");\n    return 1;\n  }\n\n  if (!change_user(user_detail->user_name, user_detail->user_group)) {\n    execvp(argv[0], argv);\n    fprintf(LOGFILE, \"Failure to exec command - %s\\n\",\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int is_only_root_writable(const char *file) {\n    struct stat file_stat;\n    if (stat(file, &file_stat) != 0) {\n        fprintf(LOGFILE, \"Can't stat file %s - %s\\n\", file, strerror((*__errno_location())));\n        return 0;\n    }\n    if (file_stat.st_uid != 0) {\n        fprintf(LOGFILE, \"File %s must be owned by root, but is owned by %d\\n\", file, file_stat.st_uid);\n        return 0;\n    }\n    if ((file_stat.st_mode & ((128 >> 3) | ((128 >> 3) >> 3))) != 0) {\n        fprintf(LOGFILE, \"File %s must not be world or group writable, but is %03o\\n\", file, file_stat.st_mode & (~61440));\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"int is_only_root_writable_name_conflict(char *filename) {\n  struct stat statbuf;\n\n  if (!stat(filename, &statbuf)) {\n    if (statbuf.st_uid != 0) {\n      fprintf(LOGFILE, \"File %s must be owned by root, but is owned by %d\\n\",\n              filename, statbuf.st_uid);\n      return 0;\n    }\n    if (statbuf.st_mode & 0002 || statbuf.st_mode & 0020) {\n      fprintf(LOGFILE,\n              \"File %s must not be world or group writable, but is %03o\\n\",\n              filename, statbuf.st_mode & ~0007);\n      return 0;\n    }\n    return 1;\n  } else {\n    fprintf(LOGFILE, \"Can't stat file %s - %s\\n\", filename,\n            strerror(*__errno_location()));\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"int check_configuration_permissions(const char *file_name) {\n    char *dir = strdup(file_name);\n    char *buffer = dir;\n    do {\n        if (!is_only_root_writable(dir)) {\n            free(buffer);\n            return -1;\n        }\n        dir = dirname(dir);\n    } while (strcmp(dir, \"/\") != 0);\n    free(buffer);\n    return 0;\n}\n","function_prediction":"int check_configuration_permissions_name_conflict(const char *path) {\n  char *path_copy = strdup(path);\n  char *dir = path_copy;\n\n  while (is_only_root_writable(dir) && strcmp(dir = dirname(dir), \"/\"))\n    ;\n\n  free(path_copy);\n\n  return !is_only_root_writable(dir) ? -1 : 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char *get_value(const char *key) {\n    int count;\n    for (count = 0; count < config.size; count++) {\n        if (strcmp(config.confdetails[count]->key, key) == 0) {\n            return strdup(config.confdetails[count]->value);\n        }\n    }\n    return ((void *)0);\n}\n","function_prediction":"char *get_values(char *key) {\n  int i;\n  char *value;\n\n  for (i = 0; i < config.size; i++) {\n    if (!strcmp(config.data[i][0], key)) {\n      value = strdup(config.data[i][1]);\n      break;\n    }\n  }\n\n  if (i >= config.size)\n    return NULL;\n\n  return extract_values(value);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char **get_values(const char *key) {\n    char *value = get_value(key);\n    return extract_values(value);\n}\n","function_prediction":"struct values get_values_name_conflict(char *line) {\n  char *value = get_value(line);\n  return extract_values(value);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char **extract_values(char *value) {\n    char **toPass = ((void *)0);\n    char *tempTok = ((void *)0);\n    char *tempstr = ((void *)0);\n    int size = 0;\n    int toPassSize = 10;\n    if (value != ((void *)0)) {\n        toPass = (char **)malloc(sizeof(char *) * toPassSize);\n        tempTok = strtok_r((char *)value, \",\", &tempstr);\n        while (tempTok != ((void *)0))\n            {\n                toPass[size++] = tempTok;\n                if (size == toPassSize) {\n                    toPassSize += 10;\n                    toPass = (char **)realloc(toPass, (sizeof(char *) * (10 * toPassSize)));\n                }\n                tempTok = strtok_r(((void *)0), \",\", &tempstr);\n            }\n    }\n    if (size > 0) {\n        toPass[size] = ((void *)0);\n    }\n    return toPass;\n}\n","function_prediction":"char **extract_values_name_conflict(char *str) {\n  char **values = NULL;\n  char *token = NULL;\n  char *saveptr = NULL;\n  int count = 0;\n  int size = 10;\n\n  if (str == NULL)\n    return NULL;\n\n  values = (char **)malloc(size * sizeof(char *));\n  token = strtok_r(str, \",\", &saveptr);\n  while (token != NULL) {\n    values[count++] = token;\n    if (count == size) {\n      size += 10;\n      values = (char **)realloc(values, size * sizeof(char *));\n    }\n    token = strtok_r(NULL, \",\", &saveptr);\n  }\n\n  if (count > 0)\n    values[count] = NULL;\n\n  return values;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"int write_config_file(char *file_name) {\n    FILE *file;\n    file = fopen(file_name, \"w\");\n    if (file == ((void *)0)) {\n        printf(\"Failed to open %s.\\n\", file_name);\n        return 1;\n    }\n    fprintf(file, \"mapred.local.dir=/tmp/test-task-controller/local-1\");\n    int i;\n    for (i = 2; i < 5; ++i) {\n        fprintf(file, \",/tmp/test-task-controller/local-%d\", i);\n    }\n    fprintf(file, \"\\n\");\n    fprintf(file, \"hadoop.log.dir=/tmp/test-task-controller/logs\\n\");\n    fclose(file);\n    return 0;\n}\n","function_prediction":"int write_config_file_name_conflict(const char *filename) {\n  FILE *fp = fopen(filename, \"w\");\n  if (fp == NULL) {\n    printf(\"Failed to open %s.\\n\", filename);\n    return 1;\n  }\n\n  fprintf(fp, \"mapred.local.dir=/tmp/test-task-controller/local-1\");\n  for (int i = 2; i <= 4; i++) {\n    fprintf(fp, \",/tmp/test-task-controller/local-%d\", i);\n  }\n  fprintf(fp, \"\\n\");\n\n  fprintf(fp, \"hadoop.log.dir=/tmp/test-task-controller/logs\\n\");\n\n  fclose(fp);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/test/test-task-controller.c"}
{"compilable":0,"function":"int edgecmp(Fibnode *a, Fibnode *b) {\n    Edge *e, *f;\n    e = (Edge *)a;\n    f = (Edge *)b;\n    if (e->dist < f->dist)\n        return -1;\n    if (e->dist > f->dist)\n        return 1;\n    return 0;\n}\n","function_prediction":"int edgecmp_name_conflict(const void *a, const void *b) {\n  const struct edge *ea = a;\n  const struct edge *eb = b;\n\n  if (ea->weight < eb->weight)\n    return -1;\n  else if (ea->weight > eb->weight)\n    return 1;\n  else\n    return 0;\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/prim.c"}
{"compilable":0,"function":"int prim(int start) {\n    Fibheap pq;\n    Node *n;\n    Edge *e;\n    int primsum;\n    fibinit(&pq, edgecmp);\n    n = nodedata(start);\n    n->intree = 1;\n    primsum = 0;\n    insertedges(&pq, n);\n    while (pq.min != ((void *)0))\n        {\n            e = (Edge *)pq.min;\n            if (fibdeletemin(&pq) < 0)\n                sysfatal(\"deletion failed\");\n            n = e->node;\n            if (n->intree)\n                continue;\n            n->intree = 1;\n            primsum += e->dist;\n            insertedges(&pq, n);\n        }\n    fibfree(&pq);\n    return primsum;\n}\n","function_prediction":"int prim_name_conflict(int start) {\n  struct fibheap fh;\n  struct node *n, *m;\n  int cost;\n\n  fibinit(&fh, edgecmp);\n  n = nodedata(start);\n  n->mark = 1;\n  cost = 0;\n  insertedges(&fh, n);\n  while (fh.min) {\n    m = fh.min;\n    if (fibdeletemin(&fh) < 0)\n      sysfatal(\"deletion failed\");\n    n = m->to;\n    if (!n->mark) {\n      n->mark = 1;\n      cost += m->cost;\n      insertedges(&fh, n);\n    }\n  }\n  fibfree(&fh);\n  return cost;\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/prim.c"}
{"compilable":1,"function":"int intcmp(Fibnode *x, Fibnode *y) {\n    Int *s, *t;\n    s = (Int *)x;\n    t = (Int *)y;\n    if (s->i < t->i)\n        return -1;\n    if (s->i > t->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"int intcmp_name_conflict(const void *a, const void *b) {\n  const int *ia = (const int *)a;\n  const int *ib = (const int *)b;\n  return (ia[10] < ib[10]) ? -1 : (ia[10] > ib[10]) ? 1 : 0;\n}","pass":1,"source_file":"C_COMPILE/spewspews_bsp/tests/fibheaptest.c"}
{"compilable":0,"function":"int nodecmp(Fibnode *a, Fibnode *b) {\n    Node *m, *n;\n    m = (Node *)a;\n    n = (Node *)b;\n    if (m->dist < n->dist)\n        return -1;\n    if (m->dist > n->dist)\n        return 1;\n    return 0;\n}\n","function_prediction":"int nodecmp_name_conflict(const void *a, const void *b) {\n  const struct node *na = a;\n  const struct node *nb = b;\n\n  if (na->weight < nb->weight)\n    return -1;\n  else if (na->weight > nb->weight)\n    return 1;\n  else\n    return 0;\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/dijkstra.c"}
{"compilable":1,"function":"int Intcmp(Avl *a, Avl *b) {\n    Int *ai, *bi;\n    ai = (Int *)a;\n    bi = (Int *)b;\n    if (ai->i < bi->i)\n        return -1;\n    if (ai->i > bi->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"int Intcmp_name_conflict(const void *a, const void *b) {\n  const int *ia = (const int *)a;\n  const int *ib = (const int *)b;\n  return (ia[4] < ib[4]) ? -1 : (ia[4] > ib[4]) ? 1 : 0;\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/avltest.c"}
{"compilable":0,"function":"int depth(Avl *n) {\n    int dl, dr, d;\n    if (n == ((void *)0))\n        return 0;\n    dl = depth(n->c[0]);\n    dr = depth(n->c[1]);\n    d = dl > dr ? dl : dr;\n    return d + 1;\n}\n","function_prediction":"int depth_name_conflict(struct node *root) {\n  if (root == NULL)\n    return 0;\n  else {\n    int ldepth_name_conflict = depth_name_conflict(root->left);\n    int rdepth_name_conflict = depth_name_conflict(root->right);\n\n    if (ldepth_name_conflict > rdepth_name_conflict)\n      return (ldepth_name_conflict + 1);\n    else\n      return (rdepth_name_conflict + 1);\n  }\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/avltest.c"}
{"compilable":0,"function":"int nodecmp(Avl *a, Avl *b) {\n    Node *m, *n;\n    m = (Node *)a;\n    n = (Node *)b;\n    return strcmp(m->key, n->key);\n}\n","function_prediction":"int nodecmp_name_conflict(const void *a, const void *b) {\n  return strcmp(((struct node *)a)->name, ((struct node *)b)->name);\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/doc/avlexample.c"}
{"compilable":1,"function":"int intcmp(Fibnode *x, Fibnode *y) {\n    Int *s, *t;\n    s = (Int *)x;\n    t = (Int *)y;\n    if (s->i < t->i)\n        return -1;\n    if (s->i > t->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"int intcmp_name_conflict(const void *a, const void *b) {\n  const int *ia = (const int *)a;\n  const int *ib = (const int *)b;\n  return (ia[10] < ib[10]) ? -1 : (ia[10] > ib[10]) ? 1 : 0;\n}","pass":1,"source_file":"C_COMPILE/spewspews_bsp/doc/fibheaptest.c"}
{"compilable":1,"function":"uint32_t pcg32_random_r(pcg32_random_t *rng) {\n    uint64_t oldstate = rng->state;\n    rng->state = oldstate * 6364136223846793005ULL + rng->inc;\n    uint32_t xorshifted = ((oldstate >> 18U) ^ oldstate) >> 27U;\n    uint32_t rot = oldstate >> 59U;\n    return (xorshifted >> rot) | (xorshifted << ((-rot) & 31));\n}\n","function_prediction":"uint32_t pcg32_random_r_name_conflict(pcg32_random_t *rng) {\n  uint64_t oldstate = rng->state;\n  rng->state = oldstate * 6364136223846793005ULL + rng->inc;\n  uint32_t xorshifted = ((oldstate >> 18u) ^ oldstate) >> 27u;\n  uint32_t rot = oldstate >> 59u;\n  return (xorshifted >> rot) | (xorshifted << ((-rot) & 31));\n}","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":1,"function":"uint32_t pcg32_random() {\n    return pcg32_random_r(&pcg32_global);\n}\n","function_prediction":"uint32_t pcg32_random_name_conflict(void) { return pcg32_random_name_conflict_r(pcg32_global); }","pass":1,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":1,"function":"uint32_t pcg32_boundedrand_r(pcg32_random_t *rng, uint32_t bound) {\n    uint32_t threshold = -bound % bound;\n    for (;;) {\n        uint32_t r = pcg32_random_r(rng);\n        if (r >= threshold)\n            return r % bound;\n    }\n}\n","function_prediction":"uint32_t pcg32_boundedrand_r_name_conflict(pcg32_random_t *rng, uint32_t bound) {\n  uint32_t threshold = -bound % bound;\n\n  for (;;) {\n    uint32_t r = pcg32_random_r(rng);\n    if (r >= threshold)\n      return r % bound;\n  }\n}","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":1,"function":"uint32_t pcg32_boundedrand(uint32_t bound) {\n    return pcg32_boundedrand_r(&pcg32_global, bound);\n}\n","function_prediction":"uint32_t pcg32_boundedrand_name_conflict(uint32_t bound) {\n  return pcg32_boundedrand_name_conflict_r(pcg32_global, bound);\n}","pass":1,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"const char *get_key_name_name_conflict(int key) {\n  if (key == 0x1b)\n    return \"Escape\";\n\n  switch (key) {\n  case 0x561f0000:\n    return \"Tab\";\n  case 0x561f0001:\n    return \"unknown\";\n  case 0x561f0002:\n    return \"F1\";\n  case 0x561f0003:\n    return \"F2\";\n  case 0x561f0004:\n    return \"F3\";\n  case 0x561f0005:\n    return \"F4\";\n  case 0x561f0006:\n    return \"F5\";\n  case 0x561f0007:\n    return \"F6\";\n  case 0x561f0008:\n    return \"F7\";\n  case 0x561f0009:\n    return \"F8\";\n  case 0x561f000a:\n    return \"F9\";\n  case 0x561f000b:\n    return \"F10\";\n  case 0x561f000c:\n    return \"F11\";\n  case 0x561f000d:\n    return \"F12\";\n  case 0x561f0026:\n    return \"Up\";\n  case 0x561f0027:\n    return \"Down\";\n  case 0x561f0028:\n    return \"Right\";\n  case 0x561f0029:\n    return \"Left\";\n  case 0x561f002a:\n    return \"CtrlUp\";\n  case 0x561f002b:\n    return \"CtrlDown\";\n  case 0x561f002c:\n    return \"CtrlRight\";\n  case 0x561f002d:\n    return \"CtrlLeft\";\n  case 0x561f002e:\n    return \"Enter\";\n  case 0x561f002f:\n    return","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"int decode_regular_key_pressed_name_conflict(void) {\n  int c = getc(stdin);\n  if ((c & 0xf8) == 0xf0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int c3 = getc(stdin);\n    c = (((c & 0x0f) << 16) + ((c1 & 0x7f) << 12) + ((c2 & 0x7f) << 6) +\n         (c3 & 0x7f));\n    if (c < 0x10000)\n      return -1;\n  } else if ((c & 0xf0) == 0xe0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    c = (((c & 0x1f) << 12) + ((c1 & 0x7f) << 6) + (c2 & 0x7f));\n    if (c < 0x800)\n      return -1;\n  } else if ((c & 0xe0) == 0xc0) {\n    int c1 = getc(stdin);\n    c = (((c & 0x3f) << 6) + (c1 & 0x7f));\n    if (c < 0x80)\n      return -1;\n  } else if (c & 0x80) {\n    return -1;\n  }\n  return c & 0xff;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"int decode_key_pressed_name_conflict() {\n  int c;\n\n  c = getc(stdin);\n  if (c == '\\n')\n    return 1000000000 + 46;\n  if (c == '\\t')\n    return 1000000000 + 0;\n  if (c == 127)\n    return 1000000000 + 48;\n  if (c == 8)\n    return 1000000000 + 49;\n  if (c == -1 || c == -1)\n    return 4;\n  if (c == 23)\n    return 1000000000 + 50;\n  if (c == 0)\n    return 1000000000 + 51;\n  if (c == 27) {\n    int c2;\n\n    c2 = getc(stdin);\n    if (c2 == 79) {\n      int c3;\n\n      c3 = getc(stdin);\n      if (c3 >= 80 && c3 <= 83)\n        return 1000000000 + 42 + c3;\n      else\n        return -1;\n    } else if (c2 == 91) {\n      int c3;\n\n      c3 = getc(stdin);\n      switch (c3) {\n      case 97:\n        return 1000000000 + 38;\n      case 98:\n        return 1000000000 + 39;\n      case 99:\n        return 1000000000 + 40;\n      case 100:\n        return 1000000000 + 41;\n      case 102:\n        return 1000000000 + 47;\n      case 104:\n        return 1000000000 + 53;\n      case","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"int is_special_name_conflict(int c) {\n  return (c < 32 || c == 0x7f || c == 0x09 || c == 0x0a || c == 0x0d ||\n          c == 0x20 || c == 0x56 || c == 0x57 || c == 0x58 || c == 0x59 ||\n          c == 0x5a || c == 0x5b || c == 0x5c || c == 0x5d || c == 0x5e ||\n          c == 0x5f || c == 0x60 || c == 0x7b || c == 0x7c || c == 0x7d ||\n          c == 0x7e);\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"const char *get_key_name_name_conflict(int key) {\n  if (key == 0x1b)\n    return \"Escape\";\n\n  switch (key) {\n  case 0x561f0000:\n    return \"Tab\";\n  case 0x561f0001:\n    return \"unknown\";\n  case 0x561f0002:\n    return \"F1\";\n  case 0x561f0003:\n    return \"F2\";\n  case 0x561f0004:\n    return \"F3\";\n  case 0x561f0005:\n    return \"F4\";\n  case 0x561f0006:\n    return \"F5\";\n  case 0x561f0007:\n    return \"F6\";\n  case 0x561f0008:\n    return \"F7\";\n  case 0x561f0009:\n    return \"F8\";\n  case 0x561f000a:\n    return \"F9\";\n  case 0x561f000b:\n    return \"F10\";\n  case 0x561f000c:\n    return \"F11\";\n  case 0x561f000d:\n    return \"F12\";\n  case 0x561f0026:\n    return \"Up\";\n  case 0x561f0027:\n    return \"Down\";\n  case 0x561f0028:\n    return \"Right\";\n  case 0x561f0029:\n    return \"Left\";\n  case 0x561f002a:\n    return \"CtrlUp\";\n  case 0x561f002b:\n    return \"CtrlDown\";\n  case 0x561f002c:\n    return \"CtrlRight\";\n  case 0x561f002d:\n    return \"CtrlLeft\";\n  case 0x561f002e:\n    return \"Enter\";\n  case 0x561f002f:\n    return","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"int decode_regular_key_pressed_name_conflict(void) {\n  int c = getc(stdin);\n  if ((c & 0xf8) == 0xf0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int c3 = getc(stdin);\n    c = (((c & 0x0f) << 16) + ((c1 & 0x7f) << 12) + ((c2 & 0x7f) << 6) +\n         (c3 & 0x7f));\n    if (c < 0x10000)\n      return -1;\n  } else if ((c & 0xf0) == 0xe0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    c = (((c & 0x1f) << 12) + ((c1 & 0x7f) << 6) + (c2 & 0x7f));\n    if (c < 0x800)\n      return -1;\n  } else if ((c & 0xe0) == 0xc0) {\n    int c1 = getc(stdin);\n    c = (((c & 0x3f) << 6) + (c1 & 0x7f));\n    if (c < 0x80)\n      return -1;\n  } else if (c & 0x80) {\n    return -1;\n  }\n  return c & 0xff;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"int decode_key_pressed_name_conflict() {\n  int c;\n\n  c = getc(stdin);\n  if (c == '\\n')\n    return 1000000000 + 46;\n  if (c == '\\t')\n    return 1000000000 + 0;\n  if (c == 127)\n    return 1000000000 + 48;\n  if (c == 8)\n    return 1000000000 + 49;\n  if (c == -1 || c == -1)\n    return 4;\n  if (c == 23)\n    return 1000000000 + 50;\n  if (c == 0)\n    return 1000000000 + 51;\n  if (c == 27) {\n    int c2;\n\n    c2 = getc(stdin);\n    if (c2 == 79) {\n      int c3;\n\n      c3 = getc(stdin);\n      if (c3 >= 80 && c3 <= 83)\n        return 1000000000 + 42 + c3;\n      else\n        return -1;\n    } else if (c2 == 91) {\n      int c3;\n\n      c3 = getc(stdin);\n      switch (c3) {\n      case 97:\n        return 1000000000 + 38;\n      case 98:\n        return 1000000000 + 39;\n      case 99:\n        return 1000000000 + 40;\n      case 100:\n        return 1000000000 + 41;\n      case 102:\n        return 1000000000 + 47;\n      case 104:\n        return 1000000000 + 53;\n      case","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"int is_special_name_conflict(int c) {\n  return (c < 32 || c == 0x7f || c == 0x09 || c == 0x0a || c == 0x0d ||\n          c == 0x20 || c == 0x56 || c == 0x57 || c == 0x58 || c == 0x59 ||\n          c == 0x5a || c == 0x5b || c == 0x5c || c == 0x5d || c == 0x5e ||\n          c == 0x5f || c == 0x60 || c == 0x7b || c == 0x7c || c == 0x7d ||\n          c == 0x7e);\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"char *search_completion_name_conflict(char *line, int len) {\n  int i, j;\n  int start, end;\n  compute_completion_ranges(line, len, &start, &end);\n  if (start == 0 || len == 0)\n    return NULL;\n  i = (end - start) / sizeof(int);\n  j = (start - (int)&completions[0]) / sizeof(int);\n  if (j / 4096 == current_num_completions - 1)\n    return &line[len];\n  for (i = 0; line[i + len] && line[i + len] == completions[j + i]; i++)\n    line_1[i] = line[i + len];\n  line_1[i] = 0;\n  return line_1;\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"int is_stopkey_name_conflict(int c) { return (c == '.' || c == '/' || c == '[' || c == ' '); }","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"char *getline_complete_name_conflict(char *prompt) {\n  int key, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  int *completion;\n  void (*old_handler)(int);\n\n  memset(line, 0, 4096);\n  gprompt = prompt;\n  old_handler = __sysv_signal(2, sighandler);\n  i = last_history_entry + 1;\n  if (i >= 200)\n    i = 0;\n  line_len = 0;\n  cursorpos = 0;\n  n = 0;\n  echo_disable();\n  printf(\"\\033[4h\");\n  print_prompt(prompt);\n  while (1) {\n    key = decode_key_pressed();\n    if (key == -1) {\n      printf(\"Invalid input sequence!\\n\");\n      break;\n    }\n    if (is_special(key) == 1) {\n      if (key == 0x561f002d && cursorpos != 0) {\n        j = 0;\n        do {\n          cursorpos--;\n          j++;\n        } while (is_stopkey(line[cursorpos]) != 1 && cursorpos != 0);\n        printf(\"\\033[%dD\", j);\n      }\n      if (key == 0x561f002c && cursorpos < line_len) {\n        k = 0;\n        do {\n          cursorpos++;\n          k++;\n        } while (is_stopkey(line[cursorpos]) != 1 && cursorpos < line_len);\n        printf(\"\\033[%dC\", k);\n      }\n      if (key == 0x561f0029 && cursorpos != 0) {\n        printf(\"\\033[%dD\", 1);\n        cursorpos--;\n      }\n      if (key == 0x561f0028 && cursorpos < line_len) {\n                printf(\"\\033[%dC\",","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"int init_completion_name_conflict(char *str) {\n  int i;\n\n  if (current_num_completions == 2048)\n    return 1;\n\n  for (i = 0; str[i] != '\\0'; i++) {\n    if (i >= 2048 - 1) {\n      memset(&completions[current_num_completions * 16384], 0, 16384);\n      return 1;\n    }\n    completions[current_num_completions * 16384 + i] = str[i];\n  }\n  completions[current_num_completions * 16384 + i] = '\\0';\n  current_num_completions++;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"int completion_exists_name_conflict(char *str) {\n  int i;\n  int tmp[4096];\n\n  for (i = 0; str[i] != '\\0' && i < 4096 - 1; i++)\n    tmp[i] = str[i];\n  tmp[i] = 0;\n  memsize = i;\n\n  if (lfind(tmp, completions, &current_num_completions, 4096 * sizeof(int),\n            compl_eqcompar))\n    return 1;\n  else\n    return 0;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"const char *get_key_name_name_conflict(int key) {\n  if (key == 0x1b)\n    return \"Escape\";\n\n  switch (key) {\n  case 0x561f0000:\n    return \"Tab\";\n  case 0x561f0001:\n    return \"unknown\";\n  case 0x561f0002:\n    return \"F1\";\n  case 0x561f0003:\n    return \"F2\";\n  case 0x561f0004:\n    return \"F3\";\n  case 0x561f0005:\n    return \"F4\";\n  case 0x561f0006:\n    return \"F5\";\n  case 0x561f0007:\n    return \"F6\";\n  case 0x561f0008:\n    return \"F7\";\n  case 0x561f0009:\n    return \"F8\";\n  case 0x561f000a:\n    return \"F9\";\n  case 0x561f000b:\n    return \"F10\";\n  case 0x561f000c:\n    return \"F11\";\n  case 0x561f000d:\n    return \"F12\";\n  case 0x561f0026:\n    return \"Up\";\n  case 0x561f0027:\n    return \"Down\";\n  case 0x561f0028:\n    return \"Right\";\n  case 0x561f0029:\n    return \"Left\";\n  case 0x561f002a:\n    return \"CtrlUp\";\n  case 0x561f002b:\n    return \"CtrlDown\";\n  case 0x561f002c:\n    return \"CtrlRight\";\n  case 0x561f002d:\n    return \"CtrlLeft\";\n  case 0x561f002e:\n    return \"Enter\";\n  case 0x561f002f:\n    return","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"int decode_regular_key_pressed_name_conflict(void) {\n  int c = getc(stdin);\n  if ((c & 0xf8) == 0xf0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int c3 = getc(stdin);\n    c = (((c & 0x0f) << 16) + ((c1 & 0x7f) << 12) + ((c2 & 0x7f) << 6) +\n         (c3 & 0x7f));\n    if (c < 0x10000)\n      return -1;\n  } else if ((c & 0xf0) == 0xe0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    c = (((c & 0x1f) << 12) + ((c1 & 0x7f) << 6) + (c2 & 0x7f));\n    if (c < 0x800)\n      return -1;\n  } else if ((c & 0xe0) == 0xc0) {\n    int c1 = getc(stdin);\n    c = (((c & 0x3f) << 6) + (c1 & 0x7f));\n    if (c < 0x80)\n      return -1;\n  } else if (c & 0x80) {\n    return -1;\n  }\n  return c & 0xff;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"int decode_key_pressed_name_conflict() {\n  int c;\n\n  c = getc(stdin);\n  if (c == '\\n')\n    return 1000000000 + 46;\n  if (c == '\\t')\n    return 1000000000 + 0;\n  if (c == 127)\n    return 1000000000 + 48;\n  if (c == 8)\n    return 1000000000 + 49;\n  if (c == -1 || c == -1)\n    return 4;\n  if (c == 23)\n    return 1000000000 + 50;\n  if (c == 0)\n    return 1000000000 + 51;\n  if (c == 27) {\n    int c2;\n\n    c2 = getc(stdin);\n    if (c2 == 79) {\n      int c3;\n\n      c3 = getc(stdin);\n      if (c3 >= 80 && c3 <= 83)\n        return 1000000000 + 42 + c3;\n      else\n        return -1;\n    } else if (c2 == 91) {\n      int c3;\n\n      c3 = getc(stdin);\n      switch (c3) {\n      case 97:\n        return 1000000000 + 38;\n      case 98:\n        return 1000000000 + 39;\n      case 99:\n        return 1000000000 + 40;\n      case 100:\n        return 1000000000 + 41;\n      case 102:\n        return 1000000000 + 47;\n      case 104:\n        return 1000000000 + 53;\n      case","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"int is_special_name_conflict(int c) {\n  return (c < 32 || c == 0x7f || c == 0x09 || c == 0x0a || c == 0x0d ||\n          c == 0x20 || c == 0x56 || c == 0x57 || c == 0x58 || c == 0x59 ||\n          c == 0x5a || c == 0x5b || c == 0x5c || c == 0x5d || c == 0x5e ||\n          c == 0x5f || c == 0x60 || c == 0x7b || c == 0x7c || c == 0x7d ||\n          c == 0x7e);\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"char *search_completion_name_conflict(char *line, int len) {\n  int i, j;\n  int start, end;\n  compute_completion_ranges(line, len, &start, &end);\n  if (start == 0 || len == 0)\n    return NULL;\n  i = (end - start) / sizeof(completion_t);\n  j = (start - (completion_t *)0x1060c0) / sizeof(completion_t);\n  if (j / 4096 == current_num_completions - 1)\n    return line + len;\n  for (i = 0; start[i] && start[i + len] == start[i + len + j]; i++)\n    line_1[i] = start[i + len];\n  line_1[i] = 0;\n  return line_1;\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"int is_stopkey_name_conflict(int c) { return (c == '.' || c == '/' || c == '[' || c == ' '); }","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"char *getline_complete_name_conflict(char *prompt) {\n  int key, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  int *completion;\n  void (*old_handler)(int);\n\n  memset(line, 0, 4096);\n  gprompt = prompt;\n  old_handler = __sysv_signal(2, sighandler);\n  i = last_history_entry + 1;\n  if (i >= 200)\n    i = 0;\n  line_len = 0;\n  cursorpos = 0;\n  z = 0;\n  echo_disable();\n  printf(\"\\033[4h\");\n  print_prompt(prompt);\n  while (1) {\n    key = decode_key_pressed();\n    if (key == -1) {\n      printf(\"Invalid input sequence!\\n\");\n      goto end;\n    }\n    if (is_special(key) == 1) {\n      if (key == 0x561f002d && cursorpos != 0) {\n        j = 0;\n        do {\n          cursorpos--;\n          j++;\n        } while (is_stopkey(line[cursorpos]) != 1 && cursorpos != 0);\n        printf(\"\\033[%dD\", j);\n      }\n      if (key == 0x561f002c && cursorpos < line_len) {\n        k = 0;\n        do {\n          cursorpos++;\n          k++;\n        } while (is_stopkey(line[cursorpos]) != 1 && cursorpos < line_len);\n        printf(\"\\033[%dC\", k);\n      }\n      if (key == 0x561f0029 && cursorpos != 0) {\n        printf(\"\\033[%dD\", 1);\n        cursorpos--;\n      }\n      if (key == 0x561f0028 && cursorpos < line_len) {\n                printf(\"\\033[%dC","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"int init_completion_name_conflict(char *str) {\n  int i;\n\n  if (current_num_completions == 2048)\n    return 1;\n\n  for (i = 0; str[i] != '\\0'; i++) {\n    if (i >= 2048 - 1) {\n      memset(&completions[current_num_completions * 16384], 0, 16384);\n      return 1;\n    }\n    completions[current_num_completions * 16384 + i] = str[i];\n  }\n  completions[current_num_completions * 16384 + i] = '\\0';\n  current_num_completions++;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"int completion_exists_name_conflict(char *str) {\n  int i;\n  int tmp[4096];\n\n  for (i = 0; str[i] != '\\0' && i < 4096 - 1; i++)\n    tmp[i] = str[i];\n  tmp[i] = 0;\n  memsize = i;\n\n  if (lfind(tmp, completions, &current_num_completions, 4096 * sizeof(int),\n            compl_eqcompar))\n    return 1;\n  else\n    return 0;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"const char *get_key_name_name_conflict(int key) {\n  if (key == 0x1b)\n    return \"Escape\";\n\n  switch (key) {\n  case 0x561f0000:\n    return \"Tab\";\n  case 0x561f0001:\n    return \"unknown\";\n  case 0x561f0002:\n    return \"F1\";\n  case 0x561f0003:\n    return \"F2\";\n  case 0x561f0004:\n    return \"F3\";\n  case 0x561f0005:\n    return \"F4\";\n  case 0x561f0006:\n    return \"F5\";\n  case 0x561f0007:\n    return \"F6\";\n  case 0x561f0008:\n    return \"F7\";\n  case 0x561f0009:\n    return \"F8\";\n  case 0x561f000a:\n    return \"F9\";\n  case 0x561f000b:\n    return \"F10\";\n  case 0x561f000c:\n    return \"F11\";\n  case 0x561f000d:\n    return \"F12\";\n  case 0x561f0026:\n    return \"Up\";\n  case 0x561f0027:\n    return \"Down\";\n  case 0x561f0028:\n    return \"Right\";\n  case 0x561f0029:\n    return \"Left\";\n  case 0x561f002a:\n    return \"CtrlUp\";\n  case 0x561f002b:\n    return \"CtrlDown\";\n  case 0x561f002c:\n    return \"CtrlRight\";\n  case 0x561f002d:\n    return \"CtrlLeft\";\n  case 0x561f002e:\n    return \"Enter\";\n  case 0x561f002f:\n    return","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"int decode_regular_key_pressed_name_conflict(void) {\n  int c = getc(stdin);\n  if ((c & 0xf8) == 0xf0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int c3 = getc(stdin);\n    c = (((c & 0x0f) << 16) + ((c1 & 0x7f) << 12) + ((c2 & 0x7f) << 6) +\n         (c3 & 0x7f));\n    if (c < 0x10000)\n      return -1;\n  } else if ((c & 0xf0) == 0xe0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    c = (((c & 0x1f) << 12) + ((c1 & 0x7f) << 6) + (c2 & 0x7f));\n    if (c < 0x800)\n      return -1;\n  } else if ((c & 0xe0) == 0xc0) {\n    int c1 = getc(stdin);\n    c = (((c & 0x3f) << 6) + (c1 & 0x7f));\n    if (c < 0x80)\n      return -1;\n  } else if (c & 0x80) {\n    return -1;\n  }\n  return c & 0xff;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"int decode_key_pressed_name_conflict() {\n  int c;\n\n  c = getc(stdin);\n  if (c == '\\n')\n    return 1000000000 + 46;\n  if (c == '\\t')\n    return 1000000000 + 0;\n  if (c == 127)\n    return 1000000000 + 48;\n  if (c == 8)\n    return 1000000000 + 49;\n  if (c == -1 || c == -1)\n    return 4;\n  if (c == 23)\n    return 1000000000 + 50;\n  if (c == 0)\n    return 1000000000 + 51;\n  if (c == 27) {\n    int c2;\n\n    c2 = getc(stdin);\n    if (c2 == 79) {\n      int c3;\n\n      c3 = getc(stdin);\n      if (c3 >= 80 && c3 <= 83)\n        return 1000000000 + 42 + c3;\n      else\n        return -1;\n    } else if (c2 == 91) {\n      int c3;\n\n      c3 = getc(stdin);\n      switch (c3) {\n      case 97:\n        return 1000000000 + 38;\n      case 98:\n        return 1000000000 + 39;\n      case 99:\n        return 1000000000 + 40;\n      case 100:\n        return 1000000000 + 41;\n      case 102:\n        return 1000000000 + 47;\n      case 104:\n        return 1000000000 + 53;\n      case","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"int is_special_name_conflict(int c) {\n  return (c < 32 || c == 0x7f || c == 0x09 || c == 0x0a || c == 0x0d ||\n          c == 0x20 || c == 0x56 || c == 0x57 || c == 0x58 || c == 0x59 ||\n          c == 0x5a || c == 0x5b || c == 0x5c || c == 0x5d || c == 0x5e ||\n          c == 0x5f || c == 0x60 || c == 0x7b || c == 0x7c || c == 0x7d ||\n          c == 0x7e);\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"char *search_completion_name_conflict(char *line, int len) {\n  int i, j;\n  int start, end;\n  compute_completion_ranges(line, len, &start, &end);\n  if (start == 0 || len == 0)\n    return NULL;\n  i = (end - start) / sizeof(int);\n  j = (start - (int)&completions[0]) / sizeof(int);\n  if (j / 4096 == current_num_completions - 1)\n    return &line[len];\n  for (i = 0; line[i + len] && line[i + len] == completions[j + i]; i++)\n    line_1[i] = line[i + len];\n  line_1[i] = 0;\n  return line_1;\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"int is_stopkey_name_conflict(int c) { return (c == '.' || c == '/' || c == '[' || c == ' '); }","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"char *getline_complete_name_conflict(char *prompt) {\n  int key, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  int *completion;\n  void (*old_handler)(int);\n\n  memset(line, 0, 4096);\n  gprompt = prompt;\n  old_handler = __sysv_signal(2, sighandler);\n  i = last_history_entry + 1;\n  if (i >= 200)\n    i = 0;\n  line_len = 0;\n  cursorpos = 0;\n  n = 0;\n  echo_disable();\n  printf(\"\\033[4h\");\n  print_prompt(prompt);\n  while (1) {\n    key = decode_key_pressed();\n    if (key == -1) {\n      printf(\"Invalid input sequence!\\n\");\n      break;\n    }\n    if (is_special(key) == 1) {\n      if (key == 0x561f002d && cursorpos != 0) {\n        j = 0;\n        do {\n          cursorpos--;\n          j++;\n        } while (is_stopkey(line[cursorpos]) != 1 && cursorpos != 0);\n        printf(\"\\033[%dD\", j);\n      }\n      if (key == 0x561f002c && cursorpos < line_len) {\n        k = 0;\n        do {\n          cursorpos++;\n          k++;\n        } while (is_stopkey(line[cursorpos]) != 1 && cursorpos < line_len);\n        printf(\"\\033[%dC\", k);\n      }\n      if (key == 0x561f0029 && cursorpos != 0) {\n        printf(\"\\033[%dD\", 1);\n        cursorpos--;\n      }\n      if (key == 0x561f0028 && cursorpos < line_len) {\n                printf(\"\\033[%dC\",","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"int init_completion_name_conflict(char *str) {\n  int i;\n\n  if (current_num_completions == 2048)\n    return 1;\n\n  for (i = 0; str[i] != '\\0'; i++) {\n    if (i >= 2048 - 1) {\n      memset(&completions[current_num_completions * 16384], 0, 16384);\n      return 1;\n    }\n    completions[current_num_completions * 16384 + i] = str[i];\n  }\n  completions[current_num_completions * 16384 + i] = '\\0';\n  current_num_completions++;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"int completion_exists_name_conflict(char *str) {\n  int i;\n  int tmp[4096];\n\n  for (i = 0; str[i] != '\\0' && i < 4096 - 1; i++)\n    tmp[i] = str[i];\n  tmp[i] = 0;\n  memsize = i;\n\n  if (lfind(tmp, completions, &current_num_completions, 4096 * sizeof(int),\n            compl_eqcompar))\n    return 1;\n  else\n    return 0;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"static int beenhere(int syms, int len, int left, int mem, int rem) {\n    size_t index;\n    size_t offset;\n    int bit;\n    size_t length;\n    char *vector;\n    index = (((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) + (left >> 1) - 1) * (max - 1) + len - 1);\n    mem -= 1 << root;\n    offset = (mem >> 3) + rem;\n    offset = ((offset * (offset + 1)) >> 1) + rem;\n    bit = 1 << (mem & 7);\n    length = done[index].len;\n    if (offset < length && (done[index].vec[offset] & bit) != 0)\n        return 1;\n    if (length <= offset) {\n        if (length) {\n            do {\n                length <<= 1;\n            } while (length <= offset);\n            vector = realloc(done[index].vec, length);\n            if (vector != ((void *)0))\n                memset(vector + done[index].len, 0, length - done[index].len);\n        } else {\n            length = 1 << (len - root);\n            while (length <= offset)\n                length <<= 1;\n            vector = calloc(length, sizeof(char));\n        }\n        if (vector == ((void *)0)) {\n            fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n            cleanup();\n            exit(1);\n        }\n        done[index].len = length;\n        done[index].vec = vector;\n    }\n    done[index].vec[offset] |= bit;\n    return 0;\n}\n","function_prediction":"int beenhere_name_conflict(int x, int y, int z, int w, int h) {\n  unsigned long long int i, j, k, l, m, n, o, p, q, r, s, t, u, v, ww, xx, yy,\n      zz;\n  char *x1;\n\n  i = x - 1;\n  j = y - 1;\n  k = z - 1;\n  l = w - (1 << root);\n  m = h + (l >> 3);\n  n = h + (m * (m + 1)) >> 1;\n  o = 1 << (l & 7);\n\n  p = (((i * (i - 1)) >> 1) + ((j * (j - 1)) >> 1) + ((k * (k - 1)) >> 1)) +\n      (max - 1);\n  q = done[p].size;\n  if (n < q && (done[p].data[n] & o))\n    return 1;\n  if (n >= q) {\n    if (q) {\n      while (n >= q)\n        q <<= 1;\n      x1 = realloc(done[p].data, q);\n      if (x1) {\n        memset(x1 + done[p].size, 0, q - done[p].size);\n      }\n    } else {\n      q = 1 << (y - root);\n      while (n >= q)\n        q <<= 1;\n      x1 = calloc(q, 1);\n    }\n    if (!x1) {\n      fwrite(\"abort: unable to allocate enough memory\\n\", 1, 40, stderr);\n      cleanup();\n      exit(1);\n    }\n    done[p].size = q;\n    done[p].data = x1;\n  }\n  done[p].data[n] |= o;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/sergiobenrocha2_mgba/src/third-party/zlib/examples/enough.c"}
{"compilable":0,"function":"int unique_chars(char str[]) {\n    char c;\n    int i, j, len = strlen(str);\n    for (i = 0; i < len; i++) {\n        c = str[i];\n        for (j = i + 1; j < len; j++) {\n            if (str[j] == c)\n                return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"int unique_chars2(char *str) {\n  int i, j, len;\n  char count[26];\n\n  len = strlen(str);\n\n  for (i = 0; i < 26; i++)\n    count[i] = 0;\n\n  for (i = 0; i < len; i++)\n    count[tolower(str[i]) - 'a']++;\n\n  for (i = 0; i < 26; i++)\n    if (count[i] > 1)\n      return 0;\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/mohangorai_Collection/unique_chars.c"}
{"compilable":1,"function":"int unique_chars2(char str[]) {\n    char freq[26];\n    int i, len = strlen(str);\n    for (i = 0; i < 26; i++)\n        freq[i] = 0;\n    for (i = 0; i < len; i++)\n        freq[tolower(str[i]) - 'a']++;\n    for (i = 0; i < 26; i++)\n        if (freq[i] > 1)\n            return 0;\n    return 1;\n}\n","function_prediction":"int unique_chars2_name_conflict(char *str) {\n  int len = strlen(str);\n  int i, j;\n  int char_count[26];\n\n  for (i = 0; i < 26; i++) {\n    char_count[i] = 0;\n  }\n\n  for (i = 0; i < len; i++) {\n    char_count[tolower(str[i]) - 'a']++;\n  }\n\n  for (i = 0; i < 26; i++) {\n    if (char_count[i] > 1) {\n      return 0;\n    }\n  }\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/mohangorai_Collection/unique_chars.c"}
{"compilable":1,"function":"int *shuffle(int n) {\n    int *shuffled = (int *)calloc(n, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        shuffled[i] = i;\n    }\n    int temp;\n    for (int i = n - 1; i >= 0; i--) {\n        int pos = rand() % (i + 1);\n        temp = shuffled[i];\n        shuffled[i] = shuffled[pos];\n        shuffled[pos] = temp;\n    }\n    return shuffled;\n}\n","function_prediction":"int *shuffle_name_conflict(int n) {\n  int *a = calloc(n, sizeof(int));\n  for (int i = 0; i < n; i++)\n    a[i] = i;\n  for (int i = n - 1; i >= 0; i--) {\n    int j = rand() % (i + 1);\n    int t = a[i];\n    a[i] = a[j];\n    a[j] = t;\n  }\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":1,"function":"int check_prefix(const char *prefix, const char *str) {\n    return strncmp(prefix, str, strlen(prefix)) == 0;\n}\n","function_prediction":"int check_prefix_name_conflict(const char *prefix, const char *str) {\n  return !strncmp(prefix, str, strlen(prefix));\n}","pass":1,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":1,"function":"int read_labels(int **vector, int out_instances, int out_nodes, char *filename) {\n    FILE *labelset = fopen(filename, \"r\");\n    int bufflen = 20;\n    char *line = (char *)calloc(bufflen, sizeof(char));\n    int i = 0;\n    int min = 2147483647;\n    int max = (-2147483647 - 1);\n    while (fgets(line, bufflen, labelset))\n        {\n            (*vector)[i] = atoi(line);\n            if ((*vector)[i] < min)\n                min = (*vector)[i];\n            if ((*vector)[i] > max)\n                max = (*vector)[i];\n            i++;\n            if (i > out_instances) {\n                fprintf(stderr, \"ERROR: Too few allocated out rows!\\n\");\n                exit(1);\n            }\n        }\n    if (pow(2., out_nodes) < (max - min)) {\n        fprintf(stderr, \"ERROR: Too few nodes to represent the outputs!\\n\");\n        exit(1);\n    }\n    if (min != 0) {\n        for (int i = 0; i < out_instances; i++)\n            (*vector)[i] -= min;\n    }\n    free(line);\n    fclose(labelset);\n    return min;\n}\n","function_prediction":"int read_labels_name_conflict(int **labels, int n_rows, int n_cols, char *filename) {\n  FILE *fp = fopen(filename, \"r\");\n  char *line = calloc(20, sizeof(char));\n  int i = 0;\n  int min = 2147483647;\n  int max = -2147483648;\n  while (fgets(line, 20, fp) != NULL) {\n    (*labels)[i] = atoi(line);\n    if ((*labels)[i] < min) {\n      min = (*labels)[i];\n    }\n    if ((*labels)[i] > max) {\n      max = (*labels)[i];\n    }\n    i++;\n    if (i > n_rows) {\n      fprintf(stderr, \"ERROR: Too few allocated out rows!\\n\");\n      exit(1);\n    }\n  }\n  if ((max - min) > pow(2, n_cols)) {\n    fprintf(stderr, \"ERROR: Too few nodes to represent the outputs!\\n\");\n    exit(1);\n  }\n  if (min != 0) {\n    for (int j = 0; j < n_rows; j++) {\n      (*labels)[j] -= min;\n    }\n  }\n  free(line);\n  fclose(fp);\n  return min;\n}","pass":1,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":1,"function":"char *remove_whitespace(char *str) {\n    char *end;\n    while (((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISspace))\n        str++;\n    if (*str == 0)\n        return str;\n    end = str + strlen(str) - 1;\n    while (end > str && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        end--;\n    *(end + 1) = 0;\n    return str;\n}\n","function_prediction":"char *remove_whitespace_name_conflict(char *str) {\n  char *end;\n\n  while (isspace((unsigned char)*str))\n    str++;\n\n  if (*str == 0)\n    return str;\n\n  end = str + strlen(str) - 1;\n  while (end > str && isspace((unsigned char)*end))\n    end--;\n\n  end[1] = '\\0';\n\n  return str;\n}","pass":1,"source_file":"C_COMPILE/kevinvandervlist_kesh/tokenize.c"}
{"compilable":0,"function":"int p(z)\n    int z;\n {\n    putchar(\"UniBwM\"[z % 6]);\n}\n","function_prediction":"void p_name_conflict(int i) {\n  char *s = \"UniBwM\";\n  p_name_conflictutchar(s[i % 6]);\n}","pass":0,"source_file":"C_COMPILE/florianl_stander/stander.c"}
{"compilable":1,"function":"unsigned int get_baud(unsigned int baud_rate) {\n    unsigned int BAUD = 0;\n    switch (baud_rate) {\n      case 921600:\n        BAUD = 4103;\n        break;\n      case 460800:\n        BAUD = 4100;\n        break;\n      case 230400:\n        BAUD = 4099;\n        break;\n      case 115200:\n        BAUD = 4098;\n        break;\n      default:\n        printf(\"Baud rate not recognized, using default B57600\\n\");\n      case 57600:\n        BAUD = 4097;\n        break;\n      case 38400:\n        BAUD = 15;\n        break;\n      case 19200:\n        BAUD = 14;\n        break;\n      case 9600:\n        BAUD = 13;\n        break;\n      case 4800:\n        BAUD = 12;\n        break;\n      case 2400:\n        BAUD = 11;\n        break;\n      case 1800:\n        BAUD = 10;\n        break;\n      case 1200:\n        BAUD = 9;\n        break;\n      case 600:\n        BAUD = 8;\n        break;\n      case 300:\n        BAUD = 7;\n        break;\n      case 200:\n        BAUD = 6;\n        break;\n      case 150:\n        BAUD = 5;\n        break;\n      case 134:\n        BAUD = 4;\n        break;\n      case 110:\n        BAUD = 3;\n        break;\n      case 75:\n        BAUD = 2;\n        break;\n      case 50:\n        BAUD = 1;\n        break;\n    }\n    return BAUD;\n}\n","function_prediction":"int get_baud_name_conflict(int baud) {\n  switch (baud) {\n  case 300:\n    return 0x0007;\n  case 600:\n    return 0x0008;\n  case 1200:\n    return 0x0009;\n  case 2400:\n    return 0x000a;\n  case 4800:\n    return 0x000b;\n  case 9600:\n    return 0x000c;\n  case 19200:\n    return 0x000d;\n  case 38400:\n    return 0x000e;\n  case 57600:\n    return 0x000f;\n  case 115200:\n    return 0x0010;\n  case 230400:\n    return 0x0011;\n  case 460800:\n    return 0x0012;\n  case 921600:\n    return 0x0013;\n  default:\n    puts(\"Baud rate not recognized, using default B57600\");\n    return 0x0001;\n  }\n}","pass":0,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":1,"function":"int serial_init(char *port_name, unsigned int baud) {\n    struct termios orig_termios, cur_termios;\n    int br = get_baud(baud);\n    fd = open(port_name, 2 | 256 | 2048);\n    if (fd == -1) {\n        printf(\"opening modem serial device : fd < 0\\n\");\n        return -1;\n    }\n    if (tcgetattr(fd, &orig_termios)) {\n        printf(\"getting modem serial device attr\\n\");\n        return -2;\n    }\n    cur_termios = orig_termios;\n    cur_termios.c_iflag &= ~(1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 1024 | 2048 | 4096 | 8192);\n    cur_termios.c_iflag |= 2;\n    cur_termios.c_oflag &= ~(1 | 4 | 8 | 16 | 32);\n    cur_termios.c_cflag &= ~(48 | 64 | 128 | 256 | 512 | 1024 | 2048);\n    cur_termios.c_cflag |= 128 | 48 | 2048;\n    cur_termios.c_cflag &= ~(2147483648U);\n    cur_termios.c_lflag &= ~(1 | 2 | 32768 | 8 | 4096 | 16384);\n    cur_termios.c_lflag |= 128;\n    if (cfsetspeed(&cur_termios, br)) {\n        printf(\"setting modem serial device speed\\n\");\n        return -3;\n    }\n    if (tcsetattr(fd, 1, &cur_termios)) {\n        printf(\"setting modem serial device attr\\n\");\n        return -4;\n    }\n    return 0;\n}\n","function_prediction":"int serial_init_name_conflict(char *device, int baud) {\n  struct termios tty;\n  speed_t baudrate = get_baud(baud);\n\n  fd = open(device, O_RDWR | O_NOCTTY | O_NDELAY);\n  if (fd < 0) {\n    printf(\"opening modem serial device : fd < 0\\n\");\n    return -1;\n  }\n\n  if (tcgetattr(fd, &tty) != 0) {\n    printf(\"getting modem serial device attr\\n\");\n    return -2;\n  }\n\n  tty.c_cflag &= ~(PARENB | CSTOPB | CSIZE | CRTSCTS);\n  tty.c_cflag |= CS8;\n  tty.c_cflag |= CREAD | CLOCAL;\n  tty.c_iflag &= ~(IXON | IXOFF | IXANY);\n  tty.c_iflag |= IGNBRK;\n  tty.c_oflag &= ~OPOST;\n  tty.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);\n  tty.c_cc[VTIME] = 10;\n  tty.c_cc[VMIN] = 0;\n\n  if (cfsetspeed(&tty, baudrate) != 0) {\n    printf(\"setting modem serial device speed\\n\");\n    return -3;\n  }\n\n  if (tcsetattr(fd, 1, &tty) != 0) {\n    printf(\"setting modem serial device attr\\n\");\n    return -4;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":0,"function":"bool in_download_range(int download_id) {\n    if (download_id <= log_index.last_completed_log && download_id > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","function_prediction":"int in_download_range_name_conflict(int index) {\n  if (index > log_index[4] || index < 1)\n    return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":1,"function":"char *uri_decode(char *uri) {\n    int i = 0;\n    int ptr = 0;\n    char *command;\n    char hexa[3];\n    char code;\n    command = (char *)malloc(strlen(uri));\n    for (i = 0; i < strlen(uri); i++) {\n        switch (*(uri + i)) {\n          case '+':\n            *(command + ptr) = ' ';\n            ptr++;\n            break;\n          case '%':\n            sprintf(hexa, \"%c%c\\000\", *(uri + i + 1), *(uri + i + 2));\n            i += 2;\n            sscanf(hexa, \"%x\", &code);\n            *(command + ptr) = code;\n            ptr++;\n            break;\n          default:\n            *(command + ptr) = *(uri + i);\n            ptr++;\n            break;\n        }\n    }\n    *(command + ptr) = '\\x00';\n    return command;\n}\n","function_prediction":"char *uri_decode_name_conflict(char *str) {\n  char *pstr = str, *buf = malloc(strlen(str)), *pbuf = buf;\n  char t[3];\n  int len = 0;\n\n  while (len++ < strlen(str)) {\n    if (*pstr == '%') {\n      sprintf(t, \"%c%c\", *(pstr + 1), *(pstr + 2));\n      pstr += 2;\n      *pbuf = (char)__isoc99_sscanf(t, \"%x\", (unsigned int *)t);\n      pbuf++;\n    } else if (*pstr == '+') {\n      *pbuf = ' ';\n      pbuf++;\n      pstr++;\n    } else {\n      *pbuf = *pstr;\n      pbuf++;\n      pstr++;\n    }\n  }\n  *pbuf = '\\0';\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/certego_webshell/fuzzdb-webshell/c/cmd.c"}
{"compilable":1,"function":"char *uri_decode(char *uri) {\n    int i = 0;\n    int ptr = 0;\n    char *command;\n    char hexa[3];\n    char code;\n    command = (char *)malloc(strlen(uri));\n    for (i = 0; i < strlen(uri); i++) {\n        switch (*(uri + i)) {\n          case '+':\n            *(command + ptr) = ' ';\n            ptr++;\n            break;\n          case '%':\n            sprintf(hexa, \"%c%c\\000\", *(uri + i + 1), *(uri + i + 2));\n            i += 2;\n            sscanf(hexa, \"%x\", &code);\n            *(command + ptr) = code;\n            ptr++;\n            break;\n          default:\n            *(command + ptr) = *(uri + i);\n            ptr++;\n            break;\n        }\n    }\n    *(command + ptr) = '\\x00';\n    return command;\n}\n","function_prediction":"char *uri_decode_name_conflict(char *str) {\n  char *pstr = str, *buf = malloc(strlen(str)), *pbuf = buf;\n  char t[3];\n  int len = 0;\n\n  while (len++ < strlen(str)) {\n    if (*pstr == '%') {\n      sprintf(t, \"%c%c\", *(pstr + 1), *(pstr + 2));\n      pstr += 2;\n      *pbuf = (char)__isoc99_sscanf(t, \"%x\", (unsigned int *)t);\n      pbuf++;\n    } else if (*pstr == '+') {\n      *pbuf = ' ';\n      pbuf++;\n      pstr++;\n    } else {\n      *pbuf = *pstr;\n      pbuf++;\n      pstr++;\n    }\n  }\n  *pbuf = '\\0';\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/certego_webshell/web-malware-collection-13-06-2012/Other/cmd.c"}
{"compilable":1,"function":"static int isAlphanum(int c) {\n    return ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$' || c == '\\\\' || c > 126);\n}\n","function_prediction":"int isAlphanum_name_conflict(int c) {\n  return (((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||\n           (c >= '0' && c <= '9') || c == '_' || c == '$' || c == '\\\\')\n              ? 1\n              : 0);\n}","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":1,"function":"static int get() {\n    int c = theLookahead;\n    theLookahead = (-1);\n    if (c == (-1)) {\n        c = getc(stdin);\n    }\n    if (c >= ' ' || c == '\\n' || c == (-1)) {\n        return c;\n    }\n    if (c == '\\r') {\n        return '\\n';\n    }\n    return ' ';\n}\n","function_prediction":"int get_name_conflict() {\n  int c;\n\n  c = theLookahead;\n  theLookahead = -1;\n  if (c == -1)\n    c = get_name_conflictc(stdin);\n  if (c == -1 || c == '\\n' || c < 32) {\n    if (c == '\\r')\n      c = '\\n';\n    else\n      c = ' ';\n  }\n  return c;\n}","pass":1,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":1,"function":"static int peek() {\n    theLookahead = get();\n    return theLookahead;\n}\n","function_prediction":"int peek_name_conflict() {\n  theLookahead = get();\n  return theLookahead;\n}","pass":1,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":1,"function":"static int next() {\n    int c = get();\n    if (c == '/') {\n        switch (peek()) {\n          case '/':\n            for (;;) {\n                c = get();\n                if (c <= '\\n') {\n                    return c;\n                }\n            }\n          case '*':\n            get();\n            for (;;) {\n                switch (get()) {\n                  case '*':\n                    if (peek() == '/') {\n                        get();\n                        return ' ';\n                    }\n                    break;\n                  case (-1):\n                    fprintf(stderr, \"Error: JSMIN Unterminated comment.\\n\");\n                    exit(1);\n                }\n            }\n          default:\n            return c;\n        }\n    }\n    return c;\n}\n","function_prediction":"int next_name_conflict() {\n  int c = get();\n  if (c == '/') {\n    switch (peek()) {\n    case '*':\n      get();\n      do {\n        c = get();\n        if (c == -1) {\n          fwrite(\"Error: JSMIN Unterminated comment.\\n\", 1, 35, stderr);\n          exit(1);\n        }\n      } while (c != '*' || peek() != '/');\n      get();\n      return ' ';\n    case '/':\n      do {\n        c = get();\n      } while (c <= '\\n');\n      return c;\n    }\n  }\n  return c;\n}","pass":1,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":1,"function":"int readNlSock(int sockFd, char *bufPtr, size_t buf_size, int seqNum, int pId) {\n    struct nlmsghdr *nlHdr;\n    int readLen = 0, msgLen = 0;\n    do {\n        if ((readLen = recv(sockFd, bufPtr, buf_size - msgLen, 0)) < 0) {\n            perror(\"SOCK READ: \");\n            return -1;\n        }\n        nlHdr = (struct nlmsghdr *)bufPtr;\n        if ((((readLen) >= (int)sizeof(struct nlmsghdr) && (nlHdr)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlHdr)->nlmsg_len <= (readLen)) == 0) || (nlHdr->nlmsg_type == 2)) {\n            perror(\"Error in recieved packet\");\n            return -1;\n        }\n        if (nlHdr->nlmsg_type == 3) {\n            break;\n        } else {\n            bufPtr += readLen;\n            msgLen += readLen;\n        }\n        if ((nlHdr->nlmsg_flags & 2) == 0) {\n            break;\n        }\n    } while ((nlHdr->nlmsg_seq != seqNum) || (nlHdr->nlmsg_pid != pId));\n    return msgLen;\n}\n","function_prediction":"int readNlSock_name_conflict(int sock, char *buf, size_t len, int pid, int seq) {\n  int rcvd = 0;\n  struct nlmsghdr *hdr = (struct nlmsghdr *)buf;\n  while (1) {\n    rcvd = recv(sock, hdr, len - rcvd, 0);\n    if (rcvd < 0) {\n      perror(\"SOCK READ: \");\n      return -1;\n    }\n    if (!(rcvd >= sizeof(*hdr) && hdr->nlmsg_len >= sizeof(*hdr) &&\n          rcvd >= hdr->nlmsg_len)) {\n      perror(\"Error in recieved packet\");\n      return -1;\n    }\n    if (hdr->nlmsg_type == 2) {\n      perror(\"Error in recieved packet\");\n      return -1;\n    }\n    if (hdr->nlmsg_type == 3) {\n      return rcvd;\n    }\n    rcvd += rcvd;\n    if (!(hdr->nlmsg_flags & 2)) {\n      return rcvd;\n    }\n    if (hdr->nlmsg_pid == pid && hdr->nlmsg_seq == seq) {\n      return rcvd;\n    }\n    hdr = (struct nlmsghdr *)((char *)hdr + rcvd);\n  }\n}","pass":1,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":0,"function":"int parseRoutes(struct nlmsghdr *nlHdr, struct route_info *rtInfo) {\n    struct rtmsg *rtMsg;\n    struct rtattr *rtAttr;\n    int rtLen;\n    rtMsg = (struct rtmsg *)((void *)(((char *)nlHdr) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    if ((rtMsg->rtm_family != 2) || (rtMsg->rtm_table != RT_TABLE_MAIN))\n        return -1;\n    rtAttr = (struct rtattr *)((struct rtattr *)(((char *)(rtMsg)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1))));\n    rtLen = ((nlHdr)->nlmsg_len - ((((((sizeof(struct rtmsg))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    for (; ((rtLen) >= (int)sizeof(struct rtattr) && (rtAttr)->rta_len >= sizeof(struct rtattr) && (rtAttr)->rta_len <= (rtLen)); rtAttr = ((rtLen) -= ((((rtAttr)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rtAttr)) + ((((rtAttr)->rta_len) + 4U - 1) & ~(4U - 1))))) {\n        switch (rtAttr->rta_type) {\n          case RTA_OIF:\n            if_indextoname(*(int *)((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), rtInfo->ifName);\n            break;\n          case RTA_GATEWAY:\n            memcpy(&rtInfo->gateWay, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->gateWay));\n            break;\n          case RTA_PREFSRC:\n            memcpy(&rtInfo->srcAddr, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->srcAddr));\n            break;\n          case RTA_DST:\n            memcpy(&rtInfo->dstAddr, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->dstAddr));\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int parseRoutes_name_conflict(struct ndmsg *ndm, struct route *route) {\n  struct rt_msghdr *rtm;\n  int len;\n\n  if (ndm->nd_type != 2 || ndm->nd_len != 255 - 28)\n    return -1;\n\n  len = ndm->nd_msg_len - (sizeof(struct ndmsg) - sizeof(struct nd_msg));\n  rtm = (struct rt_msghdr *)((char *)ndm + sizeof(struct ndmsg));\n\n  while (len > 3 && rtm->rtm_msglen > 3 && rtm->rtm_msglen <= len) {\n    switch (rtm->rtm_type) {\n    case 1:\n      route->rt_src = rtm->rtm_addrs;\n      break;\n    case 4:\n      if_indextoname(rtm->rtm_addrs, route->rt_ifname);\n      break;\n    case 5:\n      route->rt_gateway = rtm->rtm_addrs;\n      break;\n    case 7:\n      route->rt_dst = rtm->rtm_addrs;\n      break;\n    }\n\n    len -= (rtm->rtm_msglen + 3) & ~3;\n    rtm = (struct rt_msghdr *)((char *)rtm + (rtm->rtm_msglen + 3) & ~3);\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":0,"function":"int get_gatewayip(char *gatewayip, socklen_t size) {\n    int found_gatewayip = 0;\n    struct nlmsghdr *nlMsg;\n    struct route_info route_info;\n    char msgBuf[8192];\n    int sock, len, msgSeq = 0;\n    if ((sock = socket(16, SOCK_DGRAM, 0)) < 0) {\n        perror(\"Socket Creation: \");\n        return (-1);\n    }\n    memset(msgBuf, 0, sizeof (msgBuf));\n    nlMsg = (struct nlmsghdr *)msgBuf;\n    nlMsg->nlmsg_len = ((sizeof(struct rtmsg)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))));\n    nlMsg->nlmsg_type = RTM_GETROUTE;\n    nlMsg->nlmsg_flags = (256 | 512) | 1;\n    nlMsg->nlmsg_seq = msgSeq++;\n    nlMsg->nlmsg_pid = getpid();\n    if (send(sock, nlMsg, nlMsg->nlmsg_len, 0) < 0) {\n        fprintf(stderr, \"Write To Socket Failed...\\n\");\n        return -1;\n    }\n    if ((len = readNlSock(sock, msgBuf, sizeof (msgBuf), msgSeq, getpid())) < 0) {\n        fprintf(stderr, \"Read From Socket Failed...\\n\");\n        return -1;\n    }\n    for (; ((len) >= (int)sizeof(struct nlmsghdr) && (nlMsg)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlMsg)->nlmsg_len <= (len)); nlMsg = ((len) -= ((((nlMsg)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlMsg)) + ((((nlMsg)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n        memset(&route_info, 0, sizeof (route_info));\n        if (parseRoutes(nlMsg, &route_info) < 0)\n            continue;\n        if (strstr((char *)inet_ntoa(route_info.dstAddr), \"0.0.0.0\")) {\n            inet_ntop(2, &route_info.gateWay, gatewayip, size);\n            found_gatewayip = 1;\n            break;\n        }\n    }\n    close(sock);\n    return found_gatewayip;\n}\n","function_prediction":"int get_gatewayip_name_conflict(char *ip, int ip_len) {\n  int sockfd, ret, len, n, i, found = 0;\n  struct nlmsghdr *nlh;\n  struct rtmsg *rtm;\n  struct rtattr *rta;\n  struct sockaddr_nl sa;\n  char buf[8192];\n  struct in_addr dst, gw;\n\n  sockfd = socket(0x0010, 2, 0);\n  if (sockfd < 0) {\n    perror(\"Socket Creation: \");\n    return -1;\n  }\n\n  memset(buf, 0, sizeof(buf));\n  nlh = (struct nlmsghdr *)buf;\n  nlh->nlmsg_len =\n      sizeof(struct nlmsghdr) + sizeof(struct rtmsg) + sizeof(struct rtattr);\n  nlh->nlmsg_type = 0x001a;\n  nlh->nlmsg_flags = 0x0003;\n  nlh->nlmsg_seq = n = 0;\n  nlh->nlmsg_pid = getpid();\n\n  rtm = (struct rtmsg *)(buf + sizeof(struct nlmsghdr));\n  rtm->rtm_table = 0x001c;\n  rtm->rtm_type = 0x0000;\n\n  if (send(sockfd, nlh, nlh->nlmsg_len, 0) < 0) {\n    fwrite(\"Write To Socket Failed...\\n\", 1, 26, stderr);\n    return -1;\n  }\n\n  len = readNlSock(sockfd, buf, sizeof(buf), n, getpid());\n  if (len < 0) {\n    fwrite(\"Read From Socket Failed...\\n\", 1, 27, stderr);\n    return -1;\n  }\n\n  while (len >= sizeof(struct nlmsghdr)) {\n    nlh = (struct nlmsghdr *)buf;\n    if (len < nlh->nlmsg_len)\n      break;\n","pass":0,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":1,"function":"int compare_mac(MAC *m1, MAC *m2) {\n    return memcmp(m1, m2, 6);\n}\n","function_prediction":"int compare_mac_name_conflict(const void *a, const void *b) { return memcmp(a, b, 6); }","pass":1,"source_file":"C_COMPILE/nikkolasg_arp/test_misc.c"}
{"compilable":1,"function":"int compare_ip(IP *ip1, IP *ip2) {\n    return memcmp(ip1, ip2, 4);\n}\n","function_prediction":"int compare_ip_name_conflict(const void *a, const void *b) {\n  return memcmp(a, b, sizeof(struct in_addr));\n}","pass":1,"source_file":"C_COMPILE/nikkolasg_arp/test_misc.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 1;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 500000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  int hash = GetWordHash(word);\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 500000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int i;\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(str, argv[i])) {\n      if (i == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      } else\n        return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 0;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 30000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  unsigned int hash;\n\n  len = strlen(word) + 1;\n  if (len > 100)\n    len = 100;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1) {\n      vocab_hash[hash] = vocab_size - 1;\n      break;\n    }\n    hash = (hash + 1) % 30000000;\n  }\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int i;\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(str, argv[i])) {\n      if (i == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      } else\n        return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":1,"function":"char *rat(char *message) {\n    char *cyphertext = (char *)malloc(sizeof(char) * strlen(message));\n    int i;\n    for (i = 0; i < strlen(message); i++) {\n        cyphertext[i] = (isalpha(message[i])) ? (((message[i] + 13 - 'a') % 26) + 'a') : message[i];\n    }\n    return cyphertext;\n}\n","function_prediction":"char *rat_name_conflict(char *s) {\n  char *r = malloc(strlen(s));\n  int i;\n  for (i = 0; i < strlen(s); i++) {\n    if (isalpha(s[i])) {\n      r[i] = (s[i] - 'T' + 26) % 26 + 'a';\n    } else {\n      r[i] = s[i];\n    }\n  }\n  return r;\n}","pass":0,"source_file":"C_COMPILE/chamoysvoice_rat13/rat13.c"}
{"compilable":1,"function":"int is_delimeter(char c) {\n    int ii = 0;\n    char dlms[] = \"\\t\\r\\n (){}[]+-*/%\\\"'&|^~:;<>.,\";\n    while (dlms[ii])\n        {\n            if (c == dlms[ii++])\n                return 1;\n        }\n    return 0;\n}\n","function_prediction":"int is_delimeter_name_conflict(char c) {\n  char delimeters[] = \" \\n\\t\\v\\f\\r\\a)(}{][#%^&*\\\"'+-/\\\\|~:;<>,.?!\";\n  int i;\n\n  for (i = 0; delimeters[i]; i++)\n    if (c == delimeters[i])\n      return (1);\n  return (0);\n}","pass":0,"source_file":"C_COMPILE/lboulard_cscope/contrib/webcscope/hilite.c"}
{"compilable":1,"function":"int is_keyword(char *str) {\n    char *kwords[] = {\"asm\", \"auto\", \"break\", \"case\", \"cdecl\", \"char\", \"class\", \"const\", \"continue\", \"default\", \"delete\", \"do\", \"double\", \"else\", \"enum\", \"extern\", \"far\", \"float\", \"for\", \"friend\", \"goto\", \"huge\", \"if\", \"inline\", \"int\", \"interrupt\", \"long\", \"near\", \"new\", \"operator\", \"pascal\", \"private\", \"protected\", \"public\", \"register\", \"return\", \"short\", \"signed\", \"sizeof\", \"static\", \"struct\", \"switch\", \"template\", \"this\", \"typedef\", \"union\", \"unsigned\", \"virtual\", \"void\", \"volatile\", \"while\", ((void *)0)};\n    int ii = 0;\n    int jj;\n    int check;\n    while (kwords[ii])\n        {\n            jj = 0;\n            check = 1;\n            while (kwords[ii][jj] && check)\n                {\n                    if (str[jj] != kwords[ii][jj]) {\n                        check = 0;\n                    }\n                    jj++;\n                }\n            if (check)\n                return 1;\n            ii++;\n        }\n    return 0;\n}\n","function_prediction":"int is_keyword_name_conflict(char *str) {\n  char *keywords[] = {\"auto\",     \"break\",   \"case\",   \"char\",     \"const\",\n                      \"continue\", \"default\", \"do\",     \"double\",   \"else\",\n                      \"enum\",     \"extern\",  \"float\",  \"for\",      \"goto\",\n                      \"if\",       \"int\",     \"long\",   \"register\", \"return\",\n                      \"short\",    \"signed\",  \"sizeof\", \"static\",   \"struct\",\n                      \"switch\",   \"typedef\", \"union\",  \"unsigned\", \"void\",\n                      \"volatile\", \"while\",   \"NULL\",   \"true\",     \"false\"};\n\n  int i, j, k;\n\n  for (i = 0; i < 52; i++) {\n    if (keywords[i] == NULL)\n      break;\n\n    j = 0;\n    k = 1;\n\n    while (keywords[i][j] != '\\0' && k) {\n      if (str[j] != keywords[i][j])\n        k = 0;\n\n      j++;\n    }\n\n    if (k)\n      return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/lboulard_cscope/contrib/webcscope/hilite.c"}
{"compilable":0,"function":"static int load_uca_file(MY_UCA *uca, size_t maxchar, int *pageloaded) {\n    char str[512];\n    size_t lineno, out_of_range_chars = 0;\n    char *weights[64];\n    for (lineno = 0; fgets(str, sizeof (str), stdin); lineno++) {\n        char *comment;\n        char *weight;\n        char *s, *ch[6];\n        size_t codenum, i, code;\n        MY_UCA_ITEM *item = ((void *)0);\n        if (*str == '\\r' || *str == '\\n' || *str == '#')\n            continue;\n        if (*str == '@' && !strncmp(str, \"@version \", 9)) {\n            const char *value;\n            if (strtok(str, \" \\r\\n\\t\") && (value = strtok(((void *)0), \" \\r\\n\\t\")))\n                snprintf(uca->version, 32, value);\n            continue;\n        }\n        if ((code = strtol(str, ((void *)0), 16)) > maxchar) {\n            out_of_range_chars++;\n            continue;\n        }\n        if ((comment = strchr(str, '#'))) {\n            *comment++ = '\\x00';\n            for (; *comment == ' '; comment++)\n                ;\n        } else {\n            fprintf(stderr, \"Warning: could not parse line #%d:\\n'%s'\\n\", lineno, str);\n            continue;\n        }\n        if ((weight = strchr(str, ';'))) {\n            *weight++ = '\\x00';\n            for (; *weight == ' '; weight++)\n                ;\n        } else {\n            fprintf(stderr, \"Warning: could not parse line #%d:\\n%s\\n\", lineno, str);\n            continue;\n        }\n        for (codenum = 0 , s = strtok(str, \" \\t\"); s; codenum++ , s = strtok(((void *)0), \" \\t\")) {\n            if (codenum == 6) {\n                fprintf(stderr, \"Contraction length is too long (%d) line #%d\", codenum, lineno);\n                exit(1);\n            }\n            ch[codenum] = s;\n            ch[codenum + 1] = 0;\n        }\n        if (codenum > 1) {\n            MY_UCA_CONTRACTION *c = &uca->contraction[uca->ncontractions++];\n            size_t i;\n            if (uca->ncontractions >= 1024) {\n                fprintf(stderr, \"Too many contractions (%d) at line #%d\\nRebuild with a bigger MY_UCA_MAXCONTRACTIONS value\\n\", uca->ncontractions, lineno);\n                exit(1);\n            }\n            for (i = 0; i < 6; i++) {\n                c->ch[i] = (i < codenum) ? (uint)strtol(ch[i], ((void *)0), 16) : 0;\n            }\n            if (uca->debug)\n                fprintf(stderr, \"Contraction: %04X-%04X-%04X\\n\", c->ch[0], c->ch[1], c->ch[2]);\n            item = &c->item;\n        } else {\n            item = &uca->item[code];\n        }\n        item->num = 0;\n        s = strtok(weight, \" []\");\n        while (s)\n            {\n                if (item->num >= 64) {\n                    fprintf(stderr, \"Line #%d has more than %d weights\\n\", lineno, 64);\n                    fprintf(stderr, \"Can't continue.\\n\");\n                    exit(1);\n                }\n                weights[item->num] = s;\n                s = strtok(((void *)0), \" []\");\n                item->num++;\n            }\n        for (i = 0; i < item->num; i++) {\n            size_t level = 0;\n            if (i >= 8) {\n                fprintf(stderr, \"Warning: at line %d: character %04X has more than %d many weights (%d). Skipping the extra weights.\\n\", lineno, code, 8, item->num);\n                item->num = 8;\n                break;\n            }\n            for (s = weights[i]; *s;) {\n                char *endptr;\n                size_t part = strtol(s + 1, &endptr, 16);\n                if (i < 8) {\n                    item->weight[level][i] = part;\n                } else {\n                    fprintf(stderr, \"Too many weights (%d) at line %d\\n\", i, lineno);\n                    exit(1);\n                }\n                s = endptr;\n                level++;\n            }\n        }\n        pageloaded[code >> 8]++;\n    }\n    if (out_of_range_chars)\n        fprintf(stderr, \"%d out-of-range characters skipped\\n\", out_of_range_chars);\n    return 0;\n}\n","function_prediction":"int load_uca_file(struct uca_data *uca, unsigned long max_char,\n                  unsigned int *uca_count) {\n  char line[512];\n  unsigned int line_num = 0;\n  unsigned int out_of_range = 0;\n  unsigned int i;\n  unsigned int j;\n  unsigned int k;\n  unsigned int char_code;\n  unsigned int char_code_high;\n  unsigned int char_code_low;\n  unsigned int char_code_low_high;\n  unsigned int char_code_low_low;\n  unsigned int char_code_low_low_high;\n  unsigned int char_code_low_low_low;\n  unsigned int char_code_low_low_low_high;\n  unsigned int char_code_low_low_low_low;\n  unsigned int char_code_low_low_low_low_high;\n  unsigned int char_code_low_low_low_low_low;\n  unsigned int char_code_low_low_low_low_low_high;\n  unsigned int char_code_low_low_low_low_low_low;\n  unsigned int char_code_low_low_low_low_low_low_high;\n  unsigned int char_code_low_low_low_low_low_low_low;\n  unsigned int char_code_low_low_low_low_low_low_low_high;\n  unsigned int char_code_low_low_low_low_low_low_low_low;\n  unsigned int char_code_low_low_low_low_low_low_low_low_high;\n  unsigned int char_code_low_low_low_low_low_low_low_low_low;\n  unsigned int char_code_low_low_low_low_low_low_low_low_low_high;\n  unsigned int char_code_low_low_low_low_low_low_low_low_low_low;\n  unsigned int char_code_low_low_low_low_low_low_low_low_low_low_high;\n  unsigned int char_code_low_low","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static char *prefix_name(MY_UCA *uca) {\n    static char prefix[32];\n    char *s, *d;\n    strcpy(prefix, \"uca\");\n    for (s = uca->version , d = prefix + strlen(prefix); *s; s++) {\n        if ((*s >= '0' && *s <= '9') || (*s >= 'a' && *s <= 'z'))\n            *d++ = *s;\n    }\n    *d = '\\x00';\n    return prefix;\n}\n","function_prediction":"char *prefix_name_name_conflict(char *name) {\n  char *p, *q;\n\n  prefix_3[0] = 'a';\n  prefix_3[1] = 'c';\n  prefix_3[2] = 'u';\n  p = prefix_3 + strlen(prefix_3);\n  for (q = name; *q; q++)\n    if (*q >= '0' && *q <= '9' || *q >= 'A' && *q <= 'Z' ||\n        *q >= 'a' && *q <= 'z')\n      *p++ = *q;\n  *p = '\\0';\n  return prefix_3;\n}","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":1,"function":"static char *page_name(MY_UCA *uca, size_t page, size_t level) {\n    static char page_name_buf[120];\n    snprintf(page_name_buf, sizeof (page_name_buf), \"%s_p%03X%s\", prefix_name(uca), page, pname[level]);\n    return page_name_buf;\n}\n","function_prediction":"char *page_name_name_conflict(const char *prefix, unsigned long page, unsigned long pageno) {\n  static char page_name_name_conflict_buf[128];\n\n  snprintf(page_name_name_conflict_buf, sizeof(page_name_name_conflict_buf), \"%s_p%03X%s\",\n           prefix_name(prefix), page, pname[pageno]);\n  return page_name_name_conflict_buf;\n}","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static size_t normalize_weight(MY_UCA_ITEM *item, size_t level, uint16 *weight, size_t weight_elements) {\n    size_t num, i;\n    memset(weight, 0, weight_elements * sizeof (*weight));\n    for (num = 0 , i = 0; i < item->num && i < 8; i++) {\n        if (item->weight[level][i]) {\n            weight[num] = item->weight[level][i];\n            num++;\n        }\n    }\n    return num;\n}\n","function_prediction":"size_t normalize_weight(const struct weight_table *table, size_t index,\n                        short *weight, size_t size) {\n  size_t i, j;\n\n  memset(weight, 0, size * sizeof(short));\n\n  for (i = 0, j = 0; i < table->size && j < 8; i++) {\n    if (table->weight[index * 8 + i].weight) {\n      weight[j++] = table->weight[index * 8 + i].weight;\n    }\n  }\n\n  return j;\n}","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":1,"function":"static int weight_cmp(uint16 *w1, uint16 *w2, size_t len) {\n    size_t i;\n    for (i = 0; i < len; i++) {\n        if (w1[i] != w2[i])\n            return 1;\n    }\n    return 0;\n}\n","function_prediction":"int weight_cmp_name_conflict(short *a, short *b, size_t n) {\n  size_t i;\n  for (i = 0; i < n; i++)\n    if (a[i] != b[i])\n      return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":1,"function":"static int get_int_option(const char *str, const char *name, int *num) {\n    size_t namelen = strlen(name);\n    if (!strncmp(str, name, namelen)) {\n        *num = atoi(str + namelen);\n        if (*num == 0 && str[namelen] != '0') {\n            fprintf(stderr, \"\\nBad numeric option value: %s\\n\\n\", str);\n            usage(stderr, 1);\n        }\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int get_int_option_name_conflict(char *arg, char *opt, int *val) {\n  size_t len = strlen(opt);\n\n  if (!strncmp(arg, opt, len)) {\n    *val = atoi(arg + len);\n    if (!*val && arg[len] != '0') {\n      fprintf(stderr, \"\\nBad numeric option value: %s\\n\\n\", arg);\n      usage(stderr, 1);\n    }\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":1,"function":"static _Bool is_color_enabled(void) {\n    const char *env = getenv(\"LESS\");\n    return (env != 0 && (strstr(env, \"-r\") != 0 || strstr(env, \"-R\") != 0));\n}\n","function_prediction":"int is_color_enabled_name_conflict(void) {\n  char *less = getenv(\"LESS\");\n\n  if (less == NULL)\n    return 0;\n\n  if (strstr(less, \"-r\") || strstr(less, \"-R\"))\n    return 1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/frugalware_frugalware-stable/source/apps/lesspipe/code2color.c"}
{"compilable":1,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"int findbreak_name_conflict(char *s, int start, int max) {\n  int i, j;\n\n  i = start;\n  j = start;\n  while (j <= max) {\n    if (s[j] == '\\t')\n      s[j] = ' ';\n    if (s[j] == '\\n') {\n      s[j] = ' ';\n      return j;\n    }\n    if (s[j] == '\\0')\n      return j;\n    if (s[j] == '-' && j < max - 1)\n      i = j + 1;\n    if (s[j] == ' ')\n      i = j;\n    j++;\n  }\n  return i;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int argindex_name_conflict(int n) {\n  int i;\n  int found = 0;\n\n  if (argv == NULL || argv[0] == NULL)\n    return -1;\n\n  for (i = 1; argv[i] != NULL; i++) {\n    if (found || (argv[i][0] != '-' && argv[i][0] != '+' &&\n                  strchr(argv[i], '=') == NULL)) {\n      if (n-- == 0)\n        return i;\n    }\n    if (!strcmp(argv[i], \"--\"))\n      found = 1;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"int OptNArgs_name_conflict(void) {\n  int i, n;\n  int flag;\n\n  n = 0;\n  flag = 0;\n  if (argv) {\n    if (argv[0]) {\n      for (i = 1; argv[i]; i++) {\n        if (flag || argv[i][0] == '-' || argv[i][0] == '+' ||\n            strchr(argv[i], '=')) {\n          n++;\n        }\n        if (!strcmp(argv[i], \"--\")) {\n          flag = 1;\n        }\n      }\n    }\n  }\n  return n;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"char *OptArg_name_conflict(int opt) {\n  int i;\n\n  i = argindex(opt);\n  if (i < 0)\n    return NULL;\n  else\n    return argv[i];\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"void preprocess_input_name_conflict(char *pzInput) {\n  int i, j, k, nLine, nDepth, nStart, nEnd, nDefined;\n\n  nDepth = 0;\n  nLine = 1;\n  for (i = 0; pzInput[i]; i++) {\n    if (pzInput[i] == '\\n')\n      nLine++;\n    if (pzInput[i] == '%' && (i == 0 || pzInput[i - 1] == '\\n')) {\n      if (!strncmp(pzInput + i, \"%endif\", 6) &&\n          (__ctype_b_loc()[(unsigned char)pzInput[i + 6]] & 0x2000)) {\n        if (nDepth) {\n          nDepth--;\n          if (nDepth == 0) {\n            for (j = nStart; j < i; j++)\n              if (pzInput[j] != '\\n')\n                pzInput[j] = ' ';\n          }\n        }\n        for (j = i; pzInput[j] && pzInput[j] != '\\n'; j++)\n          pzInput[j] = ' ';\n      } else if (!strncmp(pzInput + i, \"%ifdef\", 6) &&\n                 (__ctype_b_loc()[(unsigned char)pzInput[i + 6]] & 0x2000)) {\n        if (nDepth)\n          nDepth++;\n        else {\n          for (j = i + 6; __ctype_b_loc()[(unsigned char)pzInput[j]] & 0x2000;\n               j++)\n            ;\n          nStart = j;\n          for (j = 0;\n               pzInput[nStart + j] &&\n               !(__ctype_b_loc()[(unsigned char)pzInput[nStart + j]] & 0x2000);\n               j++)\n            ;\n          nEnd = j;\n          nDefined = 0;\n                    for (k = 0; k < n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"char *pathsearch_name_conflict(char *path, char *name, int mode) {\n  char *p, *q, *r, *s;\n  char c;\n\n  if ((p = strrchr(path, '/'))) {\n    c = *p;\n    *p = '\\0';\n    s = malloc(strlen(path) + strlen(name) + 2);\n    if (s) {\n      sprintf(s, \"%s/%s\", path, name);\n    }\n    *p = c;\n    return s;\n  }\n\n  if (!(s = getenv(\"PATH\"))) {\n    s = \".:/bin:/usr/bin\";\n  }\n\n  r = malloc(strlen(s) + strlen(name) + 2);\n  if (!r) {\n    return NULL;\n  }\n\n  while (*s) {\n    if ((q = strchr(s, ':'))) {\n      c = *q;\n      *q = '\\0';\n    } else {\n      q = s + strlen(s);\n    }\n    sprintf(r, \"%s/%s\", s, name);\n    if (q) {\n      *q = c;\n      if (c) {\n        s = q + 1;\n      } else {\n        s = \"\";\n      }\n    } else {\n      s = \"\";\n    }\n    if (!access(r, mode)) {\n      return r;\n    }\n  }\n\n  return r;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"const char *minimum_size_type_name_conflict(int min, int max) {\n  if (min >= 0) {\n    if (max <= 255)\n      return \"unsigned char\";\n    else if (max <= 65535)\n      return \"unsigned short int\";\n    else\n      return \"unsigned int\";\n  } else {\n    if (min >= -127 && max <= 127)\n      return \"signed char\";\n    else if (min >= -32767 && max <= 32767)\n      return \"short\";\n    else\n      return \"int\";\n  }\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"char *SetNew_name_conflict(void) {\n  char *set;\n  int i;\n\n  set = (char *)malloc(size);\n  if (set == NULL)\n    memory_error();\n\n  for (i = 0; i < size; i++)\n    set[i] = 0;\n\n  return set;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"int SetAdd_name_conflict(char *set, int index) {\n  char old = set[index];\n  set[index] = 1;\n  return old == 0;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"int SetUnion_name_conflict(char *a, char *b) {\n  int i, changed = 0;\n\n  for (i = 0; i < size; i++)\n    if (b[i] && !a[i]) {\n      changed = 1;\n      a[i] = 1;\n    }\n  return changed;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"int strhash_name_conflict(char *str) {\n  int hash = 0;\n  while (*str)\n    hash = hash * 13 + *str++;\n  return hash;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"char *Strsafe_name_conflict(char *s) {\n  char *p;\n\n  p = Strsafe_name_conflict_find(s);\n  if (p == NULL) {\n    p = malloc(strlen(s) + 1);\n    if (p != NULL) {\n      strcpy(p, s);\n      if (!Strsafe_name_conflict_insert(p))\n        p = NULL;\n    }\n  }\n  if (p == NULL)\n    memory_error();\n  return p;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"int Strsafe_insert_name_conflict(char *s) {\n  int h, i, n;\n  struct strsafe_entry *p;\n  struct strsafe_entry *new_table;\n  struct strsafe_entry **new_hash;\n\n  if (x1a == NULL)\n    return 0;\n\n  h = strhash(s);\n  for (p = x1a->table[h & (x1a->size - 1)]; p != NULL; p = p->next)\n    if (!strcmp(p->s, s))\n      return 0;\n\n  if (x1a->count >= x1a->size) {\n    n = x1a->size * 2;\n    new_table =\n        (struct strsafe_entry *)malloc(n * sizeof(struct strsafe_entry));\n    if (new_table == NULL)\n      return 0;\n    new_hash = (struct strsafe_entry **)&new_table[n];\n    for (i = 0; i < n; i++)\n      new_hash[i] = NULL;\n    for (i = 0; i < x1a->count; i++) {\n      p = &x1a->table[i];\n      h = strhash(p->s) & (n - 1);\n      if (new_hash[h] != NULL)\n        new_hash[h]->next = &new_table[i + 1];\n      new_table[i + 1].next = new_hash[h];\n      new_table[i + 1].s = p->s;\n      new_table[i + 1].prev = &new_table[h];\n      new_hash[h] = &new_table[i + 1];\n    }\n    free(x1a->table);\n    x1a->size = n;\n    x1a->table = new_table;\n    x1a->hash = new_hash;\n  }\n\n  h = h & (x1a->size - 1);\n  p = &x1a->table[x1a-","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"char *Strsafe_find_name_conflict(char *s) {\n  int h;\n  struct strsafe_entry *e;\n\n  if (x1a == NULL)\n    return NULL;\n\n  h = strhash(s) & (x1a->size - 1);\n  e = x1a->table[h];\n  while (e != NULL) {\n    if (!strcmp(e->s, s))\n      return e->s;\n    e = e->next;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"int Symbol_count_name_conflict() {\n  if (x2a == NULL)\n    return 0;\n  return x2a->count;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"int findbreak_name_conflict(char *s, int start, int max) {\n  int i, j;\n\n  i = start;\n  j = start;\n  while (j <= max) {\n    if (s[j] == '\\t')\n      s[j] = ' ';\n    if (s[j] == '\\n') {\n      s[j] = ' ';\n      return j;\n    }\n    if (s[j] == '\\0')\n      return j;\n    if (s[j] == '-' && j < max - 1)\n      i = j + 1;\n    if (s[j] == ' ')\n      i = j;\n    j++;\n  }\n  return i;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int argindex_name_conflict(int n) {\n  int i;\n  int found = 0;\n\n  if (argv == NULL || argv[0] == NULL)\n    return -1;\n\n  for (i = 1; argv[i] != NULL; i++) {\n    if (found || (argv[i][0] != '-' && argv[i][0] != '+' &&\n                  strchr(argv[i], '=') == NULL)) {\n      if (n-- == 0)\n        return i;\n    }\n    if (!strcmp(argv[i], \"--\"))\n      found = 1;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"int OptNArgs_name_conflict(void) {\n  int i, n;\n  int flag;\n\n  n = 0;\n  flag = 0;\n  if (argv) {\n    if (argv[0]) {\n      for (i = 1; argv[i]; i++) {\n        if (flag || argv[i][0] == '-' || argv[i][0] == '+' ||\n            strchr(argv[i], '=')) {\n          n++;\n        }\n        if (!strcmp(argv[i], \"--\")) {\n          flag = 1;\n        }\n      }\n    }\n  }\n  return n;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"char *OptArg_name_conflict(int opt) {\n  int i;\n\n  i = argindex(opt);\n  if (i < 0)\n    return NULL;\n  else\n    return argv[i];\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"void preprocess_input_name_conflict(char *pzInput) {\n  int i, j, k, nLine, nDepth, nStart, nEnd, nDefined;\n\n  nDepth = 0;\n  nLine = 1;\n  for (i = 0; pzInput[i]; i++) {\n    if (pzInput[i] == '\\n')\n      nLine++;\n    if (pzInput[i] == '%' && (i == 0 || pzInput[i - 1] == '\\n')) {\n      if (!strncmp(pzInput + i, \"%endif\", 6) &&\n          (__ctype_b_loc()[(unsigned char)pzInput[i + 6]] & 0x2000)) {\n        if (nDepth) {\n          nDepth--;\n          if (nDepth == 0) {\n            for (j = nStart; j < i; j++)\n              if (pzInput[j] != '\\n')\n                pzInput[j] = ' ';\n          }\n        }\n        for (j = i; pzInput[j] && pzInput[j] != '\\n'; j++)\n          pzInput[j] = ' ';\n      } else if (!strncmp(pzInput + i, \"%ifdef\", 6) &&\n                 (__ctype_b_loc()[(unsigned char)pzInput[i + 6]] & 0x2000)) {\n        if (nDepth)\n          nDepth++;\n        else {\n          for (j = i + 6; __ctype_b_loc()[(unsigned char)pzInput[j]] & 0x2000;\n               j++)\n            ;\n          nStart = j;\n          for (j = 0;\n               pzInput[nStart + j] &&\n               !(__ctype_b_loc()[(unsigned char)pzInput[nStart + j]] & 0x2000);\n               j++)\n            ;\n          nEnd = j;\n          nDefined = 0;\n                    for (k = 0; k < n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"char *pathsearch_name_conflict(char *path, char *name, int mode) {\n  char *p, *q, *r, *s;\n  char c;\n\n  if ((p = strrchr(path, '/'))) {\n    c = *p;\n    *p = '\\0';\n    s = malloc(strlen(path) + strlen(name) + 2);\n    if (s) {\n      sprintf(s, \"%s/%s\", path, name);\n    }\n    *p = c;\n    return s;\n  }\n\n  if (!(s = getenv(\"PATH\"))) {\n    s = \".:/bin:/usr/bin\";\n  }\n\n  r = malloc(strlen(s) + strlen(name) + 2);\n  if (!r) {\n    return NULL;\n  }\n\n  while (*s) {\n    if ((q = strchr(s, ':'))) {\n      c = *q;\n      *q = '\\0';\n    } else {\n      q = s + strlen(s);\n    }\n    sprintf(r, \"%s/%s\", s, name);\n    if (q) {\n      *q = c;\n      if (c) {\n        s = q + 1;\n      } else {\n        s = \"\";\n      }\n    } else {\n      s = \"\";\n    }\n    if (!access(r, mode)) {\n      return r;\n    }\n  }\n\n  return r;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"const char *minimum_size_type_name_conflict(int min, int max) {\n  if (min >= 0) {\n    if (max <= 255)\n      return \"unsigned char\";\n    else if (max <= 65535)\n      return \"unsigned short int\";\n    else\n      return \"unsigned int\";\n  } else {\n    if (min >= -127 && max <= 127)\n      return \"signed char\";\n    else if (min >= -32767 && max <= 32767)\n      return \"short\";\n    else\n      return \"int\";\n  }\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"char *SetNew_name_conflict(void) {\n  char *set;\n  int i;\n\n  set = (char *)malloc(size);\n  if (set == NULL)\n    memory_error();\n\n  for (i = 0; i < size; i++)\n    set[i] = 0;\n\n  return set;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"int SetAdd_name_conflict(char *set, int index) {\n  char old = set[index];\n  set[index] = 1;\n  return old == 0;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"int SetUnion_name_conflict(char *a, char *b) {\n  int i, changed = 0;\n\n  for (i = 0; i < size; i++)\n    if (b[i] && !a[i]) {\n      changed = 1;\n      a[i] = 1;\n    }\n  return changed;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"int strhash_name_conflict(char *str) {\n  int hash = 0;\n  while (*str)\n    hash = hash * 13 + *str++;\n  return hash;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"char *Strsafe_name_conflict(char *s) {\n  char *p;\n\n  p = Strsafe_name_conflict_find(s);\n  if (p == NULL) {\n    p = malloc(strlen(s) + 1);\n    if (p != NULL) {\n      strcpy(p, s);\n      if (!Strsafe_name_conflict_insert(p))\n        p = NULL;\n    }\n  }\n  if (p == NULL)\n    memory_error();\n  return p;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"int Strsafe_insert_name_conflict(char *s) {\n  int h, i, n;\n  struct strsafe_entry *p;\n  struct strsafe_entry *new_table;\n  struct strsafe_entry **new_hash;\n\n  if (x1a == NULL)\n    return 0;\n\n  h = strhash(s);\n  for (p = x1a->table[h & (x1a->size - 1)]; p != NULL; p = p->next)\n    if (!strcmp(p->s, s))\n      return 0;\n\n  if (x1a->count >= x1a->size) {\n    n = x1a->size * 2;\n    new_table =\n        (struct strsafe_entry *)malloc(n * sizeof(struct strsafe_entry));\n    if (new_table == NULL)\n      return 0;\n    new_hash = (struct strsafe_entry **)&new_table[n];\n    for (i = 0; i < n; i++)\n      new_hash[i] = NULL;\n    for (i = 0; i < x1a->count; i++) {\n      p = &x1a->table[i];\n      h = strhash(p->s) & (n - 1);\n      if (new_hash[h] != NULL)\n        new_hash[h]->next = &new_table[i + 1];\n      new_table[i + 1].next = new_hash[h];\n      new_table[i + 1].s = p->s;\n      new_table[i + 1].prev = &new_table[h];\n      new_hash[h] = &new_table[i + 1];\n    }\n    free(x1a->table);\n    x1a->size = n;\n    x1a->table = new_table;\n    x1a->hash = new_hash;\n  }\n\n  h = h & (x1a->size - 1);\n  p = &x1a->table[x1a-","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"char *Strsafe_find_name_conflict(char *s) {\n  int h;\n  struct strsafe_entry *e;\n\n  if (x1a == NULL)\n    return NULL;\n\n  h = strhash(s) & (x1a->size - 1);\n  e = x1a->table[h];\n  while (e != NULL) {\n    if (!strcmp(e->s, s))\n      return e->s;\n    e = e->next;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"int Symbol_count_name_conflict() {\n  if (x2a == NULL)\n    return 0;\n  return x2a->count;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"int findbreak_name_conflict(char *s, int start, int max) {\n  int i, j;\n\n  i = start;\n  j = start;\n  while (j <= max) {\n    if (s[j] == '\\t')\n      s[j] = ' ';\n    if (s[j] == '\\n') {\n      s[j] = ' ';\n      return j;\n    }\n    if (s[j] == '\\0')\n      return j;\n    if (s[j] == '-' && j < max - 1)\n      i = j + 1;\n    if (s[j] == ' ')\n      i = j;\n    j++;\n  }\n  return i;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int argindex_name_conflict(int n) {\n  int i;\n  int found = 0;\n\n  if (argv == NULL || argv[0] == NULL)\n    return -1;\n\n  for (i = 1; argv[i] != NULL; i++) {\n    if (found || (argv[i][0] != '-' && argv[i][0] != '+' &&\n                  strchr(argv[i], '=') == NULL)) {\n      if (n-- == 0)\n        return i;\n    }\n    if (!strcmp(argv[i], \"--\"))\n      found = 1;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"int OptNArgs_name_conflict(void) {\n  int i, n;\n  int flag;\n\n  n = 0;\n  flag = 0;\n  if (argv) {\n    if (argv[0]) {\n      for (i = 1; argv[i]; i++) {\n        if (flag || argv[i][0] == '-' || argv[i][0] == '+' ||\n            strchr(argv[i], '=')) {\n          n++;\n        }\n        if (!strcmp(argv[i], \"--\")) {\n          flag = 1;\n        }\n      }\n    }\n  }\n  return n;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"char *OptArg_name_conflict(int opt) {\n  int i;\n\n  i = argindex(opt);\n  if (i < 0)\n    return NULL;\n  else\n    return argv[i];\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"void preprocess_input_name_conflict(char *pzInput) {\n  int i, j, k, nLine, nDepth, nStart, nEnd, nDefined;\n\n  nDepth = 0;\n  nLine = 1;\n  for (i = 0; pzInput[i]; i++) {\n    if (pzInput[i] == '\\n')\n      nLine++;\n    if (pzInput[i] == '%' && (i == 0 || pzInput[i - 1] == '\\n')) {\n      if (!strncmp(pzInput + i, \"%endif\", 6) &&\n          (__ctype_b_loc()[(unsigned char)pzInput[i + 6]] & 0x2000)) {\n        if (nDepth) {\n          nDepth--;\n          if (nDepth == 0) {\n            for (j = nStart; j < i; j++)\n              if (pzInput[j] != '\\n')\n                pzInput[j] = ' ';\n          }\n        }\n        for (j = i; pzInput[j] && pzInput[j] != '\\n'; j++)\n          pzInput[j] = ' ';\n      } else if (!strncmp(pzInput + i, \"%ifdef\", 6) &&\n                 (__ctype_b_loc()[(unsigned char)pzInput[i + 6]] & 0x2000)) {\n        if (nDepth)\n          nDepth++;\n        else {\n          for (j = i + 6; __ctype_b_loc()[(unsigned char)pzInput[j]] & 0x2000;\n               j++)\n            ;\n          nStart = j;\n          for (j = 0;\n               pzInput[nStart + j] &&\n               !(__ctype_b_loc()[(unsigned char)pzInput[nStart + j]] & 0x2000);\n               j++)\n            ;\n          nEnd = j;\n          nDefined = 0;\n                    for (k = 0; k < n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"char *pathsearch_name_conflict(char *path, char *name, int mode) {\n  char *p, *q, *r, *s;\n  char c;\n\n  if ((p = strrchr(path, '/'))) {\n    c = *p;\n    *p = '\\0';\n    s = malloc(strlen(path) + strlen(name) + 2);\n    if (s) {\n      sprintf(s, \"%s/%s\", path, name);\n    }\n    *p = c;\n    return s;\n  }\n\n  if (!(s = getenv(\"PATH\"))) {\n    s = \".:/bin:/usr/bin\";\n  }\n\n  r = malloc(strlen(s) + strlen(name) + 2);\n  if (!r) {\n    return NULL;\n  }\n\n  while (*s) {\n    if ((q = strchr(s, ':'))) {\n      c = *q;\n      *q = '\\0';\n    } else {\n      q = s + strlen(s);\n    }\n    sprintf(r, \"%s/%s\", s, name);\n    if (q) {\n      *q = c;\n      if (c) {\n        s = q + 1;\n      } else {\n        s = \"\";\n      }\n    } else {\n      s = \"\";\n    }\n    if (!access(r, mode)) {\n      return r;\n    }\n  }\n\n  return r;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"const char *minimum_size_type_name_conflict(int min, int max) {\n  if (min >= 0) {\n    if (max <= 255)\n      return \"unsigned char\";\n    else if (max <= 65535)\n      return \"unsigned short int\";\n    else\n      return \"unsigned int\";\n  } else {\n    if (min >= -127 && max <= 127)\n      return \"signed char\";\n    else if (min >= -32767 && max <= 32767)\n      return \"short\";\n    else\n      return \"int\";\n  }\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"char *SetNew_name_conflict(void) {\n  char *set;\n  int i;\n\n  set = (char *)malloc(size);\n  if (set == NULL)\n    memory_error();\n\n  for (i = 0; i < size; i++)\n    set[i] = 0;\n\n  return set;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"int SetAdd_name_conflict(char *set, int index) {\n  char old = set[index];\n  set[index] = 1;\n  return old == 0;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"int SetUnion_name_conflict(char *a, char *b) {\n  int i, changed = 0;\n\n  for (i = 0; i < size; i++)\n    if (b[i] && !a[i]) {\n      changed = 1;\n      a[i] = 1;\n    }\n  return changed;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"int strhash_name_conflict(char *str) {\n  int hash = 0;\n  while (*str)\n    hash = hash * 13 + *str++;\n  return hash;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"char *Strsafe_name_conflict(char *s) {\n  char *p;\n\n  p = Strsafe_name_conflict_find(s);\n  if (p == NULL) {\n    p = malloc(strlen(s) + 1);\n    if (p != NULL) {\n      strcpy(p, s);\n      if (!Strsafe_name_conflict_insert(p))\n        p = NULL;\n    }\n  }\n  if (p == NULL)\n    memory_error();\n  return p;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"int Strsafe_insert_name_conflict(char *s) {\n  int h, i, n;\n  struct strsafe_entry *p;\n  struct strsafe_entry *new_table;\n  struct strsafe_entry **new_hash;\n\n  if (x1a == NULL)\n    return 0;\n\n  h = strhash(s);\n  for (p = x1a->table[h & (x1a->size - 1)]; p != NULL; p = p->next)\n    if (!strcmp(p->s, s))\n      return 0;\n\n  if (x1a->count >= x1a->size) {\n    n = x1a->size * 2;\n    new_table =\n        (struct strsafe_entry *)malloc(n * sizeof(struct strsafe_entry));\n    if (new_table == NULL)\n      return 0;\n    new_hash = (struct strsafe_entry **)&new_table[n];\n    for (i = 0; i < n; i++)\n      new_hash[i] = NULL;\n    for (i = 0; i < x1a->count; i++) {\n      p = &x1a->table[i];\n      h = strhash(p->s) & (n - 1);\n      if (new_hash[h] != NULL)\n        new_hash[h]->next = &new_table[i + 1];\n      new_table[i + 1].next = new_hash[h];\n      new_table[i + 1].s = p->s;\n      new_table[i + 1].prev = &new_table[h];\n      new_hash[h] = &new_table[i + 1];\n    }\n    free(x1a->table);\n    x1a->size = n;\n    x1a->table = new_table;\n    x1a->hash = new_hash;\n  }\n\n  h = h & (x1a->size - 1);\n  p = &x1a->table[x1a-","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"char *Strsafe_find_name_conflict(char *s) {\n  int h;\n  struct strsafe_entry *e;\n\n  if (x1a == NULL)\n    return NULL;\n\n  h = strhash(s) & (x1a->size - 1);\n  e = x1a->table[h];\n  while (e != NULL) {\n    if (!strcmp(e->s, s))\n      return e->s;\n    e = e->next;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"int Symbol_count_name_conflict() {\n  if (x2a == NULL)\n    return 0;\n  return x2a->count;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"int findbreak_name_conflict(char *s, int start, int max) {\n  int i, j;\n\n  i = start;\n  j = start;\n  while (j <= max) {\n    if (s[j] == '\\t')\n      s[j] = ' ';\n    if (s[j] == '\\n') {\n      s[j] = ' ';\n      return j;\n    }\n    if (s[j] == '\\0')\n      return j;\n    if (s[j] == '-' && j < max - 1)\n      i = j + 1;\n    if (s[j] == ' ')\n      i = j;\n    j++;\n  }\n  return i;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int argindex_name_conflict(int n) {\n  int i;\n  int found = 0;\n\n  if (argv == NULL || argv[0] == NULL)\n    return -1;\n\n  for (i = 1; argv[i] != NULL; i++) {\n    if (found || (argv[i][0] != '-' && argv[i][0] != '+' &&\n                  strchr(argv[i], '=') == NULL)) {\n      if (n-- == 0)\n        return i;\n    }\n    if (!strcmp(argv[i], \"--\"))\n      found = 1;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":1,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"int OptNArgs_name_conflict(void) {\n  int i, n;\n  int flag;\n\n  n = 0;\n  flag = 0;\n  if (argv) {\n    if (argv[0]) {\n      for (i = 1; argv[i]; i++) {\n        if (flag || argv[i][0] == '-' || argv[i][0] == '+' ||\n            strchr(argv[i], '=')) {\n          n++;\n        }\n        if (!strcmp(argv[i], \"--\")) {\n          flag = 1;\n        }\n      }\n    }\n  }\n  return n;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"char *OptArg_name_conflict(int opt) {\n  int i;\n\n  i = argindex(opt);\n  if (i < 0)\n    return NULL;\n  else\n    return argv[i];\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"void preprocess_input_name_conflict(char *pzInput) {\n  int i, j, k, nLine, nDepth, nStart, nEnd, nDefined;\n\n  nDepth = 0;\n  nLine = 1;\n  for (i = 0; pzInput[i]; i++) {\n    if (pzInput[i] == '\\n')\n      nLine++;\n    if (pzInput[i] == '%' && (i == 0 || pzInput[i - 1] == '\\n')) {\n      if (!strncmp(pzInput + i, \"%endif\", 6) &&\n          (__ctype_b_loc()[(unsigned char)pzInput[i + 6]] & 0x2000)) {\n        if (nDepth) {\n          nDepth--;\n          if (nDepth == 0) {\n            for (j = nStart; j < i; j++)\n              if (pzInput[j] != '\\n')\n                pzInput[j] = ' ';\n          }\n        }\n        for (j = i; pzInput[j] && pzInput[j] != '\\n'; j++)\n          pzInput[j] = ' ';\n      } else if (!strncmp(pzInput + i, \"%ifdef\", 6) &&\n                 (__ctype_b_loc()[(unsigned char)pzInput[i + 6]] & 0x2000)) {\n        if (nDepth)\n          nDepth++;\n        else {\n          for (j = i + 6; __ctype_b_loc()[(unsigned char)pzInput[j]] & 0x2000;\n               j++)\n            ;\n          nStart = j;\n          for (j = 0;\n               pzInput[nStart + j] &&\n               !(__ctype_b_loc()[(unsigned char)pzInput[nStart + j]] & 0x2000);\n               j++)\n            ;\n          nEnd = j;\n          nDefined = 0;\n                    for (k = 0; k < n","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"char *pathsearch_name_conflict(char *path, char *name, int mode) {\n  char *p, *q, *r, *s;\n  char c;\n\n  if ((p = strrchr(path, '/'))) {\n    c = *p;\n    *p = '\\0';\n    s = malloc(strlen(path) + strlen(name) + 2);\n    if (s) {\n      sprintf(s, \"%s/%s\", path, name);\n    }\n    *p = c;\n    return s;\n  }\n\n  if (!(s = getenv(\"PATH\"))) {\n    s = \".:/bin:/usr/bin\";\n  }\n\n  r = malloc(strlen(s) + strlen(name) + 2);\n  if (!r) {\n    return NULL;\n  }\n\n  while (*s) {\n    if ((q = strchr(s, ':'))) {\n      c = *q;\n      *q = '\\0';\n    } else {\n      q = s + strlen(s);\n    }\n    sprintf(r, \"%s/%s\", s, name);\n    if (q) {\n      *q = c;\n      if (c) {\n        s = q + 1;\n      } else {\n        s = \"\";\n      }\n    } else {\n      s = \"\";\n    }\n    if (!access(r, mode)) {\n      return r;\n    }\n  }\n\n  return r;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"const char *minimum_size_type_name_conflict(int min, int max) {\n  if (min >= 0) {\n    if (max <= 255)\n      return \"unsigned char\";\n    else if (max <= 65535)\n      return \"unsigned short int\";\n    else\n      return \"unsigned int\";\n  } else {\n    if (min >= -127 && max <= 127)\n      return \"signed char\";\n    else if (min >= -32767 && max <= 32767)\n      return \"short\";\n    else\n      return \"int\";\n  }\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"char *SetNew_name_conflict(void) {\n  char *set;\n  int i;\n\n  set = (char *)malloc(size);\n  if (set == NULL)\n    memory_error();\n\n  for (i = 0; i < size; i++)\n    set[i] = 0;\n\n  return set;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":1,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"int SetAdd_name_conflict(char *set, int index) {\n  char old = set[index];\n  set[index] = 1;\n  return old == 0;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":1,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"int SetUnion_name_conflict(char *a, char *b) {\n  int i, changed = 0;\n\n  for (i = 0; i < size; i++)\n    if (b[i] && !a[i]) {\n      changed = 1;\n      a[i] = 1;\n    }\n  return changed;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":1,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"int strhash_name_conflict(char *str) {\n  int hash = 0;\n  while (*str)\n    hash = hash * 13 + *str++;\n  return hash;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"char *Strsafe_name_conflict(char *s) {\n  char *p;\n\n  p = Strsafe_name_conflict_find(s);\n  if (p == NULL) {\n    p = malloc(strlen(s) + 1);\n    if (p != NULL) {\n      strcpy(p, s);\n      if (!Strsafe_name_conflict_insert(p))\n        p = NULL;\n    }\n  }\n  if (p == NULL)\n    memory_error();\n  return p;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"int Strsafe_insert_name_conflict(char *s) {\n  int h, i, n;\n  struct strsafe_entry *p;\n  struct strsafe_entry *new_table;\n  struct strsafe_entry **new_hash;\n\n  if (x1a == NULL)\n    return 0;\n\n  h = strhash(s);\n  for (p = x1a->table[h & (x1a->size - 1)]; p != NULL; p = p->next)\n    if (!strcmp(p->s, s))\n      return 0;\n\n  if (x1a->count >= x1a->size) {\n    n = x1a->size * 2;\n    new_table =\n        (struct strsafe_entry *)malloc(n * sizeof(struct strsafe_entry));\n    if (new_table == NULL)\n      return 0;\n    new_hash = (struct strsafe_entry **)&new_table[n];\n    for (i = 0; i < n; i++)\n      new_hash[i] = NULL;\n    for (i = 0; i < x1a->count; i++) {\n      p = &x1a->table[i];\n      h = strhash(p->s) & (n - 1);\n      if (new_hash[h] != NULL)\n        new_hash[h]->next = &new_table[i + 1];\n      new_table[i + 1].next = new_hash[h];\n      new_table[i + 1].s = p->s;\n      new_table[i + 1].prev = &new_table[h];\n      new_hash[h] = &new_table[i + 1];\n    }\n    free(x1a->table);\n    x1a->size = n;\n    x1a->table = new_table;\n    x1a->hash = new_hash;\n  }\n\n  h = h & (x1a->size - 1);\n  p = &x1a->table[x1a-","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"char *Strsafe_find_name_conflict(char *s) {\n  int h;\n  struct strsafe_entry *e;\n\n  if (x1a == NULL)\n    return NULL;\n\n  h = strhash(s) & (x1a->size - 1);\n  e = x1a->table[h];\n  while (e != NULL) {\n    if (!strcmp(e->s, s))\n      return e->s;\n    e = e->next;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":1,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"int Symbol_count_name_conflict() {\n  if (x2a == NULL)\n    return 0;\n  return x2a->count;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int parseHex(const char *buf, unsigned long *value) {\n    int len = 0;\n    char ch;\n    *value = 0;\n    while ((ch = buf[len]) != '\\x00')\n        {\n            if (ch >= '0' && ch <= '9') {\n                *value = *value * 16 + (unsigned long)(ch - '0');\n            } else if (ch >= 'A' && ch <= 'F') {\n                *value = *value * 16 + (unsigned long)(ch - 'A' + 10);\n            } else if (ch >= 'a' && ch <= 'f') {\n                *value = *value * 16 + (unsigned long)(ch - 'a' + 10);\n            } else {\n                break;\n            }\n            ++len;\n        }\n    return len;\n}\n","function_prediction":"int parseHex_name_conflict(const char *str, uint32_t *value) {\n  int i;\n  *value = 0;\n  for (i = 0; str[i]; i++) {\n    if (str[i] >= '0' && str[i] <= '9') {\n      *value = (*value << 4) + (str[i] - '0');\n    } else if (str[i] >= 'A' && str[i] <= 'F') {\n      *value = (*value << 4) + (str[i] - 'A' + 10);\n    } else if (str[i] >= 'a' && str[i] <= 'f') {\n      *value = (*value << 4) + (str[i] - 'a' + 10);\n    } else {\n      break;\n    }\n  }\n  return i;\n}","pass":0,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/ucm2cp.c"}
{"compilable":0,"function":"static int parseHex(const char *buf, unsigned long *value) {\n    int len = 0;\n    char ch;\n    *value = 0;\n    while ((ch = buf[len]) != '\\x00')\n        {\n            if (ch >= '0' && ch <= '9') {\n                *value = *value * 16 + (unsigned long)(ch - '0');\n            } else if (ch >= 'A' && ch <= 'F') {\n                *value = *value * 16 + (unsigned long)(ch - 'A' + 10);\n            } else if (ch >= 'a' && ch <= 'f') {\n                *value = *value * 16 + (unsigned long)(ch - 'a' + 10);\n            } else {\n                break;\n            }\n            ++len;\n        }\n    return len;\n}\n","function_prediction":"int parseHex_name_conflict(const char *str, uint32_t *value) {\n  int i;\n  *value = 0;\n  for (i = 0; str[i]; i++) {\n    if (str[i] >= '0' && str[i] <= '9') {\n      *value = (*value << 4) + (str[i] - '0');\n    } else if (str[i] >= 'A' && str[i] <= 'F') {\n      *value = (*value << 4) + (str[i] - 'A' + 10);\n    } else if (str[i] >= 'a' && str[i] <= 'f') {\n      *value = (*value << 4) + (str[i] - 'a' + 10);\n    } else {\n      break;\n    }\n  }\n  return i;\n}","pass":0,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/uni2tab.c"}
{"compilable":1,"function":"static int createTables(void) {\n    FILE *file;\n    if ((file = fopen(\"jis.table\", \"wb\")) == ((void *)0)) {\n        if ((file = fopen(\"jis.table\", \"wb\")) == ((void *)0)) {\n            perror(\"jis.table\");\n            return 1;\n        }\n    }\n    writeJis(file);\n    fclose(file);\n    return 0;\n}\n","function_prediction":"int createTables_name_conflict(void) {\n  FILE *fp;\n\n  if ((fp = fopen(\"jis.table\", \"wb\")) == NULL)\n    if ((fp = fopen(\"jis.table\", \"wb\")) == NULL) {\n      perror(\"jis.table\");\n      return 1;\n    }\n\n  writeJis(fp);\n  fclose(fp);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/uni2tab.c"}
{"compilable":1,"function":"int wordCount(char *sentence_array, int *numWords) {\n    if (sentence_array == '\\x00') {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    *numWords = CountWords(sentence_array, 0, 0, 1000);\n    return 0;\n}\n","function_prediction":"int wordCount_name_conflict(char *array, int *count) {\n  if (array == NULL) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n\n  *count = CountWords(array, 0, 0, 1000);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int CountWords(char *sentence_array, int count, int start, int maxSize) {\n    if (count < 0) {\n        printf(\"ERROR: count needs to be greater than 0.\\n\");\n        return 1;\n    }\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (start > maxSize) {\n        printf(\"ERROR: the start point was greater than the max size.\\n\");\n        return 1;\n    }\n    if (start < 0 || maxSize < 0) {\n        printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n        return 1;\n    }\n    if (sentence_array[0] == ' ') {\n        printf(\"ERROR: the first character in the array was empty. Please start your sentence from the beginning.\\n\");\n        return 1;\n    }\n    int a = 0;\n    while (sentence_array[a] != '\\x00')\n        {\n            a++;\n        }\n    maxSize = a;\n    if (sentence_array[start] == ' ' && sentence_array[start - 1] != ' ' && start != (maxSize - 1)) {\n        count = count + 1;\n    }\n    if (start != maxSize) {\n        count = CountWords(sentence_array, count, (start + 1), maxSize);\n    }\n    if (start == maxSize) {\n        count++;\n        printf(\"number of words: %d\\n\", count);\n        return count;\n    }\n    return count;\n}\n","function_prediction":"int CountWords_name_conflict(char *array, int count, int start, int max) {\n  if (count < 0) {\n    printf(\"ERROR: count needs to be greater than 0.\\n\");\n    return 1;\n  }\n  if (array == NULL) {\n    printf(\"ERROR: array entered was null.\\n\");\n    return 1;\n  }\n  if (start > max) {\n    printf(\"ERROR: the start point was greater than the max size.\\n\");\n    return 1;\n  }\n  if (start < 0 || max < 0) {\n    printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n    return 1;\n  }\n  if (array[0] == ' ') {\n    printf(\"ERROR: the first character in the array was empty. Please start \"\n           \"your sentence from the beginning.\\n\");\n    return 1;\n  }\n\n  int i;\n  for (i = 0; array[i] != '\\0'; i++) {\n  }\n  int length = i;\n\n  if (array[start] == ' ' && array[start - 1] != ' ' && start != length - 1) {\n    count++;\n  }\n\n  if (start == length) {\n    count++;\n    printf(\"number of words: %d\\n\", count);\n    return count;\n  } else {\n    return CountWords_name_conflict(array, count, start + 1, length);\n  }\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int wordRemove(char *sentence_array, char *word) {\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (word == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    int sizeSentence = 0;\n    while (sentence_array[sizeSentence] != '\\x00')\n        {\n            sizeSentence++;\n        }\n    int sizeWord = 0;\n    while (word[sizeWord] != '\\x00')\n        {\n            sizeWord++;\n        }\n    int head = -1, scanner, stop = sizeSentence - sizeWord;\n    int found = 0;\n    while (head <= stop && found == 0)\n        {\n            head++;\n            scanner = 0;\n            if (sentence_array[head] == word[0]) {\n                while (scanner < sizeWord)\n                    {\n                        found = 1;\n                        if (sentence_array[head + scanner] != word[scanner]) {\n                            found = 0;\n                            break;\n                        }\n                        scanner++;\n                    }\n            }\n        }\n    int i = head;\n    while (sentence_array[i + sizeWord] != '\\x00')\n        {\n            sentence_array[i] = sentence_array[i + sizeWord];\n            i++;\n        }\n    sentence_array[i] = '\\x00';\n    return 0;\n}\n","function_prediction":"int wordRemove_name_conflict(char *array, char *word) {\n  if (array == NULL) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n  if (word == NULL) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n\n  int arrayLength = 0;\n  int wordLength = 0;\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int match = 0;\n\n  while (array[arrayLength] != '\\0') {\n    arrayLength++;\n  }\n  while (word[wordLength] != '\\0') {\n    wordLength++;\n  }\n\n  for (i = -1; i < arrayLength - wordLength; i++) {\n    if (array[i] == word[0]) {\n      match = 1;\n      for (j = 0; j < wordLength; j++) {\n        if (array[i + j] != word[j]) {\n          match = 0;\n          break;\n        }\n      }\n      if (match == 1) {\n        break;\n      }\n    }\n  }\n\n  for (k = i; array[k] != '\\0'; k++) {\n    array[k] = array[k + wordLength];\n  }\n  array[k] = '\\0';\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int vowelCheck(char *array, int *vowels) {\n    int i;\n    *vowels = 0;\n    for (i = 0; array[i] != '\\x00'; i++) {\n        if ((array[i] == 'a' || array[i] == 'e' || array[i] == 'i' || array[i] == 'o' || array[i] == 'u') || (array[i] == 'A' || array[i] == 'E' || array[i] == 'I' || array[i] == 'O' || array[i] == 'U')) {\n            *vowels = *vowels + 1;\n        }\n    }\n    printf(\"No. of vowels in %s = %d\\n\", array, *vowels);\n    return 0;\n}\n","function_prediction":"int vowelCheck_name_conflict(char *str, int *vowelCount) {\n  *vowelCount = 0;\n  int i;\n  for (i = 0; str[i] != '\\0'; i++) {\n    if (str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' ||\n        str[i] == 'u' || str[i] == 'A' || str[i] == 'E' || str[i] == 'I' ||\n        str[i] == 'O' || str[i] == 'U') {\n      *vowelCount = *vowelCount + 1;\n    }\n  }\n  printf(\"No. of vowels in %s = %d\\n\", str, *vowelCount);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int subString(char *array1, int index1, int index2) {\n    int position;\n    int i = 0;\n    char input2[100];\n    if (array1 == ((void *)0)) {\n        return 1;\n    }\n    position = index1;\n    for (i = 0; array1[i] != '\\x00'; i++ , position++) {\n        if (position <= index2) {\n            array1[i] = array1[position];\n        } else {\n            array1[i] = ((void *)0);\n        }\n    }\n    return 0;\n}\n","function_prediction":"int subString_name_conflict(char *str, int start, int end) {\n  if (str == NULL) {\n    return 1;\n  }\n\n  int i = 0;\n  int j = start;\n  while (str[i] != '\\0') {\n    if (j <= end) {\n      str[i] = str[j];\n    } else {\n      str[i] = '\\0';\n    }\n    i++;\n    j++;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int concatenateStrings(char *str1, char *str2) {\n    int firstArrayLength = 0;\n    int secondArrayLength = 0;\n    while (str1[firstArrayLength] != '\\x00')\n        {\n            firstArrayLength++;\n        }\n    printf(\"%d\", firstArrayLength);\n    while (str2[secondArrayLength] != '\\x00')\n        {\n            str1[firstArrayLength] = str2[secondArrayLength];\n            secondArrayLength++;\n            firstArrayLength++;\n        }\n    str1[firstArrayLength] = '\\x00';\n    return 0;\n}\n","function_prediction":"int concatenateStrings_name_conflict(char *s1, char *s2) {\n  int i = 0, j = 0;\n  while (s1[i] != '\\0') {\n    i++;\n  }\n  printf(\"%d\", i);\n  while (s2[j] != '\\0') {\n    s1[i] = s2[j];\n    i++;\n    j++;\n  }\n  s1[i] = '\\0';\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int printString() {\n    char mystring[50];\n    printf(\"Please type a string\\n\\n\");\n    scanf(\"\\n%50[^\\n]s\", mystring);\n    printf(\"%s\\n\", mystring);\n}\n","function_prediction":"int printStringWLen(char *str, int *len) {\n  char str2[50];\n  int i;\n\n  if (str[0] == '\\0') {\n    printf(\"Error -- array is null\");\n    return 1;\n  }\n\n  for (i = 0; str[i] != '\\0'; i++) {\n  }\n\n  *len = i;\n\n  printf(\"You Entered:%s\\n\", str);\n  printf(\"The Length of the string is: %d\\n\", *len);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int printStringWLen(char *array, int *length) {\n    if (array[0] == '\\x00') {\n        printf(\"Error -- array is null\");\n        return 1;\n    }\n    int number = 0;\n    while (array[number] != '\\x00')\n        {\n            number++;\n        }\n    *length = number;\n    printf(\"You Entered:%s\\n\", array);\n    printf(\"The Length of the string is: %d\\n\", *length);\n    return 0;\n}\n","function_prediction":"int printStringWLen_name_conflict(char *str, int *len) {\n  int i;\n  if (str[0] == '\\0') {\n    printf(\"Error -- array is null\");\n    return 1;\n  }\n  for (i = 0; str[i] != '\\0'; i++)\n    ;\n  *len = i;\n  printf(\"You Entered:%s\\n\", str);\n  printf(\"The Length of the string is: %d\\n\", *len);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int alphaNumeric(char ch) {\n    if (ch >= '0' && ch <= '9') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'A' && ch <= 'Z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'a' && ch <= 'z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else {\n        printf(\"%c is not alphanumeric.\\n\", ch);\n    }\n    return 0;\n}\n","function_prediction":"int alphaNumeric_name_conflict(char c) {\n  if (c >= '0' && c <= '9') {\n    printf(\"|%c| is alphanumeric.\\n\", c);\n  } else if (c >= 'A' && c <= 'Z') {\n    printf(\"|%c| is alphanumeric.\\n\", c);\n  } else if (c >= 'a' && c <= 'z') {\n    printf(\"|%c| is alphanumeric.\\n\", c);\n  } else {\n    printf(\"%c is not alphanumeric.\\n\", c);\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int testFindLength() {\n    int i, strLength, strLengthResponse = -5, returnValue;\n    for (i = 0; i < numArrays; i++) {\n        strLength = strings[i].length;\n        char *string = malloc(strLength * sizeof(char));\n        string = strings[i].value;\n        strLength = strlen(string);\n        returnValue = printStringWLen(string, &strLengthResponse);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strLengthResponse == -5) {\n            return -2;\n        }\n        if (strLengthResponse != strLength) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int testFindLength_name_conflict() {\n  int i, j, len, maxLen = -5;\n  char *str;\n  for (i = 0; i < numArrays; i++) {\n    len = strings[i].len;\n    str = (char *)malloc(len);\n    str = strings[i].str;\n    len = strlen(str);\n    if (printStringWLen(str, &maxLen)) {\n      return 1;\n    }\n    if (maxLen == -5) {\n      return -2;\n    }\n    if (len != maxLen) {\n      return -1;\n    }\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testVowels() {\n    int i, e, numVowels, strLength, strVowelResponse, returnValue;\n    for (e = 0; e < numArrays; e++) {\n        loadArrays();\n        strLength = strings[e].length;\n        char *string = malloc(strLength);\n        string = strings[e].value;\n        numVowels = 0;\n        strVowelResponse = -5;\n        for (i = 0; string[i] != '\\x00'; i++) {\n            if (string[i] == 'a' || string[i] == 'e' || string[i] == 'i' || string[i] == 'o' || string[i] == 'u' || string[i] == 'A' || string[i] == 'E' || string[i] == 'I' || string[i] == 'O' || string[i] == 'U')\n                numVowels++;\n        }\n        returnValue = vowelCheck(string, &strVowelResponse);\n        printf(\"Num Vowels Response -- %d\\n\", strVowelResponse);\n        printf(\"Num Vowels -- %d\\n\", numVowels);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strVowelResponse == -5) {\n            return -2;\n        }\n        if (strVowelResponse != numVowels) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int testVowels_name_conflict() {\n\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n\n  for (i = 0; i < numArrays; i++) {\n\n    loadArrays(i);\n\n    int stringLength = strings[i].length;\n    char *string = (char *)malloc(stringLength);\n    string = strings[i].string;\n\n    int numVowels = 0;\n    int numVowelsResponse = -5;\n\n    for (j = 0; string[j] != '\\0'; j++) {\n      if (string[j] == 'a' || string[j] == 'e' || string[j] == 'i' ||\n          string[j] == 'o' || string[j] == 'u' || string[j] == 'A' ||\n          string[j] == 'E' || string[j] == 'I' || string[j] == 'O' ||\n          string[j] == 'U') {\n        numVowels++;\n      }\n    }\n\n    int vowelCheckResponse = vowelCheck(string, &numVowelsResponse);\n\n    printf(\"Num Vowels Response -- %d\\n\", numVowelsResponse);\n    printf(\"Num Vowels -- %d\\n\", numVowels);\n\n    if (vowelCheckResponse != 0) {\n      return 1;\n    }\n    if (numVowelsResponse == -5) {\n      return -2;\n    }\n    if (numVowelsResponse != numVowels) {\n      return -1;\n    }\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testNumberWords() {\n    int i, e, numWords, strLength, strWordResponse = -5, returnValue;\n    for (e = 0; e < numArrays; e++) {\n        loadArrays();\n        strLength = strings[e].length;\n        char *string = malloc(strLength);\n        string = strings[e].value;\n        string[0] = 'A';\n        numWords = 1;\n        strWordResponse = 0;\n        for (i = 1; string[i] != '\\x00'; i++) {\n            if ((string[i] == ' ' && string[i - 1] != ' ')) {\n                numWords++;\n            }\n        }\n        returnValue = wordCount(string, &strWordResponse);\n        printf(\"\\n\\n%s\\n NUMBER OF WORDS my %d theirs %d\\n\\n\", string, numWords, strWordResponse);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strWordResponse == -5) {\n            return -2;\n        }\n        if (strWordResponse != numWords) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int testNumberWords_name_conflict() {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  int result, expected;\n  char *string;\n  int length;\n\n  expected = -5;\n  for (i = 0; i < numArrays; i++) {\n    loadArrays(i);\n    length = strings[i].length;\n    string = (char *)malloc(length);\n    string = strings[i].string;\n    string[0] = 'A';\n    expected = 1;\n    result = -5;\n    for (j = 1; string[j] != '\\0'; j++) {\n      if (string[j] == ' ' && string[j - 1] != ' ') {\n        expected++;\n      }\n    }\n    result = wordCount(string, &result);\n    printf(\"\\n\\n%s\\n NUMBER OF WORDS my %d theirs %d\\n\\n\", string, expected,\n           result);\n    if (result != 0) {\n      return 1;\n    }\n    if (result == -5) {\n      return -2;\n    }\n    if (result != expected) {\n      return -1;\n    }\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":1,"function":"int testAlphaNumericChar() {\n    int value;\n    int first;\n    int second;\n    int third;\n    value = alphaNumeric('n');\n    if (value == 0) {\n        first = 0;\n    }\n    if (value == 1) {\n        first = 1;\n    }\n    value = alphaNumeric('9');\n    if (value == 0) {\n        second = 0;\n    }\n    if (value == 1) {\n        second = 1;\n    }\n    value = alphaNumeric('!');\n    if (value == 0) {\n        third = 0;\n    }\n    if (value == 1) {\n        third = 1;\n    }\n    if (third == 0 && second == 0 && first == 0) {\n        return 0;\n    } else\n        return 1;\n}\n","function_prediction":"int testAlphaNumericChar_name_conflict() {\n  int n = 0;\n  int nine = 0;\n  int exclamation = 0;\n\n  if (alphaNumeric('n') == 0) {\n    n = 0;\n  }\n  if (alphaNumeric('n') == 1) {\n    n = 1;\n  }\n\n  if (alphaNumeric('9') == 0) {\n    nine = 0;\n  }\n  if (alphaNumeric('9') == 1) {\n    nine = 1;\n  }\n\n  if (alphaNumeric('!') == 0) {\n    exclamation = 0;\n  }\n  if (alphaNumeric('!') == 1) {\n    exclamation = 1;\n  }\n\n  if (n == 0 && nine == 0 && exclamation == 0) {\n    return 0;\n  }\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":1,"function":"int testSubString() {\n    char string[] = \"lucille\";\n    subString(string, 2, 5);\n    if (strcmp(string, \"cill\") != 0) {\n        printf(\"Testing Sub String -- %s\\n\", string);\n        return -1;\n    }\n    if (string == ((void *)0)) {\n        return -2;\n    }\n    return 0;\n}\n","function_prediction":"int testSubString_name_conflict() {\n  char str[] = \"culicel\";\n  subString(str, 2, 5);\n  if (!strcmp(str, \"cill\")) {\n    return 0;\n  }\n  printf(\"Testing Sub String -- %s\\n\", str);\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testConcat() {\n    char string1[500] = \"A melancholy-looking man, he had the appearance of one \";\n    char string2[] = \"who has searched for the leak in life's gas-pipe with a lighted candle - PG Wodehouse\";\n    char stringTotal[] = \"A melancholy-looking man, he had the appearance of one who has searched for the leak in life's gas-pipe with a lighted candle - PG Wodehouse\";\n    int returnValue = concatenateStrings(string1, string2);\n    if (returnValue != 0) {\n        return 1;\n    }\n    int i = 0;\n    while (stringTotal[i] != '\\x00')\n        {\n            if (string1[i] != stringTotal[i]) {\n                return -2;\n            }\n            i++;\n        }\n    return 0;\n}\n","function_prediction":"int testConcat_name_conflict() {\n  char str1[] = \"Alemonecloohylolodah\";\n  char str2[] = \"secrets of the heart of the king\";\n  char str3[100] = {0};\n  int i;\n  int result = concatenateStrings(str1, str2, str3);\n  if (result != 0) {\n    return 1;\n  }\n  for (i = 0; str3[i] != '\\0'; i++) {\n    if (str1[i] != str3[i]) {\n      return -2;\n    }\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":1,"function":"int testRemove() {\n    char chararray[] = \"mother hubbard\";\n    char removeword[] = \"hubbard\";\n    wordRemove(chararray, removeword);\n    if (strcmp(chararray, \"mother \") != 0) {\n        return 0;\n    }\n    if (strcmp(chararray, \"mother\") != 0) {\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"int testRemove_name_conflict() {\n  char str[] = \"motherhood\";\n  char word[] = \"mother\";\n  wordRemove(str, word);\n  if (!strcmp(str, \"mother \") || strcmp(str, \"mother\")) {\n    return 0;\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int generateReport(char *file) {\n    FILE *outFile;\n    outFile = fopen(file, \"a\");\n    int functionResponse, i, numFunctions = 7, numErrors = 0;\n    struct TesterFunction functions[7] = {{\"Find Length Function\", &testFindLength}, {\"Find Vowels Function\", &testVowels}, {\"Find Number of Words Function\", &testNumberWords}, {\"Test if char is alpha-numeric\", &testAlphaNumericChar}, {\"Create Substring function\", &testSubString}, {\"Contatenate Function\", &testConcat}, {\"Remove Word Function\", &testRemove}};\n    addStrings(outFile, \"\\n\\nGenerall Tests ...\\n\");\n    addStrings(outFile, \"-----------------------------------------------------------------\\n\");\n    for (i = 0; i < numFunctions; i++) {\n        functionResponse = functions[i].function();\n        printf(\"Index %d Function %s returned %d\\n\", i, functions[i].name, functionResponse);\n        addStrings(outFile, functions[i].name);\n        switch (functionResponse) {\n          case 0:\n            addStrings(outFile, \" function ---  passed all tests.\\n\\n\");\n            break;\n          case 1:\n            addStrings(outFile, \" function ---- failed to run.\\n\\n\");\n            break;\n          case -1:\n            addStrings(outFile, \" function ---- did not return the correct result\\n\\n\");\n            break;\n          case -2:\n            addStrings(outFile, \" function ---- did not return result\\n\\n\");\n            break;\n        }\n    }\n    addStrings(outFile, \"\\n\\nExtra Targeted Testing ...\\n\");\n    addStrings(outFile, \"-----------------------------------------------------------------\\n\");\n    addStrings(outFile, \"ALL PASS\");\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n-----------------------------------------------------------------\\n\");\n    printf(\"REPORT HAS BEEN SAVED in file '%s' \\n\", file);\n    printf(\"Output fclose - %d\", fclose(outFile));\n    return 0;\n}\n","function_prediction":"int generateReport_name_conflict(char *fileName) {\n  FILE *fp;\n  int i, result, numTests = 7;\n  char *testNames[7] = {\n      \"Find Length Function\",          \"Find Vowels Function\",\n      \"Find Number of Words Function\", \"Test if char is alpha-numeric\",\n      \"Create Substring function\",     \"Contatenate Function\",\n      \"Remove Word Function\"};\n  int (*testFunctions[7])() = {\n      testFindLength, testVowels, testNumberWords, testAlphaNumericChar,\n      testSubString,  testConcat, testRemove};\n\n  fp = fopen(fileName, \"a\");\n\n  addStrings(fp, \"\\n\\nGenerall Tests ...\\n\");\n  addStrings(\n      fp,\n      \"-----------------------------------------------------------------\\n\");\n\n  for (i = 0; i < numTests; i++) {\n    result = testFunctions[i]();\n    printf(\"Index %d Function %s returned %d\\n\", i, testNames[i], result);\n    addStrings(fp, testNames[i]);\n    if (result == 1) {\n      addStrings(fp, \" function ---- failed to run.\\n\\n\");\n    } else if (result == 0) {\n      addStrings(fp, \" function ---  passed all tests.\\n\\n\");\n    } else if (result == -1) {\n      addStrings(fp, \" function ---- did not return result\\n\\n\");\n    } else if (result == -2) {\n      addStrings(fp, \" function ---- did not return the correct result\\n\\n\");\n    }\n  }\n\n  addStrings(fp, \"\\n\\nExtra Targeted Testing ...\\n\");\n  addStrings(\n      fp,\n      \"-----------------------------------------------------------------\\n\");\n  addStrings(fp, \"ALL PASS\");\n\n  printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n---------------------------------------------------\"\n         \"--------------\\n\");\n    printf(\"REPORT HAS BE","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":1,"function":"int generate_random_string_array(char *array, int array_length) {\n    int i;\n    if (!array) {\n        printf(\"Error: Input array was NULL\\n\");\n        return 1;\n    }\n    if (array_length < 1) {\n        printf(\"Error: required array size < 1\\n\");\n        return 1;\n    }\n    for (i = 0; i < array_length; i++) {\n        switch (rand() % 5) {\n          case 0:\n            array[i] = 'A' + (rand() % 26);\n            break;\n          case 1:\n            array[i] = ' ';\n            break;\n          default:\n            array[i] = 'a' + (rand() % 26);\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int generate_random_string_array_name_conflict(char *array, int size) {\n  if (array == NULL) {\n    puts(\"Error: Input array was NULL\");\n    return 1;\n  }\n\n  if (size < 1) {\n    puts(\"Error: required array size < 1\");\n    return 1;\n  }\n\n  int i;\n  for (i = 0; i < size; i++) {\n    int rand_num = rand();\n    if (rand_num % 5 == 0) {\n      array[i] = 'A' + (rand() % 26);\n    } else if (rand_num % 5 == 1) {\n      array[i] = ' ';\n    } else {\n      array[i] = 'a' + (rand() % 26);\n    }\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int loadArrays() {\n    int i, currentArrayLength = 10;\n    for (i = 0; i < numArrays; i++) {\n        char array[currentArrayLength];\n        generate_random_string_array(array, currentArrayLength);\n        strings[i].value = malloc(currentArrayLength);\n        strcpy(strings[i].value, array);\n        strings[i].length = currentArrayLength;\n        currentArrayLength *= 5;\n    }\n    return 0;\n}\n","function_prediction":"int loadArrays_name_conflict() {\n\n  int i;\n  int size = 10;\n\n  for (i = 0; i < numArrays; i++) {\n    char str[size];\n    generate_random_string_array(str, size);\n    strings[i].str = malloc(size);\n    strcpy(strings[i].str, str);\n    strings[i].size = size;\n    size *= 5;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":1,"function":"int wordCount_handler(char *array) {\n    int numWords = 0;\n    wordCount(array, &numWords);\n    return 0;\n}\n","function_prediction":"int wordCount_handler_name_conflict(char *input) {\n  int count = 0;\n  wordCount(input, &count);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int wordRemove_handler(char *array) {\n    char wordToRemove[1000];\n    char sentence[1000];\n    askQuestionString(sentence, \"Enter a sentence\");\n    askQuestionString(wordToRemove, \"Enter a word to remove\");\n    wordRemove(sentence, wordToRemove);\n    printf(\"Sentence after '%s' removed -- %s\\n\", wordToRemove, sentence);\n    return 0;\n}\n","function_prediction":"int wordRemove_handler_name_conflict() {\n  char sentence[1000];\n  char word[1000];\n\n  askQuestionString(sentence, \"Enter a sentence\");\n  askQuestionString(word, \"Enter a word to remove\");\n\n  wordRemove(sentence, word);\n\n  printf(\"Sentence after '%s' removed -- %s\\n\", word, sentence);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int vowelCheck_handler(char *array) {\n    int vowels = 0;\n    vowelCheck(array, &vowels);\n    return 0;\n}\n","function_prediction":"int vowelCheck_handler_name_conflict(char *str) {\n  int count = 0;\n  vowelCheck(str, &count);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int subString_handler(char *array) {\n    int start = 0, end = 0;\n    if (askQuestionInt(&start, \"Input start of substring\") == 1 || askQuestionInt(&end, \"Input end of substring\") == 1) {\n        return 1;\n    }\n    subString(array, start, end);\n    printf(\"String has been modified -- new string -- %s\\n\", array);\n    return 0;\n}\n","function_prediction":"int subString_handler_name_conflict(char *string) {\n  int start = 0, end = 0;\n  if (askQuestionInt(&start, \"Input start of substring\") == 1)\n    return 1;\n  if (askQuestionInt(&end, \"Input end of substring\") == 1)\n    return 1;\n  subString(string, start, end);\n  printf(\"String has been modified -- new string -- %s\\n\", string);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int concatStrings_handler(char *array) {\n    char one[100], two[100];\n    if (askQuestionString(one, \"Input first of string\") == 1 || askQuestionString(two, \"Input second of string\") == 1) {\n        return 1;\n    }\n    concatenateStrings(one, two);\n    printf(\"Concatenated Strings -- %s\\n\", one);\n    return 0;\n}\n","function_prediction":"int concatStrings_handler_name_conflict() {\n  char firstString[100];\n  char secondString[100];\n\n  if (askQuestionString(firstString, \"Input first of string\") == 1)\n    return 1;\n\n  if (askQuestionString(secondString, \"Input second of string\") == 1)\n    return 1;\n\n  concatenateStrings(firstString, secondString);\n  printf(\"Concatenated Strings -- %s\\n\", firstString);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int printHandler(char *array) {\n    printf(\"%s\\n\", array);\n    return 0;\n}\n","function_prediction":"int printHandler_name_conflict(char *msg) {\n  puts(msg);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int isAlpha_handler(char *array) {\n    char c;\n    printf(\"\\nEnter a Char :: \");\n    scanf(\" %c\", &c);\n    int isAlphaNum = alphaNumeric(c);\n    return 0;\n}\n","function_prediction":"int isAlpha_handler_name_conflict() {\n  char ch;\n  printf(\"\\nEnter a Char :: \");\n  __isoc99_scanf(\"%c\", &ch);\n  alphaNumeric(ch);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int printMenu(char **array, int arrayLength) {\n    int i;\n    printf(\"\\n\\n Created by Nathan Morin for CNIT 315 Purdue University\\n\\n\");\n    for (i = 0; i < arrayLength; i++) {\n        printf(\"\\t%d for %s\\n\", i, array[i]);\n    }\n    return 0;\n}\n","function_prediction":"int printMenu_name_conflict(char *menu[], int numOptions) {\n  int i;\n\n  printf(\"\\n\\n Created by Nathan Morin for CNIT 315 Purdue University\\n\\n\");\n  for (i = 0; i < numOptions; i++) {\n    printf(\"\\t%d for %s\\n\", i, menu[i]);\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":1,"function":"int askQuestionInt(int *value, char *q) {\n    printf(\"\\n%s : \", q);\n    scanf(\"%d\", value);\n    if (*value == -1) {\n        return -1;\n    }\n    while (getchar() != '\\n')\n        ;\n    return 0;\n}\n","function_prediction":"int askQuestionInt_name_conflict(int *answer, char *question) {\n  printf(\"\\n%s : \", question);\n  __isoc99_scanf(\"%d\", answer);\n  if (*answer == -1)\n    return -1;\n  while (getchar() != '\\n')\n    ;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":1,"function":"int askQuestionString(char *value, char *q) {\n    printf(\"%s : \", q);\n    scanf(\"%[^\\t\\n]s\", value);\n    printf(\"%s\\n\", value);\n    while (getchar() != '\\n')\n        ;\n    return 0;\n}\n","function_prediction":"int askQuestionString_name_conflict(char *answer, char *question) {\n  printf(\"%s : \", question);\n  __isoc99_scanf(\"%[^\\t\\n]s\", answer);\n  puts(answer);\n  while (getchar() != '\\n')\n    ;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":0,"function":"int wordCount(char *sentence_array, int *numWords) {\n    if (sentence_array == '\\x00') {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    *numWords = CountWords(sentence_array, 0, 0, 1000);\n    return 0;\n}\n","function_prediction":"int wordCount_handler(char *input) {\n  int count = 0;\n  wordCount(input, &count);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int CountWords(char *sentence_array, int count, int start, int maxSize) {\n    if (count < 0) {\n        printf(\"ERROR: count needs to be greater than 0.\\n\");\n        return 1;\n    }\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (start > maxSize) {\n        printf(\"ERROR: the start point was greater than the max size.\\n\");\n        return 1;\n    }\n    if (start < 0 || maxSize < 0) {\n        printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n        return 1;\n    }\n    if (sentence_array[0] == ' ') {\n        printf(\"ERROR: the first character in the array was empty. Please start your sentence from the beginning.\\n\");\n        return 1;\n    }\n    int a = 0;\n    while (sentence_array[a] != '\\x00')\n        {\n            a++;\n        }\n    maxSize = a;\n    if (sentence_array[start] == ' ' && sentence_array[start - 1] != ' ' && start != (maxSize - 1)) {\n        count = count + 1;\n    }\n    if (start != maxSize) {\n        count = CountWords(sentence_array, count, (start + 1), maxSize);\n    }\n    if (start == maxSize) {\n        count++;\n        printf(\"number of words: %d\\n\", count);\n        return count;\n    }\n    return count;\n}\n","function_prediction":"int CountWords_name_conflict(char *array, int count, int start, int max) {\n  if (count < 0) {\n    printf(\"ERROR: count needs to be greater than 0.\\n\");\n    return 1;\n  }\n  if (array == NULL) {\n    printf(\"ERROR: array entered was null.\\n\");\n    return 1;\n  }\n  if (start > max) {\n    printf(\"ERROR: the start point was greater than the max size.\\n\");\n    return 1;\n  }\n  if (start < 0 || max < 0) {\n    printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n    return 1;\n  }\n  if (array[0] == ' ') {\n    printf(\"ERROR: the first character in the array was empty. Please start \"\n           \"your sentence from the beginning.\\n\");\n    return 1;\n  }\n\n  int i;\n  for (i = 0; array[i] != '\\0'; i++) {\n  }\n  int length = i;\n\n  if (array[start] == ' ' && array[start - 1] != ' ' && start != length - 1) {\n    count++;\n  }\n\n  if (start == length) {\n    count++;\n    printf(\"number of words: %d\\n\", count);\n    return count;\n  } else {\n    return CountWords_name_conflict(array, count, start + 1, length);\n  }\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int wordRemove(char *sentence_array, char *word) {\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (word == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    int sizeSentence = 0;\n    while (sentence_array[sizeSentence] != '\\x00')\n        {\n            sizeSentence++;\n        }\n    int sizeWord = 0;\n    while (word[sizeWord] != '\\x00')\n        {\n            sizeWord++;\n        }\n    int head = -1, scanner, stop = sizeSentence - sizeWord;\n    int found = 0;\n    while (head <= stop && found == 0)\n        {\n            head++;\n            scanner = 0;\n            if (sentence_array[head] == word[0]) {\n                while (scanner < sizeWord)\n                    {\n                        found = 1;\n                        if (sentence_array[head + scanner] != word[scanner]) {\n                            found = 0;\n                            break;\n                        }\n                        scanner++;\n                    }\n            }\n        }\n    int i = head;\n    while (sentence_array[i + sizeWord] != '\\x00')\n        {\n            sentence_array[i] = sentence_array[i + sizeWord];\n            i++;\n        }\n    sentence_array[i] = '\\x00';\n    return 0;\n}\n","function_prediction":"int wordRemove_handler() {\n  char sentence[1000];\n  char word[1000];\n\n  askQuestionString(sentence, \"Enter a sentence\");\n  askQuestionString(word, \"Enter a word to remove\");\n\n  wordRemove(sentence, word);\n\n  printf(\"Sentence after '%s' removed -- %s\\n\", word, sentence);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int vowelCheck(char *array, int *vowels) {\n    int i;\n    *vowels = 0;\n    for (i = 0; array[i] != '\\x00'; i++) {\n        if ((array[i] == 'a' || array[i] == 'e' || array[i] == 'i' || array[i] == 'o' || array[i] == 'u') || (array[i] == 'A' || array[i] == 'E' || array[i] == 'I' || array[i] == 'O' || array[i] == 'U')) {\n            *vowels = *vowels + 1;\n        }\n    }\n    printf(\"No. of vowels in %s = %d\\n\", array, *vowels);\n    return 0;\n}\n","function_prediction":"int vowelCheck_handler(char *str) {\n  int count = 0;\n  vowelCheck(str, &count);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int subString(char *array1, int index1, int index2) {\n    int position;\n    int i = 0;\n    char input2[100];\n    if (array1 == ((void *)0)) {\n        return 1;\n    }\n    position = index1;\n    for (i = 0; array1[i] != '\\x00'; i++ , position++) {\n        if (position <= index2) {\n            array1[i] = array1[position];\n        } else {\n            array1[i] = ((void *)0);\n        }\n    }\n    return 0;\n}\n","function_prediction":"int subString_handler(char *string) {\n  int start = 0, end = 0;\n  if (askQuestionInt(&start, \"Input start of substring\") == 1)\n    return 1;\n  if (askQuestionInt(&end, \"Input end of substring\") == 1)\n    return 1;\n  subString(string, start, end);\n  printf(\"String has been modified -- new string -- %s\\n\", string);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int concatenateStrings(char *str1, char *str2) {\n    int firstArrayLength = 0;\n    int secondArrayLength = 0;\n    while (str1[firstArrayLength] != '\\x00')\n        {\n            firstArrayLength++;\n        }\n    printf(\"%d\", firstArrayLength);\n    while (str2[secondArrayLength] != '\\x00')\n        {\n            str1[firstArrayLength] = str2[secondArrayLength];\n            secondArrayLength++;\n            firstArrayLength++;\n        }\n    str1[firstArrayLength] = '\\x00';\n    return 0;\n}\n","function_prediction":"int concatenateStrings_name_conflict(char *s1, char *s2) {\n  int i = 0, j = 0;\n  while (s1[i] != '\\0') {\n    i++;\n  }\n  printf(\"%d\", i);\n  while (s2[j] != '\\0') {\n    s1[i] = s2[j];\n    i++;\n    j++;\n  }\n  s1[i] = '\\0';\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int printString() {\n    char mystring[50];\n    printf(\"Please type a string\\n\\n\");\n    scanf(\"\\n%50[^\\n]s\", mystring);\n    printf(\"%s\\n\", mystring);\n}\n","function_prediction":"int printStringWLen(char *str, int *len) {\n  char str2[50];\n  int i;\n\n  if (str[0] == '\\0') {\n    printf(\"Error -- array is null\");\n    return 1;\n  }\n\n  for (i = 0; str[i] != '\\0'; i++) {\n  }\n\n  *len = i;\n\n  printf(\"You Entered:%s\\n\", str);\n  printf(\"The Length of the string is: %d\\n\", *len);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int printStringWLen(char *array, int *length) {\n    if (array[0] == '\\x00') {\n        printf(\"Error -- array is null\");\n        return 1;\n    }\n    int number = 0;\n    while (array[number] != '\\x00')\n        {\n            number++;\n        }\n    *length = number;\n    printf(\"You Entered:%s\\n\", array);\n    printf(\"The Length of the string is: %d\\n\", *length);\n    return 0;\n}\n","function_prediction":"int printStringWLen_name_conflict(char *str, int *len) {\n  int i;\n  if (str[0] == '\\0') {\n    printf(\"Error -- array is null\");\n    return 1;\n  }\n  for (i = 0; str[i] != '\\0'; i++)\n    ;\n  *len = i;\n  printf(\"You Entered:%s\\n\", str);\n  printf(\"The Length of the string is: %d\\n\", *len);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int alphaNumeric(char ch) {\n    if (ch >= '0' && ch <= '9') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'A' && ch <= 'Z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'a' && ch <= 'z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else {\n        printf(\"%c is not alphanumeric.\\n\", ch);\n    }\n    return 0;\n}\n","function_prediction":"int alphaNumeric_name_conflict(char c) {\n  if (c >= '0' && c <= '9') {\n    printf(\"|%c| is alphanumeric.\\n\", c);\n  } else if (c >= 'A' && c <= 'Z') {\n    printf(\"|%c| is alphanumeric.\\n\", c);\n  } else if (c >= 'a' && c <= 'z') {\n    printf(\"|%c| is alphanumeric.\\n\", c);\n  } else {\n    printf(\"%c is not alphanumeric.\\n\", c);\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"static int foo1(void) {\n    return 1;\n}\n","function_prediction":"int foo1_name_conflict(void) {\n  int x = 1;\n  return x;\n}","pass":1,"source_file":"C_COMPILE/keszybz_prelink/testsuite/ifunctest.c"}
{"compilable":1,"function":"static int foo2(void) {\n    return 2;\n}\n","function_prediction":"int foo2_name_conflict(void) { return 2; }","pass":1,"source_file":"C_COMPILE/keszybz_prelink/testsuite/ifunctest.c"}
{"compilable":0,"function":"int tty_break() {\n    struct termio modmodes;\n    if (ioctl(fileno(stdin), 21509, &saved_modes) == -1) {\n        return -1;\n    }\n    have_modes = 1;\n    modmodes = saved_modes;\n    modmodes.c_lflag &= ~(2 | 8);\n    modmodes.c_cc[6] = 1;\n    modmodes.c_cc[5] = 0;\n    return ioctl(fileno(stdin), 21511, &modmodes);\n}\n","function_prediction":"int tty_break_name_conflict(void) {\n  struct sgttyb tty;\n  int fd;\n\n  fd = fileno(stdin);\n  if (ioctl(fd, 0x5405, &saved_modes) == -1)\n    return -1;\n  have_modes = 1;\n  tty = saved_modes;\n  tty.sg_flags &= ~(0x00000001 | 0x00000002 | 0x00000004);\n  tty.sg_flags |= 0x00000001;\n  return ioctl(fileno(stdin), 0x5407, &tty);\n}","pass":0,"source_file":"C_COMPILE/jtyr_legoirc-server/src/legoirc-client.c"}
{"compilable":1,"function":"int tty_fix() {\n    if (!have_modes) {\n        return 0;\n    }\n    return ioctl(fileno(stdin), 21511, &saved_modes);\n}\n","function_prediction":"int tty_fix_name_conflict(void) {\n  if (!have_modes)\n    return 0;\n  return ioctl(fileno(stdin), 0x5407, &saved_modes);\n}","pass":1,"source_file":"C_COMPILE/jtyr_legoirc-server/src/legoirc-client.c"}
{"compilable":0,"function":"size_t fmsynth_preset_size(void) {\n    return 8 + sizeof(struct fmsynth_preset_metadata) + FMSYNTH_PARAM_END * 8 * sizeof(uint32_t) + FMSYNTH_GLOBAL_PARAM_END * sizeof(uint32_t);\n}\n","function_prediction":"int fmsynth_preset_size_name_conflict(void) { return 1040; }","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"static uint32_t read_u32(const uint8_t *buffer) {\n    return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] << 0);\n}\n","function_prediction":"uint32_t read_u32_name_conflict(const uint8_t *p) {\n  return (uint32_t)p[0] << 24 | (uint32_t)p[1] << 16 | (uint32_t)p[2] << 8 |\n         (uint32_t)p[3];\n}","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"unsigned int fmsynth_get_version(void) {\n    return 2;\n}\n","function_prediction":"int fmsynth_get_version_name_conflict(void) { return 2; }","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"int User_Authonrize(struct user *list_head, struct user *login) {\n    User_Login(login);\n    list_head = list_head->next;\n    while (list_head != ((void *)0))\n        {\n            if (!strcmp(login->ID, list_head->ID)) {\n                if (!strcmp(login->Key, list_head->Key)) {\n                    memcpy(login, list_head, sizeof(struct user));\n                    return 0;\n                }\n            }\n            list_head = list_head->next;\n        }\n    return -1;\n}\n","function_prediction":"int User_Authonrize_name_conflict(User_t *user, char *username) {\n  User_Login(username);\n  User_t *p = user->next;\n  while (p) {\n    if (!strcmp(username, p->username) && !strcmp(username + 28, p->password)) {\n      memcpy(username, p, 64);\n      return 0;\n    }\n    p = p->next;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/sys.c"}
{"compilable":0,"function":"int getch(void) {\n    struct termios tm, tm_bak;\n    if (tcgetattr(0, &tm) < 0) {\n        perror(\"tcgetattr\");\n        exit(-1);\n    }\n    tm_bak = tm;\n    cfmakeraw(&tm);\n    if (tcsetattr(0, 0, &tm) < 0) {\n        perror(\"tcsetattr\");\n        exit(-1);\n    }\n    int ch = getchar();\n    if (tcsetattr(0, 0, &tm_bak) < 0) {\n        perror(\"tcsetattr\");\n        exit(-1);\n    }\n    if (ch == 3 || ch == 4)\n        exit(0);\n    else\n        return ch;\n}\n","function_prediction":"int getch_name_conflict() {\n  struct termios oldt, newt;\n  int ch;\n  int oldf;\n\n  if (tcgetattr(0, &oldt) < 0) {\n    perror(\"tcgetattr\");\n    exit(-1);\n  }\n  newt = oldt;\n  cfmakeraw(&newt);\n\n  if (tcsetattr(0, 0, &newt) < 0) {\n    perror(\"tcsetattr\");\n    exit(-1);\n  }\n  ch = getch_name_conflictar();\n\n  if (tcsetattr(0, 0, &oldt) < 0) {\n    perror(\"tcsetattr\");\n    exit(-1);\n  }\n\n  if (ch == 3 || ch == 4) {\n    exit(0);\n  }\n  return ch;\n}","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/getch.c"}
{"compilable":0,"function":"int Change_User_Passwd(struct user **list_head, char *key) {\n    struct user *pcur = (*list_head)->next;\n    while (pcur != ((void *)0))\n        {\n            if (!(strcmp(pcur->ID, key) && strcmp(pcur->Name, key))) {\n                char passwd_1[20] = {0};\n                char passwd_2[20] = {0};\n                int i;\n                for (i = 0; i < 3; i++) {\n                    printf(\"New password:\");\n                    scanf(\"%s\", passwd_1);\n                    printf(\"Retype new password:\");\n                    scanf(\"%s\", passwd_2);\n                    if (!strcmp(passwd_1, passwd_2)) {\n                        strcpy(pcur->Key, passwd_1);\n                        puts(\"all authentication tokens updated successfully.\");\n                        break;\n                    } else\n                        puts(\"Sorry, passwords do not match.\");\n                }\n                if (i == 3)\n                    puts(\"Have exhausted maximum number of retries for service\");\n                break;\n            }\n            pcur = pcur->next;\n        }\n    if (pcur == ((void *)0))\n        return -1;\n    return 0;\n}\n","function_prediction":"int Change_User_Passwd_name_conflict(struct passwd *pw, char *user) {\n  struct passwd *p;\n  char passwd1[100], passwd2[100];\n  int i;\n\n  for (p = pw->pw_shell; p; p = p->pw_shell) {\n    if (!strcmp(p->pw_name, user) || !strcmp(p->pw_passwd, user)) {\n      passwd1[0] = passwd2[0] = '\\0';\n      i = 0;\n      break;\n    }\n  }\n  if (!p)\n    return -1;\n\n  while (i < 3) {\n    printf(\"New password:\");\n    __isoc99_scanf(\"%s\", passwd1);\n    printf(\"Retype new password:\");\n    __isoc99_scanf(\"%s\", passwd2);\n    if (!strcmp(passwd1, passwd2)) {\n      strcpy(p->pw_passwd, passwd1);\n      printf(\"all authentication tokens updated successfully.\\n\");\n      break;\n    } else {\n      printf(\"Sorry, passwords do not match.\\n\");\n      i++;\n    }\n  }\n  if (i == 3)\n    printf(\"Have exhausted maximum number of retries for service\\n\");\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/linklist.c"}
{"compilable":1,"function":"const char *memstr(const char *full_data, int full_data_len, const char *substr) {\n    if (full_data == ((void *)0) || full_data_len <= 0 || substr == ((void *)0)) {\n        return ((void *)0);\n    }\n    if (*substr == '\\x00') {\n        return ((void *)0);\n    }\n    int sublen = strlen(substr);\n    int i;\n    const char *cur = full_data;\n    int last_possible = full_data_len - sublen + 1;\n    for (i = 0; i < last_possible; i++) {\n        if (*cur == *substr) {\n            if (memcmp(cur, substr, sublen) == 0) {\n                return cur;\n            }\n        }\n        cur++;\n    }\n    return ((void *)0);\n}\n","function_prediction":"char *memstr_name_conflict(char *haystack, int hlen, char *needle) {\n  int nlen, i;\n\n  if (haystack == NULL || hlen <= 0 || needle == NULL || *needle == '\\0')\n    return NULL;\n\n  nlen = strlen(needle);\n\n  for (i = 0; i < hlen - nlen + 1; i++) {\n    if (haystack[i] == *needle && !memcmp(haystack + i, needle, nlen))\n      return haystack + i;\n  }\n\n  return NULL;\n}","pass":1,"source_file":"C_COMPILE/qwerty258_HLSDownload_old/utils.c"}
{"compilable":0,"function":"int isdirreducable() {\n    int ndirs = (int)pow(2, directory->globle_depth);\n    for (int i = 0; i < ndirs; ++i) {\n        if (directory->dir_elem_list[i].flag == -1) {\n            if (directory->dir_elem_list[i].bucket->local_depth == directory->globle_depth) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"int isdirreducable_name_conflict(void) {\n  int i;\n  int n;\n\n  n = pow(2, directory->n);\n  for (i = 0; i < n; i++)\n    if (directory->entry[i].parent != -1 &&\n        directory->entry[i].parent->level == directory->n)\n      return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/nilesh2014_Extendible-Hashing/hashing.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint8(uint8_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (value <= 23) {\n        if (buffer_size >= 1) {\n            buffer[0] = value + offset;\n            return 1;\n        }\n    } else {\n        if (buffer_size >= 2) {\n            buffer[0] = 24 + offset;\n            buffer[1] = value;\n            return 2;\n        }\n    }\n    return 0;\n}\n","function_prediction":"size_t _cbor_encode_uint8(uint8_t value, char *buffer, size_t buffer_size,\n                          char offset) {\n  if (value < 24) {\n    if (buffer_size < 1) {\n      return 0;\n    }\n    buffer[0] = value + offset;\n    return 1;\n  }\n  if (buffer_size < 2) {\n    return 0;\n  }\n  buffer[0] = 24 + offset;\n  buffer[1] = value;\n  return 2;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint16(uint16_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 3) {\n        buffer[0] = 25 + offset;\n        buffer[1] = (unsigned char)(value >> 8);\n        buffer[2] = (unsigned char)value;\n        return 3;\n    } else\n        return 0;\n}\n","function_prediction":"size_t _cbor_encode_uint16(unsigned short value, unsigned char *buffer,\n                           size_t buffer_size, unsigned char major_type) {\n  if (buffer_size < 3)\n    return 0;\n\n  buffer[0] = (unsigned char)(major_type + 25);\n  buffer[1] = (unsigned char)(value >> 8);\n  buffer[2] = (unsigned char)(value);\n\n  return 3;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint32(uint32_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 5) {\n        buffer[0] = 26 + offset;\n        buffer[1] = (unsigned char)(value >> 24);\n        buffer[2] = (unsigned char)(value >> 16);\n        buffer[3] = (unsigned char)(value >> 8);\n        buffer[4] = (unsigned char)value;\n        return 5;\n    } else\n        return 0;\n}\n","function_prediction":"size_t _cbor_encode_uint32(uint32_t value, char *buffer, size_t buffer_size,\n                           char major_type) {\n  if (buffer_size < 5)\n    return 0;\n\n  buffer[0] = (char)(0x1A + major_type);\n  buffer[1] = (char)(value >> 24);\n  buffer[2] = (char)(value >> 16);\n  buffer[3] = (char)(value >> 8);\n  buffer[4] = (char)value;\n\n  return 5;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint64(uint64_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 9) {\n        buffer[0] = 27 + offset;\n        buffer[1] = (unsigned char)(value >> 56);\n        buffer[2] = (unsigned char)(value >> 48);\n        buffer[3] = (unsigned char)(value >> 40);\n        buffer[4] = (unsigned char)(value >> 32);\n        buffer[5] = (unsigned char)(value >> 24);\n        buffer[6] = (unsigned char)(value >> 16);\n        buffer[7] = (unsigned char)(value >> 8);\n        buffer[8] = (unsigned char)value;\n        return 9;\n    } else\n        return 0;\n}\n","function_prediction":"size_t _cbor_encode_uint64(uint64_t value, unsigned char *buffer,\n                           size_t buffer_size, unsigned char major_type) {\n  if (buffer_size < 9)\n    return 0;\n\n  buffer[0] = major_type + 25;\n  buffer[1] = (unsigned char)(value >> 56);\n  buffer[2] = (unsigned char)(value >> 48);\n  buffer[3] = (unsigned char)(value >> 40);\n  buffer[4] = (unsigned char)(value >> 32);\n  buffer[5] = (unsigned char)(value >> 24);\n  buffer[6] = (unsigned char)(value >> 16);\n  buffer[7] = (unsigned char)(value >> 8);\n  buffer[8] = (unsigned char)(value);\n\n  return 9;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint(uint64_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (value <= (65535))\n        if (value <= (255))\n            return _cbor_encode_uint8((uint8_t)value, buffer, buffer_size, offset);\n        else\n            return _cbor_encode_uint16((uint16_t)value, buffer, buffer_size, offset);\n    else if (value <= (4294967295U))\n        return _cbor_encode_uint32((uint32_t)value, buffer, buffer_size, offset);\n    else\n        return _cbor_encode_uint64((uint64_t)value, buffer, buffer_size, offset);\n}\n","function_prediction":"size_t _cbor_encode_uint(uint64_t value, char *buf, size_t buf_size,\n                         char offset) {\n  if (value < 24) {\n    if (buf_size < 1) {\n      return 0;\n    }\n    buf[0] = value + offset;\n    return 1;\n  }\n  if (value < 0x100) {\n    if (buf_size < 2) {\n      return 0;\n    }\n    buf[0] = 0x18 + offset;\n    buf[1] = value;\n    return 2;\n  }\n  if (value < 0x10000) {\n    if (buf_size < 3) {\n      return 0;\n    }\n    buf[0] = 0x19 + offset;\n    buf[1] = value >> 8;\n    buf[2] = value;\n    return 3;\n  }\n  if (value < 0x100000000) {\n    if (buf_size < 5) {\n      return 0;\n    }\n    buf[0] = 0x1a + offset;\n    buf[1] = value >> 24;\n    buf[2] = value >> 16;\n    buf[3] = value >> 8;\n    buf[4] = value;\n    return 5;\n  }\n  if (buf_size < 9) {\n    return 0;\n  }\n  buf[0] = 0x1b + offset;\n  buf[1] = value >> 56;\n  buf[2] = value >> 48;\n  buf[3] = value >> 40;\n  buf[4] = value >> 32;\n  buf[5] = value >> 24;\n  buf[6] = value >> 16;\n  buf[7] = value >> 8;\n  buf[8] = value;\n  return 9;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t cbor_encode_uint8(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 0);\n}\n","function_prediction":"size_t cbor_encode_uint8_name_conflict(uint8_t value, uint8_t *buffer, size_t buffer_size) {\n  return _cbor_encode_uint8_name_conflict(value, buffer, buffer_size, 0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint16(uint16_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint16(value, buffer, buffer_size, 0);\n}\n","function_prediction":"size_t cbor_encode_uint16_name_conflict(uint16_t value, uint8_t *buffer, size_t buffer_size) {\n  return _cbor_encode_uint16_name_conflict(value, buffer, buffer_size, 0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint32(uint32_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint32(value, buffer, buffer_size, 0);\n}\n","function_prediction":"size_t cbor_encode_uint32_name_conflict(uint32_t value, uint8_t *buffer, size_t buffer_size) {\n  return _cbor_encode_uint32_name_conflict(value, buffer, buffer_size, 0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint64(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint64(value, buffer, buffer_size, 0);\n}\n","function_prediction":"size_t cbor_encode_uint64_name_conflict(uint8_t *buffer, size_t buffer_size, uint64_t value) {\n  return _cbor_encode_uint64_name_conflict(buffer, buffer_size, value, 0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 0);\n}\n","function_prediction":"void cbor_encode_uint8(uint8_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint8(value, buffer, index, 0);\n}\n\nvoid cbor_encode_uint16(uint16_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint16(value, buffer, index, 0);\n}\n\nvoid cbor_encode_uint32(uint32_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint32(value, buffer, index, 0);\n}\n\nvoid cbor_encode_uint64(uint64_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint64(value, buffer, index, 0);\n}\n\nvoid cbor_encode_uint(uint64_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint(value, buffer, index, 0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint8(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 32);\n}\n","function_prediction":"int cbor_encode_negint8_name_conflict(uint8_t value, uint8_t *buffer, size_t len) {\n  return _cbor_encode_uint8(value, buffer, len, 32);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint16(uint16_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint16(value, buffer, buffer_size, 32);\n}\n","function_prediction":"int cbor_encode_negint16_name_conflict(cbor_stream_t *st, uint16_t value) {\n  return _cbor_encode_uint16(st, value, 32);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint32(uint32_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint32(value, buffer, buffer_size, 32);\n}\n","function_prediction":"int cbor_encode_negint32_name_conflict(cbor_stream_t *st, uint32_t value, size_t *len) {\n  return _cbor_encode_uint32(st, value, len, 32);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint64(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint64(value, buffer, buffer_size, 32);\n}\n","function_prediction":"int cbor_encode_negint64(cbor_stream_t *st, cbor_encode_major_type_t mj,\n                         int64_t val) {\n  return _cbor_encode_uint64(st, mj, val, 32);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 32);\n}\n","function_prediction":"void cbor_encode_negint8(int8_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint8(value, buffer, index, 0x20);\n}\n\nvoid cbor_encode_negint16(int16_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint16(value, buffer, index, 0x20);\n}\n\nvoid cbor_encode_negint32(int32_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint32(value, buffer, index, 0x20);\n}\n\nvoid cbor_encode_negint64(int64_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint64(value, buffer, index, 0x20);\n}\n\nvoid cbor_encode_negint(int value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint(value, buffer, index, 0x20);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_bytestring_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 64);\n}\n","function_prediction":"int cbor_encode_bytestring_start(cbor_encode_buffer_t *buffer, size_t size,\n                                 size_t *written) {\n  return _cbor_encode_uint(buffer, size, written, 64);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t _cbor_encode_byte(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    if (buffer_size >= 1) {\n        buffer[0] = value;\n        return 1;\n    } else\n        return 0;\n}\n","function_prediction":"bool _cbor_encode_byte_name_conflict(uint8_t value, uint8_t *buffer, size_t buffer_size) {\n  if (buffer_size < 1) {\n    return false;\n  }\n\n  buffer[0] = value;\n  return true;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_bytestring_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(95, buffer, buffer_size);\n}\n","function_prediction":"int cbor_encode_indef_bytestring_start(cbor_encode_buffer_t *buffer,\n                                       cbor_encode_buffer_t *scratch) {\n  return _cbor_encode_byte(0x5F, buffer, scratch);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_string_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 96);\n}\n","function_prediction":"int cbor_encode_string_start(cbor_encode_buffer_t *buffer, size_t *written,\n                             size_t length) {\n  return _cbor_encode_uint(buffer, written, length, 0x60);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_string_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(127, buffer, buffer_size);\n}\n","function_prediction":"int cbor_encode_indef_string_start(cbor_encode_buffer_t *buffer,\n                                   cbor_encode_error_t *error) {\n  return _cbor_encode_byte(0x7F, buffer, error);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_array_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 128);\n}\n","function_prediction":"int cbor_encode_array_start(cbor_encode_buffer_t *buffer, size_t *written,\n                            size_t length) {\n  return _cbor_encode_uint(buffer, written, length, 0x80);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_array_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(159, buffer, buffer_size);\n}\n","function_prediction":"int cbor_encode_indef_array_start(cbor_encode_buffer_t *buffer,\n                                  cbor_encode_buffer_t *scratch) {\n  return _cbor_encode_byte(0x9F, buffer, scratch);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_map_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 160);\n}\n","function_prediction":"int cbor_encode_map_start(cbor_encode_buffer_t *buffer, size_t *written,\n                          size_t size) {\n  return _cbor_encode_uint(buffer, written, size, 0x80 | 10);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_map_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(191, buffer, buffer_size);\n}\n","function_prediction":"int cbor_encode_indef_map_start(cbor_encode_buffer_t *buffer,\n                                cbor_encode_error_t *error) {\n  return _cbor_encode_byte(0xBF, buffer, error);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_tag(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 192);\n}\n","function_prediction":"size_t cbor_encode_tag_name_conflict(uint8_t *buffer, size_t buffer_size, uint64_t tag) {\n  return _cbor_encode_uint(buffer, buffer_size, tag, 0xC0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_bool(bool value, unsigned char *buffer, size_t buffer_size) {\n    return value ? _cbor_encode_byte(245, buffer, buffer_size) : _cbor_encode_byte(244, buffer, buffer_size);\n}\n","function_prediction":"int cbor_encode_bool_name_conflict(bool value, uint8_t *buffer, size_t *index, size_t size) {\n  if (value) {\n    return _cbor_encode_byte(0xf5, buffer, index, size);\n  } else {\n    return _cbor_encode_byte(0xf4, buffer, index, size);\n  }\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_null(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(246, buffer, buffer_size);\n}\n","function_prediction":"int cbor_encode_null_name_conflict(cbor_encode_buffer_t *buffer, cbor_encode_error_t *error) {\n  return _cbor_encode_byte(0xf6, buffer, error);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_undef(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(247, buffer, buffer_size);\n}\n","function_prediction":"int cbor_encode_undef(cbor_encode_buffer_t *buffer,\n                      cbor_encode_error_t *error) {\n  return _cbor_encode_byte(0xF7, buffer, error);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_break(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(255, buffer, buffer_size);\n}\n","function_prediction":"int cbor_encode_break_name_conflict(uint8_t *buffer, size_t *cursor) {\n  return _cbor_encode_byte(0xFF, buffer, cursor);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_ctrl(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 224);\n}\n","function_prediction":"int cbor_encode_ctrl_name_conflict(uint8_t ctrl, uint8_t *buf, size_t *len) {\n  return _cbor_encode_uint8(ctrl, buf, len, 0xE0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":1,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":1,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":1,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int work(long loop_count) {\n    while (loop_count-- > 0)\n        {\n            syslog(6, \"loglog\");\n        }\n    return 0;\n}\n","function_prediction":"void *work_name_conflict(void *arg) {\n  long i = (long)arg;\n  while (i > 0) {\n    syslog(6, \"loglog\");\n    i--;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_syslog.c"}
{"compilable":1,"function":"int test(long process_count, long loop_count) {\n    long i;\n    pid_t pid;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            work(loop_count);\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"int test_name_conflict(long long n, long long m) {\n  long long i;\n  for (i = 0; i < n; i++) {\n    pid_t pid = fork();\n    if (pid < 0) {\n      puts(\"fork fail\");\n    } else if (pid == 0) {\n      work(m);\n      return 0;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    wait(NULL);\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_syslog.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, (void *)j);\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"void *test_name_conflict(void *arg) {\n  long i, j;\n  long n = (long)arg;\n  pthread_t tid[n];\n  for (i = 0; i < n; i++) {\n    pid_t pid = fork();\n    if (pid < 0) {\n      printf(\"fork fail\\n\");\n    } else if (pid == 0) {\n      for (j = 0; j < n; j++) {\n        pthread_create(&tid[j], NULL, work, (void *)j);\n      }\n      for (j = 0; j < n; j++) {\n        pthread_join(tid[j], NULL);\n      }\n      return NULL;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    wait(NULL);\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_write2.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, ((void *)0));\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"int test_name_conflict(long long n, long long m) {\n  long long i, j;\n  pthread_t tid[m];\n  for (i = 0; i < n; i++) {\n    pid_t pid = fork();\n    if (pid < 0) {\n      printf(\"fork fail\\n\");\n    } else if (pid == 0) {\n      for (j = 0; j < m; j++) {\n        pthread_create(&tid[j], NULL, work, NULL);\n      }\n      for (j = 0; j < m; j++) {\n        pthread_join(tid[j], NULL);\n      }\n      return 0;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    wait(NULL);\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_zlog.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int size, char **str) {\n  char *p;\n  int len;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n  len = p + 1 - *str;\n  if (len > size)\n    len = size;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  FILE *fp = NULL;\n  char time_str[21];\n  va_list ap;\n  va_list ap2;\n\n  if (init_flag_2 == 0) {\n    init_flag_2 = 1;\n    debug_log_1 = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log_0 = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  switch (level) {\n  case 0:\n    if (debug_log_1 == NULL) {\n      return 0;\n    }\n    fp = fopen64(debug_log_1, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 1:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  case 2:\n    if (error_log_0 == NULL) {\n      return 0;\n    }\n    fp = fopen64(error_log_0, \"a\");\n    if (fp == NULL) {\n      return -1;\n    }\n    zc_time(time_str, sizeof(time_str));\n    fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    break;\n  default:\n    return 0;\n  }\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, ((void *)0));\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"void *test_name_conflict(void *arg) {\n  long i, j;\n  long n = (long)arg;\n  pthread_t tid[n];\n  for (i = 0; i < n; i++) {\n    pid_t pid = fork();\n    if (pid < 0) {\n      printf(\"fork fail\\n\");\n    } else if (pid == 0) {\n      for (j = 0; j < n; j++) {\n        pthread_create(&tid[j], NULL, work, NULL);\n      }\n      for (j = 0; j < n; j++) {\n        pthread_join(tid[j], NULL);\n      }\n      return NULL;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    wait(NULL);\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_write.c"}
{"compilable":0,"function":"int send_garp(int ifindex, __be32 sip, char *sha, __be32 tip, char *tha) {\n    static char buf[64];\n    struct sockaddr_ll sll;\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    ;\n    arp->ar_hrd = htons(1);\n    arp->ar_pro = htons(2048);\n    arp->ar_hln = 6;\n    arp->ar_pln = 4;\n    arp->ar_op = htons(2);\n    memcpy(p, sha, 6);\n    p += 6;\n    memcpy(p, &sip, 4);\n    p += 4;\n    memcpy(p, tha, 6);\n    p += 6;\n    memcpy(p, &tip, 4);\n    p += 4;\n    memset(&sll, 0, sizeof (sll));\n    sll.sll_protocol = htons(2054);\n    sll.sll_ifindex = ifindex;\n    sll.sll_halen = 6;\n    memset(sll.sll_addr, 255, 6);\n    if (sendto(arp_sock, buf, p - buf, 0, (struct sockaddr *)&sll, sizeof (sll)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\", __func__, ifindex, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int send_garp_name_conflict(int ifindex, int iftype, char *smac, int stype, char *tmac) {\n  struct sockaddr_ll sll;\n  char *p;\n  struct timeval tv;\n\n  p = (char *)&buf;\n\n  *(unsigned short *)p = htons(0x0001);\n  p += 2;\n  *(unsigned short *)p = htons(0x0800);\n  p += 2;\n  *p = 6;\n  p++;\n  *p = 4;\n  p++;\n  *(unsigned short *)p = htons(0x0002);\n  p += 2;\n\n  memcpy(p, smac, 6);\n  p += 6;\n  *(unsigned int *)p = iftype;\n  p += 4;\n  memcpy(p, tmac, 6);\n  p += 6;\n  *(unsigned int *)p = stype;\n  p += 4;\n\n  memset(&sll, 0, sizeof(sll));\n  sll.sll_family = htons(0x0806);\n  sll.sll_protocol = htons(0x0006);\n  sll.sll_ifindex = ifindex;\n  memset(sll.sll_addr, 0xff, 6);\n\n  if (sendto(arp_sock, &buf, p - (char *)&buf, 0, (struct sockaddr *)&sll,\n             sizeof(sll)) < 0) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"send_garp_name_conflict\", ifindex, strerror(*__errno_location()));\n    } else {\n            syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\", \"send_garp_name_conflict\", if","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int recv_arp(int *ifindex, __u16 *type, __u16 *op, __be32 *sip, char *sha, __be32 *tip, char *tha) {\n    int len;\n    static char buf[1024];\n    struct sockaddr_ll sll;\n    socklen_t sll_len = sizeof (sll);\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    len = recvfrom(arp_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&sll, &sll_len);\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (len < sizeof (*arp) || (arp->ar_op != htons(1) && arp->ar_op != htons(2)) || arp->ar_pln != 4 || arp->ar_pro != htons(2048) || arp->ar_hln != 6 || len < sizeof (*arp) + 2 * 4 + 2 * 6) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = sll.sll_ifindex;\n    *type = sll.sll_pkttype;\n    *op = ntohs(arp->ar_op);\n    memcpy(sha, p, 6);\n    memcpy(sip, p + 6, 4);\n    memcpy(tha, p + 6 + 4, 6);\n    memcpy(tip, p + 6 + 4 + 6, 4);\n    return 0;\n}\n","function_prediction":"int recv_arp(unsigned char *src_mac, unsigned short *src_port,\n             unsigned short *dst_port, unsigned char *dst_mac,\n             unsigned char *src_ip, unsigned char *dst_ip,\n             unsigned char *dst_mac2) {\n  struct sockaddr_in from;\n  socklen_t fromlen = sizeof(from);\n  int n;\n  unsigned char *p = buf_2;\n\n  n = recvfrom(arp_sock, buf_2, 1024, 0x40, (struct sockaddr *)&from, &fromlen);\n  if (n < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", (long)tv.tv_sec,\n              (long)tv.tv_usec, \"recv_arp\", strerror(errno));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\",\n             \"recv_arp\", strerror(errno));\n    }\n    return -1;\n  }\n\n  if (n < 8 || n < 28) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"recv_arp\");\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\",\n             \"recv_arp\");\n    }\n    return -1;\n  }\n\n  if (p[6] != htons(1) && p[6] != htons(2)) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n   fprintf(stderr, \"%ld.%","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":1,"function":"int open_arp(void) {\n    if ((arp_sock = socket(17, SOCK_DGRAM, htons(2054))) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return arp_sock;\n}\n","function_prediction":"int open_arp_name_conflict() {\n  struct timeval tv;\n\n  arp_sock = socket(17, 2, htons(1346));\n  if (arp_sock < 0) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"open_arp_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\",\n             \"open_arp_name_conflict\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n  return arp_sock;\n}","pass":1,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"static int fill_if_addrs(struct mpgw *gw) {\n    int sock, ret = -1;\n    struct ifreq ifr;\n    struct sockaddr_in saddr;\n    socklen_t len;\n    if ((sock = socket(2, SOCK_DGRAM, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    memset(&ifr, 0, sizeof (ifr));\n    ifr.ifr_ifru.ifru_ivalue = gw->if_id;\n    if (ioctl(sock, 35088, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, gw->if_id, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\", __func__, gw->if_id, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ioctl(sock, 35111, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ifr.ifr_ifru.ifru_hwaddr.sa_family != 1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid if %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name);\n        });\n        goto close_ret;\n    }\n    if (setsockopt(sock, 1, 25, ifr.ifr_ifrn.ifrn_name, strlen(ifr.ifr_ifrn.ifrn_name) + 1) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    memset(&saddr, 0, sizeof (saddr));\n    saddr.sin_family = 2;\n    saddr.sin_port = htons(1025);\n    saddr.sin_addr.s_addr = gw->gw_ip;\n    if (connect(sock, (struct sockaddr *)&saddr, sizeof (saddr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect to %s from %s %s\\\"}\", __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    len = sizeof (saddr);\n    if (getsockname(sock, (struct sockaddr *)&saddr, &len) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    ret = 0;\n    memcpy(gw->if_hw, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    gw->if_ip = saddr.sin_addr.s_addr;\n  close_ret:\n    close(sock);\n    return ret;\n}\n","function_prediction":"int fill_if_addrs_name_conflict(struct if_addr *if_addr) {\n  int sock = -1;\n  int ret = -1;\n  struct ifreq ifr;\n  struct sockaddr_in sin;\n  socklen_t sin_len;\n\n  if ((sock = socket(2, 2, 0)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: socket sock %s\\n\", (long)tv.tv_sec,\n              (long)tv.tv_usec, \"fill_if_addrs_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\",\n             \"fill_if_addrs_name_conflict\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  memset(&ifr, 0, sizeof(ifr));\n  ifr.ifr_ifindex = if_addr->if_index;\n  if (ioctl(sock, 0x8910, &ifr) != 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"fill_if_addrs_name_conflict\",\n              if_addr->if_index, strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\",\n             \"fill_if_addrs_name_conflict\", if_addr->if_index, strerror(*__errno_location()));\n    }\n    goto out;\n  }\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *add_mpgw(__be32 addr, int ifindex) {\n    int i, j = -1;\n    struct timespec now;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED) {\n            if (j == -1)\n                j = i;\n            continue;\n        }\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    if (j == -1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: not enough memory\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\", __func__);\n        });\n        return ((void *)0);\n    }\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return ((void *)0);\n    }\n    memset(&mpgws[j], 0, sizeof (mpgws[j]));\n    mpgws[j].gw_ip = addr;\n    mpgws[j].if_id = ifindex;\n    if (fill_if_addrs(&mpgws[j]) < 0)\n        return ((void *)0);\n    mpgws[j].last_sent = now;\n    mpgws[j].last_rcvd = now;\n    update_mpgw(&mpgws[j], MPGW_S_PROBE);\n    srandom(mpgws[j].if_ip);\n    return &mpgws[j];\n}\n","function_prediction":"struct mpgw *add_mpgw_name_conflict(int sock, int port) {\n  int i, j, k;\n  struct timespec ts;\n\n  j = -1;\n  for (i = 0; i < 32; i++) {\n    if (!mpgws[i].used) {\n      if (j == -1)\n        j = i;\n    } else if (mpgws[i].sock == sock && mpgws[i].port == port)\n      return &mpgws[i];\n  }\n\n  if (j == -1) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"not enough memory\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, __func__);\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"not enough memory\"\n               \"\\\"}\",\n               __func__);\n      }\n    } while (0);\n    return NULL;\n  }\n\n  k = clock_gettime(1, &ts);\n  if (k < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"clock_gettime %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, __func__,\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"clock_gettime %s\"\n               \"\\\"}\",\n               __func__, strerror(*__errno_location()));\n      }\n    } while (0);\n    return NULL;\n  }\n\n  memset(&mpgws[j], 0, sizeof(mpgws[j]));\n  mpgws[j].sock = sock;\n  mpgws[j].port = port;\n  k = fill_if_addrs(&mpgws[j]);\n if (k","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *find_mpgw(__be32 addr, int ifindex) {\n    int i;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED)\n            continue;\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    return ((void *)0);\n}\n","function_prediction":"struct mpgw *find_mpgw_name_conflict(int id, int port) {\n  int i;\n\n  for (i = 0; i < 32; i++) {\n    if (!mpgws[i].in_use)\n      continue;\n    if (mpgws[i].id == id && mpgws[i].port == port)\n      return &mpgws[i];\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"int update_mpgw(struct mpgw *gw, enum mpgw_state newstate) {\n    if (gw->state == newstate)\n        return 0;\n    ({\n        if (foreground) {\n            struct timeval tv;\n            gettimeofday(&tv, ((void *)0));\n            fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec, tv.tv_usec, ip2str(gw->gw_ip), gw->if_id, newstate);\n        } else\n            syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\", ip2str(gw->gw_ip), gw->if_id, newstate);\n    });\n    gw->state = newstate;\n    if (gw->state == MPGW_S_PROBE)\n        gw->timeout = (1000 + 10 + random() % (1000));\n    else\n        gw->timeout = (60000 + random() % 30000);\n    return 1;\n}\n","function_prediction":"int update_mpgw_name_conflict(struct mpgw_t *mpgw, int state) {\n  if (mpgw->state == state)\n    return 0;\n\n  if (foreground) {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec,\n            tv.tv_usec, ip2str(mpgw->ip), mpgw->ifindex, state);\n  } else {\n    syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\",\n           ip2str(mpgw->ip), mpgw->ifindex, state);\n  }\n\n  mpgw->state = state;\n\n  if (mpgw->state == 1)\n    mpgw->timeout = 1000 + random() % 1000;\n  else\n    mpgw->timeout = 60000 + random() % 30000;\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"static struct rtattr *rta_find(struct rtattr *head, int len, int type) {\n    struct rtattr *rta;\n    for (rta = head; ((len) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len)); rta = ((len) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n        if (rta->rta_type == type)\n            return rta;\n    return ((void *)0);\n}\n","function_prediction":"struct rtentry *rta_find_name_conflict(struct rtentry *rt, int len, int type) {\n  struct rtentry *rtp;\n\n  for (rtp = rt; len > 3 && rtp->rt_len > 3 && len >= rtp->rt_len;\n       rtp = (struct rtentry *)((char *)rtp + (((rtp->rt_len) + 3) & ~3))) {\n    if (rtp->rt_type == type)\n      return (rtp);\n    len -= (((rtp->rt_len) + 3) & ~3);\n  }\n  return (NULL);\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"static int process_rt(struct nlmsghdr *nlh) {\n    int len;\n    struct rtmsg *rtm = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    struct rtattr *rta;\n    struct rtnexthop *nh;\n    len = ((nlh)->nlmsg_len - ((((((sizeof (*rtm))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid nlmsg_len %d\\\"}\", __func__, len);\n        });\n        return -1;\n    }\n    if (rtm->rtm_family != 2 || rtm->rtm_scope >= RT_SCOPE_LINK)\n        return 0;\n    rta = rta_find(((struct rtattr *)(((char *)(rtm)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1)))), len, RTA_MULTIPATH);\n    if (rta == ((void *)0))\n        return 0;\n    for (len = ((int)((rta)->rta_len) - ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))) , nh = ((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))); len >= sizeof (*nh) && len >= nh->rtnh_len; len -= (((nh->rtnh_len) + 4 - 1) & ~(4 - 1)) , nh = ((struct rtnexthop *)(((char *)(nh)) + ((((nh)->rtnh_len) + 4 - 1) & ~(4 - 1))))) {\n        __be32 gw;\n        rta = rta_find(((struct rtattr *)(((char *)(nh)) + ((((sizeof(struct rtnexthop)) + 4 - 1) & ~(4 - 1)) + (0)))), nh->rtnh_len - (((sizeof (*nh)) + 4 - 1) & ~(4 - 1)), RTA_GATEWAY);\n        if (rta == ((void *)0)) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: no gateway in nh info\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s no gateway in nh info\\\"}\", __func__);\n            });\n            return 0;\n        }\n        gw = *(__be32 *)((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))));\n        if (add_mpgw(gw, nh->rtnh_ifindex) == ((void *)0))\n            return -1;\n    }\n    return 0;\n}\n","function_prediction":"int process_rt_name_conflict(struct nlmsghdr *nh) {\n  struct rtmsg *rtm;\n  struct rtattr *rta;\n  struct rtattr *rta_gw;\n  struct in_addr gw;\n  int len;\n\n  len = nh->nlmsg_len - sizeof(*rtm);\n  if (len < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"invalid nlmsg_len %d\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"process_rt_name_conflict\", len);\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"invalid nlmsg_len %d\"\n               \"\\\"}\",\n               \"process_rt_name_conflict\", len);\n      }\n    } while (0);\n    return -1;\n  }\n\n  rtm = (struct rtmsg *)(((char *)nh) + sizeof(*nh));\n  if (rtm->rtm_family != 2)\n    return 0;\n\n  if (rtm->rtm_type >= 253)\n    return 0;\n\n  rta = rta_find(((char *)rtm) + sizeof(*rtm), len, 9);\n  if (!rta)\n    return 0;\n\n  len = rta->rta_len - sizeof(*rta);\n  rta = (struct rtattr *)(((char *)rta) + sizeof(*rta));\n\n  while (len > 7) {\n    if (len < rta->rta_len)\n      break;\n\n    rta_gw = rta_find(((char *)rta) + sizeof(*rta), rta->rta_len - 8, 5);\n    if (!rta_gw) {\n      do {\n        if (foreground) {\n          struct timeval tv;\n          gettimeofday(&tv, NULL); fprintf(stderr, \"%ld.%06ld [error] %s: \" \"no gateway in nh info\"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int get_nhs(void) {\n    int len;\n    struct nlmsghdr *nlh;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg rtm;\n    } req;\n    reset_mpgws();\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETROUTE;\n    req.nlh.nlmsg_flags = 1 | 256;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.rtm.rtgen_family = 2;\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        for (nlh = (struct nlmsghdr *)recv_buf; ((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len)); nlh = ((len) -= ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlh)) + ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n            if (nlh->nlmsg_seq != talk_seq) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n                });\n                continue;\n            }\n            if (nlh->nlmsg_type == 3)\n                return 0;\n            if (nlh->nlmsg_type == 2) {\n                ({\n                    struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    int rc __attribute__((unused));\n                    if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                        });\n                        rc = -1;\n                    } else if (err->error) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                        });\n                        rc = -1;\n                    }\n                    rc = 0;\n                });\n                return -1;\n            }\n            if (nlh->nlmsg_type != RTM_NEWROUTE) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n                });\n                continue;\n            }\n            if (process_rt(nlh) < 0)\n                return -1;\n        }\n    }\n}\n","function_prediction":"int get_nhs_name_conflict(void) {\n  struct nlmsghdr *nh;\n  struct nlmsgerr *err;\n  int len;\n  int ret;\n  char *buf;\n\n  reset_mpgws();\n\n  struct nlmsghdr nlh;\n  memset(&nlh, 0, sizeof(nlh));\n  nlh.nlmsg_len = sizeof(nlh);\n  nlh.nlmsg_type = 26;\n  nlh.nlmsg_flags = 0x00000001;\n  nlh.nlmsg_seq = talk_seq++;\n  nlh.nlmsg_pid = 2;\n\n  if (send(talk_sock, &nlh, sizeof(nlh), 0) < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"send %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"get_nhs_name_conflict\", strerror(errno));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"send %s\"\n               \"\\\"}\",\n               \"get_nhs_name_conflict\", strerror(errno));\n      }\n    } while (0);\n    return -1;\n  }\n\n  while (1) {\n    len = recv(talk_sock, &recv_buf, 16384, 0);\n    if (len < 0) {\n      if (errno != 4 && errno != 11) {\n        do {\n          if (foreground) {\n            struct timeval tv;\n            gettimeofday(&tv, NULL);\n            fprintf(stderr,\n                    \"%ld.%06ld [error] %s: \"\n                    \"recv %s\"\n                    \"\\n\",\n                    (long)tv.tv_sec, (long)tv.tv_usec, \"get_nhs_name_conflict\",\n                    strerror(errno));\n          } else { syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int update_neigh(int ifindex, __be32 ip, char *hw, int reachable) {\n    struct {\n        struct nlmsghdr nlh;\n        struct ndmsg ndm;\n        struct nlattr nla_dst;\n        __be32 dst;\n        struct nlattr nla_hw;\n        char hw[8];\n    } req;\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_NEWNEIGH;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.nlh.nlmsg_flags = (1 | 4 | 1024 | 256);\n    req.ndm.ndm_family = 2;\n    req.ndm.ndm_ifindex = ifindex;\n    req.ndm.ndm_state = reachable ? 2 : 32;\n    req.nla_dst.nla_len = sizeof(struct nlattr) + sizeof(__be32);\n    req.nla_dst.nla_type = NDA_DST;\n    req.dst = ip;\n    req.nla_hw.nla_len = sizeof(struct nlattr) + 6;\n    req.nla_hw.nla_type = NDA_LLADDR;\n    memcpy(&req.hw, hw, 6);\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        int len;\n        struct nlmsghdr *nlh;\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        nlh = (struct nlmsghdr *)recv_buf;\n        if (!((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len))) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\", __func__, len);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_seq != talk_seq) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_type != 2) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n            });\n            return -1;\n        }\n        return ({\n            struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n            int rc __attribute__((unused));\n            if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                });\n                rc = -1;\n            } else if (err->error) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                });\n                rc = -1;\n            }\n            rc = 0;\n        });\n    }\n}\n","function_prediction":"int update_neigh_name_conflict(int type, int id, char *mac, int is_neigh) {\n  struct nlmsghdr nlh;\n  struct nlmsgerr nlerr;\n  struct ifinfomsg ifi;\n  struct sockaddr_nl nladdr;\n  int len;\n  char *buf;\n\n  memset(&nlh, 0, sizeof(nlh));\n  nlh.nlmsg_len = sizeof(nlh);\n  nlh.nlmsg_type = 28;\n  nlh.nlmsg_flags = 0x00000002;\n  nlh.nlmsg_seq = ++talk_seq;\n  nlh.nlmsg_pid = 0x0505;\n\n  ifi.ifi_type = type;\n  ifi.ifi_index = id;\n  ifi.ifi_change = is_neigh ? 0x0002 : 0x0020;\n  ifi.ifi_flags = 0x0008;\n  ifi.ifi_family = 0x0001;\n  ifi.ifi_prefixlen = 10;\n  ifi.ifi_scope = 2;\n\n  nladdr.nl_family = AF_NETLINK;\n  nladdr.nl_pid = 0;\n  nladdr.nl_groups = 0;\n\n  buf = (char *)&nlh;\n  memcpy(buf + sizeof(nlh), &ifi, sizeof(ifi));\n\n  if (send(talk_sock, buf, nlh.nlmsg_len, 0) < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"send %s\"\n                \"\\n\",\n                tv.tv_sec, tv.tv_usec, \"update_neigh_name_conflict\", strerror(errno));\n      } else { syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \" \"send %s\" \"\\\"}\", \"update_neigh_name_conflict\", stre","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":1,"function":"int recv_nl(void) {\n    struct sockaddr_nl saddr;\n    socklen_t addrlen = sizeof (saddr);\n    if (recvfrom(poll_sock, recv_buf, sizeof (recv_buf), MSG_DONTWAIT, (struct sockaddr *)&saddr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 0;\n    }\n    if (addrlen != sizeof (saddr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid addr len\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\", __func__);\n        });\n        return 0;\n    }\n    if (saddr.nl_pid)\n        return 0;\n    get_nhs();\n    return 1;\n}\n","function_prediction":"int recv_nl_name_conflict(void) {\n  struct sockaddr_nl nladdr;\n  socklen_t nladdr_len = sizeof(nladdr);\n  ssize_t n;\n\n  n = recvfrom(poll_sock, &recv_buf, 16384, 0x00000040,\n               (struct sockaddr *)&nladdr, &nladdr_len);\n  if (n < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", (long)tv.tv_sec,\n              (long)tv.tv_usec, \"recv_nl_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\",\n             \"recv_nl_name_conflict\", strerror(*__errno_location()));\n    }\n    return 0;\n  }\n  if (nladdr_len != sizeof(nladdr)) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: invalid addr len\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"recv_nl_name_conflict\");\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\",\n             \"recv_nl_name_conflict\");\n    }\n    return 0;\n  }\n  if (nladdr.nl_pid != 0)\n    return 0;\n\n  get_nhs();\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int open_nl(void) {\n    struct sockaddr_nl addr;\n    socklen_t addrlen = sizeof (addr);\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    if ((talk_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (connect(talk_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (getsockname(talk_sock, (struct sockaddr *)&addr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    talk_seq = random();\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    addr.nl_groups = 64;\n    if ((poll_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (bind(poll_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: bind poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_poll;\n    }\n    if (get_nhs() < 0)\n        goto cleanup_poll;\n    return poll_sock;\n  cleanup_poll:\n    close(poll_sock);\n  cleanup_talk:\n    close(talk_sock);\n  err_out:\n    return -1;\n}\n","function_prediction":"int open_nl_name_conflict(void) {\n  struct sockaddr_nl sa;\n  socklen_t salen = sizeof(sa);\n\n  memset(&sa, 0, sizeof(sa));\n  sa.nl_family = AF_NETLINK;\n\n  if ((talk_sock = socket(AF_NETLINK, 3, 0)) < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"socket talk_sock %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"open_nl_name_conflict\",\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"socket talk_sock %s\"\n               \"\\\"}\",\n               \"open_nl_name_conflict\", strerror(*__errno_location()));\n      }\n    } while (0);\n    return -1;\n  }\n\n  if (connect(talk_sock, (struct sockaddr *)&sa, salen) < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"connect talk_sock %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"open_nl_name_conflict\",\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"connect talk_sock %s\"\n               \"\\\"}\",\n               \"open_nl_name_conflict\", strerror(*__errno_location()));\n      }\n    } while (0);\n    close(talk_sock);\n    return -1;\n  }\n\n  if (getsockname(talk_sock, (struct sockaddr *)&sa, &salen) < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL); fprintf(stderr,","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":1,"function":"static __be16 in_cksum(const __be16 *addr, register int len) {\n    register int nleft = len;\n    register __be32 sum = 0;\n    const __be16 *w = addr;\n    while (nleft > 1)\n        {\n            sum += *w++;\n            nleft -= 2;\n        }\n    if (nleft == 1)\n        sum += htons((__u16)(*(char *)w) << 8);\n    sum = (sum >> 16) + (sum & 65535);\n    sum += (sum >> 16);\n    return (__be16)~sum;\n}\n","function_prediction":"uint16_t in_cksum_name_conflict(void *buf, int len) {\n  uint32_t sum = 0;\n  uint16_t *buf16 = buf;\n\n  while (len > 1) {\n    sum += *buf16++;\n    len -= 2;\n  }\n\n  if (len == 1)\n    sum += htons(((uint16_t)*(char *)buf16) << 8);\n\n  sum = (sum >> 16) + (sum & 0xffff);\n  sum += (sum >> 16);\n  return ~sum;\n}","pass":1,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_ping(int ifindex, __be32 daddr) {\n    static struct sockaddr_in dest = {2, 0};\n    static char buf[16];\n    static struct iovec iov = {buf, sizeof (buf)};\n    static struct {\n        struct cmsghdr cm;\n        struct in_pktinfo ipi;\n    } cmsg = {{sizeof (cmsg.cm) + sizeof (cmsg.ipi), 0, 8}};\n    static struct msghdr msg = {&dest, sizeof (dest), &iov, 1, &cmsg, sizeof (cmsg), 0};\n    struct icmphdr *icmp = (struct icmphdr *)buf;\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    ;\n    dest.sin_addr.s_addr = daddr;\n    cmsg.ipi.ipi_ifindex = ifindex;\n    icmp->type = 8;\n    icmp->code = 0;\n    icmp->un.echo.id = ping_id;\n    icmp->un.echo.sequence = 0;\n    icmp->checksum = 0;\n    pmsg->ifindex = (__be32)ifindex;\n    pmsg->sig = 1297106775;\n    icmp->checksum = in_cksum((__be16 *)buf, sizeof (buf));\n    if (sendmsg(ping_sock, &msg, MSG_DONTROUTE) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\", __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int send_ping_name_conflict(int sock, in_addr_t ip) {\n  static char buf[16] = {0x4d, 0x50, 0x47, 0x57, 0, 0, 0, 0,\n                         0,    0,    0,    0,    0, 0, 0, 0};\n  static struct cmsghdr cmsg;\n  static struct iovec iov = {.iov_base = buf, .iov_len = sizeof(buf)};\n  static struct msghdr msg = {.msg_name = &ip,\n                              .msg_namelen = sizeof(ip),\n                              .msg_iov = &iov,\n                              .msg_iovlen = 1,\n                              .msg_control = &cmsg,\n                              .msg_controllen = sizeof(cmsg)};\n\n  buf[2] = ping_id;\n  buf[12] = in_cksum(buf, sizeof(buf));\n\n  if (sendmsg(ping_sock, &msg, 4) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr,\n              \"%ld.%06ld [error] %s: \"\n              \"sendmsg %d %s %s\"\n              \"\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"send_ping_name_conflict\", sock, ip2str(ip),\n              strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\",\n             \"send_ping_name_conflict\", sock, ip2str(ip), strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int recv_ping(int *ifindex, __be32 *daddr) {\n    static struct sockaddr_in src;\n    static char buf[1500];\n    struct icmphdr *icmp = (struct icmphdr *)(buf + sizeof(struct iphdr));\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    socklen_t srclen = sizeof (src);\n    int len;\n    len = recvfrom(ping_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&src, &srclen);\n    if (len < sizeof(struct iphdr) + sizeof (*icmp)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, len, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\", __func__, len, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (src.sin_family != 2) {\n        return -1;\n    }\n    if (icmp->un.echo.id != ping_id || icmp->type != 0 || icmp->un.echo.sequence != 0 || icmp->code != 0) {\n        return -1;\n    }\n    if (len < sizeof(struct iphdr) + sizeof (*icmp) + sizeof (*pmsg)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: msg too small\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (in_cksum((__be16 *)buf, len) != 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: checksum error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (pmsg->sig != 1297106775) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: signature error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = (int)pmsg->ifindex;\n    *daddr = src.sin_addr.s_addr;\n    ;\n    return 0;\n}\n","function_prediction":"int recv_ping_name_conflict(int *sock, int *port) {\n  struct timeval tv;\n  struct timeval tv1;\n  struct timeval tv2;\n  struct timeval tv3;\n  struct timeval tv4;\n  struct timeval tv5;\n  struct timeval tv6;\n  struct timeval tv7;\n  struct timeval tv8;\n  struct timeval tv9;\n  struct timeval tv10;\n  struct timeval tv11;\n  struct timeval tv12;\n  struct timeval tv13;\n  struct timeval tv14;\n  struct timeval tv15;\n  struct timeval tv16;\n  struct timeval tv17;\n  struct timeval tv18;\n  struct timeval tv19;\n  struct timeval tv20;\n  struct timeval tv21;\n  struct timeval tv22;\n  struct timeval tv23;\n  struct timeval tv24;\n  struct timeval tv25;\n  struct timeval tv26;\n  struct timeval tv27;\n  struct timeval tv28;\n  struct timeval tv29;\n  struct timeval tv30;\n  struct timeval tv31;\n  struct timeval tv32;\n  struct timeval tv33;\n  struct timeval tv34;\n  struct timeval tv35;\n  struct timeval tv36;\n  struct timeval tv37;\n  struct timeval tv38;\n  struct timeval tv39;\n  struct timeval tv40;\n  struct timeval tv41;\n  struct timeval tv42;\n  struct timeval tv43;\n  struct timeval tv44;\n  struct timeval tv45;\n  struct timeval tv46;\n  struct timeval tv47;\n  struct timeval tv48;\n  struct timeval tv49;\n  struct timeval tv50;\n  struct timeval tv51;\n  struct timeval tv52;\n  struct timeval tv53;\n  struct timeval tv54;\n  struct timeval tv55;\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int open_ping(void) {\n    int one = 1;\n    if ((ping_sock = socket(2, SOCK_RAW, IPPROTO_ICMP)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 2, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 8, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_PKTINFO %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    ping_id = htons(getpid() & 65535);\n    return ping_sock;\n  err_out:\n    close(ping_sock);\n    return -1;\n}\n","function_prediction":"int open_ping_name_conflict(void) {\n  int on = 1;\n\n  if ((ping_sock = socket(2, 3, 1)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", (long)tv.tv_sec,\n              (long)tv.tv_usec, \"open_ping_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\",\n             \"open_ping_name_conflict\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  if (setsockopt(ping_sock, 0, 2, &on, sizeof(on)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"open_ping_name_conflict\",\n              strerror(*__errno_location()));\n    } else {\n      syslog(3,\n             \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\",\n             \"open_ping_name_conflict\", strerror(*__errno_location()));\n    }\n    close(ping_sock);\n    return -1;\n  }\n\n  if (setsockopt(ping_sock, 0, 8, &on, sizeof(on)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n   fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\",\n    (long)tv.tv_sec, (long)tv.tv_usec, \"open_ping_name_conflict\", strerror(*__err","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_garp(int ifindex, __be32 sip, char *sha, __be32 tip, char *tha) {\n    static char buf[64];\n    struct sockaddr_ll sll;\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    ;\n    arp->ar_hrd = htons(1);\n    arp->ar_pro = htons(2048);\n    arp->ar_hln = 6;\n    arp->ar_pln = 4;\n    arp->ar_op = htons(2);\n    memcpy(p, sha, 6);\n    p += 6;\n    memcpy(p, &sip, 4);\n    p += 4;\n    memcpy(p, tha, 6);\n    p += 6;\n    memcpy(p, &tip, 4);\n    p += 4;\n    memset(&sll, 0, sizeof (sll));\n    sll.sll_protocol = htons(2054);\n    sll.sll_ifindex = ifindex;\n    sll.sll_halen = 6;\n    memset(sll.sll_addr, 255, 6);\n    if (sendto(arp_sock, buf, p - buf, 0, (struct sockaddr *)&sll, sizeof (sll)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\", __func__, ifindex, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int send_garp_name_conflict(int ifindex, int iftype, char *smac, int stype, char *tmac) {\n  struct sockaddr_ll sll;\n  char *p;\n  struct timeval tv;\n\n  p = (char *)&buf;\n\n  *(unsigned short *)p = htons(0x0001);\n  p += 2;\n  *(unsigned short *)p = htons(0x0800);\n  p += 2;\n  *p = 0x06;\n  p++;\n  *p = 0x04;\n  p++;\n  *(unsigned short *)p = htons(0x0002);\n  p += 2;\n\n  memcpy(p, smac, 6);\n  p += 6;\n  *(unsigned int *)p = iftype;\n  p += 4;\n  memcpy(p, tmac, 6);\n  p += 6;\n  *(unsigned int *)p = stype;\n  p += 4;\n\n  memset(&sll, 0, sizeof(sll));\n  sll.sll_family = AF_PACKET;\n  sll.sll_protocol = htons(0x0806);\n  sll.sll_ifindex = ifindex;\n  sll.sll_hatype = 0x0001;\n  sll.sll_halen = 0x06;\n  memset(sll.sll_addr, 0xff, 6);\n\n  if (sendto(arp_sock, &buf, p - (char *)&buf, 0, (struct sockaddr *)&sll,\n             sizeof(sll)) < 0) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"send_garp_name_conflict\", ifindex, strerror(*__errno_location()));\n    } else {\n            syslog(3, \"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int recv_arp(int *ifindex, __u16 *type, __u16 *op, __be32 *sip, char *sha, __be32 *tip, char *tha) {\n    int len;\n    static char buf[1024];\n    struct sockaddr_ll sll;\n    socklen_t sll_len = sizeof (sll);\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    len = recvfrom(arp_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&sll, &sll_len);\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (len < sizeof (*arp) || (arp->ar_op != htons(1) && arp->ar_op != htons(2)) || arp->ar_pln != 4 || arp->ar_pro != htons(2048) || arp->ar_hln != 6 || len < sizeof (*arp) + 2 * 4 + 2 * 6) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = sll.sll_ifindex;\n    *type = sll.sll_pkttype;\n    *op = ntohs(arp->ar_op);\n    memcpy(sha, p, 6);\n    memcpy(sip, p + 6, 4);\n    memcpy(tha, p + 6 + 4, 6);\n    memcpy(tip, p + 6 + 4 + 6, 4);\n    return 0;\n}\n","function_prediction":"int recv_arp(unsigned char *src_mac, unsigned short *src_port,\n             unsigned short *dst_port, unsigned char *dst_mac,\n             unsigned char *src_ip, unsigned char *dst_ip,\n             unsigned char *dst_mac2) {\n  struct sockaddr_in from;\n  socklen_t fromlen = sizeof(from);\n  int n;\n  unsigned char *p = buf_2;\n\n  n = recvfrom(arp_sock, buf_2, 1024, 0x40, (struct sockaddr *)&from, &fromlen);\n  if (n < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", (long)tv.tv_sec,\n              (long)tv.tv_usec, \"recv_arp\", strerror(errno));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\",\n             \"recv_arp\", strerror(errno));\n    }\n    return -1;\n  }\n\n  if (n < 8 || n < 28) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"recv_arp\");\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\",\n             \"recv_arp\");\n    }\n    return -1;\n  }\n\n  if (p[6] != htons(1) && p[6] != htons(2)) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n   fprintf(stderr, \"%ld.%","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":1,"function":"int open_arp(void) {\n    if ((arp_sock = socket(17, SOCK_DGRAM, htons(2054))) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return arp_sock;\n}\n","function_prediction":"int open_arp_name_conflict() {\n  struct timeval tv;\n\n  arp_sock = socket(17, 2, htons(1346));\n  if (arp_sock < 0) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"open_arp_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\",\n             \"open_arp_name_conflict\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n  return arp_sock;\n}","pass":1,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":1,"function":"static __be16 in_cksum(const __be16 *addr, register int len) {\n    register int nleft = len;\n    register __be32 sum = 0;\n    const __be16 *w = addr;\n    while (nleft > 1)\n        {\n            sum += *w++;\n            nleft -= 2;\n        }\n    if (nleft == 1)\n        sum += htons((__u16)(*(char *)w) << 8);\n    sum = (sum >> 16) + (sum & 65535);\n    sum += (sum >> 16);\n    return (__be16)~sum;\n}\n","function_prediction":"uint16_t in_cksum_name_conflict(void *buf, int len) {\n  uint32_t sum = 0;\n  uint16_t *buf16 = buf;\n\n  while (len > 1) {\n    sum += *buf16++;\n    len -= 2;\n  }\n\n  if (len == 1)\n    sum += htons(((uint16_t)*(char *)buf16) << 8);\n\n  sum = (sum >> 16) + (sum & 0xffff);\n  sum += (sum >> 16);\n  return ~sum;\n}","pass":1,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_ping(int ifindex, __be32 daddr) {\n    static struct sockaddr_in dest = {2, 0};\n    static char buf[16];\n    static struct iovec iov = {buf, sizeof (buf)};\n    static struct {\n        struct cmsghdr cm;\n        struct in_pktinfo ipi;\n    } cmsg = {{sizeof (cmsg.cm) + sizeof (cmsg.ipi), 0, 8}};\n    static struct msghdr msg = {&dest, sizeof (dest), &iov, 1, &cmsg, sizeof (cmsg), 0};\n    struct icmphdr *icmp = (struct icmphdr *)buf;\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    ;\n    dest.sin_addr.s_addr = daddr;\n    cmsg.ipi.ipi_ifindex = ifindex;\n    icmp->type = 8;\n    icmp->code = 0;\n    icmp->un.echo.id = ping_id;\n    icmp->un.echo.sequence = 0;\n    icmp->checksum = 0;\n    pmsg->ifindex = (__be32)ifindex;\n    pmsg->sig = 1297106775;\n    icmp->checksum = in_cksum((__be16 *)buf, sizeof (buf));\n    if (sendmsg(ping_sock, &msg, MSG_DONTROUTE) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\", __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int send_ping_name_conflict(int sock, in_addr_t ip) {\n  static char buf[16] = {8, 0, 0, 0, 0, 0, 0, 0, 'W', 'P', 'G', 'M'};\n  static struct cmsghdr cmsg;\n  static struct iovec iov = {.iov_base = buf, .iov_len = sizeof(buf)};\n  static struct msghdr msg = {.msg_name = &ip,\n                              .msg_namelen = sizeof(ip),\n                              .msg_iov = &iov,\n                              .msg_iovlen = 1,\n                              .msg_control = &cmsg,\n                              .msg_controllen = sizeof(cmsg)};\n\n  buf[2] = in_cksum(buf, sizeof(buf));\n\n  if (sendmsg(ping_sock, &msg, 4) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr,\n              \"%ld.%06ld [error] %s: \"\n              \"sendmsg %d %s %s\"\n              \"\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"send_ping_name_conflict\", sock, ip2str(ip),\n              strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\",\n             \"send_ping_name_conflict\", sock, ip2str(ip), strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int recv_ping(int *ifindex, __be32 *daddr) {\n    static struct sockaddr_in src;\n    static char buf[1500];\n    struct icmphdr *icmp = (struct icmphdr *)(buf + sizeof(struct iphdr));\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    socklen_t srclen = sizeof (src);\n    int len;\n    len = recvfrom(ping_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&src, &srclen);\n    if (len < sizeof(struct iphdr) + sizeof (*icmp)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, len, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\", __func__, len, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (src.sin_family != 2) {\n        return -1;\n    }\n    if (icmp->un.echo.id != ping_id || icmp->type != 0 || icmp->un.echo.sequence != 0 || icmp->code != 0) {\n        return -1;\n    }\n    if (len < sizeof(struct iphdr) + sizeof (*icmp) + sizeof (*pmsg)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: msg too small\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (in_cksum((__be16 *)buf, len) != 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: checksum error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (pmsg->sig != 1297106775) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: signature error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = (int)pmsg->ifindex;\n    *daddr = src.sin_addr.s_addr;\n    ;\n    return 0;\n}\n","function_prediction":"int recv_ping_name_conflict(int *port, int *proto) {\n  struct timeval tv;\n  struct timeval tv1;\n  struct timeval tv2;\n  struct timeval tv3;\n  struct timeval tv4;\n  struct timeval tv5;\n  struct timeval tv6;\n  struct timeval tv7;\n  struct timeval tv8;\n  struct timeval tv9;\n  struct timeval tv10;\n  struct timeval tv11;\n  struct timeval tv12;\n  struct timeval tv13;\n  struct timeval tv14;\n  struct timeval tv15;\n  struct timeval tv16;\n  struct timeval tv17;\n  struct timeval tv18;\n  struct timeval tv19;\n  struct timeval tv20;\n  struct timeval tv21;\n  struct timeval tv22;\n  struct timeval tv23;\n  struct timeval tv24;\n  struct timeval tv25;\n  struct timeval tv26;\n  struct timeval tv27;\n  struct timeval tv28;\n  struct timeval tv29;\n  struct timeval tv30;\n  struct timeval tv31;\n  struct timeval tv32;\n  struct timeval tv33;\n  struct timeval tv34;\n  struct timeval tv35;\n  struct timeval tv36;\n  struct timeval tv37;\n  struct timeval tv38;\n  struct timeval tv39;\n  struct timeval tv40;\n  struct timeval tv41;\n  struct timeval tv42;\n  struct timeval tv43;\n  struct timeval tv44;\n  struct timeval tv45;\n  struct timeval tv46;\n  struct timeval tv47;\n  struct timeval tv48;\n  struct timeval tv49;\n  struct timeval tv50;\n  struct timeval tv51;\n  struct timeval tv52;\n  struct timeval tv53;\n  struct timeval tv54;\n  struct timeval tv55;\n  struct","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int open_ping(void) {\n    int one = 1;\n    if ((ping_sock = socket(2, SOCK_RAW, IPPROTO_ICMP)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 2, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 8, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_PKTINFO %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    ping_id = htons(getpid() & 65535);\n    return ping_sock;\n  err_out:\n    close(ping_sock);\n    return -1;\n}\n","function_prediction":"int open_ping_name_conflict(void) {\n  int on = 1;\n\n  if ((ping_sock = socket(2, 3, 1)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", (long)tv.tv_sec,\n              (long)tv.tv_usec, \"open_ping_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\",\n             \"open_ping_name_conflict\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  if (setsockopt(ping_sock, 0, 2, &on, sizeof(on)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"open_ping_name_conflict\",\n              strerror(*__errno_location()));\n    } else {\n      syslog(3,\n             \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\",\n             \"open_ping_name_conflict\", strerror(*__errno_location()));\n    }\n    close(ping_sock);\n    return -1;\n  }\n\n  if (setsockopt(ping_sock, 0, 8, &on, sizeof(on)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n   fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\",\n    (long)tv.tv_sec, (long)tv.tv_usec, \"open_ping_name_conflict\", strerror(*__err","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"static int fill_if_addrs(struct mpgw *gw) {\n    int sock, ret = -1;\n    struct ifreq ifr;\n    struct sockaddr_in saddr;\n    socklen_t len;\n    if ((sock = socket(2, SOCK_DGRAM, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    memset(&ifr, 0, sizeof (ifr));\n    ifr.ifr_ifru.ifru_ivalue = gw->if_id;\n    if (ioctl(sock, 35088, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, gw->if_id, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\", __func__, gw->if_id, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ioctl(sock, 35111, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ifr.ifr_ifru.ifru_hwaddr.sa_family != 1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid if %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name);\n        });\n        goto close_ret;\n    }\n    if (setsockopt(sock, 1, 25, ifr.ifr_ifrn.ifrn_name, strlen(ifr.ifr_ifrn.ifrn_name) + 1) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    memset(&saddr, 0, sizeof (saddr));\n    saddr.sin_family = 2;\n    saddr.sin_port = htons(1025);\n    saddr.sin_addr.s_addr = gw->gw_ip;\n    if (connect(sock, (struct sockaddr *)&saddr, sizeof (saddr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect to %s from %s %s\\\"}\", __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    len = sizeof (saddr);\n    if (getsockname(sock, (struct sockaddr *)&saddr, &len) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    ret = 0;\n    memcpy(gw->if_hw, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    gw->if_ip = saddr.sin_addr.s_addr;\n  close_ret:\n    close(sock);\n    return ret;\n}\n","function_prediction":"int fill_if_addrs_name_conflict(struct if_addr *if_addr) {\n  int sock = -1;\n  int ret = -1;\n  struct ifreq ifr;\n  struct sockaddr_in sin;\n  socklen_t sin_len;\n\n  if ((sock = socket(2, 2, 0)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: socket sock %s\\n\", (long)tv.tv_sec,\n              (long)tv.tv_usec, \"fill_if_addrs_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\",\n             \"fill_if_addrs_name_conflict\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  memset(&ifr, 0, sizeof(ifr));\n  ifr.ifr_ifindex = if_addr->if_index;\n  if (ioctl(sock, 0x8910, &ifr) != 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"fill_if_addrs_name_conflict\",\n              if_addr->if_index, strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\",\n             \"fill_if_addrs_name_conflict\", if_addr->if_index, strerror(*__errno_location()));\n    }\n    goto out;\n  }\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *add_mpgw(__be32 addr, int ifindex) {\n    int i, j = -1;\n    struct timespec now;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED) {\n            if (j == -1)\n                j = i;\n            continue;\n        }\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    if (j == -1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: not enough memory\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\", __func__);\n        });\n        return ((void *)0);\n    }\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return ((void *)0);\n    }\n    memset(&mpgws[j], 0, sizeof (mpgws[j]));\n    mpgws[j].gw_ip = addr;\n    mpgws[j].if_id = ifindex;\n    if (fill_if_addrs(&mpgws[j]) < 0)\n        return ((void *)0);\n    mpgws[j].last_sent = now;\n    mpgws[j].last_rcvd = now;\n    update_mpgw(&mpgws[j], MPGW_S_PROBE);\n    srandom(mpgws[j].if_ip);\n    return &mpgws[j];\n}\n","function_prediction":"struct mpgw *add_mpgw_name_conflict(int sock, int port) {\n  int i, j, k;\n  struct timespec ts;\n\n  j = -1;\n  for (i = 0; i < 32; i++) {\n    if (!mpgws[i].used) {\n      if (j == -1)\n        j = i;\n    } else if (mpgws[i].sock == sock && mpgws[i].port == port)\n      return &mpgws[i];\n  }\n\n  if (j == -1) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"not enough memory\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, __func__);\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"not enough memory\"\n               \"\\\"}\",\n               __func__);\n      }\n    } while (0);\n    return NULL;\n  }\n\n  k = clock_gettime(1, &ts);\n  if (k < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"clock_gettime %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, __func__,\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"clock_gettime %s\"\n               \"\\\"}\",\n               __func__, strerror(*__errno_location()));\n      }\n    } while (0);\n    return NULL;\n  }\n\n  memset(&mpgws[j], 0, sizeof(mpgws[j]));\n  mpgws[j].sock = sock;\n  mpgws[j].port = port;\n  k = fill_if_addrs(&mpgws[j]);\n if (k","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *find_mpgw(__be32 addr, int ifindex) {\n    int i;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED)\n            continue;\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    return ((void *)0);\n}\n","function_prediction":"struct mpgw *find_mpgw_name_conflict(int id, int port) {\n  int i;\n\n  for (i = 0; i < 32; i++) {\n    if (!mpgws[i].in_use)\n      continue;\n    if (mpgws[i].id == id && mpgws[i].port == port)\n      return &mpgws[i];\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"int update_mpgw(struct mpgw *gw, enum mpgw_state newstate) {\n    if (gw->state == newstate)\n        return 0;\n    ({\n        if (foreground) {\n            struct timeval tv;\n            gettimeofday(&tv, ((void *)0));\n            fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec, tv.tv_usec, ip2str(gw->gw_ip), gw->if_id, newstate);\n        } else\n            syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\", ip2str(gw->gw_ip), gw->if_id, newstate);\n    });\n    gw->state = newstate;\n    if (gw->state == MPGW_S_PROBE)\n        gw->timeout = (1000 + 10 + random() % (1000));\n    else\n        gw->timeout = (60000 + random() % 30000);\n    return 1;\n}\n","function_prediction":"int update_mpgw_name_conflict(struct mpgw_t *mpgw, int state) {\n  if (mpgw->state == state)\n    return 0;\n\n  if (foreground) {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec,\n            tv.tv_usec, ip2str(mpgw->ip), mpgw->ifindex, state);\n  } else {\n    syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\",\n           ip2str(mpgw->ip), mpgw->ifindex, state);\n  }\n\n  mpgw->state = state;\n\n  if (mpgw->state == 1)\n    mpgw->timeout = 1000 + random() % 1000;\n  else\n    mpgw->timeout = 60000 + random() % 30000;\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"static int process_ping(void) {\n    int ifindex;\n    __be32 addr;\n    struct mpgw *gw;\n    if (recv_ping(&ifindex, &addr) < 0)\n        return 0;\n    if ((gw = find_mpgw(addr, ifindex)) == ((void *)0))\n        return 0;\n    if (clock_gettime(1, &gw->last_rcvd) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 1;\n    }\n    if (memcmp(gw->gw_hw, \"\\000\\000\\000\\000\\000\\000\", 6) == 0)\n        return 1;\n    if (update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 1) == 0)\n        update_mpgw(gw, MPGW_S_PROBE);\n    if (gratuitous_arp)\n        send_garp(gw->if_id, gw->gw_ip, gw->gw_hw, gw->if_ip, gw->if_hw);\n    return 1;\n}\n","function_prediction":"int process_ping_name_conflict(void) {\n  struct mpgw *mpgw;\n  struct sockaddr_in ping_addr;\n  struct timespec now;\n  int ret;\n\n  ret = recv_ping(&ping_addr, &mpgw);\n  if (ret < 0)\n    return 0;\n\n  mpgw = find_mpgw(mpgw, ping_addr);\n  if (!mpgw)\n    return 0;\n\n  ret = clock_gettime(1, &mpgw->last_ping);\n  if (ret < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"clock_gettime %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"process_ping_name_conflict\",\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"clock_gettime %s\"\n               \"\\\"}\",\n               \"process_ping_name_conflict\", strerror(*__errno_location()));\n      }\n    } while (0);\n    return 1;\n  }\n\n  if (!memcmp(&mpgw->ping_addr, \"\\0\\0\\0\\0\\0\\0\", 6))\n    return 1;\n\n  if (!update_neigh(mpgw->ifname, mpgw->neigh_addr, &mpgw->ping_addr, 1))\n    update_mpgw(mpgw, 1);\n\n  if (gratuitous_arp)\n    send_garp(mpgw->ifname, mpgw->neigh_addr, &mpgw->ping_addr,\n              mpgw->neigh_hwaddr, &mpgw->ping_hwaddr);\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static int process_arp(void) {\n    int ifindex;\n    __u16 type, op;\n    __be32 sip, tip;\n    char sha[6], tha[6];\n    struct mpgw *gw;\n    if (recv_arp(&ifindex, &type, &op, &sip, sha, &tip, tha) < 0)\n        return 0;\n    if ((gw = find_mpgw(sip, ifindex)) == ((void *)0))\n        return 0;\n    if (tip == gw->if_ip && type == 1 && op == 2)\n        return 0;\n    if (memcmp(gw->gw_hw, sha, 6)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [info] gw %s on if %d changed mac to %s\\n\", tv.tv_sec, tv.tv_usec, ip2str(sip), ifindex, hw2str(sha));\n            } else\n                syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": gw %s on if %d changed mac to %s\\\"}\", ip2str(sip), ifindex, hw2str(sha));\n        });\n        memcpy(gw->gw_hw, sha, 6);\n    }\n    if (clock_gettime(1, &gw->last_rcvd) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 1;\n    }\n    if (update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 1) == 0)\n        update_mpgw(gw, MPGW_S_PROBE);\n    if (master_election && type == 1 && op == 2) {\n        if (tip < gw->if_ip)\n            gw->timeout = (1000 + 10 + random() % (1000));\n        else\n            gw->timeout = 1000;\n    }\n    return 1;\n}\n","function_prediction":"int process_arp_name_conflict(void) {\n  struct mpgw *gw;\n  unsigned int ifindex;\n  unsigned short hwtype, prtype;\n  unsigned char hwaddr[6];\n  unsigned int ipaddr;\n  unsigned int gwid;\n  int rc;\n\n  rc =\n      recv_arp(&ifindex, &hwtype, &prtype, &ipaddr, hwaddr, &gwid, &gw->ifname);\n  if (rc < 0)\n    return 0;\n\n  gw = find_mpgw(ipaddr, ifindex);\n  if (!gw)\n    return 0;\n\n  if (gw->gwid == gwid && hwtype == 1 && prtype == 2)\n    return 0;\n\n  if (memcmp(&gw->hwaddr, hwaddr, 6)) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [info] gw %s on if %d changed mac to %s\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, ip2str(ipaddr), ifindex,\n              hw2str(hwaddr));\n    } else {\n      syslog(6,\n             \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": gw %s on if %d changed mac to \"\n             \"%s\\\"}\",\n             ip2str(ipaddr), ifindex, hw2str(hwaddr));\n    }\n    gw->hwaddr = *(struct ether_addr *)hwaddr;\n    gw->hwtype = hwtype;\n  }\n\n  if (clock_gettime(1, &gw->last_arp) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n            fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\",\n                    (long)tv.tv_sec, (long)tv.tv","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static int refresh(void) {\n    int i, diff, timeout = 1000;\n    struct timespec now;\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return timeout;\n    }\n    for (i = 0; i < 32; i++) {\n        struct mpgw *gw = &mpgws[i];\n        if (gw->state == MPGW_S_UNUSED)\n            continue;\n        diff = (((&now)->tv_sec - (&gw->last_rcvd)->tv_sec) * 1000 + ((&now)->tv_nsec - (&gw->last_rcvd)->tv_nsec) / 1000000);\n        if (diff < gw->timeout) {\n            diff = gw->timeout - diff;\n            if (timeout > diff)\n                timeout = diff;\n            if (gw->timeout != 1000)\n                continue;\n        }\n        if (gw->state == MPGW_S_PROBE && diff > 3 * gw->timeout && update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 0) == 0) {\n            update_mpgw(gw, MPGW_S_FAILED);\n            memset(&gw->gw_hw, 0, sizeof (6));\n        }\n        diff = (((&now)->tv_sec - (&gw->last_sent)->tv_sec) * 1000 + ((&now)->tv_nsec - (&gw->last_sent)->tv_nsec) / 1000000);\n        if (diff < gw->timeout) {\n            diff = gw->timeout - diff;\n            if (timeout > diff)\n                timeout = diff;\n            continue;\n        }\n        send_ping(gw->if_id, gw->gw_ip);\n        gw->last_sent = now;\n        if (timeout > gw->timeout)\n            timeout = gw->timeout;\n    }\n    return timeout;\n}\n","function_prediction":"int refresh_name_conflict(void) {\n  int i, j, k, m, n, t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13,\n      t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28,\n      t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43,\n      t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58,\n      t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69, t70, t71, t72, t73,\n      t74, t75, t76, t77, t78, t79, t80, t81, t82, t83, t84, t85, t86, t87, t88,\n      t89, t90, t91, t92, t93, t94, t95, t96, t97, t98, t99, t100, t101, t102,\n      t103, t104, t105, t106, t107, t108, t109, t110, t111, t112, t113, t114,\n      t115, t116, t117, t118, t119, t120","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static struct rtattr *rta_find(struct rtattr *head, int len, int type) {\n    struct rtattr *rta;\n    for (rta = head; ((len) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len)); rta = ((len) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n        if (rta->rta_type == type)\n            return rta;\n    return ((void *)0);\n}\n","function_prediction":"struct rtentry *rta_find_name_conflict(struct rtentry *rt, int len, int type) {\n  struct rtentry *rtp;\n\n  for (rtp = rt; len > 3 && rtp->rt_len > 3 && len >= rtp->rt_len;\n       rtp = (struct rtentry *)((char *)rtp + (((rtp->rt_len) + 3) & ~3))) {\n    if (rtp->rt_type == type)\n      return (rtp);\n    len -= (((rtp->rt_len) + 3) & ~3);\n  }\n  return (NULL);\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"static int process_rt(struct nlmsghdr *nlh) {\n    int len;\n    struct rtmsg *rtm = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    struct rtattr *rta;\n    struct rtnexthop *nh;\n    len = ((nlh)->nlmsg_len - ((((((sizeof (*rtm))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid nlmsg_len %d\\\"}\", __func__, len);\n        });\n        return -1;\n    }\n    if (rtm->rtm_family != 2 || rtm->rtm_scope >= RT_SCOPE_LINK)\n        return 0;\n    rta = rta_find(((struct rtattr *)(((char *)(rtm)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1)))), len, RTA_MULTIPATH);\n    if (rta == ((void *)0))\n        return 0;\n    for (len = ((int)((rta)->rta_len) - ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))) , nh = ((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))); len >= sizeof (*nh) && len >= nh->rtnh_len; len -= (((nh->rtnh_len) + 4 - 1) & ~(4 - 1)) , nh = ((struct rtnexthop *)(((char *)(nh)) + ((((nh)->rtnh_len) + 4 - 1) & ~(4 - 1))))) {\n        __be32 gw;\n        rta = rta_find(((struct rtattr *)(((char *)(nh)) + ((((sizeof(struct rtnexthop)) + 4 - 1) & ~(4 - 1)) + (0)))), nh->rtnh_len - (((sizeof (*nh)) + 4 - 1) & ~(4 - 1)), RTA_GATEWAY);\n        if (rta == ((void *)0)) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: no gateway in nh info\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s no gateway in nh info\\\"}\", __func__);\n            });\n            return 0;\n        }\n        gw = *(__be32 *)((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))));\n        if (add_mpgw(gw, nh->rtnh_ifindex) == ((void *)0))\n            return -1;\n    }\n    return 0;\n}\n","function_prediction":"int process_rt_name_conflict(struct nlmsghdr *nh) {\n  struct rtmsg *rtm;\n  struct rtattr *rta;\n  struct rtattr *rta_gw;\n  struct in_addr gw;\n  int len;\n\n  len = nh->nlmsg_len - sizeof(*rtm);\n  if (len < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"invalid nlmsg_len %d\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"process_rt_name_conflict\", len);\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"invalid nlmsg_len %d\"\n               \"\\\"}\",\n               \"process_rt_name_conflict\", len);\n      }\n    } while (0);\n    return -1;\n  }\n\n  rtm = (struct rtmsg *)(((char *)nh) + sizeof(*nh));\n  if (rtm->rtm_family != 2)\n    return 0;\n\n  if (rtm->rtm_type >= 253)\n    return 0;\n\n  rta = rta_find(((char *)rtm) + sizeof(*rtm), len, 9);\n  if (!rta)\n    return 0;\n\n  len = rta->rta_len - sizeof(*rta);\n  rta = (struct rtattr *)(((char *)rta) + sizeof(*rta));\n\n  while (len > 7) {\n    if (len < rta->rta_len)\n      break;\n\n    rta_gw = rta_find(((char *)rta) + sizeof(*rta), rta->rta_len - 8, 5);\n    if (!rta_gw) {\n      do {\n        if (foreground) {\n          struct timeval tv;\n          gettimeofday(&tv, NULL); fprintf(stderr, \"%ld.%06ld [error] %s: \" \"no gateway in nh info\"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int get_nhs(void) {\n    int len;\n    struct nlmsghdr *nlh;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg rtm;\n    } req;\n    reset_mpgws();\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETROUTE;\n    req.nlh.nlmsg_flags = 1 | 256;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.rtm.rtgen_family = 2;\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        for (nlh = (struct nlmsghdr *)recv_buf; ((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len)); nlh = ((len) -= ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlh)) + ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n            if (nlh->nlmsg_seq != talk_seq) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n                });\n                continue;\n            }\n            if (nlh->nlmsg_type == 3)\n                return 0;\n            if (nlh->nlmsg_type == 2) {\n                ({\n                    struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    int rc __attribute__((unused));\n                    if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                        });\n                        rc = -1;\n                    } else if (err->error) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                        });\n                        rc = -1;\n                    }\n                    rc = 0;\n                });\n                return -1;\n            }\n            if (nlh->nlmsg_type != RTM_NEWROUTE) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n                });\n                continue;\n            }\n            if (process_rt(nlh) < 0)\n                return -1;\n        }\n    }\n}\n","function_prediction":"int get_nhs_name_conflict(void) {\n  struct nlmsghdr *nh;\n  struct nlmsgerr *err;\n  int len;\n  int ret;\n  char *buf;\n\n  reset_mpgws();\n\n  struct nlmsghdr nlh;\n  memset(&nlh, 0, sizeof(nlh));\n  nlh.nlmsg_len = sizeof(nlh);\n  nlh.nlmsg_type = 26;\n  nlh.nlmsg_flags = 0x00000001;\n  nlh.nlmsg_seq = talk_seq++;\n  nlh.nlmsg_pid = 2;\n\n  if (send(talk_sock, &nlh, sizeof(nlh), 0) < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"send %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"get_nhs_name_conflict\", strerror(errno));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"send %s\"\n               \"\\\"}\",\n               \"get_nhs_name_conflict\", strerror(errno));\n      }\n    } while (0);\n    return -1;\n  }\n\n  while (1) {\n    len = recv(talk_sock, &recv_buf, 16384, 0);\n    if (len < 0) {\n      if (errno != 4 && errno != 11) {\n        do {\n          if (foreground) {\n            struct timeval tv;\n            gettimeofday(&tv, NULL);\n            fprintf(stderr,\n                    \"%ld.%06ld [error] %s: \"\n                    \"recv %s\"\n                    \"\\n\",\n                    (long)tv.tv_sec, (long)tv.tv_usec, \"get_nhs_name_conflict\",\n                    strerror(errno));\n          } else { syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int update_neigh(int ifindex, __be32 ip, char *hw, int reachable) {\n    struct {\n        struct nlmsghdr nlh;\n        struct ndmsg ndm;\n        struct nlattr nla_dst;\n        __be32 dst;\n        struct nlattr nla_hw;\n        char hw[8];\n    } req;\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_NEWNEIGH;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.nlh.nlmsg_flags = (1 | 4 | 1024 | 256);\n    req.ndm.ndm_family = 2;\n    req.ndm.ndm_ifindex = ifindex;\n    req.ndm.ndm_state = reachable ? 2 : 32;\n    req.nla_dst.nla_len = sizeof(struct nlattr) + sizeof(__be32);\n    req.nla_dst.nla_type = NDA_DST;\n    req.dst = ip;\n    req.nla_hw.nla_len = sizeof(struct nlattr) + 6;\n    req.nla_hw.nla_type = NDA_LLADDR;\n    memcpy(&req.hw, hw, 6);\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        int len;\n        struct nlmsghdr *nlh;\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        nlh = (struct nlmsghdr *)recv_buf;\n        if (!((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len))) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\", __func__, len);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_seq != talk_seq) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_type != 2) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n            });\n            return -1;\n        }\n        return ({\n            struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n            int rc __attribute__((unused));\n            if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                });\n                rc = -1;\n            } else if (err->error) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                });\n                rc = -1;\n            }\n            rc = 0;\n        });\n    }\n}\n","function_prediction":"int update_neigh(int neigh_id, int neigh_type, char *neigh_addr,\n                 int neigh_port) {\n  struct talk_msg msg;\n  struct talk_msg *msg_p;\n  int len;\n  int nlerr;\n  int nlerr_len;\n  int nlerr_type;\n  int nlerr_seq;\n  int nlerr_talk_seq;\n  int nlerr_talk_id;\n  int nlerr_talk_type;\n  int nlerr_talk_port;\n  char *nlerr_talk_addr;\n  char *nlerr_talk_addr_p;\n  struct timeval tv;\n\n  memset(&msg, 0, sizeof(msg));\n  msg.len = sizeof(msg);\n  msg.seq = talk_seq++;\n  msg.talk_id = 1285;\n  msg.talk_type = 2;\n  msg.talk_port = neigh_port ? 2 : 32;\n  msg.talk_seq = 8;\n  msg.talk_id_type = 1;\n  msg.talk_id_seq = 10;\n  msg.talk_id_type_seq = 2;\n  msg.talk_id_type_seq_id = neigh_id;\n  msg.talk_id_type_seq_type = neigh_type;\n  memcpy(msg.talk_id_type_seq_addr, neigh_addr, 6);\n\n  if (send(talk_sock, &msg, sizeof(msg), 0) < 0) {\n    do {\n      if (foreground) {\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"send %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"update_neigh\",\n                strerror(errno));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"send %s\"\n               \"\\\"}\",\n               \"update_neigh\", strerror(errno));\n      }\n    } while (0);\n  return -1","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":1,"function":"int recv_nl(void) {\n    struct sockaddr_nl saddr;\n    socklen_t addrlen = sizeof (saddr);\n    if (recvfrom(poll_sock, recv_buf, sizeof (recv_buf), MSG_DONTWAIT, (struct sockaddr *)&saddr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 0;\n    }\n    if (addrlen != sizeof (saddr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid addr len\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\", __func__);\n        });\n        return 0;\n    }\n    if (saddr.nl_pid)\n        return 0;\n    get_nhs();\n    return 1;\n}\n","function_prediction":"int recv_nl_name_conflict(void) {\n  struct sockaddr_nl nladdr;\n  socklen_t nladdr_len = sizeof(nladdr);\n  ssize_t n;\n\n  n = recvfrom(poll_sock, &recv_buf, 16384, 0x00000040,\n               (struct sockaddr *)&nladdr, &nladdr_len);\n  if (n < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", (long)tv.tv_sec,\n              (long)tv.tv_usec, \"recv_nl_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\",\n             \"recv_nl_name_conflict\", strerror(*__errno_location()));\n    }\n    return 0;\n  }\n  if (nladdr_len != sizeof(nladdr)) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: invalid addr len\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"recv_nl_name_conflict\");\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\",\n             \"recv_nl_name_conflict\");\n    }\n    return 0;\n  }\n  if (nladdr.nl_pid != 0)\n    return 0;\n\n  get_nhs();\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int open_nl(void) {\n    struct sockaddr_nl addr;\n    socklen_t addrlen = sizeof (addr);\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    if ((talk_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (connect(talk_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (getsockname(talk_sock, (struct sockaddr *)&addr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    talk_seq = random();\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    addr.nl_groups = 64;\n    if ((poll_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (bind(poll_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: bind poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_poll;\n    }\n    if (get_nhs() < 0)\n        goto cleanup_poll;\n    return poll_sock;\n  cleanup_poll:\n    close(poll_sock);\n  cleanup_talk:\n    close(talk_sock);\n  err_out:\n    return -1;\n}\n","function_prediction":"int open_nl_name_conflict(void) {\n  struct sockaddr_nl sa;\n  socklen_t salen = sizeof(sa);\n\n  memset(&sa, 0, sizeof(sa));\n  sa.nl_family = AF_NETLINK;\n\n  if ((talk_sock = socket(AF_NETLINK, 3, 0)) < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"socket talk_sock %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"open_nl_name_conflict\",\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"socket talk_sock %s\"\n               \"\\\"}\",\n               \"open_nl_name_conflict\", strerror(*__errno_location()));\n      }\n    } while (0);\n    return -1;\n  }\n\n  if (connect(talk_sock, (struct sockaddr *)&sa, salen) < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"connect talk_sock %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"open_nl_name_conflict\",\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"connect talk_sock %s\"\n               \"\\\"}\",\n               \"open_nl_name_conflict\", strerror(*__errno_location()));\n      }\n    } while (0);\n    close(talk_sock);\n    return -1;\n  }\n\n  if (getsockname(talk_sock, (struct sockaddr *)&sa, &salen) < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL); fprintf(stderr,","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":1,"function":"int open_device(char *devname, long sig) {\n    struct sigaction sa = {.__sigaction_handler.sa_handler = sigio};\n    int fd;\n    printf(\"device file = %s\\n\", devname);\n    fd = open(devname, 0);\n    if (fd < 0) {\n        perror(\"open\");\n        return fd;\n    }\n    sigaction(sig, &sa, ((void *)0));\n    if (fcntl(fd, 8, getpid()) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n    if (fcntl(fd, 10, sig) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n    if (fcntl(fd, 4, 8192) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n}\n","function_prediction":"int open_device_name_conflict(char *device, int *fd) {\n  int fd_dev;\n  struct sigaction act;\n\n  act.sa_handler = sigio;\n  act.sa_flags = 0;\n  sigaction(fd, &act, NULL);\n\n  printf(\"device file = %s\\n\", device);\n\n  if ((fd_dev = open(device, 0)) < 0) {\n    perror(\"open\");\n    return fd_dev;\n  }\n\n  if (fcntl(fd_dev, 8, getpid()) < 0) {\n    perror(\"fcntl\");\n    exit(1);\n  }\n\n  if (fcntl(fd_dev, 10, *fd) < 0) {\n    perror(\"fcntl\");\n    exit(1);\n  }\n\n  if (fcntl(fd_dev, 4, 0x2000) < 0) {\n    perror(\"fcntl\");\n    exit(1);\n  }\n\n  return fd_dev;\n}","pass":1,"source_file":"C_COMPILE/NeoCat_YUREX-driver-for-Linux/sample/timing-game.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"char *parson_strndup_name_conflict(const char *s, size_t n) {\n  char *result = (char *)parson_malloc(n + 1);\n  if (result == NULL) {\n    return NULL;\n  }\n  result[n] = '\\0';\n  strncpy(result, s, n);\n  return result;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"char *parson_strdup_name_conflict(const char *s) { return parson_strndup(s, strlen(s)); }","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"int hex_char_to_int_name_conflict(char c) {\n  if (c >= '0' && c <= '9')\n    return c - '0';\n  if (c >= 'a' && c <= 'f')\n    return c - 'a' + 10;\n  if (c >= 'A' && c <= 'F')\n    return c - 'A' + 10;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"bool parse_utf16_hex_name_conflict(const char *str, uint32_t *out) {\n  if (!str[0] || !str[1] || !str[2] || !str[3])\n    return false;\n\n  int a = hex_char_to_int(str[0]);\n  int b = hex_char_to_int(str[1]);\n  int c = hex_char_to_int(str[2]);\n  int d = hex_char_to_int(str[3]);\n\n  if (a == -1 || b == -1 || c == -1 || d == -1)\n    return false;\n\n  *out = (a << 12) | (b << 8) | (c << 4) | d;\n  return true;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"size_t num_bytes_in_utf8_sequence_name_conflict(char c) {\n  if (c == 0xC0 || c == 0xC1 || (c >= 0xF5))\n    return 0;\n  if (c & 0x80) {\n    if ((c & 0xE0) == 0xC0)\n      return 2;\n    if ((c & 0xF0) == 0xE0)\n      return 3;\n    if ((c & 0xF8) == 0xF0)\n      return 4;\n    return 0;\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"int verify_utf8_sequence_name_conflict(const unsigned char *sequence, int *num_bytes) {\n  unsigned int codepoint;\n\n  *num_bytes = num_bytes_in_utf8_sequence(sequence[0]);\n\n  if (*num_bytes == 1) {\n    codepoint = sequence[0];\n  } else if (*num_bytes == 2 && (sequence[1] & 0xC0) == 0x80) {\n    codepoint = ((sequence[0] & 0x1F) << 6) | (sequence[1] & 0x3F);\n  } else if (*num_bytes == 3 && (sequence[1] & 0xC0) == 0x80 &&\n             (sequence[2] & 0xC0) == 0x80) {\n    codepoint = ((sequence[0] & 0x0F) << 12) | ((sequence[1] & 0x3F) << 6) |\n                (sequence[2] & 0x3F);\n  } else if (*num_bytes == 4 && (sequence[1] & 0xC0) == 0x80 &&\n             (sequence[2] & 0xC0) == 0x80 && (sequence[3] & 0xC0) == 0x80) {\n    codepoint = ((sequence[0] & 0x07) << 18) | ((sequence[1] & 0x3F) << 12) |\n                ((sequence[2] & 0x3F) << 6) | (sequence[3] & 0x3F);\n  } else {\n    return 0;\n  }\n\n  if ((codepoint < 0x80 && *num_bytes > 1) ||\n      (codepoint < 0x800 && *num_bytes > 2) ||\n      (codepoint < 0x10000 && *num_bytes > 3)) {\n    return 0;\n  }\n\n  if (codepoint > 0x10FFFF) {\n    return 0;\n  }\n\n  if (codepoint >= 0xD800 && codepoint <= 0xDFFF) {","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"bool is_valid_utf8_name_conflict(const char *str, size_t len) {\n  const char *end = str + len;\n  int seqlen = 0;\n\n  while (str < end) {\n    if (!verify_utf8_sequence(str, &seqlen))\n      return false;\n    str += seqlen;\n  }\n\n  return true;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"int is_decimal_name_conflict(const char *s, size_t len) {\n  if (len > 1 && s[0] == '0' && s[1] != '.')\n    return 0;\n  if (len > 2 && !strncmp(s, \"-0\", 2) && s[2] != '.')\n    return 0;\n  while (len--)\n    if (strchr(\"xX\", s[len]))\n      return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"char *read_file_name_conflict(const char *path) {\n  FILE *fp = fopen(path, \"r\");\n  if (!fp) {\n    return NULL;\n  }\n\n  fseek(fp, 0, 2);\n  long length = ftell(fp);\n  if (length < 0) {\n    fclose(fp);\n    return NULL;\n  }\n\n  rewind(fp);\n\n  char *buffer = (char *)parson_malloc(length + 1);\n  if (!buffer) {\n    fclose(fp);\n    return NULL;\n  }\n\n  size_t read_length = fread(buffer, 1, length, fp);\n  if (read_length != (size_t)length || ferror(fp)) {\n    fclose(fp);\n    parson_free(buffer);\n    return NULL;\n  }\n\n  fclose(fp);\n\n  buffer[length] = '\\0';\n  return buffer;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"int skip_quotes_name_conflict(char **str) {\n  if (**str != '\"')\n    return -1;\n  (*str)++;\n  while (**str != '\"') {\n    if (**str == '\\0')\n      return -1;\n    if (**str == '\\\\' && (*str)++ && **str == '\\0')\n      return -1;\n    (*str)++;\n  }\n  (*str)++;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"bool parse_utf16_hex(const char *str, uint32_t *out) {\n  if (!str[0] || !str[1] || !str[2] || !str[3])\n    return false;\n\n  int a = hex_char_to_int(str[0]);\n  int b = hex_char_to_int(str[1]);\n  int c = hex_char_to_int(str[2]);\n  int d = hex_char_to_int(str[3]);\n\n  if (a == -1 || b == -1 || c == -1 || d == -1)\n    return false;\n\n  *out = (a << 12) | (b << 8) | (c << 4) | d;\n  return true;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"char *process_string_name_conflict(const char *string, size_t length) {\n  char *result = NULL;\n  char *buffer = NULL;\n  char *buffer_ptr = NULL;\n  char *result_ptr = NULL;\n  size_t result_length = 0;\n  size_t buffer_length = length + 1;\n\n  buffer = (char *)parson_malloc(buffer_length);\n  if (!buffer) {\n    goto fail;\n  }\n\n  buffer_ptr = buffer;\n  result_ptr = buffer;\n\n  while (*string && (size_t)(string - result_ptr) < length) {\n    if (*string == '\\\\') {\n      string++;\n      switch (*string) {\n      case 'b':\n        *buffer_ptr = '\\b';\n        break;\n      case 'f':\n        *buffer_ptr = '\\f';\n        break;\n      case 'n':\n        *buffer_ptr = '\\n';\n        break;\n      case 'r':\n        *buffer_ptr = '\\r';\n        break;\n      case 't':\n        *buffer_ptr = '\\t';\n        break;\n      case '\\\"':\n        *buffer_ptr = '\\\"';\n        break;\n      case '\\\\':\n        *buffer_ptr = '\\\\';\n        break;\n      case '/':\n        *buffer_ptr = '/';\n        break;\n      case 'u':\n        if (parse_utf16(&string, &buffer_ptr) == -1) {\n          goto fail;\n        }\n        break;\n      default:\n        goto fail;\n      }\n    } else if (*string < 32) {\n      goto fail;\n    } else {\n      *buffer_ptr = *string;\n    }\n\n    buffer_ptr++;\n    string++;\n  }\n\n  *buffer_ptr = '\\0';\n  result_length = buffer_ptr - result + 1 - buffer_length;\n  result = (char *)parson_malloc(result_length);\n  if (!result) {\n    goto fail;\n  }\n\n    memcpy(result, buffer, result_length","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"char *get_quoted_string_name_conflict(char **str) {\n  char *start = *str;\n\n  if (!skip_quotes(str))\n    return process_string(start + 1, *str - start - 2);\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"int json_serialize_string_name_conflict(const char *str, char *buf) {\n  size_t len = strlen(str);\n  int ret;\n  char *p = buf;\n\n  if ((ret = append_string(p, \"\\\"\")) < 0)\n    return -1;\n  p += ret;\n\n  for (size_t i = 0; i < len; i++) {\n    switch (str[i]) {\n    case '\\\"':\n      if ((ret = append_string(p, \"\\\\\\\"\")) < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\\\':\n      if ((ret = append_string(p, \"\\\\\\\\\")) < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\b':\n      if ((ret = append_string(p, \"\\\\b\")) < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\f':\n      if ((ret = append_string(p, \"\\\\f\")) < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\n':\n      if ((ret = append_string(p, \"\\\\n\")) < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\r':\n      if ((ret = append_string(p, \"\\\\r\")) < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\t':\n      if ((ret = append_string(p, \"\\\\t\")) < 0)\n        return -1;\n      p += ret;\n      break;\n    case '/':\n      if ((ret = append_string(p, \"\\\\/\")) < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\0':\n      if ((ret = append_string(p, \"\\\\u0000\")) < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\1':\n      if ((ret = append_string(p, \"\\\\u0001\")) < 0)\n        return -1;","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"int append_indent_name_conflict(char *buf, int indent) {\n  int i, n, len = 0;\n\n  for (i = 0; i < indent; i++) {\n    n = append_string(buf, \"  \");\n    if (n < 0)\n      return -1;\n    if (buf)\n      buf += n;\n    len += n;\n  }\n\n  return len;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"void append_string_name_conflict(char *dest, char *src) {\n  if (dest)\n    sprintf(dest, \"%s\", src);\n  else\n    strlen(src);\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"char *parson_strndup_name_conflict(const char *s, size_t n) {\n  char *result = (char *)parson_malloc(n + 1);\n  if (result == NULL) {\n    return NULL;\n  }\n  result[n] = '\\0';\n  strncpy(result, s, n);\n  return result;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"char *parson_strdup_name_conflict(const char *s) { return parson_strndup(s, strlen(s)); }","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"int hex_char_to_int_name_conflict(char c) {\n  if (c >= '0' && c <= '9')\n    return c - '0';\n  if (c >= 'a' && c <= 'f')\n    return c - 'a' + 10;\n  if (c >= 'A' && c <= 'F')\n    return c - 'A' + 10;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"bool parse_utf16_hex_name_conflict(const char *str, uint32_t *out) {\n  if (!str[0] || !str[1] || !str[2] || !str[3])\n    return false;\n\n  int a = hex_char_to_int(str[0]);\n  int b = hex_char_to_int(str[1]);\n  int c = hex_char_to_int(str[2]);\n  int d = hex_char_to_int(str[3]);\n\n  if (a == -1 || b == -1 || c == -1 || d == -1)\n    return false;\n\n  *out = (a << 12) | (b << 8) | (c << 4) | d;\n  return true;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"size_t num_bytes_in_utf8_sequence_name_conflict(char c) {\n  if (c == 0xC0 || c == 0xC1 || (c >= 0xF5))\n    return 0;\n  if (c & 0x80) {\n    if ((c & 0xE0) == 0xC0)\n      return 2;\n    if ((c & 0xF0) == 0xE0)\n      return 3;\n    if ((c & 0xF8) == 0xF0)\n      return 4;\n    return 0;\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"int verify_utf8_sequence_name_conflict(const unsigned char *sequence, int *num_bytes) {\n  unsigned int codepoint;\n\n  *num_bytes = num_bytes_in_utf8_sequence(sequence[0]);\n\n  if (*num_bytes == 1) {\n    codepoint = sequence[0];\n  } else if (*num_bytes == 2 && (sequence[1] & 0xC0) == 0x80) {\n    codepoint = ((sequence[0] & 0x1F) << 6) | (sequence[1] & 0x3F);\n  } else if (*num_bytes == 3 && (sequence[1] & 0xC0) == 0x80 &&\n             (sequence[2] & 0xC0) == 0x80) {\n    codepoint = ((sequence[0] & 0x0F) << 12) | ((sequence[1] & 0x3F) << 6) |\n                (sequence[2] & 0x3F);\n  } else if (*num_bytes == 4 && (sequence[1] & 0xC0) == 0x80 &&\n             (sequence[2] & 0xC0) == 0x80 && (sequence[3] & 0xC0) == 0x80) {\n    codepoint = ((sequence[0] & 0x07) << 18) | ((sequence[1] & 0x3F) << 12) |\n                ((sequence[2] & 0x3F) << 6) | (sequence[3] & 0x3F);\n  } else {\n    return 0;\n  }\n\n  if ((codepoint < 0x80 && *num_bytes > 1) ||\n      (codepoint < 0x800 && *num_bytes > 2) ||\n      (codepoint < 0x10000 && *num_bytes > 3)) {\n    return 0;\n  }\n\n  if (codepoint > 0x10FFFF) {\n    return 0;\n  }\n\n  if (codepoint >= 0xD800 && codepoint <= 0xDFFF) {","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"bool is_valid_utf8_name_conflict(const char *str, size_t len) {\n  const char *end = str + len;\n  int seqlen = 0;\n\n  while (str < end) {\n    if (!verify_utf8_sequence(str, &seqlen))\n      return false;\n    str += seqlen;\n  }\n\n  return true;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"int is_decimal_name_conflict(const char *s, size_t len) {\n  if (len > 1 && s[0] == '0' && s[1] != '.')\n    return 0;\n  if (len > 2 && !strncmp(s, \"-0\", 2) && s[2] != '.')\n    return 0;\n  while (len--)\n    if (strchr(\"xX\", s[len]))\n      return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"char *read_file_name_conflict(const char *path) {\n  FILE *fp = fopen(path, \"r\");\n  if (!fp) {\n    return NULL;\n  }\n\n  fseek(fp, 0, 2);\n  long length = ftell(fp);\n  if (length < 0) {\n    fclose(fp);\n    return NULL;\n  }\n\n  rewind(fp);\n\n  char *buffer = (char *)parson_malloc(length + 1);\n  if (!buffer) {\n    fclose(fp);\n    return NULL;\n  }\n\n  size_t read_length = fread(buffer, 1, length, fp);\n  if (read_length != (size_t)length || ferror(fp)) {\n    fclose(fp);\n    parson_free(buffer);\n    return NULL;\n  }\n\n  fclose(fp);\n\n  buffer[length] = '\\0';\n  return buffer;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"int skip_quotes_name_conflict(char **str) {\n  if (**str != '\"')\n    return -1;\n  (*str)++;\n  while (**str != '\"') {\n    if (**str == '\\0')\n      return -1;\n    if (**str == '\\\\' && (*str)++ && **str == '\\0')\n      return -1;\n    (*str)++;\n  }\n  (*str)++;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"bool parse_utf16_hex(const char *str, uint32_t *out) {\n  if (!str[0] || !str[1] || !str[2] || !str[3])\n    return false;\n\n  int a = hex_char_to_int(str[0]);\n  int b = hex_char_to_int(str[1]);\n  int c = hex_char_to_int(str[2]);\n  int d = hex_char_to_int(str[3]);\n\n  if (a == -1 || b == -1 || c == -1 || d == -1)\n    return false;\n\n  *out = (a << 12) | (b << 8) | (c << 4) | d;\n  return true;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"char *process_string_name_conflict(const char *string, size_t length) {\n  char *result = NULL;\n  char *buffer = NULL;\n  char *buffer_ptr = NULL;\n  char *result_ptr = NULL;\n  size_t result_length = 0;\n  size_t buffer_length = length + 1;\n\n  buffer = (char *)parson_malloc(buffer_length);\n  if (!buffer) {\n    goto fail;\n  }\n\n  buffer_ptr = buffer;\n  result_ptr = buffer;\n\n  while (*string && (size_t)(string - result_ptr) < length) {\n    if (*string == '\\\\') {\n      string++;\n      switch (*string) {\n      case 'b':\n        *buffer_ptr++ = '\\b';\n        break;\n      case 'f':\n        *buffer_ptr++ = '\\f';\n        break;\n      case 'n':\n        *buffer_ptr++ = '\\n';\n        break;\n      case 'r':\n        *buffer_ptr++ = '\\r';\n        break;\n      case 't':\n        *buffer_ptr++ = '\\t';\n        break;\n      case 'u':\n        if (parse_utf16(&string, &buffer_ptr) == -1) {\n          goto fail;\n        }\n        break;\n      case '\"':\n        *buffer_ptr++ = '\"';\n        break;\n      case '\\\\':\n        *buffer_ptr++ = '\\\\';\n        break;\n      case '/':\n        *buffer_ptr++ = '/';\n        break;\n      default:\n        goto fail;\n      }\n    } else if (*string < 32) {\n      goto fail;\n    } else {\n      *buffer_ptr++ = *string;\n    }\n    string++;\n  }\n\n  *buffer_ptr = '\\0';\n  result_length = buffer_ptr - result;\n\n  result = (char *)parson_malloc(result_length);\n  if (!result) {\n    goto fail;\n  }\n\n  memcpy(result, buffer, result_length);\n  parson_","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"char *get_quoted_string_name_conflict(char **str) {\n  char *start = *str;\n\n  if (!skip_quotes(str))\n    return process_string(start + 1, *str - start - 2);\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"int json_serialize_string_name_conflict(const char *str, char *buf) {\n  size_t len = strlen(str);\n  int ret = 0;\n  char *p = buf;\n\n  ret = append_string(p, \"\\\"\");\n  if (ret < 0)\n    return -1;\n  if (p)\n    p += ret;\n\n  for (size_t i = 0; i < len; i++) {\n    switch (str[i]) {\n    case '\\\"':\n      ret = append_string(p, \"\\\\\\\"\");\n      if (ret < 0)\n        return -1;\n      if (p)\n        p += ret;\n      break;\n    case '\\\\':\n      ret = append_string(p, \"\\\\\\\\\");\n      if (ret < 0)\n        return -1;\n      if (p)\n        p += ret;\n      break;\n    case '/':\n      ret = append_string(p, \"\\\\/\");\n      if (ret < 0)\n        return -1;\n      if (p)\n        p += ret;\n      break;\n    case '\\b':\n      ret = append_string(p, \"\\\\b\");\n      if (ret < 0)\n        return -1;\n      if (p)\n        p += ret;\n      break;\n    case '\\f':\n      ret = append_string(p, \"\\\\f\");\n      if (ret < 0)\n        return -1;\n      if (p)\n        p += ret;\n      break;\n    case '\\n':\n      ret = append_string(p, \"\\\\n\");\n      if (ret < 0)\n        return -1;\n      if (p)\n        p += ret;\n      break;\n    case '\\r':\n      ret = append_string(p, \"\\\\r\");\n      if (ret < 0)\n        return -1;\n      if (p)\n        p += ret;\n      break;\n    case '\\t':\n      ret = append_string(p, \"\\\\t\");\n      if (ret < 0)\n        return -1;\n      if (p)\n        p += ret;\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"int append_indent_name_conflict(char *buf, int indent) {\n  int i, n, len = 0;\n\n  for (i = 0; i < indent; i++) {\n    n = append_string(buf, \"  \");\n    if (n < 0)\n      return -1;\n    if (buf)\n      buf += n;\n    len += n;\n  }\n\n  return len;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"void append_string_name_conflict(char *dest, char *src) {\n  if (dest)\n    sprintf(dest, \"%s\", src);\n  else\n    strlen(src);\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"char *parson_strndup_name_conflict(const char *s, size_t n) {\n  char *result = (char *)parson_malloc(n + 1);\n  if (result == NULL) {\n    return NULL;\n  }\n  result[n] = '\\0';\n  strncpy(result, s, n);\n  return result;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"char *parson_strdup_name_conflict(const char *s) { return parson_strndup(s, strlen(s)); }","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"int hex_char_to_int_name_conflict(char c) {\n  if (c >= '0' && c <= '9')\n    return c - '0';\n  if (c >= 'a' && c <= 'f')\n    return c - 'a' + 10;\n  if (c >= 'A' && c <= 'F')\n    return c - 'A' + 10;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"bool parse_utf16_hex_name_conflict(const char *str, uint32_t *out) {\n  if (!str[0] || !str[1] || !str[2] || !str[3])\n    return false;\n\n  int a = hex_char_to_int(str[0]);\n  int b = hex_char_to_int(str[1]);\n  int c = hex_char_to_int(str[2]);\n  int d = hex_char_to_int(str[3]);\n\n  if (a == -1 || b == -1 || c == -1 || d == -1)\n    return false;\n\n  *out = (a << 12) | (b << 8) | (c << 4) | d;\n  return true;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"size_t num_bytes_in_utf8_sequence_name_conflict(char c) {\n  if (c == 0xC0 || c == 0xC1 || (c >= 0xF5))\n    return 0;\n  if (c & 0x80) {\n    if ((c & 0xE0) == 0xC0)\n      return 2;\n    if ((c & 0xF0) == 0xE0)\n      return 3;\n    if ((c & 0xF8) == 0xF0)\n      return 4;\n    return 0;\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"int verify_utf8_sequence_name_conflict(const unsigned char *sequence, int *num_bytes) {\n  unsigned int codepoint;\n\n  *num_bytes = num_bytes_in_utf8_sequence(sequence[0]);\n\n  if (*num_bytes == 1) {\n    codepoint = sequence[0];\n  } else if (*num_bytes == 2 && (sequence[1] & 0xC0) == 0x80) {\n    codepoint = ((sequence[0] & 0x1F) << 6) | (sequence[1] & 0x3F);\n  } else if (*num_bytes == 3 && (sequence[1] & 0xC0) == 0x80 &&\n             (sequence[2] & 0xC0) == 0x80) {\n    codepoint = ((sequence[0] & 0x0F) << 12) | ((sequence[1] & 0x3F) << 6) |\n                (sequence[2] & 0x3F);\n  } else if (*num_bytes == 4 && (sequence[1] & 0xC0) == 0x80 &&\n             (sequence[2] & 0xC0) == 0x80 && (sequence[3] & 0xC0) == 0x80) {\n    codepoint = ((sequence[0] & 0x07) << 18) | ((sequence[1] & 0x3F) << 12) |\n                ((sequence[2] & 0x3F) << 6) | (sequence[3] & 0x3F);\n  } else {\n    return 0;\n  }\n\n  if ((codepoint < 0x80 && *num_bytes > 1) ||\n      (codepoint < 0x800 && *num_bytes > 2) ||\n      (codepoint < 0x10000 && *num_bytes > 3)) {\n    return 0;\n  }\n\n  if (codepoint > 0x10FFFF) {\n    return 0;\n  }\n\n  if (codepoint >= 0xD800 && codepoint <= 0xDFFF) {","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"bool is_valid_utf8_name_conflict(const char *str, size_t len) {\n  const char *end = str + len;\n  int seqlen = 0;\n\n  while (str < end) {\n    if (!verify_utf8_sequence(str, &seqlen))\n      return false;\n    str += seqlen;\n  }\n\n  return true;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"int is_decimal_name_conflict(const char *s, size_t len) {\n  if (len > 1 && s[0] == '0' && s[1] != '.')\n    return 0;\n  if (len > 2 && !strncmp(s, \"-0\", 2) && s[2] != '.')\n    return 0;\n  while (len--)\n    if (strchr(\"xX\", s[len]))\n      return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"char *read_file_name_conflict(const char *path) {\n  FILE *fp = fopen(path, \"r\");\n  if (!fp) {\n    return NULL;\n  }\n\n  fseek(fp, 0, 2);\n  long length = ftell(fp);\n  if (length < 0) {\n    fclose(fp);\n    return NULL;\n  }\n\n  rewind(fp);\n\n  char *buffer = (char *)parson_malloc(length + 1);\n  if (!buffer) {\n    fclose(fp);\n    return NULL;\n  }\n\n  size_t read_length = fread(buffer, 1, length, fp);\n  if (read_length != (size_t)length || ferror(fp)) {\n    fclose(fp);\n    parson_free(buffer);\n    return NULL;\n  }\n\n  fclose(fp);\n\n  buffer[length] = '\\0';\n  return buffer;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"int skip_quotes_name_conflict(char **str) {\n  if (**str != '\"')\n    return -1;\n  (*str)++;\n  while (**str != '\"') {\n    if (**str == '\\0')\n      return -1;\n    if (**str == '\\\\' && (*str)++ && **str == '\\0')\n      return -1;\n    (*str)++;\n  }\n  (*str)++;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"bool parse_utf16_hex(const char *str, uint32_t *out) {\n  if (!str[0] || !str[1] || !str[2] || !str[3])\n    return false;\n\n  int a = hex_char_to_int(str[0]);\n  int b = hex_char_to_int(str[1]);\n  int c = hex_char_to_int(str[2]);\n  int d = hex_char_to_int(str[3]);\n\n  if (a == -1 || b == -1 || c == -1 || d == -1)\n    return false;\n\n  *out = (a << 12) | (b << 8) | (c << 4) | d;\n  return true;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"char *process_string_name_conflict(const char *string, size_t length) {\n  char *result = NULL;\n  char *buffer = NULL;\n  char *buffer_ptr = NULL;\n  char *result_ptr = NULL;\n  size_t result_length = 0;\n  size_t buffer_length = length + 1;\n\n  buffer = (char *)parson_malloc(buffer_length);\n  if (buffer == NULL) {\n    goto fail;\n  }\n\n  buffer_ptr = buffer;\n  result_ptr = buffer;\n\n  while (*string != '\\0' && (size_t)(string - buffer) < length) {\n    if (*string == '\\\\') {\n      string++;\n      switch (*string) {\n      case 'b':\n        *buffer_ptr = '\\b';\n        break;\n      case 'f':\n        *buffer_ptr = '\\f';\n        break;\n      case 'n':\n        *buffer_ptr = '\\n';\n        break;\n      case 'r':\n        *buffer_ptr = '\\r';\n        break;\n      case 't':\n        *buffer_ptr = '\\t';\n        break;\n      case 'u':\n        if (parse_utf16(&string, &buffer_ptr) == -1) {\n          goto fail;\n        }\n        break;\n      case '\"':\n        *buffer_ptr = '\"';\n        break;\n      case '\\\\':\n        *buffer_ptr = '\\\\';\n        break;\n      case '/':\n        *buffer_ptr = '/';\n        break;\n      default:\n        goto fail;\n      }\n    } else if (*string < 32) {\n      goto fail;\n    } else {\n      *buffer_ptr = *string;\n    }\n\n    buffer_ptr++;\n    string++;\n  }\n\n  *buffer_ptr = '\\0';\n  result_length = buffer_ptr - result + 1 - buffer_length;\n\n  result = (char *)parson_malloc(result_length);\n  if (result == NULL) {\n    goto fail;\n  }\n\n    memcpy(","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"char *get_quoted_string_name_conflict(char **str) {\n  char *start = *str;\n\n  if (!skip_quotes(str))\n    return process_string(start + 1, *str - start - 2);\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"int json_serialize_string_name_conflict(const char *str, char *buf) {\n  size_t len = strlen(str);\n  int ret = 0;\n  int i;\n  char *p = buf;\n\n  ret = append_string(p, \"\\\"\");\n  if (ret < 0)\n    return -1;\n  p += ret;\n\n  for (i = 0; i < len; i++) {\n    switch (str[i]) {\n    case '\\\"':\n      ret = append_string(p, \"\\\\\\\"\");\n      if (ret < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\\\':\n      ret = append_string(p, \"\\\\\\\\\");\n      if (ret < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\b':\n      ret = append_string(p, \"\\\\b\");\n      if (ret < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\f':\n      ret = append_string(p, \"\\\\f\");\n      if (ret < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\n':\n      ret = append_string(p, \"\\\\n\");\n      if (ret < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\r':\n      ret = append_string(p, \"\\\\r\");\n      if (ret < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\t':\n      ret = append_string(p, \"\\\\t\");\n      if (ret < 0)\n        return -1;\n      p += ret;\n      break;\n    case '/':\n      ret = append_string(p, \"\\\\/\");\n      if (ret < 0)\n        return -1;\n      p += ret;\n      break;\n    case '\\0':\n      ret = append_string(p, \"\\\\u0000\");\n      if (ret < 0)\n        return -1;\n      p += ret;\n      break;\n","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"int append_indent_name_conflict(char *buf, int indent) {\n  int i, n, len = 0;\n\n  for (i = 0; i < indent; i++) {\n    n = append_string(buf, \"  \");\n    if (n < 0)\n      return -1;\n    if (buf)\n      buf += n;\n    len += n;\n  }\n\n  return len;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"void append_string_name_conflict(char *dest, char *src) {\n  if (dest)\n    sprintf(dest, \"%s\", src);\n  else\n    strlen(src);\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"int io_signal(int fd, int sig) {\n    int flags;\n    if (fcntl(fd, 10, sig) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to set signal %d on fd %d: %s\\n\", __func__, 11, sig, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    if (fcntl(fd, 8, getpid()) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to set process as owner of fd %d: %s\\n\", __func__, 15, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    flags = fcntl(fd, 3);\n    if (flags == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to get flags of fd %d: %s\\n\", __func__, 20, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    if (fcntl(fd, 4, flags | 8192 | 2048) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to enable I/O signaling for fd %d: %s\\n\", __func__, 24, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int io_signal_name_conflict(int fd, int sig) {\n  if (fcntl(fd, 10, sig) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"failed to set signal %d on fd %d: %s\\n\",\n            \"io_signal_name_conflict\", 10, sig, fd, strerror(*__errno_location()));\n    return 1;\n  }\n\n  if (fcntl(fd, 8, getpid()) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"failed to set process as owner of fd %d: %s\\n\",\n            \"io_signal_name_conflict\", 14, fd, strerror(*__errno_location()));\n    return 1;\n  }\n\n  int flags = fcntl(fd, 3);\n  if (flags == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"failed to get flags of fd %d: %s\\n\",\n            \"io_signal_name_conflict\", 19, fd, strerror(*__errno_location()));\n    return 1;\n  }\n\n  if (fcntl(fd, 4, flags | 0x2800) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"failed to enable I/O signaling for fd %d: %s\\n\",\n            \"io_signal_name_conflict\", 23, fd, strerror(*__errno_location()));\n    return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"static ssize_t read_nonblock(int fd, char *buf, size_t size) {\n    ssize_t nr;\n    nr = read(fd, buf, size);\n    if (nr == -1) {\n        if ((*__errno_location()) == 11) {\n            return 0;\n        }\n        fprintf(stderr, \"ERROR %s:%d: read from %d: %s\\n\", __func__, 38, fd, strerror((*__errno_location())));\n        return -1;\n    }\n    return nr;\n}\n","function_prediction":"ssize_t read_nonblock_name_conflict(int fd, void *buf, size_t count) {\n  ssize_t ret = read(fd, buf, count);\n  if (ret == -1) {\n    if (*__errno_location() == 11)\n      return 0;\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"read from %d: %s\"\n            \"\\n\",\n            \"read_nonblock_name_conflict\", 37, fd, strerror(*__errno_location()));\n    return -1;\n  }\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"int io_readline(int fd, char *buffer, size_t size) {\n    int nr = 0;\n    char c;\n    while (nr < size && read_nonblock(fd, &c, 1) > 0 && c != '\\n')\n        buffer[nr++] = c;\n    return nr;\n}\n","function_prediction":"int io_readline_name_conflict(int fd, char *buf, size_t len) {\n  int i;\n  char c;\n\n  for (i = 0; i < len; i++) {\n    if (read_nonblock(fd, &c, 1) <= 0)\n      break;\n    if (c == '\\n')\n      break;\n    buf[i] = c;\n  }\n\n  return i;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"static inline bool is_number(const char *str) {\n    char *end;\n    strtoul(str, &end, 10);\n    return !(*str == 0 || *end != 0);\n}\n","function_prediction":"int is_number_name_conflict(char *str) {\n  char *endptr;\n  strtoul(str, &endptr, 10);\n  if (*str && !*endptr)\n    return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/json.c"}
{"compilable":0,"function":"static int parse_section(const char *line, char *name, unsigned int size) {\n    char *closing = strchr(line, ']');\n    const int len = strlen(line);\n    if (!closing || line + len - 1 != closing) {\n        fprintf(stderr, \"ERROR %s:%d: malformated section \\\"%s\\\"\\n\", __func__, 33, line);\n        return 1;\n    }\n    if (size - 1 < len - 2) {\n        fprintf(stderr, \"ERROR %s:%d: section name too long \\\"%s\\\"\\n\", __func__, 37, line);\n        return 1;\n    }\n    memcpy(name, line + 1, len - 2);\n    name[len - 2] = '\\x00';\n    return 0;\n}\n","function_prediction":"int parse_section_name_conflict(char *line, char *section, int max_len) {\n  char *end = strchr(line, ']');\n  int len = strlen(line);\n\n  if (end == NULL || end != line + len - 1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"malformated section \\\"%s\\\"\"\n            \"\\n\",\n            \"parse_section_name_conflict\", 32, line);\n    return 1;\n  }\n\n  if (len - 2 > max_len - 1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"section name too long \\\"%s\\\"\"\n            \"\\n\",\n            \"parse_section_name_conflict\", 36, line);\n    return 1;\n  }\n\n  memcpy(section, line + 1, len - 2);\n  section[len - 2] = '\\0';\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/ini.c"}
{"compilable":0,"function":"static int parse_property(const char *line, struct properties *props, bool strict) {\n    char *equal = strchr(line, '=');\n    const char *key, *value;\n    if (!equal) {\n        fprintf(stderr, \"ERROR %s:%d: malformated property, should be a key=value pair\\n\", __func__, 50);\n        return 1;\n    }\n    *equal = '\\x00';\n    key = line;\n    value = equal + 1;\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"full_text\") == 0) {\n        strncpy(props->full_text, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"short_text\") == 0) {\n        strncpy(props->short_text, value, 512 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"color\") == 0) {\n        strncpy(props->color, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2 | 4) & 1) && strcmp(key, \"min_width\") == 0) {\n        strncpy(props->min_width, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"align\") == 0) {\n        strncpy(props->align, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"name\") == 0) {\n        strncpy(props->name, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"instance\") == 0) {\n        strncpy(props->instance, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 8) & 1) && strcmp(key, \"urgent\") == 0) {\n        strncpy(props->urgent, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 8) & 1) && strcmp(key, \"separator\") == 0) {\n        strncpy(props->separator, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 4) & 1) && strcmp(key, \"separator_block_width\") == 0) {\n        strncpy(props->separator_block_width, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"markup\") == 0) {\n        strncpy(props->markup, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (2) & 1) && strcmp(key, \"command\") == 0) {\n        strncpy(props->command, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (2 | 4) & 1) && strcmp(key, \"interval\") == 0) {\n        strncpy(props->interval, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (4) & 1) && strcmp(key, \"signal\") == 0) {\n        strncpy(props->signal, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (2) & 1) && strcmp(key, \"label\") == 0) {\n        strncpy(props->label, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (2 | 4) & 1) && strcmp(key, \"format\") == 0) {\n        strncpy(props->format, value, 8 - 1);\n        return 0;\n    }\n    ;\n    fprintf(stderr, \"ERROR %s:%d: unknown key: \\\"%s\\\"\\n\", __func__, 63, key);\n    return 1;\n}\n","function_prediction":"int parse_property_name_conflict(char *line, char *data, char is_block) {\n  char *delimiter = strchr(line, '=');\n  if (!delimiter) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"malformated property, should be a key=value pair\"\n            \"\\n\",\n            \"parse_property_name_conflict\", 49);\n    return 1;\n  }\n  *delimiter = '\\0';\n  delimiter++;\n\n  if (!strcmp(line, \"full_text\")) {\n    strncpy(data, delimiter, 1024 - 1);\n  } else if (!strcmp(line, \"short_text\")) {\n    strncpy(data + 1024, delimiter, 512 - 1);\n  } else if (!strcmp(line, \"color\")) {\n    strncpy(data + 1024 * 2, delimiter, 7);\n  } else if (!strcmp(line, \"min_width\")) {\n    strncpy(data + 1024 * 2 + 7, delimiter, 1024 - 1);\n  } else if (!strcmp(line, \"align\")) {\n    strncpy(data + 1024 * 2 + 1024 + 7, delimiter, 7);\n  } else if (!strcmp(line, \"name\")) {\n    strncpy(data + 1024 * 2 + 1024 + 1024 + 7, delimiter, 32 - 1);\n  } else if (!strcmp(line, \"instance\")) {\n    strncpy(data + 1024 * 2 + 1024 + 1024 + 32 + 7, delimiter, 32 - 1);\n  } else if (!strcmp(line, \"urgent\")) {\n    strncpy(data + 1024 * 2 + 1024 + 1024 + 32 + 32 + 7, delimiter, 7);\n    } else if (!strcmp(line,","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/ini.c"}
{"compilable":0,"function":"static int gcd(int a, int b) {\n    while (b != 0)\n        a %= b , a ^= b , b ^= a , a ^= b;\n    return a;\n}\n","function_prediction":"int gcd_name_conflict(int a, int b) {\n  while (b != 0) {\n    int t = a % b;\n    a = b;\n    b = t;\n  }\n  return a;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/sched.c"}
{"compilable":0,"function":"static int setup_signals(void) {\n    if (sigemptyset(&sigset) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigemptyset: %s\\n\", __func__, 59, strerror((*__errno_location())));\n        return 1;\n    }\n    if (sigaddset(&sigset, 15) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 64, 15, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 2) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 65, 2, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 14) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 66, 14, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 17) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 67, 17, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 10) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 68, 10, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 12) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 69, 12, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 29) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 70, 29, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, (__libc_current_sigrtmin())) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 71, (__libc_current_sigrtmin()), strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    for (int sig = (__libc_current_sigrtmin()) + 1; sig <= (__libc_current_sigrtmax()); ++sig) {\n        if (log_level >= LOG_DEBUG) {\n            fprintf(stderr, \"DEBUG %s:%d: provide signal %d (%s)\\n\", __func__, 73, sig, strsignal(sig));\n        }\n        ;\n        if (sigaddset(&sigset, sig) == -1) {\n            fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 74, sig, strerror((*__errno_location())));\n            return 1;\n        }\n        ;\n    }\n    if (sigprocmask(2, &sigset, ((void *)0)) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigprocmask: %s\\n\", __func__, 78, strerror((*__errno_location())));\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int setup_signals_name_conflict(void) {\n  int sig;\n\n  if (sigemptyset(&sigset) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"sigemptyset\"\n            \": %s\\n\",\n            \"setup_signals_name_conflict\", 58, strerror(*__errno_location()));\n    return 1;\n  }\n\n  if (sigaddset(&sigset, 15) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"sigaddset(%d)\"\n            \": %s\\n\",\n            \"setup_signals_name_conflict\", 63, 15, strerror(*__errno_location()));\n    return 1;\n  }\n\n  if (sigaddset(&sigset, 2) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"sigaddset(%d)\"\n            \": %s\\n\",\n            \"setup_signals_name_conflict\", 64, 2, strerror(*__errno_location()));\n    return 1;\n  }\n\n  if (sigaddset(&sigset, 14) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"sigaddset(%d)\"\n            \": %s\\n\",\n            \"setup_signals_name_conflict\", 65, 14, strerror(*__errno_location()));\n    return 1;\n  }\n\n  if (sigaddset(&sigset, 17) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"sigaddset(%d)\"\n            \": %s\\n\",\n            \"setup_signals_name_conflict\", 66, 17, strerror(*__errno_location()));\n    return 1;\n  }\n\n  if (sigaddset(&sigset, 10) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"sigaddset(%d)\"\n            \": %s\\n\",\n            \"setup_signals_name_conflict\", 67, 10, strerror(*__errno_location()));\n    return 1;\n  }\n\n if (sigaddset(&sig","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/sched.c"}
{"compilable":1,"function":"int binsearch(int x, int v[], int n) {\n    int low, high, mid;\n    low = 0;\n    high = n - 1;\n    while (low < high)\n        {\n            mid = (low + high) / 2;\n            if (x <= v[mid])\n                high = mid;\n            else\n                low = mid + 1;\n        }\n    return x == v[low] ? low : -1;\n}\n","function_prediction":"int binsearch_name_conflict(int x, int v[], int n) {\n  int low, high, mid;\n\n  low = 0;\n  high = n - 1;\n  while (low < high) {\n    mid = (low + high) / 2;\n    if (x <= v[mid])\n      high = mid;\n    else\n      low = mid + 1;\n  }\n  if (x == v[low])\n    return low;\n  else\n    return -1;\n}","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch3/bsearch.c"}
{"compilable":1,"function":"static int getword(char *word, int limit) {\n    int c;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        ;\n    if (c != (-1))\n        *word++ = c;\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        return c;\n    }\n    for (; --limit > 0; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"int getword_name_conflict(char *word, int lim) {\n  int c, getch(void);\n  void ungetch(int);\n  char *w = word;\n\n  while (isspace(c = getch()))\n    ;\n\n  if (c != EOF)\n    *w++ = c;\n\n  if (isalpha(c) || c == '_' || c == '#')\n    for (; --lim > 0; w++)\n      if (!isalnum(*w = getch()) && *w != '_') {\n        ungetch(*w);\n        break;\n      }\n  *w = '\\0';\n  return c;\n}","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/keyword_search.c"}
{"compilable":1,"function":"static int getch() {\n    return bufp > 0 ? buffer[--bufp] : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) { return (bufp > 0) ? buffer[--bufp] : getch_name_conflictar(); }","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/keyword_search.c"}
{"compilable":1,"function":"int getch() {\n    return bufp > 0 ? buffer[--bufp] : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) { return (bufp > 0) ? buffer[--bufp] : getch_name_conflictar(); }","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":1,"function":"int getword(char *word, int limit) {\n    int c;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        ;\n    if (c != (-1))\n        *word++ = c;\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        return c;\n    }\n    for (; --limit > 0; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"int getword_name_conflict(char *word, int lim) {\n  int c, getch(void);\n  void ungetch(int);\n  char *w = word;\n\n  while (isspace(c = getch()))\n    ;\n\n  if (c != EOF)\n    *w++ = c;\n\n  if (isalpha(c) || c == '_' || c == '#')\n    for (; --lim > 0; w++)\n      if (!isalnum(*w = getch()) && *w != '_') {\n        ungetch(*w);\n        break;\n      }\n  *w = '\\0';\n  return c;\n}","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":0,"function":"char *_strdup(char *word) {\n    char *p = (char *)malloc(strlen(word) + 1);\n    p = strcpy(p, word);\n    return p;\n}\n","function_prediction":"char *_strdup_name_conflict(char *str) {\n  char *s;\n\n  s = malloc(strlen(str) + 1);\n  return (strcpy(s, str));\n}","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":1,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[], int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/116.c"}
{"compilable":1,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[], int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/get_line.c"}
{"compilable":1,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char s[], int lim) {\n  int c, i;\n\n  for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\\n'; ++i)\n    s[i] = c;\n  if (c == '\\n') {\n    s[i] = c;\n    ++i;\n  }\n  s[i] = '\\0';\n  return i;\n}","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/117.c"}
{"compilable":0,"function":"static int test(int argc, char **argv, int t) {\n    static struct iovec iov[1024];\n    const int bs = 4 << 10;\n    const ssize_t s = bs * 1024;\n    char *p = (char *)mmap(0, bs * 1024, 1 | 2, 2 | 32, -1, 0);\n    int i;\n    for (i = 1024 - 1; i >= 0; i--) {\n        iov[i].iov_base = p;\n        iov[i].iov_len = bs;\n        *p = i;\n        p += bs;\n    }\n    for (i = 1; i < argc; i++) {\n        const char *nm = \"none\";\n        const double cs = (double)sysconf(_SC_CLK_TCK);\n        struct tms ptms, ctms;\n        clock_t pt, ct;\n        int l = 1 << 8;\n        int k = l;\n        const int fd = open(argv[i], 2 | 64 | 16384 | 262144, 438);\n        if (fd < 0) {\n            perror(argv[i]);\n            return 1;\n        }\n        pt = times(&ptms);\n        while (k-- > 0)\n            {\n                ssize_t n;\n                switch (t) {\n                  case 0:\n                    nm = \"write\";\n                    n = write(fd, iov[1024 - 1].iov_base, s);\n                    break;\n                  case 1:\n                    nm = \"writev\";\n                    n = writev(fd, iov, 1024);\n                    break;\n                  case 2:\n                    nm = \"read\";\n                    n = read(fd, iov[1024 - 1].iov_base, s);\n                    break;\n                  case 3:\n                    nm = \"readv\";\n                    n = readv(fd, iov, 1024);\n                    break;\n                  default:\n                    n = 0;\n                    break;\n                }\n                if (n != s) {\n                    perror(argv[i]);\n                    return 1;\n                }\n                if ((k & 63) == 0) {\n                    lseek(fd, 0, 0);\n                }\n            }\n        ct = times(&ctms);\n        {\n            const double d = (ct != pt) ? ct - pt : 1.0000000000000001E-9;\n            printf(\"u: %6.2f%% s: %6.2f%% w: %6.2f s %6.2f MB/s %s\\n\", (ctms.tms_utime - ptms.tms_utime) / d * 100, (ctms.tms_stime - ptms.tms_stime) / d * 100, d / cs, cs * l * s / ((1 << 20) * d), nm);\n        }\n        close(fd);\n    }\n    return 0;\n}\n","function_prediction":"int test_name_conflict(int argc, char **argv, int mode) {\n  int fd, i, j, k, n;\n  char *p, *buf;\n  struct tms tms_start, tms_end;\n  clock_t t_start, t_end;\n  double t_diff, t_real, t_user, t_sys;\n\n  n = 1024;\n  p = buf = mmap64(NULL, 1024 * 1024 * 4, 3, 34, -1, 0);\n  for (i = 1024 - 1; i >= 0; i--) {\n    iov_0[i].iov_base = p;\n    iov_0[i].iov_len = n;\n    *p = i;\n    p += n;\n  }\n\n  for (i = 1; i < argc; i++) {\n    const char *op = \"none\";\n    ssize_t r;\n    t_real = sysconf(_SC_CLK_TCK);\n    t_user = t_sys = 0;\n    t_diff = 0;\n    t_start = t_end = 0;\n    t_real = sysconf(_SC_CLK_TCK);\n    fd = open64(argv[i], 0644 | 0200 | 0020, 0666);\n    if (fd < 0) {\n      perror(argv[i]);\n      return 1;\n    }\n    t_start = times(&tms_start);\n    for (j = 1024; j > 0; j--) {\n      switch (mode) {\n      case 0:\n        op = \"write\";\n        r = write(fd, iov_0[0].iov_base, 1024 * 1024 * 4);\n        break;\n      case 1:\n        op = \"writev\";\n        r = writev(fd, iov_0, 1024);\n        break;\n      case 2:\n        op = \"read\";\n    r = read(fd, iov_0[","pass":0,"source_file":"C_COMPILE/sumedhsakdeo_zynx/src/cc/qcdio/iovperf.c"}
{"compilable":1,"function":"static int print_dirlist(char *filename) {\n    struct dirent *de;\n    char c;\n    DIR *d;\n    fprintf(stdout, \"<br><br>--------<pre>Directory listing for %s:\\n\\n\", filename);\n    d = opendir(filename);\n    if (!d) {\n        fprintf(stdout, \"No such directory\\n</pre>\");\n        return -1;\n    }\n    while (de = readdir(d))\n        {\n            if (de->d_type == DT_DIR)\n                fprintf(stdout, \"%s/\\n\", de->d_name);\n            else\n                fprintf(stdout, \"%s\\n\", de->d_name);\n        }\n    closedir(d);\n    fprintf(stdout, \"</pre>\");\n    return 0;\n}\n","function_prediction":"int print_dirlist_name_conflict(char *dirname) {\n  DIR *dir;\n  struct dirent *direntry;\n\n  fprintf(stdout, \"<br><br>--------<pre>Directory listing for %s:\\n\\n\",\n          dirname);\n\n  if ((dir = opendir(dirname)) == NULL) {\n    fprintf(stdout, \"No such directory\\n</pre>\");\n    return -1;\n  }\n\n  while ((direntry = readdir(dir)) != NULL) {\n    if (direntry->d_type == 4)\n      fprintf(stdout, \"%s/\\n\", direntry->d_name);\n    else\n      fprintf(stdout, \"%s\\n\", direntry->d_name);\n  }\n\n  closedir(dir);\n  fprintf(stdout, \"</pre>\");\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":1,"function":"static int write_to_file(char *filename, char *writeval) {\n    char *line = ((void *)0);\n    size_t len;\n    FILE *fp;\n    fp = fopen(filename, \"w\");\n    if (!fp)\n        return -1;\n    fprintf(stdout, \"<br><br>--------<pre>Writing %s to file %s:\\n\\n\", writeval, filename);\n    if (fwrite(writeval, strlen(writeval), 1, fp) < strlen(writeval))\n        fprintf(stdout, \"Write failed\\n\");\n    else\n        fprintf(stdout, \"Write succeeded\\n\");\n    fprintf(stdout, \"</pre>\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int write_to_file_name_conflict(char *filename, char *data) {\n  FILE *fp;\n\n  fp = fopen(filename, \"w\");\n  if (fp == NULL)\n    return -1;\n\n  fprintf(stdout, \"<br><br>--------<pre>Writing %s to file %s:\\n\\n\", data,\n          filename);\n  if (fwrite(data, strlen(data), 1, fp) < strlen(data))\n    fprintf(stdout, \"Write failed\\n\");\n  else\n    fprintf(stdout, \"Write succeeded\\n\");\n  fprintf(stdout, \"</pre>\");\n\n  fclose(fp);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":1,"function":"static int cat_file(char *filename) {\n    char *line = ((void *)0);\n    size_t len;\n    FILE *fp;\n    fp = fopen(filename, \"r\");\n    if (!fp) {\n        fprintf(stdout, \"No such file or directory\\n</pre>\");\n        return -1;\n    }\n    fprintf(stdout, \"<br><br>--------<pre>Contents of file %s:\\n\\n\", filename);\n    while (getline(&line, &len, fp) != -1)\n        fprintf(stdout, \"%s\", line);\n    fprintf(stdout, \"</pre>\");\n    free(line);\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int cat_file_name_conflict(char *file) {\n  FILE *fp;\n  char *line = NULL;\n  size_t len = 0;\n  ssize_t read;\n\n  fp = fopen(file, \"r\");\n  if (fp == NULL) {\n    fprintf(stdout, \"No such file or directory\\n</pre>\");\n    return -1;\n  }\n\n  fprintf(stdout, \"<br><br>--------<pre>Contents of file %s:\\n\\n\", file);\n  while ((read = getline(&line, &len, fp)) != -1) {\n    fprintf(stdout, \"%s\", line);\n  }\n  fprintf(stdout, \"</pre>\");\n\n  free(line);\n  fclose(fp);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":1,"function":"static int test(int do_exit) {\n    pthread_t t;\n    pthread_create(&t, ((void *)0), thread1_func, (void *)do_exit);\n    pthread_join(t, ((void *)0));\n    if (g_ok1 != +1) {\n        if (g_ok1 == 0) {\n            fprintf(stderr, \"cleanup1 not called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup1 called with wrong argument\\n\");\n        }\n        exit(1);\n    } else if (g_ok2 != +1) {\n        if (g_ok2 == 0)\n            fprintf(stderr, \"cleanup2 not called !!\\n\");\n        else\n            fprintf(stderr, \"cleanup2 called with wrong argument\\n\");\n        exit(2);\n    } else if (do_exit && g_ok3 != +1) {\n        if (g_ok3 == 0) {\n            fprintf(stderr, \"cleanup3 not called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup3 called with bad argument !!\\n\");\n        }\n        exit(3);\n    } else if (!do_exit && g_ok3 != 0) {\n        if (g_ok3 == 1) {\n            fprintf(stderr, \"cleanup3 wrongly called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup3 wrongly called with bad argument !!\\n\");\n        }\n        exit(3);\n    }\n    return 0;\n}\n","function_prediction":"int test_name_conflict(int arg) {\n  pthread_t thread;\n\n  pthread_create(&thread, NULL, thread1_func, (void *)arg);\n  pthread_join(thread, NULL);\n\n  if (g_ok1 != 1) {\n    if (g_ok1 == 0)\n      fputs(\"cleanup1 not called !!\\n\", stderr);\n    else\n      fputs(\"cleanup1 called with wrong argument\\n\", stderr);\n    exit(1);\n  }\n\n  if (g_ok2 != 1) {\n    if (g_ok2 == 0)\n      fputs(\"cleanup2 not called !!\\n\", stderr);\n    else\n      fputs(\"cleanup2 called with wrong argument\\n\", stderr);\n    exit(2);\n  }\n\n  if (arg && g_ok3 != 1) {\n    if (g_ok3 == 0)\n      fputs(\"cleanup3 not called !!\\n\", stderr);\n    else\n      fputs(\"cleanup3 called with bad argument !!\\n\", stderr);\n    exit(3);\n  }\n\n  if (!arg && g_ok3 != 0) {\n    if (g_ok3 == 1)\n      fputs(\"cleanup3 wrongly called !!\\n\", stderr);\n    else\n      fputs(\"cleanup3 wrongly called with bad argument !!\\n\", stderr);\n    exit(3);\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/bionic/libc/common/test_pthread_cleanup_push.c"}
{"compilable":1,"function":"static int check_library(const char *libname) {\n    void *lib = dlopen(libname, 2);\n    int *to_x;\n    void (*set_y)(int *);\n    int y = 0;\n    if (lib == ((void *)0)) {\n        fprintf(stderr, \"Could not load shared library %s: %s\\n\", libname, dlerror());\n        return 1;\n    }\n    fprintf(stderr, \"%s loaded.\\n\", libname);\n    to_x = dlsym(lib, \"x\");\n    if (to_x == ((void *)0)) {\n        fprintf(stderr, \"Could not access global DLL variable (x) in %s: %s\\n\", libname, dlerror());\n        return 10;\n    }\n    if (*to_x != 1) {\n        fprintf(stderr, \"Constructor was not run on dlopen(\\\"%s\\\") !\\n\", libname);\n        return 11;\n    }\n    set_y = dlsym(lib, \"set_y\");\n    if (set_y == ((void *)0)) {\n        fprintf(stderr, \"Could not access global DLL function (set_y) in %s: %s\\n\", libname, dlerror());\n        return 12;\n    }\n    y = 0;\n    (*set_y)(&y);\n    if (dlclose(lib) < 0) {\n        fprintf(stderr, \"Could not unload shared library %s: %s\\n\", libname, dlerror());\n        return 2;\n    }\n    fprintf(stderr, \"%s unloaded.\\n\", libname);\n    if (y != 2) {\n        fprintf(stderr, \"Static destructors was not called on dlclose()!\\n\");\n        return 2;\n    }\n    return 0;\n}\n","function_prediction":"int check_library_name_conflict(const char *libname) {\n  void *handle;\n  int *x;\n  int y;\n  void (*set_y)(int *);\n\n  handle = dlopen(libname, 2);\n  if (!handle) {\n    fprintf(stderr, \"Could not load shared library %s: %s\\n\", libname,\n            dlerror());\n    return 1;\n  }\n  fprintf(stderr, \"%s loaded.\\n\", libname);\n\n  x = dlsym(handle, \"x\");\n  if (!x) {\n    fprintf(stderr, \"Could not access global DLL variable (x) in %s: %s\\n\",\n            libname, dlerror());\n    return 10;\n  }\n  if (*x != 1) {\n    fprintf(stderr, \"Constructor was not run on dlopen(\\\"%s\\\") !\\n\", libname);\n    return 11;\n  }\n\n  set_y = dlsym(handle, \"set_y\");\n  if (!set_y) {\n    fprintf(stderr, \"Could not access global DLL function (set_y) in %s: %s\\n\",\n            libname, dlerror());\n    return 12;\n  }\n\n  y = 0;\n  set_y(&y);\n\n  if (dlclose(handle) < 0) {\n    fprintf(stderr, \"Could not unload shared library %s: %s\\n\", libname,\n            dlerror());\n    return 2;\n  }\n  fprintf(stderr, \"%s unloaded.\\n\", libname);\n\n  if (y != 2) {\n    fprintf(stderr, \"Static destructors was not called on dlclose()!\\n\");\n    return 2;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/bionic/libc/bionic/test_dlclose_destruction.c"}
{"compilable":1,"function":"static unsigned long long stop_watch() {\n    struct timespec t;\n    t.tv_sec = t.tv_nsec = 0;\n    clock_gettime(1, &t);\n    return t.tv_sec * 1000000000ULL + t.tv_nsec;\n}\n","function_prediction":"long stop_watch_name_conflict(void) {\n  struct timespec t;\n  t.tv_sec = 0;\n  t.tv_nsec = 0;\n  clock_gettime(1, &t);\n  return t.tv_sec * 1000000000 + t.tv_nsec;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/pftest/pftest.c"}
{"compilable":1,"function":"int64_t systemTime() {\n    struct timespec t;\n    t.tv_sec = t.tv_nsec = 0;\n    clock_gettime(1, &t);\n    return (int64_t)(t.tv_sec) * 1000000000LL + t.tv_nsec;\n}\n","function_prediction":"long long systemTime_name_conflict() {\n  struct timespec tp;\n  tp.tv_sec = 0;\n  tp.tv_nsec = 0;\n  clock_gettime(1, &tp);\n  return (long long)tp.tv_sec * 1000000000 + tp.tv_nsec;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/framebuffer/refresh.c"}
{"compilable":0,"function":"static u64 get_block_device_size(int fd) {\n    u64 size = 0;\n    int ret;\n    ret = ioctl(fd, (((2U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((114)) << 0) | ((((sizeof(size_t)))) << ((0 + 8) + 8))), &size);\n    if (ret)\n        return 0;\n    return size;\n}\n","function_prediction":"uint64_t get_block_device_size_name_conflict(int fd) {\n  uint64_t size = 0;\n  int ret = ioctl(fd, 0x80081272, &size);\n  if (ret)\n    size = 0;\n  return size;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/storage/wipe_blkdev.c"}
{"compilable":0,"function":"static int wipe_block_device(int fd, u64 len, int secure) {\n    u64 range[2];\n    int ret;\n    int req;\n    range[0] = 0;\n    range[1] = len;\n    if (secure) {\n        req = (((0U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((125)) << 0) | ((0) << ((0 + 8) + 8)));\n    } else {\n        req = (((0U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((119)) << 0) | ((0) << ((0 + 8) + 8)));\n    }\n    ret = ioctl(fd, req, &range);\n    if (ret < 0) {\n        fprintf(stderr, \"%s discard failed, errno = %d\\n\", secure ? \"Secure\" : \"Nonsecure\", (*__errno_location()));\n    }\n    return ret;\n}\n","function_prediction":"int wipe_block_device_name_conflict(int fd, off_t offset, int secure) {\n  int ret;\n  struct hw_erase_sector_info info = {0};\n\n  info.offset = offset;\n\n  ret = ioctl(fd, secure ? 0x127d : 0x1277, &info);\n  if (ret < 0) {\n    fprintf(stderr, \"%s discard failed, errno = %d\\n\",\n            secure ? \"Secure\" : \"Nonsecure\", *__errno_location());\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/storage/wipe_blkdev.c"}
{"compilable":0,"function":"static uid_t str2uid(char *str, int line_num) {\n    struct passwd *pw;\n    if (((*__ctype_b_loc())[(int)((str[0]))] & (unsigned short)_ISdigit))\n        return (uid_t)atol(str);\n    if (!(pw = getpwnam(str))) {\n        printf(\"# ERROR # Invalid uid '%s' reading line %d\\n\", str, line_num);\n        exit(255);\n    }\n    return pw->pw_uid;\n}\n","function_prediction":"uid_t str2uid_name_conflict(char *str, int line) {\n  if (__ctype_b_loc()->nl_ctype[*str & 0xff] & 0x0800)\n    return atol(str);\n  else {\n    struct passwd *pw;\n\n    pw = getpwnam(str);\n    if (pw == NULL) {\n      printf(\"# ERROR # Invalid uid '%s' reading line %d\\n\", str, line);\n      exit(255);\n    }\n    return pw->pw_uid;\n  }\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static gid_t str2gid(char *str, int line_num) {\n    struct group *gr;\n    if (((*__ctype_b_loc())[(int)((str[0]))] & (unsigned short)_ISdigit))\n        return (uid_t)atol(str);\n    if (!(gr = getgrnam(str))) {\n        printf(\"# ERROR # Invalid gid '%s' reading line %d\\n\", str, line_num);\n        exit(255);\n    }\n    return gr->gr_gid;\n}\n","function_prediction":"gid_t str2gid_name_conflict(char *str, int line) {\n  if (__ctype_b_loc()->nl_langinfo_chars[*str] & 0x0800)\n    return atol(str);\n\n  struct group *grp = getgrnam(str);\n  if (grp == NULL) {\n    printf(\"# ERROR # Invalid gid '%s' reading line %d\\n\", str, line);\n    exit(255);\n  }\n\n  return grp->gr_gid;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_file(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_FILE];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for file: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    if (rules_matched || retval)\n        return retval;\n    pr = rules[WILDCARD];\n    while (pr != ((void *)0))\n        {\n            if ((strstr(name, pr->spec) == name) && (!strchr(name + strlen(pr->spec), '/'))) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    pr = rules[RECURSIVE];\n    while (pr != ((void *)0))\n        {\n            if (strstr(name, pr->spec) == name) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if (!rules_matched)\n        retval++;\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"int validate_file_name_conflict(char *file, int line, int column, int level) {\n  struct rule *rule;\n  int exact_pass = 0;\n  int exact_fail = 0;\n\n  for (rule = rules; rule; rule = rule->next) {\n    if (!strcmp(file, rule->file)) {\n      if (!pass_rule(rule, line, column, level))\n        exact_pass++;\n      else\n        exact_fail++;\n    }\n  }\n\n  if (exact_pass + exact_fail > 1)\n    printf(\"# WARNING # Multiple exact rules for file: %s\\n\", file);\n\n  if (exact_pass)\n    print_new_rule(file, line, column, level);\n\n  if (exact_fail || exact_pass)\n    return exact_pass;\n\n  for (rule = rules; rule; rule = rule->next) {\n    if (strstr(file, rule->file) == file) {\n      if (strchr(file + strlen(rule->file), '/') == NULL) {\n        if (!pass_rule(rule, line, column, level))\n          exact_pass++;\n        else\n          exact_fail++;\n      }\n    }\n  }\n\n  for (rule = rules; rule; rule = rule->next) {\n    if (strstr(file, rule->file) == file) {\n      if (!pass_rule(rule, line, column, level))\n        exact_pass++;\n      else\n        exact_fail++;\n    }\n  }\n\n  if (exact_fail == 0)\n    exact_pass++;\n\n  if (exact_pass)\n    print_new_rule(file, line, column, level);\n\n  return exact_pass;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_link(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_FILE];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for link: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"int validate_link_name_conflict(char *link, int type, int flags, int priority) {\n  struct rule *r;\n  int exact = 0;\n  int inexact = 0;\n\n  for (r = rules; r; r = r->next) {\n    if (!strcmp(link, r->link)) {\n      if (!pass_rule(r, type, flags, priority))\n        exact++;\n      else\n        inexact++;\n    }\n  }\n\n  if (exact + inexact > 1)\n    printf(\"# WARNING # Multiple exact rules for link: %s\\n\", link);\n\n  if (exact)\n    print_new_rule(link, type, flags, priority);\n\n  return exact;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_dir(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_DIR];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for directory: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    if (rules_matched || retval)\n        return retval;\n    pr = rules[RECURSIVE];\n    while (pr != ((void *)0))\n        {\n            if (strstr(name, pr->spec) == name) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if (!rules_matched)\n        retval++;\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"int validate_dir_name_conflict(char *dir, int type, int perm, int uid) {\n  struct rule *rule;\n  int exact_ok = 0;\n  int exact_fail = 0;\n\n  for (rule = rule_list; rule; rule = rule->next) {\n    if (!strcmp(dir, rule->dir)) {\n      if (!pass_rule(rule, type, perm, uid))\n        exact_ok++;\n      else\n        exact_fail++;\n    }\n  }\n\n  if (exact_ok + exact_fail > 1)\n    printf(\"# WARNING # Multiple exact rules for directory: %s\\n\", dir);\n\n  if (exact_ok)\n    print_new_rule(dir, type, perm, uid);\n\n  if (exact_fail || exact_ok)\n    return exact_ok;\n\n  for (rule = rule_list; rule; rule = rule->next) {\n    if (strstr(dir, rule->dir) == dir) {\n      if (!pass_rule(rule, type, perm, uid))\n        exact_ok++;\n      else\n        exact_fail++;\n    }\n  }\n\n  if (!exact_fail)\n    exact_ok++;\n\n  if (exact_ok)\n    print_new_rule(dir, type, perm, uid);\n\n  return exact_ok;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int check_path(const char *name) {\n    char namebuf[4097];\n    char tmp[4097];\n    DIR *d;\n    struct dirent *de;\n    struct stat s;\n    int err;\n    int retval = 0;\n    err = lstat(name, &s);\n    if (err < 0) {\n        if ((*__errno_location()) != 2) {\n            perror(name);\n            return 1;\n        }\n        return 0;\n    }\n    if (((((s.st_mode)) & 61440) == (16384))) {\n        if (name[strlen(name) - 1] != '/')\n            snprintf(namebuf, sizeof (namebuf), \"%s/\", name);\n        else\n            snprintf(namebuf, sizeof (namebuf), \"%s\", name);\n        retval |= validate_dir(namebuf, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n        d = opendir(namebuf);\n        if (d == 0) {\n            printf(\"%s : opendir failed: %s\\n\", namebuf, strerror((*__errno_location())));\n            return 1;\n        }\n        while ((de = readdir(d)) != 0)\n            {\n                if (!strcmp(de->d_name, \".\") || !strcmp(de->d_name, \"..\"))\n                    continue;\n                snprintf(tmp, sizeof (tmp), \"%s%s\", namebuf, de->d_name);\n                retval |= check_path(tmp);\n            }\n        closedir(d);\n        return retval;\n    } else if (((((s.st_mode)) & 61440) == (40960))) {\n        return validate_link(name, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n    } else {\n        return validate_file(name, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n    }\n}\n","function_prediction":"int check_path_name_conflict(const char *path) {\n  int ret = 0;\n  struct stat st;\n  int rc = lstat(path, &st);\n  if (rc < 0) {\n    if (*__errno_location() == 2) {\n      return 0;\n    }\n    perror(path);\n    return 1;\n  }\n\n  if ((st.st_mode & 0170000) == 0040000) {\n    char dir[4096 + 1];\n    if (path[strlen(path) - 1] == '/') {\n      snprintf(dir, sizeof(dir), \"%s\", path);\n    } else {\n      snprintf(dir, sizeof(dir), \"%s/\", path);\n    }\n    ret |= validate_dir(dir, st.st_mode & ~0170000, st.st_uid, st.st_gid);\n\n    DIR *dp = opendir(dir);\n    if (dp == NULL) {\n      printf(\"%s : opendir failed: %s\\n\", dir, strerror(*__errno_location()));\n      return 1;\n    }\n    struct dirent *ent;\n    while ((ent = readdir(dp)) != NULL) {\n      if (!strcmp(ent->d_name, \".\") || !strcmp(ent->d_name, \"..\")) {\n        continue;\n      }\n      char path[4096 + 1];\n      snprintf(path, sizeof(path), \"%s%s\", dir, ent->d_name);\n      ret |= check_path_name_conflict(path);\n    }\n    closedir(dp);\n  } else if ((st.st_mode & 0170000) == 0120000) {\n    ret |= validate_link(path, st.st_mode & ~0170000, st.st_uid, st.st_gid);\n  } else {\n        ret |= validate_file(path, st.st_mode & ~0170000, st.st_uid, st","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":1,"function":"static int get_cpu_count() {\n    int cpu_count = get_cpu_count_from_file(\"/sys/devices/system/cpu/present\");\n    if (cpu_count != get_cpu_count_from_file(\"/sys/devices/system/cpu/online\")) {\n        {\n            fprintf(stderr, \"present cpus != online cpus\\n\");\n            exit(1);\n        }\n        ;\n    }\n    return cpu_count;\n}\n","function_prediction":"int get_cpu_count_name_conflict(void) {\n  int present_cpus, online_cpus;\n\n  present_cpus = get_cpu_count_name_conflict_from_file(\"/sys/devices/system/cpu/present\");\n  online_cpus = get_cpu_count_name_conflict_from_file(\"/sys/devices/system/cpu/online\");\n\n  if (present_cpus != online_cpus) {\n    fprintf(stderr, \"present cpus != online cpus\\n\");\n    exit(1);\n  }\n\n  return present_cpus;\n}","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":1,"function":"static int get_cpu_count_from_file(char *filename) {\n    FILE *file;\n    char line[64];\n    int cpu_count;\n    file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n    ;\n    if (!fgets(line, 64, file)) {\n        fprintf(stderr, \"Could not get %s contents\\n\", filename);\n        exit(1);\n    }\n    ;\n    fclose(file);\n    if (strcmp(line, \"0\\n\") == 0) {\n        return 1;\n    }\n    if (1 == sscanf(line, \"0-%d\\n\", &cpu_count)) {\n        return cpu_count + 1;\n    }\n    {\n        fprintf(stderr, \"Unexpected input in file %s (%s).\\n\", filename, line);\n        exit(1);\n    }\n    ;\n    return -1;\n}\n","function_prediction":"int get_cpu_count_from_file_name_conflict(const char *file) {\n  FILE *f;\n  char buf[64];\n  int cpu_count;\n\n  f = fopen(file, \"r\");\n  if (!f) {\n    fprintf(stderr, \"Could not open %s\\n\", file);\n    exit(1);\n  }\n\n  if (fgets(buf, sizeof(buf), f) == NULL) {\n    fprintf(stderr, \"Could not get %s contents\\n\", file);\n    exit(1);\n  }\n  fclose(f);\n\n  if (!strcmp(buf, \"0\\n\"))\n    return 1;\n\n  if (__isoc99_sscanf(buf, \"0-%d\\n\", &cpu_count) != 1) {\n    fprintf(stderr, \"Unexpected input in file %s (%s).\\n\", file, buf);\n    exit(1);\n  }\n\n  return cpu_count + 1;\n}","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":1,"function":"static int get_freq_scales_count(int cpu) {\n    FILE *file;\n    char filename[64];\n    unsigned long freq;\n    int count = 0;\n    sprintf(filename, \"/sys/devices/system/cpu/cpu%d/cpufreq/stats/time_in_state\", cpu);\n    file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n    ;\n    do {\n        freq = 0;\n        fscanf(file, \"%lu %*d\\n\", &freq);\n        if (freq)\n            count++;\n    } while (freq);\n    fclose(file);\n    return count;\n}\n","function_prediction":"int get_freq_scales_count_name_conflict(int cpu) {\n  FILE *fp;\n  char filename[64];\n  unsigned long time_in_state;\n  int count = 0;\n\n  sprintf(filename, \"/sys/devices/system/cpu/cpu%d/cpufreq/stats/time_in_state\",\n          cpu);\n  fp = fopen(filename, \"r\");\n  if (!fp) {\n    fprintf(stderr, \"Could not open %s\\n\", filename);\n    exit(1);\n  }\n\n  while (1) {\n    time_in_state = 0;\n    if (__isoc99_fscanf(fp, \"%lu %*d\\n\", &time_in_state) == EOF)\n      break;\n    if (time_in_state == 0)\n      break;\n    count++;\n  }\n\n  fclose(fp);\n  return count;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static char should_print_freq_stats() {\n    int i, j;\n    for (i = 1; i < cpu_count; i++) {\n        for (j = 0; j < new_cpus[i].freq_count; j++) {\n            if (new_cpus[i].freqs[j].time - old_cpus[i].freqs[j].time != new_cpus[0].freqs[j].time - old_cpus[0].freqs[j].time) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"int should_print_freq_stats_name_conflict(void) {\n  int i, j;\n\n  for (i = 1; i < cpu_count; i++) {\n    for (j = 0; j < new_cpus[i].core.num_pkg; j++) {\n      if (new_cpus[i].core.pkg[j].freq.max - old_cpus[i].core.pkg[j].freq.max !=\n          new_cpus[i].core.pkg[j].freq.max - old_cpus[i].core.pkg[j].freq.max)\n        return 1;\n    }\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":1,"function":"static char should_aggregate_freq_stats() {\n    int i, j;\n    for (i = 1; i < cpu_count; i++) {\n        if (new_cpus[i].freq_count != new_cpus[0].freq_count) {\n            return 0;\n        }\n        for (j = 0; j < new_cpus[i].freq_count; j++) {\n            if (new_cpus[i].freqs[j].freq != new_cpus[0].freqs[j].freq) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"int should_aggregate_freq_stats_name_conflict(void) {\n  int i, j;\n\n  for (i = 1; i < cpu_count; i++) {\n    if (new_cpus[i].freq_count != new_cpus[0].freq_count)\n      return 0;\n\n    for (j = 0; j < new_cpus[i].freq_count; j++) {\n      if (new_cpus[i].freqs[j].freq != new_cpus[0].freqs[j].freq)\n        return 0;\n    }\n  }\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static struct slab_info *get_slabinfo(struct slab_stat *stats) {\n    struct slab_info *head = ((void *)0), *p = ((void *)0), *prev = ((void *)0);\n    FILE *slabfile;\n    char line[512];\n    unsigned int major, minor;\n    slabfile = fopen(\"/proc/slabinfo\", \"r\");\n    if (!slabfile) {\n        perror(\"fopen\");\n        return ((void *)0);\n    }\n    if (!fgets(line, 512, slabfile)) {\n        fprintf(stderr, \"cannot read from /proc/slabinfo\\n\");\n        return ((void *)0);\n    }\n    if (sscanf(line, \"slabinfo - version: %u.%u\", &major, &minor) != 2) {\n        fprintf(stderr, \"unable to parse slabinfo version!\\n\");\n        return ((void *)0);\n    }\n    if (major != 2 || minor > 1) {\n        fprintf(stderr, \"we only support slabinfo 2.0 and 2.1!\\n\");\n        return ((void *)0);\n    }\n    stats->min_obj_size = 2147483647;\n    while (fgets(line, 512, slabfile))\n        {\n            unsigned long nr_active_slabs, pages_per_slab;\n            int ret;\n            if (line[0] == '#')\n                continue;\n            p = malloc(sizeof(struct slab_info));\n            if (!p) {\n                perror(\"malloc\");\n                head = ((void *)0);\n                break;\n            }\n            if (stats->nr_caches++ == 0)\n                head = prev = p;\n            ret = sscanf(line, \"%32s %lu %lu %lu %lu %lu : tunables %*d %*d %*d :         slabdata %lu %lu %*d\", p->name, &p->nr_active_objs, &p->nr_objs, &p->obj_size, &p->objs_per_slab, &pages_per_slab, &nr_active_slabs, &p->nr_slabs);\n            if (ret != 8) {\n                fprintf(stderr, \"unrecognizable data in slabinfo!\\n\");\n                head = ((void *)0);\n                break;\n            }\n            if (p->obj_size < stats->min_obj_size)\n                stats->min_obj_size = p->obj_size;\n            if (p->obj_size > stats->max_obj_size)\n                stats->max_obj_size = p->obj_size;\n            p->nr_pages = p->nr_slabs * pages_per_slab;\n            if (p->nr_objs) {\n                p->use = 100 * p->nr_active_objs / p->nr_objs;\n                stats->nr_active_caches++;\n            } else\n                p->use = 0;\n            stats->nr_objs += p->nr_objs;\n            stats->nr_active_objs += p->nr_active_objs;\n            stats->total_size += p->nr_objs * p->obj_size;\n            stats->active_size += p->nr_active_objs * p->obj_size;\n            stats->nr_slabs += p->nr_slabs;\n            stats->nr_active_slabs += nr_active_slabs;\n            prev->next = p;\n            prev = p;\n        }\n    if (fclose(slabfile))\n        perror(\"fclose\");\n    if (p)\n        p->next = ((void *)0);\n    if (stats->nr_objs)\n        stats->avg_obj_size = stats->total_size / stats->nr_objs;\n    return head;\n}\n","function_prediction":"struct slabinfo *get_slabinfo_name_conflict(struct slabinfo_stats *stats) {\n  FILE *fp;\n  char buf[512];\n  struct slabinfo *slabinfo = NULL;\n  struct slabinfo *slabinfo_head = NULL;\n  struct slabinfo *slabinfo_tail = NULL;\n  int ret;\n  unsigned int major, minor;\n\n  fp = fopen(\"/proc/slabinfo\", \"r\");\n  if (!fp) {\n    perror(\"fopen\");\n    return NULL;\n  }\n\n  if (fgets(buf, sizeof(buf), fp) == NULL) {\n    fprintf(stderr, \"cannot read from /proc/slabinfo\\n\");\n    return NULL;\n  }\n\n  ret = __isoc99_sscanf(buf, \"slabinfo - version: %u.%u\", &major, &minor);\n  if (ret != 2) {\n    fprintf(stderr, \"unable to parse slabinfo version!\\n\");\n    return NULL;\n  }\n\n  if (major != 2 || minor > 1) {\n    fprintf(stderr, \"we only support slabinfo 2.0 and 2.1!\\n\");\n    return NULL;\n  }\n\n  stats->min_objsize = 0x7fffffff;\n\n  while (fgets(buf, sizeof(buf), fp)) {\n    if (buf[0] == '#')\n      continue;\n\n    slabinfo = malloc(sizeof(*slabinfo));\n    if (!slabinfo) {\n      perror(\"malloc\");\n      return NULL;\n    }\n\n    stats->num_slabs++;\n\n    if (stats->num_slabs == 1) {\n      slabinfo_head = slabinfo;\n      slabinfo_tail = slabinfo;\n    }\n\n    unsigned long nr_objs, nr_active_objs, nr_obj, nr_free_objs, nr_slab,\n        nr_slabdata, nr_slabdata_free;\n\n  ret = __isoc99_sscanf(buf, \"%3","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"static struct slab_info *merge_objs(struct slab_info *a, struct slab_info *b) {\n    struct slab_info list;\n    struct slab_info *p = &list;\n    while (a && b)\n        {\n            if (sort_func(a, b)) {\n                p->next = a;\n                p = a;\n                a = a->next;\n            } else {\n                p->next = b;\n                p = b;\n                b = b->next;\n            }\n        }\n    p->next = (a == ((void *)0)) ? b : a;\n    return list.next;\n}\n","function_prediction":"struct obj *merge_objs_name_conflict(struct obj *a, struct obj *b) {\n  struct obj *head, *tail;\n\n  head.next = tail = &head;\n  while (a && b) {\n    if (!sort_func(a, b)) {\n      tail = tail->next = a;\n      a = a->next;\n    } else {\n      tail = tail->next = b;\n      b = b->next;\n    }\n  }\n  tail->next = a ? a : b;\n  return head.next;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"static struct slab_info *slabsort(struct slab_info *list) {\n    struct slab_info *a, *b;\n    if (!list || !list->next)\n        return list;\n    a = list;\n    b = list->next;\n    while (b && b->next)\n        {\n            list = list->next;\n            b = b->next->next;\n        }\n    b = list->next;\n    list->next = ((void *)0);\n    return merge_objs(slabsort(a), slabsort(b));\n}\n","function_prediction":"struct obj *slabsort_name_conflict(struct obj *list) {\n  struct obj *a, *b, *c;\n\n  if (list == NULL || list->next == NULL)\n    return list;\n\n  a = list;\n  b = list->next;\n\n  while (b != NULL && b->next != NULL) {\n    a = a->next;\n    b = b->next->next;\n  }\n\n  c = a->next;\n  a->next = NULL;\n\n  return merge_objs(slabsort_name_conflict(list), slabsort_name_conflict(c));\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"int wav_play(const char *fn) {\n    struct wav_header hdr;\n    unsigned int rate, channels;\n    int fd;\n    fd = open(fn, 0);\n    if (fd < 0) {\n        fprintf(stderr, \"playwav: cannot open '%s'\\n\", fn);\n        return -1;\n    }\n    if (read(fd, &hdr, sizeof (hdr)) != sizeof (hdr)) {\n        fprintf(stderr, \"playwav: cannot read header\\n\");\n        return -1;\n    }\n    fprintf(stderr, \"playwav: %d ch, %d hz, %d bit, %s\\n\", hdr.num_channels, hdr.sample_rate, hdr.bits_per_sample, hdr.audio_format == 1 ? \"PCM\" : \"unknown\");\n    if ((hdr.riff_id != 1179011410) || (hdr.riff_fmt != 1163280727) || (hdr.fmt_id != 544501094)) {\n        fprintf(stderr, \"playwav: '%s' is not a riff/wave file\\n\", fn);\n        return -1;\n    }\n    if ((hdr.audio_format != 1) || (hdr.fmt_sz != 16)) {\n        fprintf(stderr, \"playwav: '%s' is not pcm format\\n\", fn);\n        return -1;\n    }\n    if (hdr.bits_per_sample != 16) {\n        fprintf(stderr, \"playwav: '%s' is not 16bit per sample\\n\", fn);\n        return -1;\n    }\n    play_file(hdr.sample_rate, hdr.num_channels, fd, hdr.data_sz);\n    return 0;\n}\n","function_prediction":"int wav_play_name_conflict(char *filename) {\n  int fd;\n  struct wav_header hdr;\n\n  if ((fd = open(filename, 0)) < 0) {\n    fprintf(stderr, \"playwav: cannot open '%s'\\n\", filename);\n    return -1;\n  }\n\n  if (read(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {\n    fprintf(stderr, \"playwav: cannot read header\\n\");\n    return -1;\n  }\n\n  fprintf(stderr, \"playwav: %d ch, %d hz, %d bit, %s\\n\", hdr.num_channels,\n          hdr.sample_rate, hdr.bits_per_sample,\n          hdr.audio_format == 1 ? \"PCM\" : \"unknown\");\n\n  if (hdr.riff_id != 0x46464952 || hdr.wave_id != 0x45564157 ||\n      hdr.fmt_id != 0x20746d66) {\n    fprintf(stderr, \"playwav: '%s' is not a riff/wave file\\n\", filename);\n    return -1;\n  }\n\n  if (hdr.audio_format != 1 || hdr.block_align != 16) {\n    fprintf(stderr, \"playwav: '%s' is not pcm format\\n\", filename);\n    return -1;\n  }\n\n  if (hdr.bits_per_sample != 16) {\n    fprintf(stderr, \"playwav: '%s' is not 16bit per sample\\n\", filename);\n    return -1;\n  }\n\n  play_file(hdr.sample_rate, hdr.num_channels, fd, hdr.data_size);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":0,"function":"int wav_rec(const char *fn, unsigned int channels, unsigned int rate) {\n    struct wav_header hdr;\n    unsigned char buf[8192];\n    struct msm_audio_config cfg;\n    unsigned int sz, n;\n    int fd, afd;\n    unsigned int total = 0;\n    unsigned char tmp;\n    hdr.riff_id = 1179011410;\n    hdr.riff_sz = 0;\n    hdr.riff_fmt = 1163280727;\n    hdr.fmt_id = 544501094;\n    hdr.fmt_sz = 16;\n    hdr.audio_format = 1;\n    hdr.num_channels = channels;\n    hdr.sample_rate = rate;\n    hdr.byte_rate = hdr.sample_rate * hdr.num_channels * 2;\n    hdr.block_align = hdr.num_channels * 2;\n    hdr.bits_per_sample = 16;\n    hdr.data_id = 1635017060;\n    hdr.data_sz = 0;\n    fd = open(fn, 64 | 2, 438);\n    if (fd < 0) {\n        perror(\"cannot open output file\");\n        return -1;\n    }\n    write(fd, &hdr, sizeof (hdr));\n    afd = open(\"/dev/msm_pcm_in\", 2);\n    if (afd < 0) {\n        perror(\"cannot open msm_pcm_in\");\n        close(fd);\n        return -1;\n    }\n    if (ioctl(afd, (((2U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot read audio config\");\n        goto fail;\n    }\n    cfg.channel_count = hdr.num_channels;\n    cfg.sample_rate = hdr.sample_rate;\n    if (ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot write audio config\");\n        goto fail;\n    }\n    if (ioctl(afd, (((2U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot read audio config\");\n        goto fail;\n    }\n    sz = cfg.buffer_size;\n    fprintf(stderr, \"buffer size %d x %d\\n\", sz, cfg.buffer_count);\n    if (sz > sizeof (buf)) {\n        fprintf(stderr, \"buffer size %d too large\\n\", sz);\n        goto fail;\n    }\n    if (ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), 0)) {\n        perror(\"cannot start audio\");\n        goto fail;\n    }\n    fcntl(0, 4, 2048);\n    fprintf(stderr, \"\\n*** RECORDING * HIT ENTER TO STOP ***\\n\");\n    for (;;) {\n        while (read(0, &tmp, 1) == 1)\n            {\n                if ((tmp == 13) || (tmp == 10))\n                    goto done;\n            }\n        if (read(afd, buf, sz) != sz) {\n            perror(\"cannot read buffer\");\n            goto fail;\n        }\n        if (write(fd, buf, sz) != sz) {\n            perror(\"cannot write buffer\");\n            goto fail;\n        }\n        total += sz;\n    }\n  done:\n    close(afd);\n    hdr.data_sz = total;\n    hdr.riff_sz = total + 8 + 16 + 8;\n    lseek(fd, 0, 0);\n    write(fd, &hdr, sizeof (hdr));\n    close(fd);\n    return 0;\n  fail:\n    close(afd);\n    close(fd);\n    unlink(fn);\n    return -1;\n}\n","function_prediction":"int wav_rec_name_conflict(char *filename, unsigned short channels, unsigned int rate) {\n  int fd, fd_audio, ret, size, count = 0;\n  struct wave_header header;\n  char buf[8192];\n  struct audio_config config;\n\n  header.chunk_id = 0x46464952;\n  header.chunk_size = 0;\n  header.format = 0x45564157;\n  header.subchunk1_id = 0x20746d66;\n  header.subchunk1_size = 16;\n  header.audio_format = 1;\n  header.num_channels = channels;\n  header.sample_rate = rate;\n  header.bits_per_sample = 16;\n  header.byte_rate = channels * rate * 2;\n  header.block_align = channels * 2;\n  header.subchunk2_id = 0x61746164;\n  header.subchunk2_size = 0;\n\n  fd = open(filename, 0x42, 0666);\n  if (fd < 0) {\n    perror(\"cannot open output file\");\n    return -1;\n  }\n\n  write(fd, &header, sizeof(header));\n\n  fd_audio = open(\"/dev/msm_pcm_in\", 2);\n  if (fd_audio < 0) {\n    perror(\"cannot open msm_pcm_in\");\n    close(fd);\n    return -1;\n  }\n\n  ret = ioctl(fd_audio, 0x80046103, &config);\n  if (ret) {\n    perror(\"cannot read audio config\");\n    goto error;\n  }\n\n  config.channels = channels;\n  config.rate = rate;\n\n  ret = ioctl(fd_audio, 0x40046104, &config);\n  if (ret) {\n    perror(\"cannot write audio config\");\n    goto error;\n  }\n","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":1,"function":"int mp3_play(const char *fn) {\n    char buf[65536];\n    int r;\n    int fd, afd;\n    fd = open(fn, 0);\n    if (fd < 0) {\n        perror(\"cannot open mp3 file\");\n        return -1;\n    }\n    afd = open(\"/dev/msm_mp3\", 2);\n    if (afd < 0) {\n        close(fd);\n        perror(\"cannot open mp3 output device\");\n        return -1;\n    }\n    fprintf(stderr, \"MP3 PLAY\\n\");\n    ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), 0);\n    for (;;) {\n        r = read(fd, buf, 64 * 1024);\n        if (r <= 0)\n            break;\n        r = write(afd, buf, r);\n        if (r < 0)\n            break;\n    }\n    close(fd);\n    close(afd);\n    return 0;\n}\n","function_prediction":"int mp3_play_name_conflict(char *mp3_file) {\n  int fd, fd_out, ret;\n  char buf[65536];\n\n  fd = open(mp3_file, 0);\n  if (fd < 0) {\n    perror(\"cannot open mp3 file\");\n    return -1;\n  }\n\n  fd_out = open(\"/dev/msm_mp3\", 2);\n  if (fd_out < 0) {\n    close(fd);\n    perror(\"cannot open mp3 output device\");\n    return -1;\n  }\n\n  fwrite(\"MP3 PLAY\\n\", 1, 9, stderr);\n\n  ioctl(fd_out, 0x40046100, 0);\n\n  while (1) {\n    ret = read(fd, buf, 65536);\n    if (ret <= 0)\n      break;\n    ret = write(fd_out, buf, ret);\n    if (ret < 0)\n      break;\n  }\n\n  close(fd);\n  close(fd_out);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":0,"function":"static struct latency_entry *read_global_stats(struct latency_entry *list, int erase) {\n    FILE *f;\n    struct latency_entry *e;\n    if (erase) {\n        f = fopen(GLOBAL_STATS_FILE, \"w\");\n        if (!f) {\n            fprintf(stderr, \"Could not open global latency stats file: %s\\n\", strerror((*__errno_location())));\n            exit(1);\n        }\n        fprintf(f, \"erase\\n\");\n        fclose(f);\n    }\n    f = fopen(GLOBAL_STATS_FILE, \"r\");\n    if (!f) {\n        fprintf(stderr, \"Could not open global latency stats file: %s\\n\", strerror((*__errno_location())));\n        exit(1);\n    }\n    e = read_latency_file(f, list);\n    fclose(f);\n    return e;\n}\n","function_prediction":"double read_global_stats_name_conflict(int *count, int reset) {\n  FILE *fp;\n  double ret;\n\n  if (reset) {\n    fp = fopen(GLOBAL_STATS_FILE, \"w\");\n    if (fp == NULL) {\n      fprintf(stderr, \"Could not open global latency stats file: %s\\n\",\n              strerror(*__errno_location()));\n      exit(1);\n    }\n    fprintf(fp, \"erase\\n\");\n    fclose(fp);\n  }\n\n  fp = fopen(GLOBAL_STATS_FILE, \"r\");\n  if (fp == NULL) {\n    fprintf(stderr, \"Could not open global latency stats file: %s\\n\",\n            strerror(*__errno_location()));\n    exit(1);\n  }\n\n  ret = read_latency_file(fp, count);\n  fclose(fp);\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *read_process_stats(struct latency_entry *list, int erase, int pid) {\n    char dirname[64];\n    DIR *dir;\n    struct dirent *ent;\n    struct latency_entry *e;\n    int tid;\n    sprintf(dirname, \"/proc/%d/task\", pid);\n    dir = opendir(dirname);\n    if (!dir) {\n        fprintf(stderr, \"Could not open task dir for process %d.\\n\", pid);\n        fprintf(stderr, \"Perhaps the process has terminated?\\n\");\n        exit(1);\n    }\n    e = list;\n    while ((ent = readdir(dir)))\n        {\n            if (!((*__ctype_b_loc())[(int)((ent->d_name[0]))] & (unsigned short)_ISdigit))\n                continue;\n            tid = atoi(ent->d_name);\n            e = read_thread_stats(e, erase, pid, tid, 0);\n        }\n    closedir(dir);\n    return e;\n}\n","function_prediction":"struct process_stats *read_process_stats(struct process_stats *stats, int pid,\n                                         int tid) {\n  char path[64];\n  sprintf(path, \"/proc/%d/task\", tid);\n  DIR *dir = opendir(path);\n  if (!dir) {\n    fprintf(stderr, \"Could not open task dir for process %d.\\n\", tid);\n    fprintf(stderr, \"Perhaps the process has terminated?\\n\");\n    exit(1);\n  }\n\n  struct dirent *entry;\n  while ((entry = readdir(dir)) != NULL) {\n    if (__ctype_b_loc()[(unsigned char)(entry->d_name[0])] & (02000)) {\n      int tid = atoi(entry->d_name);\n      stats = read_thread_stats(stats, pid, tid, tid, 0);\n    }\n  }\n\n  closedir(dir);\n  return stats;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *read_thread_stats(struct latency_entry *list, int erase, int pid, int tid, int fatal) {\n    char filename[64];\n    FILE *f;\n    struct latency_entry *e;\n    sprintf(filename, THREAD_STATS_FILE_FORMAT, pid, tid);\n    if (erase) {\n        f = fopen(filename, \"w\");\n        if (!f) {\n            if (fatal) {\n                fprintf(stderr, \"Could not open %s: %s\\n\", filename, strerror((*__errno_location())));\n                fprintf(stderr, \"Perhaps the process or thread has terminated?\\n\");\n                exit(1);\n            } else {\n                return list;\n            }\n        }\n        fprintf(f, \"erase\\n\");\n        fclose(f);\n    }\n    f = fopen(GLOBAL_STATS_FILE, \"r\");\n    if (!f) {\n        if (fatal) {\n            fprintf(stderr, \"Could not open %s: %s\\n\", filename, strerror((*__errno_location())));\n            fprintf(stderr, \"Perhaps the process or thread has terminated?\\n\");\n            exit(1);\n        } else {\n            return list;\n        }\n    }\n    e = read_latency_file(f, list);\n    fclose(f);\n    return e;\n}\n","function_prediction":"struct latency_stats *read_thread_stats(struct latency_stats *stats, int erase,\n                                        int pid, int tid, int die_on_error) {\n  char filename[64];\n  FILE *f;\n\n  sprintf(filename, THREAD_STATS_FILE_FORMAT, pid, tid);\n\n  if (erase) {\n    f = fopen(filename, \"w\");\n    if (!f) {\n      if (die_on_error) {\n        fprintf(stderr, \"Could not open %s: %s\\n\", filename,\n                strerror(*__errno_location()));\n        fprintf(stderr, \"Perhaps the process or thread has terminated?\\n\");\n        exit(1);\n      }\n      return stats;\n    }\n    fprintf(f, \"erase\\n\");\n    fclose(f);\n  }\n\n  f = fopen(GLOBAL_STATS_FILE, \"r\");\n  if (!f) {\n    if (die_on_error) {\n      fprintf(stderr, \"Could not open %s: %s\\n\", filename,\n              strerror(*__errno_location()));\n      fprintf(stderr, \"Perhaps the process or thread has terminated?\\n\");\n      exit(1);\n    }\n    return stats;\n  }\n  stats = read_latency_file(f, stats);\n  fclose(f);\n\n  return stats;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *alloc_latency_entry(void) {\n    struct latency_entry *e;\n    if (free_entries) {\n        e = free_entries;\n        free_entries = free_entries->next;\n    } else {\n        e = calloc(1, sizeof(struct latency_entry));\n        if (!e) {\n            fprintf(stderr, \"Could not allocate latency entry: %s\\n\", strerror((*__errno_location())));\n            exit(1);\n        }\n    }\n    return e;\n}\n","function_prediction":"struct latency_entry *alloc_latency_entry_name_conflict(void) {\n  struct latency_entry *entry;\n\n  if (free_entries) {\n    entry = free_entries;\n    free_entries = free_entries->next;\n  } else {\n    entry = calloc(1, sizeof(*entry));\n    if (!entry) {\n      fprintf(stderr, \"Could not allocate latency entry: %s\\n\",\n              strerror(*__errno_location()));\n      exit(1);\n    }\n  }\n\n  return entry;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *find_latency_entry(struct latency_entry *head, char *reason) {\n    struct latency_entry *e;\n    e = head;\n    while (e)\n        {\n            if (!strcmp(e->reason, reason))\n                return e;\n            e = e->next;\n        }\n    return ((void *)0);\n}\n","function_prediction":"struct latency_entry *find_latency_entry(struct latency_entry *head,\n                                         const char *name) {\n  struct latency_entry *entry;\n\n  for (entry = head; entry; entry = entry->next)\n    if (!strcmp(entry->name, name))\n      return entry;\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":1,"function":"static int numcmp(const long long a, const long long b) {\n    if (a < b)\n        return -1;\n    if (a > b)\n        return 1;\n    return 0;\n}\n","function_prediction":"int numcmp_name_conflict(const void *a, const void *b) {\n  if (*(long *)a < *(long *)b)\n    return -1;\n  else if (*(long *)a > *(long *)b)\n    return 1;\n  else\n    return 0;\n}","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":1,"function":"static const char *next_line(const char *b) {\n    while (1)\n        {\n            switch (*b) {\n              case '\\n':\n                return b + 1;\n              case '\\x00':\n                return ((void *)0);\n            }\n            b++;\n        }\n}\n","function_prediction":"char *next_line_name_conflict(char *s) {\n  while (*s) {\n    if (*s == '\\n')\n      return s + 1;\n    s++;\n  }\n  return NULL;\n}","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int print() {\n    int i;\n    printf(\"CPU  yield() schedule() switch idle   ttwu() local  cpu_time wait_time timeslices\\n\");\n    for (i = 0; i < 2; i++) {\n        printf(\" %2d  %7u %10u %6u %4u %8u %5u %9llu %9llu %10lu\\n\", i, cpu_delta[i].yld_count, cpu_delta[i].sched_count, cpu_delta[i].sched_switch, cpu_delta[i].sched_goidle, cpu_delta[i].ttwu_count, cpu_delta[i].ttwu_local, cpu_delta[i].cpu_time / 1000000, cpu_delta[i].run_delay / 1000000, cpu_delta[i].pcount);\n    }\n    return 0;\n}\n","function_prediction":"int print_name_conflict(void) {\n  int i;\n\n  print_name_conflictf(\"CPU  yield() schedule() switch idle   ttwu() local  cpu_time \"\n         \"wait_time timeslices\\n\");\n  for (i = 0; i < 2; i++)\n    print_name_conflictf(\" %2d  %7u %10u %6u %4u %8u %5u %9llu %9llu %10lu\\n\", i,\n           cpu_delta[i].yield, cpu_delta[i].schedule, cpu_delta[i].switch_count,\n           cpu_delta[i].idle, cpu_delta[i].ttwu, cpu_delta[i].local,\n           cpu_delta[i].cpu_time / 1000000, cpu_delta[i].wait_time / 1000000,\n           cpu_delta[i].timeslices);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int parse_cpu_v15(const char *b) {\n    int cpu;\n    if (sscanf(b, \"cpu%d %u %u %u %u %u %u %llu %llu %lu\\n\", &cpu, &tmp.yld_count, &tmp.sched_switch, &tmp.sched_count, &tmp.sched_goidle, &tmp.ttwu_count, &tmp.ttwu_local, &tmp.cpu_time, &tmp.run_delay, &tmp.pcount) != 10) {\n        printf(\"Could not parse %s\\n\", b);\n        return -1;\n    }\n    cpu_delta[cpu].yld_count = tmp.yld_count - cpu_prev[cpu].yld_count;\n    cpu_delta[cpu].sched_switch = tmp.sched_switch - cpu_prev[cpu].sched_switch;\n    cpu_delta[cpu].sched_count = tmp.sched_count - cpu_prev[cpu].sched_count;\n    cpu_delta[cpu].sched_goidle = tmp.sched_goidle - cpu_prev[cpu].sched_goidle;\n    cpu_delta[cpu].ttwu_count = tmp.ttwu_count - cpu_prev[cpu].ttwu_count;\n    cpu_delta[cpu].ttwu_local = tmp.ttwu_local - cpu_prev[cpu].ttwu_local;\n    cpu_delta[cpu].cpu_time = tmp.cpu_time - cpu_prev[cpu].cpu_time;\n    cpu_delta[cpu].run_delay = tmp.run_delay - cpu_prev[cpu].run_delay;\n    cpu_delta[cpu].pcount = tmp.pcount - cpu_prev[cpu].pcount;\n    cpu_prev[cpu] = tmp;\n    return 0;\n}\n","function_prediction":"int parse_cpu_v15_name_conflict(char *line) {\n  int cpu;\n\n  if (__isoc99_sscanf(line, \"cpu%d %u %u %u %u %u %u %llu %llu %lu\\n\", &cpu,\n                      &tmp.user, &tmp.nice, &tmp.system, &tmp.idle, &tmp.iowait,\n                      &tmp.irq, &tmp.softirq, &tmp.steal, &tmp.guest) != 10) {\n    printf(\"Could not parse %s\\n\", line);\n    return -1;\n  }\n\n  cpu_delta[cpu].user = tmp.user - cpu_prev[cpu].user;\n  cpu_delta[cpu].nice = tmp.nice - cpu_prev[cpu].nice;\n  cpu_delta[cpu].system = tmp.system - cpu_prev[cpu].system;\n  cpu_delta[cpu].idle = tmp.idle - cpu_prev[cpu].idle;\n  cpu_delta[cpu].iowait = tmp.iowait - cpu_prev[cpu].iowait;\n  cpu_delta[cpu].irq = tmp.irq - cpu_prev[cpu].irq;\n  cpu_delta[cpu].softirq = tmp.softirq - cpu_prev[cpu].softirq;\n  cpu_delta[cpu].steal = tmp.steal - cpu_prev[cpu].steal;\n  cpu_delta[cpu].guest = tmp.guest - cpu_prev[cpu].guest;\n\n  cpu_prev[cpu] = tmp;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int parse(const char *b) {\n    unsigned int version;\n    unsigned long long ts;\n    if (sscanf(b, \"version %u\\n\", &version) != 1) {\n        printf(\"Could not parse version\\n\");\n        return -1;\n    }\n    switch (version) {\n      case 15:\n        b = next_line(b);\n        if (!b || sscanf(b, \"timestamp %llu\\n\", &ts) != 1) {\n            printf(\"Could not parse timestamp\\n\");\n            return -1;\n        }\n        while (1)\n            {\n                b = next_line(b);\n                if (!b)\n                    break;\n                if (b[0] == 'c') {\n                    if (parse_cpu_v15(b))\n                        return -1;\n                }\n            }\n        break;\n      default:\n        printf(\"Can not handle version %u\\n\", version);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int parse_name_conflict(char *line) {\n  char *next;\n  unsigned int version;\n  unsigned int cpu;\n  unsigned int ret;\n\n  ret = __isoc99_sscanf(line, \"version %u\\n\", &version);\n  if (ret != 1) {\n    printf(\"Could not parse_name_conflict version\\n\");\n    return -1;\n  }\n\n  if (version != 15) {\n    printf(\"Can not handle version %u\\n\", version);\n    return -1;\n  }\n\n  next = next_line(line);\n  if (next == NULL)\n    return -1;\n\n  ret = __isoc99_sscanf(next, \"timestamp %llu\\n\", &tmp.tv_sec);\n  if (ret != 1) {\n    printf(\"Could not parse_name_conflict timestamp\\n\");\n    return -1;\n  }\n\n  while ((next = next_line(next)) != NULL) {\n    if (next[0] == 'c') {\n      ret = parse_name_conflict_cpu_v15(next);\n      if (ret != 0)\n        return -1;\n    }\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":1,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"off_t hash_file_name_conflict(MD5_CTX *ctx, int fd) {\n  char buf[4096];\n  off_t total = 0;\n  ssize_t n;\n\n  while ((n = read(fd, buf, sizeof(buf))) > 0) {\n    MD5Update(ctx, buf, n);\n    total += n;\n  }\n\n  buf[0] = '\\0';\n  MD5Update(ctx, buf, 1);\n\n  return total;\n}","pass":1,"source_file":"C_COMPILE/Malvineous_buildroot-openipcam/package/x11r7/mcookie/mcookie.c"}
{"compilable":0,"function":"char *path_filename_ext(const char *path) {\n    char *fname = __xpg_basename((char *)path);\n    char *dot = strrchr(fname, '.');\n    if (!dot || dot == fname)\n        return (\"\");\n    return (dot);\n}\n","function_prediction":"const char *path_filename_ext_name_conflict(const char *path) {\n  const char *filename = __xpg_basename(path);\n  const char *ext = strrchr(filename, '.');\n\n  if (ext == NULL || ext == filename)\n    return \"\";\n\n  return ext;\n}","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_filename_ext.c"}
{"compilable":0,"function":"int path_isdir(const char *path) {\n    struct stat *sb = calloc(1, sizeof(struct stat));\n    int s = stat(path, sb);\n    if (s == -1) {\n        log_perror(\"stat error\");\n        free(sb);\n        return (-1);\n    }\n    mode_t m = sb->st_mode;\n    free(sb);\n    return (((((m)) & 61440) == (16384)));\n}\n","function_prediction":"int path_isdir_name_conflict(const char *path) {\n  struct stat *st = calloc(1, sizeof(struct stat));\n  int ret;\n\n  ret = stat(path, st);\n  if (ret == -1) {\n    log_perror(\"stat error\");\n    free(st);\n    return -1;\n  }\n\n  ret = (st->st_mode & 0170000) == 0040000;\n  free(st);\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_isdir.c"}
{"compilable":0,"function":"int path_exists(const char *path) {\n    int ret = access(path, 0);\n    if (ret == 0)\n        return (1);\n    return (0);\n}\n","function_prediction":"int path_exists_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_exists.c"}
{"compilable":0,"function":"int log_perror(char *fmt, ...) {\n    perror(\"\");\n    va_list ap;\n    __builtin_va_start(ap, fmt);\n    int ret = _logfp(stderr, \"ERR\", fmt, ap);\n    __builtin_va_end(ap);\n    return (ret);\n}\n","function_prediction":"int log_perror_name_conflict(const char *fmt, ...) {\n  va_list ap;\n  struct _log_args la;\n\n  perror(\"\");\n\n  la.fmt = fmt;\n  la.ap = &ap;\n  la.level = 8;\n  la.errno_flag = '0';\n\n  return _logfp(stderr, \"%s: \", &la);\n}","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/log/log_perror.c"}
{"compilable":0,"function":"int log_warn(char *fmt, ...) {\n    va_list ap;\n    __builtin_va_start(ap, fmt);\n    int ret = _logfp(stderr, \"WARN\", fmt, ap);\n    __builtin_va_end(ap);\n    return (ret);\n}\n","function_prediction":"int log_warn(const char *file, int line, const char *func, const char *fmt,\n             ...) {\n  va_list ap;\n  struct log_info info;\n\n  info.level = '0';\n  info.file = file;\n  info.line = line;\n  info.func = func;\n  info.fmt = fmt;\n  info.ap = &ap;\n\n  return _logfp(stderr, \"\\033[33m\", &info, &ap);\n}","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/log/log_warn.c"}
{"compilable":1,"function":"char *currTime(const char *format) {\n    static char buf[1000];\n    time_t t;\n    size_t s;\n    struct tm *tm;\n    t = time(((void *)0));\n    tm = localtime(&t);\n    if (tm == ((void *)0))\n        return ((void *)0);\n    s = strftime(buf, 1000, (format != ((void *)0)) ? format : \"%c\", tm);\n    return (s == 0) ? ((void *)0) : buf;\n}\n","function_prediction":"char *currTime_name_conflict(const char *format) {\n  static char buf[1000];\n  time_t t = time(NULL);\n  struct tm *tm = localtime(&t);\n  if (tm == NULL)\n    return NULL;\n  if (format == NULL)\n    format = \"%c\";\n  if (strftime(buf, sizeof(buf), format, tm) == 0)\n    return NULL;\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/matianfu_mock-server-for-witness/formatter.c"}
{"compilable":1,"function":"bool isValidMacAddrStr(char *str) {\n    return 1;\n}\n","function_prediction":"int isValidMacAddrStr_name_conflict(char *mac) { return 1; }","pass":1,"source_file":"C_COMPILE/matianfu_mock-server-for-witness/formatter.c"}
{"compilable":0,"function":"size_t addst(size_t x, size_t y) {\n    if ((18446744073709551615UL) - x < y) {\n        fatal(\"integer overflow\");\n    }\n    return x + y;\n}\n","function_prediction":"intptr_t addst_name_conflict(intptr_t a, intptr_t b) {\n  if (b > (intptr_t)~a)\n    fatal(\"integer overflow\");\n  return a + b;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"size_t mulst(size_t x, size_t y) {\n    if (x == 0 || y == 0) {\n        return 0;\n    }\n    if ((18446744073709551615UL) / x < y) {\n        fatal(\"integer overflow\");\n    }\n    return x * y;\n}\n","function_prediction":"size_t mulst_name_conflict(size_t a, size_t b) {\n  if (a == 0 || b == 0)\n    return 0;\n  if (a > (SIZE_MAX - b) / a)\n    fatal(\"integer overflow\");\n  return a * b;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xstrdup(const char *s) {\n    char *result = strdup(s);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  p = strdup(s);\n  if (p == NULL)\n    fatal(\"out of memory\");\n  return p;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xstrndup(const char *s, size_t size) {\n    char *result = strndup(s, size);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"char *xstrndup_name_conflict(const char *s, size_t n) {\n  char *p;\n\n  p = strndup(s, n);\n  if (p == NULL)\n    fatal(\"out of memory\");\n  return p;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int xasprintf(char **s, const char *template, ...) {\n    va_list a;\n    __builtin_va_start(a, template);\n    int result = vasprintf(s, template, a);\n    __builtin_va_end(a);\n    if (result < 0) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"int xasprintf_name_conflict(char **ret, const char *fmt, ...) {\n  va_list ap;\n  int len;\n\n  len = vasprintf(ret, fmt, ap);\n  if (len < 0)\n    fatal(\"out of memory\");\n  return len;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xgetcwd(void) {\n    char *result = getcwd(((void *)0), 0);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"char *xgetcwd_name_conflict(void) {\n  char *p;\n\n  p = getcwd(NULL, 0);\n  if (p == NULL)\n    fatal(\"out of memory\");\n  return p;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool str_starts_with(const char *string, const char *prefix) {\n    const char *string_ptr = string;\n    const char *prefix_ptr = prefix;\n    while (*string_ptr != '\\x00' && *prefix_ptr != '\\x00')\n        {\n            if (*string_ptr != *prefix_ptr) {\n                return 0;\n            }\n            string_ptr++;\n            prefix_ptr++;\n        }\n    if (*string_ptr == '\\x00' && *prefix_ptr != '\\x00') {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"bool str_starts_with_name_conflict(const char *str, const char *prefix) {\n  const char *s = str;\n  const char *p = prefix;\n\n  while (*s && *p) {\n    if (*s != *p)\n      return false;\n    s++;\n    p++;\n  }\n\n  if (*s == '\\0' && *p != '\\0')\n    return false;\n\n  return true;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool str_ends_with(const char *string, const char *suffix) {\n    size_t string_length = strlen(string);\n    size_t suffix_length = strlen(suffix);\n    if (string_length < suffix_length) {\n        return 0;\n    }\n    return strcmp(string + string_length - suffix_length, suffix) == 0;\n}\n","function_prediction":"int str_ends_with_name_conflict(const char *str, const char *suffix) {\n  size_t str_len = strlen(str);\n  size_t suffix_len = strlen(suffix);\n\n  if (str_len < suffix_len)\n    return 0;\n\n  return !strcmp(str + str_len - suffix_len, suffix);\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_path(const char *parent, const char *relative_path) {\n    size_t parent_length = strlen(parent);\n    size_t relative_path_length = strlen(relative_path);\n    size_t result_length = addst(parent_length, relative_path_length);\n    result_length = addst(result_length, 2);\n    char *result = xmalloc(result_length);\n    strcpy(result, parent);\n    result[parent_length] = '/';\n    strcpy(result + parent_length + 1, relative_path);\n    return result;\n}\n","function_prediction":"char *make_path_name_conflict(char *dir, char *file) {\n  size_t dirlen = strlen(dir);\n  size_t filelen = strlen(file);\n  size_t len = addst(dirlen, filelen) + 2;\n  char *path = xmalloc(len);\n  strcpy(path, dir);\n  path[dirlen] = '/';\n  strcpy(path + dirlen + 1, file);\n  return path;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_canonical_path(const char *relative_path) {\n    char *original_directory = xgetcwd();\n    char *base = make_basename(relative_path);\n    char *dir = make_dirname(relative_path);\n    xchdir(dir);\n    char *canonical_dir = xgetcwd();\n    char *result = make_path(canonical_dir, base);\n    free(canonical_dir);\n    free(base);\n    free(dir);\n    xchdir(original_directory);\n    free(original_directory);\n    return result;\n}\n","function_prediction":"char *make_canonical_path_name_conflict(const char *path) {\n  char *cwd = xgetcwd();\n  char *basename = make_basename(path);\n  char *dirname = make_dirname(path);\n  char *new_cwd;\n  char *new_path;\n\n  xchdir(dirname);\n  new_cwd = xgetcwd();\n  new_path = make_path(new_cwd, basename);\n  free(new_cwd);\n  free(basename);\n  free(dirname);\n  xchdir(cwd);\n  free(cwd);\n  return new_path;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_basename(const char *path) {\n    char *copy = xstrdup(path);\n    char *result = xstrdup(__xpg_basename(copy));\n    free(copy);\n    return result;\n}\n","function_prediction":"char *make_basename_name_conflict(const char *path) {\n  char *ret, *tmp;\n\n  tmp = xstrdup(path);\n  ret = xstrdup(__xpg_basename(tmp));\n  free(tmp);\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_dirname(const char *path) {\n    char *copy = xstrdup(path);\n    char *result = xstrdup(dirname(copy));\n    free(copy);\n    return result;\n}\n","function_prediction":"char *make_dirname_name_conflict(const char *path) {\n  char *dir, *ret;\n\n  dir = xstrdup(path);\n  ret = xstrdup(dirname(dir));\n  free(dir);\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int is_same_file(const char *file1, const char *file2) {\n    if (strcmp(file1, file2) == 0) {\n        return 1;\n    }\n    char *canonical1 = make_canonical_path(file1);\n    char *canonical2 = make_canonical_path(file2);\n    int cmp = strcmp(canonical1, canonical2);\n    free(canonical1);\n    free(canonical2);\n    if (cmp == 0) {\n        return 1;\n    }\n    struct stat buf1;\n    if (stat(file1, &buf1) == -1) {\n        if ((*__errno_location()) == 2) {\n            return 0;\n        } else {\n            fatal(\"cannot stat file: %s\", file1);\n        }\n    }\n    struct stat buf2;\n    if (stat(file2, &buf2) == -1) {\n        if ((*__errno_location()) == 2) {\n            return 0;\n        } else {\n            fatal(\"cannot stat file: %s\", file2);\n        }\n    }\n    if (buf1.st_dev == buf2.st_dev && buf1.st_ino == buf2.st_ino) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int is_same_file_name_conflict(const char *path1, const char *path2) {\n  struct stat st1, st2;\n  char *canonical_path1, *canonical_path2;\n  int ret;\n\n  if (!strcmp(path1, path2))\n    return 1;\n\n  canonical_path1 = make_canonical_path(path1);\n  canonical_path2 = make_canonical_path(path2);\n  ret = strcmp(canonical_path1, canonical_path2);\n  free(canonical_path1);\n  free(canonical_path2);\n  if (!ret)\n    return 1;\n\n  if (stat(path1, &st1) == -1) {\n    if (*__errno_location() == 2)\n      return 0;\n    fatal(\"cannot stat file: %s\", path1);\n  }\n  if (stat(path2, &st2) == -1) {\n    if (*__errno_location() == 2)\n      return 0;\n    fatal(\"cannot stat file: %s\", path2);\n  }\n\n  return st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int contains_file(const char *file1, const char *file2) {\n    int result = 0;\n    char *ancestor = make_canonical_path(file1);\n    char *d = make_canonical_path(file2);\n    char *parent = make_dirname(d);\n    while (strcmp(d, parent) != 0)\n        {\n            if (is_same_file(ancestor, parent)) {\n                result = 1;\n                break;\n            }\n            free(d);\n            d = parent;\n            parent = make_dirname(d);\n        }\n    free(d);\n    free(parent);\n    free(ancestor);\n    return result;\n}\n","function_prediction":"int contains_file_name_conflict(const char *file, const char *dir) {\n  int ret = 0;\n  char *file_canon = make_canonical_path(file);\n  char *dir_canon = make_canonical_path(dir);\n  char *parent = make_dirname(dir_canon);\n\n  while (strcmp(dir_canon, parent)) {\n    if (is_same_file(file_canon, parent)) {\n      ret = 1;\n      break;\n    }\n    free(dir_canon);\n    dir_canon = parent;\n    parent = make_dirname(parent);\n  }\n\n  free(dir_canon);\n  free(parent);\n  free(file_canon);\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool directory_is_empty(const char *directory) {\n    bool result = 1;\n    DIR *dir = xopendir(directory);\n    struct dirent *e;\n    while ((e = readdir(dir)) != ((void *)0))\n        {\n            if (strcmp(e->d_name, \".\") != 0 && strcmp(e->d_name, \"..\") != 0) {\n                result = 0;\n                break;\n            }\n        }\n    closedir(dir);\n    return result;\n}\n","function_prediction":"int directory_is_empty_name_conflict(const char *path) {\n  int empty = 1;\n  DIR *dir = xopendir(path);\n  struct dirent *d;\n\n  while ((d = readdir(dir)) != NULL) {\n    if (strcmp(d->d_name, \".\") != 0 && strcmp(d->d_name, \"..\") != 0) {\n      empty = 0;\n      break;\n    }\n  }\n\n  closedir(dir);\n  return empty;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":1,"function":"int verify_values(char **values, char **expected, int n) {\n    int i = 0;\n    while (i < n)\n        {\n            if (0 != strcmp(values[i], expected[i])) {\n                return -1;\n            }\n            i++;\n        }\n    return 0;\n}\n","function_prediction":"int verify_values_name_conflict(char **values, char **expected, int count) {\n  int i;\n\n  for (i = 0; i < count; i++) {\n    if (!strcmp(values[i], expected[i]))\n      continue;\n    return -1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *test_split_string_by_comma_ok() {\n    int rv;\n    char *test_str;\n    char *values[24];\n    test_str = strdup(\"JACK,ENGQVIST,JOHANSSON,89\");\n    rv = _split_string_by_comma(test_str, values, (sizeof values / sizeof (values[0])));\n    do {\n        if (!(4 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return the correct number of values\", \"\\033[0m\");\n            return \"should return the correct number of values\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return the correct number of values\", \"\\033[0m\");\n    } while (0);\n    char *expected[] = {\"JACK\", \"ENGQVIST\", \"JOHANSSON\", \"89\"};\n    do {\n        if (!(0 == verify_values(values, expected, rv))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to split a comma seperated string\", \"\\033[0m\");\n            return \"should be able to split a comma seperated string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to split a comma seperated string\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\",SOME,EMPTY,VALUES,,\");\n    rv = _split_string_by_comma(test_str, values, (sizeof values / sizeof (values[0])));\n    do {\n        if (!(6 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return the correct number of values even when there is empty values (,,)\", \"\\033[0m\");\n            return \"should return the correct number of values even when there is empty values (,,)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return the correct number of values even when there is empty values (,,)\", \"\\033[0m\");\n    } while (0);\n    char *expected2[] = {\"\", \"SOME\", \"EMPTY\", \"VALUES\", \"\", \"\"};\n    do {\n        if (!(0 == verify_values(values, expected2, rv))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to split empty values (,,)\", \"\\033[0m\");\n            return \"should be able to split empty values (,,)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to split empty values (,,)\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    return 0;\n}\n","function_prediction":"char *test_split_string_by_comma_ok_name_conflict() {\n  char *test_string = strdup(\"JACK,ENGQVIST,JOHANSSON,89\");\n  char *values[24];\n  int number_of_values = _split_string_by_comma(test_string, values, 24);\n  do {\n    if (!(number_of_values == 4)) {\n      printf(\"[%s] %s\\n\", \"ok\", \"should return the correct number of values\");\n      return \"should return the correct number of values\";\n    }\n  } while (0);\n  char *expected_values[] = {\"JACK\", \"ENGQVIST\", \"JOHANSSON\", \"89\"};\n  do {\n    if (!(verify_values(values, expected_values, number_of_values) == 0)) {\n      printf(\"[%s] %s\\n\", \"ok\",\n             \"should be able to split a comma seperated string\");\n      return \"should be able to split a comma seperated string\";\n    }\n  } while (0);\n  printf(\"[%s] %s\\n\", \"ok\", \"should be able to split a comma seperated string\");\n\n  free(test_string);\n  test_string = strdup(\",SOME,EMPTY,VALUES,,\");\n  number_of_values = _split_string_by_comma(test_string, values, 24);\n  do {\n    if (!(number_of_values == 6)) {\n      printf(\"[%s] %s\\n\", \"not ok\",\n             \"should return the correct number of values even when there is \"\n             \"empty values (,,)\");\n      return \"should return the correct number of values even when there is \"\n             \"empty values (,,)\";\n    }\n  } while (0);\n  char *expected_values2[] = {\"\", \"SOME\", \"EMPTY\", \"VALUES\", \"\", \"\"};\n  do {\n    if (!(verify_values(values, expected_values2, number_of_values) == 0)) {\n      printf(\"[%s] %s\\n\", \"ok\", \"should be able to split empty values (,,)\");\n      return \"should be able to split empty values (,,)\";\n    }\n  } while (0);\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *test_crop_sentence_ok() {\n    char *rv;\n    char *test_str;\n    test_str = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89*D1\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \"ENGQVIST,JOHANSSON,89\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return a cropped string\", \"\\033[0m\");\n            return \"should return a cropped string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return a cropped string\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \"ENGQVIST,JOHANSSON,89\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return a cropped string without checksum\", \"\\033[0m\");\n            return \"should return a cropped string without checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return a cropped string without checksum\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,,ENGQVIST,,JOHANSSON,,89,,\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \",ENGQVIST,,JOHANSSON,,89,,\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should work with empty values\", \"\\033[0m\");\n            return \"should work with empty values\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should work with empty values\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,,ENGQVIST,,JOHANSSON,,89,,*1D\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \",ENGQVIST,,JOHANSSON,,89,,\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should work with empty values and checksum\", \"\\033[0m\");\n            return \"should work with empty values and checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should work with empty values and checksum\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    return 0;\n}\n","function_prediction":"char *test_crop_sentence_ok_name_conflict() {\n  char *sentence = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89*D1\\r\\n\");\n  char *cropped = _crop_sentence(sentence, strlen(sentence));\n  if (!strcmp(cropped, \"ENGQVIST,JOHANSSON,89\")) {\n    printf(\"%s%s%s\\n\", \"\\x1B[32m\", \"ok\", \"\\x1B[0m\");\n  } else {\n    printf(\"%s%s%s\\n\", \"\\x1B[31m\", \"not ok\", \"\\x1B[0m\");\n    return \"should return a cropped string\";\n  }\n  free(sentence);\n\n  sentence = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89\\r\\n\");\n  cropped = _crop_sentence(sentence, strlen(sentence));\n  if (!strcmp(cropped, \"ENGQVIST,JOHANSSON,89\")) {\n    printf(\"%s%s%s\\n\", \"\\x1B[32m\", \"ok\", \"\\x1B[0m\");\n  } else {\n    printf(\"%s%s%s\\n\", \"\\x1B[31m\", \"not ok\", \"\\x1B[0m\");\n    return \"should return a cropped string without checksum\";\n  }\n  free(sentence);\n\n  sentence = strdup(\"$GPGGA,,ENGQVIST,,JOHANSSON,,89,,\\r\\n\");\n  cropped = _crop_sentence(sentence, strlen(sentence));\n  if (!strcmp(cropped, \",ENGQVIST,,JOHANSSON,,89,,\")) {\n    printf(\"%s%s%s\\n\", \"\\x1B[32m\", \"ok\", \"\\x1B[0m\");\n  } else {\n    printf(\"%s%s%s\\n\", \"\\x1B[","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":1,"function":"static char *test_is_value_set() {\n    int rv;\n    rv = _is_value_set(\"JACK\");\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when there is a value\", \"\\033[0m\");\n            return \"should return 0 when there is a value\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when there is a value\", \"\\033[0m\");\n    } while (0);\n    rv = _is_value_set(\"\");\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when the string is empty\", \"\\033[0m\");\n            return \"should return -1 when the string is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when the string is empty\", \"\\033[0m\");\n    } while (0);\n    rv = _is_value_set(((void *)0));\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on NULL\", \"\\033[0m\");\n            return \"should return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"char *test_is_value_set_name_conflict() {\n  do {\n    if (!(_is_value_set(\"foo\") == 0)) {\n      printf(\"%s%s%s\\n\",\n             \"\\x1B[31m\"\n             \"FAIL\"\n             \"\\x1B[0m\",\n             \" - \", \"should return 0 when there is a value\");\n      return \"should return 0 when there is a value\";\n    } else {\n      printf(\"%s%s%s\\n\",\n             \"\\x1B[32m\"\n             \"PASS\"\n             \"\\x1B[0m\",\n             \" - \", \"should return 0 when there is a value\");\n    }\n  } while (0);\n  do {\n    if (!(_is_value_set(\"\") == -1)) {\n      printf(\"%s%s%s\\n\",\n             \"\\x1B[31m\"\n             \"FAIL\"\n             \"\\x1B[0m\",\n             \" - \", \"should return -1 when the string is empty\");\n      return \"should return -1 when the string is empty\";\n    } else {\n      printf(\"%s%s%s\\n\",\n             \"\\x1B[32m\"\n             \"PASS\"\n             \"\\x1B[0m\",\n             \" - \", \"should return -1 when the string is empty\");\n    }\n  } while (0);\n  do {\n    if (!(_is_value_set(NULL) == -1)) {\n      printf(\"%s%s%s\\n\",\n             \"\\x1B[31m\"\n             \"FAIL\"\n             \"\\x1B[0m\",\n             \" - \", \"should return -1 on NULL\");\n      return \"should return -1 on NULL\";\n    } else {\n      printf(\"%s%s%s\\n\",\n             \"\\x1B[32m\"\n             \"PASS\"\n             \"\\x1B[0m\",\n             \" - \", \"should return -1 on NULL\");\n    }\n  } while (0);\n}","pass":1,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_split_string_by_comma()\", \"\\033[0m\");\n    do {\n        char *message = test_split_string_by_comma_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_crop_sentence()\", \"\\033[0m\");\n    do {\n        char *message = test_crop_sentence_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_is_value_set()\", \"\\033[0m\");\n    do {\n        char *message = test_is_value_set();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"char *all_tests_name_conflict() {\n  do {\n    printf(\"..%s\\n\",\n           \"\"_split_string_by_comma() \"_\"\n                                      \"\"_crop_sentence() \"_\"\n                                                         \"\"_is_value_set() \"\");\n    char *message = test_split_string_by_comma_ok();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"..%s\\n\",\n           \"\"_split_string_by_comma() \"_\"\n                                      \"\"_crop_sentence() \"_\"\n                                                         \"\"_is_value_set() \"\");\n    char *message = test_crop_sentence_ok();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"..%s\\n\",\n           \"\"_split_string_by_comma() \"_\"\n                                      \"\"_crop_sentence() \"_\"\n                                                         \"\"_is_value_set() \"\");\n    char *message = test_is_value_set();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":1,"function":"static int _get_so_files(const char *path, char **files) {\n    int j, i = 0;\n    size_t len;\n    char *name;\n    DIR *d = ((void *)0);\n    struct dirent *dir;\n    d = opendir(path);\n    if (((void *)0) == d) {\n        return -1;\n    }\n    while (((void *)0) != (dir = readdir(d)))\n        {\n            if ('.' == dir->d_name[0]) {\n                continue;\n            }\n            len = strlen(dir->d_name);\n            if (len < 3) {\n                continue;\n            }\n            if (0 != strncmp(dir->d_name + len - 3, \".so\", 3)) {\n                continue;\n            }\n            name = malloc(255);\n            if (((void *)0) == name) {\n                goto fail;\n            }\n            strcpy(name, path);\n            strcat(name, dir->d_name);\n            files[i++] = name;\n        }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return i;\n  fail:\n    for (j = 0; j < i; i++) {\n        free(files[j]);\n    }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return -1;\n}\n","function_prediction":"int _get_so_files_name_conflict(char *path, char **so_files) {\n  int i = 0;\n  DIR *dir;\n  struct dirent *ent;\n\n  if ((dir = opendir(path)) != NULL) {\n    while ((ent = readdir(dir)) != NULL) {\n      if (ent->d_name[0] == '.')\n        continue;\n\n      size_t len = strlen(ent->d_name);\n      if (len < 3)\n        continue;\n\n      if (!strncmp(ent->d_name + len - 3, \".so\", 3)) {\n        char *so_file = malloc(255);\n        if (so_file == NULL) {\n          for (; i > 0; i++)\n            free(so_files[i]);\n          if (dir != NULL)\n            closedir(dir);\n          return -1;\n        }\n        strcpy(so_file, path);\n        strcat(so_file, ent->d_name);\n        so_files[i] = so_file;\n        i++;\n      }\n    }\n    if (dir != NULL)\n      closedir(dir);\n  } else {\n    i = -1;\n  }\n\n  return i;\n}","pass":1,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":1,"function":"int nmea_load_parsers() {\n    int i;\n    char *files[255];\n    char *parser_path;\n    nmea_parser_module_s *parser;\n    parser_path = getenv(\"NMEA_PARSER_PATH\");\n    if (((void *)0) == parser_path) {\n        parser_path = \"/usr/lib/nmea/\";\n    }\n    n_parsers = _get_so_files(parser_path, files);\n    if (1 > n_parsers) {\n        return -1;\n    }\n    parsers = malloc((sizeof(nmea_parser_module_s *)) * n_parsers);\n    if (((void *)0) == parsers) {\n        return -1;\n    }\n    memset(parsers, 0, (sizeof(nmea_parser_module_s *)) * n_parsers);\n    i = n_parsers;\n    while (i-- > 0)\n        {\n            parser = nmea_init_parser(files[i]);\n            free(files[i]);\n            if (((void *)0) == parser) {\n                return -1;\n            }\n            parsers[i] = parser;\n        }\n    return n_parsers;\n}\n","function_prediction":"int nmea_load_parsers_name_conflict(void) {\n  char *path;\n  char *so_files[255];\n  int i;\n  struct nmea_parser *parser;\n\n  path = getenv(\"NMEA_PARSER_PATH\");\n  if (path == NULL)\n    path = \"/usr/lib/nmea/\";\n\n  n_parsers = _get_so_files(path, so_files);\n  if (n_parsers <= 0)\n    return -1;\n\n  parsers = malloc(n_parsers * sizeof(struct nmea_parser *));\n  if (parsers == NULL)\n    return -1;\n\n  memset(parsers, 0, n_parsers * sizeof(struct nmea_parser *));\n\n  for (i = n_parsers; i > 0; i--) {\n    parser = nmea_init_parser(so_files[i - 1]);\n    free(so_files[i - 1]);\n    if (parser == NULL)\n      return -1;\n    parsers[i - 1] = parser;\n  }\n\n  return n_parsers;\n}","pass":1,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"static char *test_position_parse_ok() {\n    int res;\n    char *s;\n    nmea_position *pos = malloc(sizeof(nmea_position));\n    s = strdup(\"12311.12\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(123 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(11.119999999999999 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"2621.44\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(26 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(21.440000000000001 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"901.01\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1.01 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"901.\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1. == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    free(pos);\n    return 0;\n}\n","function_prediction":"char *test_position_parse_ok_name_conflict() {\n  nmeaPOS *pos = malloc(sizeof(nmeaPOS));\n  char *str = strdup(\"12311.12\");\n  do {\n    if (!(0 == nmea_position_parse(str, pos))) {\n      printf(\"%s:%s %s\\n\", \"..\", \"should return return 0 when successfull\",\n             \"FAIL\");\n      return \"should return return 0 when successfull\";\n    } else\n      printf(\"%s:%s %s\\n\", \"..\", \"should return return 0 when successfull\",\n             \"OK\");\n  } while (0);\n  do {\n    if (!(123 == pos->degrees)) {\n      printf(\"%s:%s %s\\n\", \"..\", \"pos->degrees should be 123\", \"FAIL\");\n      return \"pos->degrees should be 123\";\n    } else\n      printf(\"%s:%s %s\\n\", \"..\", \"pos->degrees should be 123\", \"OK\");\n  } while (0);\n  do {\n    if (!(11.12 == pos->minutes)) {\n      printf(\"%s:%s %s\\n\", \"..\", \"pos->minutes should be 11.12\", \"FAIL\");\n      return \"pos->minutes should be 11.12\";\n    } else\n      printf(\"%s:%s %s\\n\", \"..\", \"pos->minutes should be 11.12\", \"OK\");\n  } while (0);\n  free(str);\n  str = strdup(\"2621.44\");\n  do {\n    if (!(0 == nmea_position_parse(str, pos))) {\n      printf(\"%s:%s %s\\n\", \"..\", \"should return return 0 when successfull\",\n             \"FAIL\");\n      return \"should return return 0 when successfull\";\n    } else\n      printf(\"%s:%s %s\\n\", \"..\", \"should return return 0 when successfull\",\n             \"OK\");\n  } while (0);\n  do {\n    if (!(123 == pos->degrees)) { printf(\"%s:%s %s\\n\", \"..\", \"pos->degrees should be 1","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_position_parse_fail() {\n    int res;\n    char *s;\n    nmea_position *pos = malloc(sizeof(nmea_position));\n    s = strdup(\"123\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on failure\", \"\\033[0m\");\n            return \"should return return -1 on failure\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on failure\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on empty string\", \"\\033[0m\");\n            return \"should return return -1 on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on empty string\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    res = nmea_position_parse(((void *)0), pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on NULL\", \"\\033[0m\");\n            return \"should return return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    free(pos);\n    return 0;\n}\n","function_prediction":"char *test_position_parse_fail_name_conflict() {\n  nmeaPOS *pos = malloc(sizeof(nmeaPOS));\n  char *sentence = strdup(\"123\");\n  do {\n    if (!(nmea_position_parse(sentence, pos) == -1)) {\n      printf(\"%s ...FAILED\\n\", \"should return return -1 on failure\");\n      return \"should return return -1 on failure\";\n    }\n  } while (0);\n  free(sentence);\n  sentence = strdup(\"\");\n  do {\n    if (!(nmea_position_parse(sentence, pos) == -1)) {\n      printf(\"%s ...FAILED\\n\", \"should return return -1 on empty string\");\n      return \"should return return -1 on empty string\";\n    }\n  } while (0);\n  free(sentence);\n  do {\n    if (!(nmea_position_parse(NULL, pos) == -1)) {\n      printf(\"%s ...PASSED\\n\", \"should return return -1 on NULL\");\n    } else {\n      printf(\"%s ...FAILED\\n\", \"should return return -1 on NULL\");\n      return \"should return return -1 on NULL\";\n    }\n  } while (0);\n  free(pos);\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_cardinal_dir_parse_ok() {\n    nmea_cardinal_t card;\n    card = nmea_cardinal_direction_parse(\"N\");\n    do {\n        if (!((nmea_cardinal_t)'N' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"E\");\n    do {\n        if (!((nmea_cardinal_t)'E' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"S\");\n    do {\n        if (!((nmea_cardinal_t)'S' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"W\");\n    do {\n        if (!((nmea_cardinal_t)'W' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"const char *test_cardinal_dir_parse_ok_name_conflict() {\n  do {\n    if (!(nmea_cardinal_direction_parse(\"N\") == 'N')) {\n      printf(\"\\x1B[31m\"\n             \" %s: \"\n             \"\\x1B[0m\"\n             \"\\x1B[1m\"\n             \"%s\"\n             \"\\x1B[0m\"\n             \"\\n\",\n             \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\", \"failed\");\n      return \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\";\n    } else {\n      printf(\"\\x1B[32m\"\n             \" %s: \"\n             \"\\x1B[0m\"\n             \"\\x1B[1m\"\n             \"%s\"\n             \"\\x1B[0m\"\n             \"\\n\",\n             \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\", \"passed\");\n    }\n  } while (0);\n  do {\n    if (!(nmea_cardinal_direction_parse(\"E\") == 'E')) {\n      printf(\"\\x1B[31m\"\n             \" %s: \"\n             \"\\x1B[0m\"\n             \"\\x1B[1m\"\n             \"%s\"\n             \"\\x1B[0m\"\n             \"\\n\",\n             \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\", \"failed\");\n      return \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\";\n    } else {\n      printf(\"\\x1B[32m\"\n             \" %s: \"\n             \"\\x1B[0m\"\n             \"\\x1B[1m\"\n             \"%s\"\n             \"\\x1B[0m\"\n             \"\\n\",\n             \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\", \"passed\");\n    }\n  } while (0);\n  do {\n    if (!(nmea_cardinal_direction_parse(\"S\") == 'S')) {\n      printf(\"\\x1B[31m\"\n             \" %s: \"\n             \"\\x1B[0m\"\n             \"\\x1B[1m\"\n             \"%s\"\n             \"\\x1B[0m\"\n             \"\\n\",\n             \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\", \"failed\");\n      return \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\";\n    } else { printf(\"\\x","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_cardinal_dir_parse_fail() {\n    nmea_cardinal_t card;\n    card = nmea_cardinal_direction_parse(\"\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on empty string\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on empty string\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(((void *)0));\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on NULL\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on NULL\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"J\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"n\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"const char *test_cardinal_dir_parse_fail_name_conflict() {\n  do {\n    if (!((nmea_cardinal_direction_parse(\"\") == NMEA_CARDINAL_UNKNOWN))) {\n      printf(\"\\x1B[31m\"\n             \"test_cardinal_dir_parse_fail_name_conflict\"\n             \": \"\n             \"\\x1B[0m\"\n             \"%s\\n\",\n             \"should return NMEA_CARDINAL_UNKNOWN on empty string\");\n      return \"should return NMEA_CARDINAL_UNKNOWN on empty string\";\n    } else\n      printf(\"\\x1B[32m\"\n             \"test_cardinal_dir_parse_fail_name_conflict\"\n             \": \"\n             \"\\x1B[0m\"\n             \"%s\\n\",\n             \"should return NMEA_CARDINAL_UNKNOWN on empty string\");\n  } while (0);\n  do {\n    if (!((nmea_cardinal_direction_parse(NULL) == NMEA_CARDINAL_UNKNOWN))) {\n      printf(\"\\x1B[31m\"\n             \"test_cardinal_dir_parse_fail_name_conflict\"\n             \": \"\n             \"\\x1B[0m\"\n             \"%s\\n\",\n             \"should return NMEA_CARDINAL_UNKNOWN on NULL\");\n      return \"should return NMEA_CARDINAL_UNKNOWN on NULL\";\n    } else\n      printf(\"\\x1B[32m\"\n             \"test_cardinal_dir_parse_fail_name_conflict\"\n             \": \"\n             \"\\x1B[0m\"\n             \"%s\\n\",\n             \"should return NMEA_CARDINAL_UNKNOWN on NULL\");\n  } while (0);\n  do {\n    if (!((nmea_cardinal_direction_parse(\"J\") == NMEA_CARDINAL_UNKNOWN))) {\n      printf(\"\\x1B[31m\"\n             \"test_cardinal_dir_parse_fail_name_conflict\"\n             \": \"\n             \"\\x1B[0m\"\n             \"%s\\n\",\n             \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\");\n      return \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\";\n    } else printf(\"\\x1B[32m\" \"test_cardinal_dir_parse_fail_name_conflict\"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_time_parse_ok() {\n    int rv;\n    struct tm t;\n    rv = nmea_time_parse(\"171521\", &t);\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 on success\", \"\\033[0m\");\n            return \"should return 0 on success\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 on success\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(21 == t.tm_sec)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_sec should be 21\", \"\\033[0m\");\n            return \"t.tm_sec should be 21\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_sec should be 21\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(15 == t.tm_min)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_min should be 15\", \"\\033[0m\");\n            return \"t.tm_min should be 15\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_min should be 15\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(17 == t.tm_hour)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_hour should be 17\", \"\\033[0m\");\n            return \"t.tm_hour should be 17\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_hour should be 17\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"090801\", &t);\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 on success\", \"\\033[0m\");\n            return \"should return 0 on success\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 on success\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1 == t.tm_sec)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_sec should be 1\", \"\\033[0m\");\n            return \"t.tm_sec should be 1\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_sec should be 1\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(8 == t.tm_min)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_min should be 8\", \"\\033[0m\");\n            return \"t.tm_min should be 8\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_min should be 8\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == t.tm_hour)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_hour should be 9\", \"\\033[0m\");\n            return \"t.tm_hour should be 9\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_hour should be 9\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"const char *test_time_parse_ok_name_conflict() {\n  struct tm t;\n  do {\n    int __retres = nmea_time_parse(\"171521\", &t);\n    if (__retres != 0) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"should return 0 on success\");\n      return \"should return 0 on success\";\n    }\n  } while (0);\n  do {\n    if (t.tm_sec != 21) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"t.tm_sec should be 21\");\n      return \"t.tm_sec should be 21\";\n    } else {\n      printf(\"%s: %s\\n\", \"PASS\", \"t.tm_sec should be 21\");\n    }\n  } while (0);\n  do {\n    if (t.tm_min != 15) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"t.tm_min should be 15\");\n      return \"t.tm_min should be 15\";\n    } else {\n      printf(\"%s: %s\\n\", \"PASS\", \"t.tm_min should be 15\");\n    }\n  } while (0);\n  do {\n    if (t.tm_hour != 17) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"t.tm_hour should be 17\");\n      return \"t.tm_hour should be 17\";\n    } else {\n      printf(\"%s: %s\\n\", \"PASS\", \"t.tm_hour should be 17\");\n    }\n  } while (0);\n\n  do {\n    int __retres = nmea_time_parse(\"090801\", &t);\n    if (__retres != 0) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"should return 0 on success\");\n      return \"should return 0 on success\";\n    }\n  } while (0);\n  do {\n    if (t.tm_sec != 1) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"t.tm_sec should be 1\");\n      return \"t.tm_sec should be 1\";\n    } else {\n      printf(\"%s: %s\\n\", \"PASS\", \"t.tm_sec should be 1\");\n    } } while (","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_time_parse_fail() {\n    int rv;\n    struct tm t;\n    rv = nmea_time_parse(\"240000\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when hours is over 23\", \"\\033[0m\");\n            return \"should return -1 when hours is over 23\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when hours is over 23\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"006000\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when minutes is over 59\", \"\\033[0m\");\n            return \"should return -1 when minutes is over 59\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when minutes is over 59\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"000062\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when seconds is over 59\", \"\\033[0m\");\n            return \"should return -1 when seconds is over 59\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when seconds is over 59\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"2345\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on too short string\", \"\\033[0m\");\n            return \"should return -1 on too short string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on too short string\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"2345XX\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on invalid characters\", \"\\033[0m\");\n            return \"should return -1 on invalid characters\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on invalid characters\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on empty string\", \"\\033[0m\");\n            return \"should return -1 on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on empty string\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(((void *)0), &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on NULL\", \"\\033[0m\");\n            return \"should return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"const char *test_time_parse_fail_name_conflict() {\n  struct nmea_time time;\n\n  do {\n    if (-1 != nmea_time_parse(\"240000\", &time)) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"should return -1 when hours is over 23\");\n      return \"should return -1 when hours is over 23\";\n    }\n  } while (0);\n  do {\n    if (-1 != nmea_time_parse(\"006000\", &time)) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"should return -1 when minutes is over 59\");\n      return \"should return -1 when minutes is over 59\";\n    }\n  } while (0);\n  do {\n    if (-1 != nmea_time_parse(\"000062\", &time)) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"should return -1 when seconds is over 59\");\n      return \"should return -1 when seconds is over 59\";\n    }\n  } while (0);\n  do {\n    if (-1 != nmea_time_parse(\"2345\", &time)) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"should return -1 on too short string\");\n      return \"should return -1 on too short string\";\n    }\n  } while (0);\n  do {\n    if (-1 != nmea_time_parse(\"2345XX\", &time)) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"should return -1 on invalid characters\");\n      return \"should return -1 on invalid characters\";\n    }\n  } while (0);\n  do {\n    if (-1 != nmea_time_parse(\"\", &time)) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"should return -1 on empty string\");\n      return \"should return -1 on empty string\";\n    }\n  } while (0);\n  do {\n    if (-1 != nmea_time_parse(NULL, &time)) {\n      printf(\"%s: %s\\n\", \"FAIL\", \"should return -1 on NULL\");\n      return \"should return -1 on NULL\";\n    }\n  } while (0);\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":1,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_position_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_position_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_position_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_cardinal_dir_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_cardinal_dir_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_cardinal_dir_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_time_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_time_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_time_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"char *all_tests_name_conflict() {\n  do {\n    printf(\"..%s\\n\", \"nmea_position_parse()\");\n    char *message = test_position_parse_ok();\n    if (message)\n      return message;\n    tests_run++;\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_position_parse()\");\n    char *message = test_position_parse_fail();\n    if (message)\n      return message;\n    tests_run++;\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_cardinal_dir_parse()\");\n    char *message = test_cardinal_dir_parse_ok();\n    if (message)\n      return message;\n    tests_run++;\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_cardinal_dir_parse()\");\n    char *message = test_cardinal_dir_parse_fail();\n    if (message)\n      return message;\n    tests_run++;\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_time_parse()\");\n    char *message = test_time_parse_ok();\n    if (message)\n      return message;\n    tests_run++;\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_time_parse()\");\n    char *message = test_time_parse_fail();\n    if (message)\n      return message;\n    tests_run++;\n  } while (0);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"nmea_cardinal_t nmea_cardinal_direction_parse(char *s) {\n    if (((void *)0) == s || '\\x00' == *s) {\n        return (nmea_cardinal_t)'\\x00';\n    }\n    switch (*s) {\n      case (nmea_cardinal_t)'N':\n        return (nmea_cardinal_t)'N';\n      case (nmea_cardinal_t)'E':\n        return (nmea_cardinal_t)'E';\n      case (nmea_cardinal_t)'S':\n        return (nmea_cardinal_t)'S';\n      case (nmea_cardinal_t)'W':\n        return (nmea_cardinal_t)'W';\n      default:\n        break;\n    }\n    return (nmea_cardinal_t)'\\x00';\n}\n","function_prediction":"nmea_cardinal_direction_t nmea_cardinal_direction_parse_name_conflict(const char *str) {\n  if (!str || !*str)\n    return 0;\n\n  switch (*str) {\n  case 'N':\n    return 'N';\n  case 'E':\n    return 'E';\n  case 'S':\n    return 'S';\n  case 'W':\n    return 'W';\n  default:\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/parsers/parse.c"}
{"compilable":0,"function":"static char *test_get_type_ok() {\n    char *sentence;\n    nmea_t res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_GPGLL == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct type (GPGLL)\", \"\\033[0m\");\n            return \"should return correct type (GPGLL)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct type (GPGLL)\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GPGGA,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_GPGGA == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct type (GPGGA)\", \"\\033[0m\");\n            return \"should return correct type (GPGGA)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct type (GPGGA)\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_get_type_ok_name_conflict() {\n  char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n  if (nmea_get_type(sentence) != 2) {\n    printf(\"\\033[31m\"\n           \"%s\"\n           \" %s\"\n           \"\\033[0m\"\n           \"\\n\",\n           \"✗\", \"should return correct type (GPGLL)\");\n    return \"should return correct type (GPGLL)\";\n  }\n  printf(\"\\033[32m\"\n         \"%s\"\n         \" %s\"\n         \"\\033[0m\"\n         \"\\n\",\n         \"✓\", \"should return correct type (GPGLL)\");\n  free(sentence);\n\n  sentence = strdup(\"$GPGGA,4916.45,N,12311.12,W,225444,A\\r\\n\");\n  if (nmea_get_type(sentence) != 1) {\n    printf(\"\\033[31m\"\n           \"%s\"\n           \" %s\"\n           \"\\033[0m\"\n           \"\\n\",\n           \"✗\", \"should return correct type (GPGGA)\");\n    return \"should return correct type (GPGGA)\";\n  }\n  printf(\"\\033[32m\"\n         \"%s\"\n         \" %s\"\n         \"\\033[0m\"\n         \"\\n\",\n         \"✓\", \"should return correct type (GPGGA)\");\n  free(sentence);\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_type_unknown() {\n    char *sentence;\n    nmea_t res;\n    sentence = strdup(\"THISISWRONG\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n            return \"should return NMEA_UNKNOWN on unknown sentence type\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$UNKNOWN\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n            return \"should return NMEA_UNKNOWN on unknown sentence type\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return nmea_unknown on empty sentence\", \"\\033[0m\");\n            return \"should return nmea_unknown on empty sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return nmea_unknown on empty sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_get_type_unknown_name_conflict() {\n  char *sentence = strdup(\"THISISWRONG\");\n  do {\n    if (!(nmea_get_type(sentence) == 0)) {\n      printf(\"%s: %s %s\\n\", \"fail\",\n             \"should return NMEA_UNKNOWN on unknown sentence type\", \"\");\n      free(sentence);\n      return \"should return NMEA_UNKNOWN on unknown sentence type\";\n    } else\n      printf(\"%s: %s %s\\n\", \"pass\",\n             \"should return NMEA_UNKNOWN on unknown sentence type\", \"\");\n  } while (0);\n  free(sentence);\n\n  sentence = strdup(\"$UNKNOWN\");\n  do {\n    if (!(nmea_get_type(sentence) == 0)) {\n      printf(\"%s: %s %s\\n\", \"fail\",\n             \"should return NMEA_UNKNOWN on unknown sentence type\", \"\");\n      free(sentence);\n      return \"should return NMEA_UNKNOWN on unknown sentence type\";\n    } else\n      printf(\"%s: %s %s\\n\", \"pass\",\n             \"should return NMEA_UNKNOWN on unknown sentence type\", \"\");\n  } while (0);\n  free(sentence);\n\n  sentence = strdup(\"\");\n  do {\n    if (!(nmea_get_type(sentence) == 0)) {\n      printf(\"%s: %s %s\\n\", \"fail\",\n             \"should return nmea_unknown on empty sentence\", \"\");\n      free(sentence);\n      return \"should return nmea_unknown on empty sentence\";\n    } else\n      printf(\"%s: %s %s\\n\", \"pass\",\n             \"should return nmea_unknown on empty sentence\", \"\");\n  } while (0);\n  free(sentence);\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_checksum_with_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    uint8_t res = nmea_get_checksum(sentence);\n    do {\n        if (!(29 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct checksum\", \"\\033[0m\");\n            return \"should return correct checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_get_checksum_with_crc_name_conflict() {\n  char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n  char checksum = nmea_get_checksum(sentence);\n  if (checksum != 'd') {\n    printf(\"\\033[31m%s\\033[0m\\n\", \"should return correct checksum\");\n    return \"should return correct checksum\";\n  }\n  printf(\"\\033[32m%s\\033[0m\\n\", \"should return correct checksum\");\n  free(sentence);\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_checksum_without_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,\\r\\n\");\n    uint8_t res = nmea_get_checksum(sentence);\n    do {\n        if (!(29 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct checksum\", \"\\033[0m\");\n            return \"should return correct checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_get_checksum_without_crc_name_conflict() {\n  char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,\\r\\n\");\n  char checksum = nmea_get_checksum(sentence);\n  if (checksum != '}') {\n    printf(\"\\033[31m%s\\033[0m %s\\n\", \"[FAIL]\",\n           \"should return correct checksum\");\n    return \"should return correct checksum\";\n  }\n  printf(\"\\033[32m%s\\033[0m %s\\n\", \"[PASS]\", \"should return correct checksum\");\n  free(sentence);\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_has_checksum_yes() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*1D\\r\\n\");\n    int res = nmea_has_checksum(sentence, strlen(sentence));\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence has a checksum\", \"\\033[0m\");\n            return \"should return 0 when sentence has a checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence has a checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_has_checksum_yes_name_conflict() {\n  char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*1D\\r\\n\");\n  size_t len = strlen(sentence);\n  if (!nmea_has_checksum(sentence, len)) {\n    printf(\"%s: %s\\n\", \"✓\", \"should return 0 when sentence has a checksum\");\n    free(sentence);\n    return NULL;\n  }\n  printf(\"%s: %s\\n\", \"✗\", \"should return 0 when sentence has a checksum\");\n  return \"should return 0 when sentence has a checksum\";\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_has_checksum_no() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_has_checksum(sentence, strlen(sentence));\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence does not have a checksum\", \"\\033[0m\");\n            return \"should return -1 when sentence does not have a checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence does not have a checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_has_checksum_no_name_conflict() {\n  char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n  size_t len = strlen(sentence);\n  int result = nmea_has_checksum(sentence, len);\n  if (result == -1) {\n    printf(\"%s: %s %s\\n\", \"✓\",\n           \"should return -1 when sentence does not have a checksum\", \"✓\");\n    free(sentence);\n    return NULL;\n  } else {\n    printf(\"%s: %s %s\\n\", \"✗\",\n           \"should return -1 when sentence does not have a checksum\", \"✗\");\n    return \"should return -1 when sentence does not have a checksum\";\n  }\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_ok_with_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n            return \"should return 0 when sentence is valid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_validate_ok_with_crc_name_conflict() {\n  char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n  size_t len = strlen(sentence);\n  int result = nmea_validate(sentence, len, 1);\n  if (result != 0) {\n    printf(\"\\033[31m\"\n           \"✗ %s\\n\"\n           \"\\033[0m\",\n           \"should return 0 when sentence is valid\");\n    return \"should return 0 when sentence is valid\";\n  }\n  printf(\"\\033[32m\"\n         \"✓ %s\\n\"\n         \"\\033[0m\",\n         \"should return 0 when sentence is valid\");\n  free(sentence);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_ok_without_crc() {\n    char *sentence;\n    int res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n            return \"should return 0 when sentence is valid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*FF\\r\\n\");\n    res = nmea_validate(sentence, strlen(sentence), 0);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when check_checksum is 0 and crc is invalid\", \"\\033[0m\");\n            return \"should return 0 when check_checksum is 0 and crc is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when check_checksum is 0 and crc is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_validate_ok_without_crc_name_conflict() {\n  char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n  if (!(!nmea_validate(sentence, strlen(sentence), 1))) {\n    printf(\"%s: %s %s\\n\", \"TEST\", \"should return 0 when sentence is valid\",\n           \"FAIL\");\n    return \"should return 0 when sentence is valid\";\n  };\n  printf(\"%s: %s %s\\n\", \"TEST\", \"should return 0 when sentence is valid\", \"OK\");\n  free(sentence);\n\n  sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*FF\\r\\n\");\n  if (!(!nmea_validate(sentence, strlen(sentence), 0))) {\n    printf(\"%s: %s %s\\n\", \"TEST\",\n           \"should return 0 when check_checksum is 0 and crc is invalid\",\n           \"FAIL\");\n    return \"should return 0 when check_checksum is 0 and crc is invalid\";\n  };\n  printf(\"%s: %s %s\\n\", \"TEST\",\n         \"should return 0 when check_checksum is 0 and crc is invalid\", \"OK\");\n  free(sentence);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_type() {\n    char *sentence = strdup(\"$GPgll,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence type is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence type is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence type is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_validate_fail_type_name_conflict() {\n  char *sentence = strdup(\"$GPgll,4916.45,N,12311.12,W,225444,A\\r\\n\");\n  int len = strlen(sentence);\n  int result = nmea_validate(sentence, len, 1);\n  if (result == -1) {\n    printf(\"%s ... %s\\n\",\n           \"\\x1B[1m\\x1B[32m\"\n           \"ok\"\n           \"\\x1B[0m\",\n           \"should return -1 when sentence type is invalid\");\n    free(sentence);\n    return 0;\n  } else {\n    printf(\"%s ... %s\\n\",\n           \"\\x1B[1m\\x1B[31m\"\n           \"not ok\"\n           \"\\x1B[0m\",\n           \"should return -1 when sentence type is invalid\");\n    return \"should return -1 when sentence type is invalid\";\n  }\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_start() {\n    char *sentence = strdup(\"\\302\\243GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence start is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence start is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence start is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_validate_fail_start_name_conflict() {\n  char *sentence =\n      strdup(\"$GPRMC,220516,A,5133.82,N,00042.24,W,000.0,0.0,130691,0.0,E*62\");\n  int result = nmea_validate(sentence, strlen(sentence), 1);\n  if (result == -1) {\n    printf(\"\\033[32m\"\n           \"✓\"\n           \"\\033[0m\"\n           \" %s\\n\",\n           \"should return -1 when sentence start is invalid\");\n    free(sentence);\n    return NULL;\n  } else {\n    printf(\"\\033[31m\"\n           \"✗\"\n           \"\\033[0m\"\n           \" %s\\n\",\n           \"should return -1 when sentence start is invalid\");\n    return \"should return -1 when sentence start is invalid\";\n  }\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_end() {\n    char *sentence;\n    int res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence ending is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence ending is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence ending is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GP\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence is too short\", \"\\033[0m\");\n            return \"should return -1 when sentence is too short\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence is too short\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_validate_fail_end_name_conflict() {\n  char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\");\n  if (nmea_validate(sentence, strlen(sentence), 1) != -1) {\n    printf(\"\\033[31m%s\\033[0m %s\\n\", \"✗\",\n           \"should return -1 when sentence ending is invalid\");\n    free(sentence);\n    return \"should return -1 when sentence ending is invalid\";\n  }\n  printf(\"\\033[32m%s\\033[0m %s\\n\", \"✓\",\n         \"should return -1 when sentence ending is invalid\");\n  free(sentence);\n\n  sentence = strdup(\"$GP\");\n  if (nmea_validate(sentence, strlen(sentence), 1) != -1) {\n    printf(\"\\033[31m%s\\033[0m %s\\n\", \"✗\",\n           \"should return -1 when sentence is too short\");\n    free(sentence);\n    return \"should return -1 when sentence is too short\";\n  }\n  printf(\"\\033[32m%s\\033[0m %s\\n\", \"✓\",\n         \"should return -1 when sentence is too short\");\n  free(sentence);\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_empty() {\n    char *sentence = strdup(\"\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence is empty\", \"\\033[0m\");\n            return \"should return -1 when sentence is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence is empty\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"char *test_validate_fail_empty_name_conflict() {\n  char *sentence = strdup(\"\");\n  int result = nmea_validate(sentence, strlen(sentence), true);\n  if (result == -1) {\n    printf(\"\\033[32m[PASS]\\033[0m %s %s\\n\",\n           \"should return -1 when sentence is empty\", \"\\xF0\\x9F\\x94\\x94\");\n    free(sentence);\n    return NULL;\n  } else {\n    printf(\"\\033[31m[FAIL]\\033[0m %s %s\\n\",\n           \"should return -1 when sentence is empty\", \"\\xF0\\x9F\\x94\\x94\");\n    return \"should return -1 when sentence is empty\";\n  }\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_ok() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) != res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n            return \"should be able to parse a GPGGA sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 0);\n    do {\n        if (!(((void *)0) != res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n            return \"should be able to parse a GPGGA sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"char *test_parse_ok_name_conflict() {\n  char *sentence = strdup(\n      \"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n  size_t len = strlen(sentence);\n  struct nmea_sentence *parsed = nmea_parse(sentence, len, 1);\n  if (parsed == NULL) {\n    printf(\"\\033[31m\"\n           \"✗ %s %s\"\n           \"\\033[0m\"\n           \"\\n\",\n           \"should be able to parse a GPGGA sentence\", \"[FAIL]\");\n    return \"should be able to parse a GPGGA sentence\";\n  }\n  printf(\"\\033[32m\"\n         \"✓ %s %s\"\n         \"\\033[0m\"\n         \"\\n\",\n         \"should be able to parse a GPGGA sentence\", \"[OK]\");\n  free(sentence);\n  nmea_free(parsed);\n\n  sentence = strdup(\n      \"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n  len = strlen(sentence);\n  parsed = nmea_parse(sentence, len, 0);\n  if (parsed == NULL) {\n    printf(\"\\033[31m\"\n           \"✗ %s %s\"\n           \"\\033[0m\"\n           \"\\n\",\n           \"should be able to parse a GPGGA sentence\", \"[FAIL]\");\n    return \"should be able to parse a GPGGA sentence\";\n  }\n  printf(\"\\033[32m\"\n         \"✓ %s %s\"\n         \"\\033[0m\"\n         \"\\n\",\n         \"should be able to parse a GPGGA sentence\", \"[OK]\");\n  free(sentence);\n  nmea_","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_unknown() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$JACK1,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence type is unknown\", \"\\033[0m\");\n            return \"should return NULL when sentence type is unknown\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence type is unknown\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"char *test_parse_unknown_name_conflict() {\n  char *sentence = strdup(\n      \"$JACK1,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n  size_t len = strlen(sentence);\n  nmea_t *nmea = nmea_parse(sentence, len, 1);\n  if (nmea == NULL) {\n    printf(\"%s ... %s\\n\",\n           \"\\x1B[32m\"\n           \"OK\"\n           \"\\x1B[0m\",\n           \"should return NULL when sentence type is unknown\");\n    free(sentence);\n    nmea_free(nmea);\n    return NULL;\n  } else {\n    printf(\"%s ... %s\\n\",\n           \"\\x1B[31m\"\n           \"NOT OK\"\n           \"\\x1B[0m\",\n           \"should return NULL when sentence type is unknown\");\n    return \"should return NULL when sentence type is unknown\";\n  }\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_invalid() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when checksum is invalid\", \"\\033[0m\");\n            return \"should return NULL when checksum is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when checksum is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is empty\", \"\\033[0m\");\n            return \"should return NULL when sentence is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is empty\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"invalid\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is invalid\", \"\\033[0m\");\n            return \"should return NULL when sentence is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    res = nmea_parse(((void *)0), 0, 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is NULL\", \"\\033[0m\");\n            return \"should return NULL when sentence is NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is NULL\", \"\\033[0m\");\n    } while (0);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"char *test_parse_invalid_name_conflict() {\n  char *sentence = strdup(\n      \"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n  if (nmea_parse(sentence, strlen(sentence), 1) != NULL) {\n    printf(\"\\033[31m\"\n           \"%s\"\n           \" %s\"\n           \"\\033[0m\"\n           \"\\n\",\n           \"FAIL\", \"should return NULL when checksum is invalid\");\n    free(sentence);\n    nmea_free(NULL);\n    return \"should return NULL when checksum is invalid\";\n  }\n  printf(\"\\033[32m\"\n         \".\"\n         \"\\033[0m\"\n         \"\\n\");\n  free(sentence);\n  nmea_free(NULL);\n\n  sentence = strdup(\"\");\n  if (nmea_parse(sentence, strlen(sentence), 1) != NULL) {\n    printf(\"\\033[31m\"\n           \"%s\"\n           \" %s\"\n           \"\\033[0m\"\n           \"\\n\",\n           \"FAIL\", \"should return NULL when sentence is empty\");\n    free(sentence);\n    nmea_free(NULL);\n    return \"should return NULL when sentence is empty\";\n  }\n  printf(\"\\033[32m\"\n         \".\"\n         \"\\033[0m\"\n         \"\\n\");\n  free(sentence);\n  nmea_free(NULL);\n\n  sentence = strdup(\"invalid\");\n  if (nmea_parse(sentence, strlen(sentence), 1) != NULL) {\n    printf(\"\\033[31m\"\n           \"%s\"\n           \" %s\"\n           \"\\033[0m\"\n           \"\\n\",\n           \"FAIL\", \"should return NULL when sentence is invalid\");\n    free(sentence);\n    nmea_free(NULL);\n    return \"should return NULL when sentence is invalid\";\n  }\n  printf(\"\\033[32m\" \"","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_get_type()\", \"\\033[0m\");\n    do {\n        char *message = test_get_type_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_get_type_unknown();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_get_checksum()\", \"\\033[0m\");\n    do {\n        char *message = test_get_checksum_with_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_get_checksum_without_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_has_checksum()\", \"\\033[0m\");\n    do {\n        char *message = test_has_checksum_yes();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_has_checksum_no();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_validate()\", \"\\033[0m\");\n    do {\n        char *message = test_validate_ok_with_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_ok_without_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_type();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_start();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_end();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_empty();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_parse_unknown();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_parse_invalid();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"char *all_tests_name_conflict() {\n  do {\n    printf(\"..%s\\n\", \"nmea_get_type()\");\n    do {\n      char *message = test_get_type_ok();\n      tests_run++;\n      if (message)\n        return message;\n    } while (0);\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_get_type()\");\n    do {\n      char *message = test_get_type_unknown();\n      tests_run++;\n      if (message)\n        return message;\n    } while (0);\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_get_checksum()\");\n    do {\n      char *message = test_get_checksum_with_crc();\n      tests_run++;\n      if (message)\n        return message;\n    } while (0);\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_get_checksum()\");\n    do {\n      char *message = test_get_checksum_without_crc();\n      tests_run++;\n      if (message)\n        return message;\n    } while (0);\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_has_checksum()\");\n    do {\n      char *message = test_has_checksum_yes();\n      tests_run++;\n      if (message)\n        return message;\n    } while (0);\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_has_checksum()\");\n    do {\n      char *message = test_has_checksum_no();\n      tests_run++;\n      if (message)\n        return message;\n    } while (0);\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_validate()\");\n    do {\n      char *message = test_validate_ok_with_crc();\n      tests_run++;\n      if (message)\n        return message;\n    } while (0);\n  } while (0);\n  do {\n    printf(\"..%s\\n\", \"nmea_validate()\");\n    do {\n      char *message = test_validate_ok_without_crc();\n      tests_run++;\n      if (message)\n        return message;\n    } while (0);\n  } while (0);\n  do { printf(\"..%s\\n\", \"nmea_","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static int _is_value_set(const char *value) {\n    if (((void *)0) == value || '\\x00' == *value) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int _is_value_set_name_conflict(char *value) {\n  if (value == NULL || *value == '\\0')\n    return -1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static char *_crop_sentence(char *sentence, size_t length) {\n    sentence += 5 + 2;\n    sentence[length - 9] = '\\x00';\n    if ('*' == sentence[length - 12]) {\n        sentence[length - 12] = '\\x00';\n    }\n    return sentence;\n}\n","function_prediction":"char *_crop_sentence_name_conflict(char *sentence, size_t len) {\n  sentence += 7;\n  sentence[len - 9] = '\\0';\n  if (sentence[len - 12] == '*')\n    sentence[len - 12] = '\\0';\n  return sentence;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static int _split_string_by_comma(char *string, char **values, int max_values) {\n    int i = 0;\n    values[i++] = string;\n    while (i < max_values && ((void *)0) != (string = strchr(string, ',')))\n        {\n            *string = '\\x00';\n            values[i++] = ++string;\n        }\n    return i;\n}\n","function_prediction":"int _split_string_by_comma_name_conflict(char *str, char **tokens, int max_tokens) {\n  int i;\n  char *p;\n\n  tokens[0] = str;\n  p = str;\n  for (i = 1; i < max_tokens; i++) {\n    p = strchr(p, ',');\n    if (p == NULL)\n      break;\n    *p = '\\0';\n    p++;\n    tokens[i] = p;\n  }\n  return i;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"nmea_t nmea_get_type(const char *sentence) {\n    if (((void *)0) == sentence) {\n        return NMEA_UNKNOWN;\n    }\n    nmea_parser_module_s *parser = nmea_get_parser_by_sentence(sentence);\n    if (((void *)0) == parser) {\n        return NMEA_UNKNOWN;\n    }\n    return parser->parser.type;\n}\n","function_prediction":"nmea_type_t nmea_get_type_name_conflict(const char *sentence) {\n  if (sentence == NULL)\n    return 0;\n\n  const nmea_parser_t *parser = nmea_get_parser_by_sentence(sentence);\n  if (parser == NULL)\n    return 0;\n\n  return parser->type;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"uint8_t nmea_get_checksum(const char *sentence) {\n    const char *n = sentence + 1;\n    uint8_t chk = 0;\n    while ('*' != *n && '\\r' != *n && '\\x00' != *n)\n        {\n            chk ^= (uint8_t)*n;\n            n++;\n        }\n    return chk;\n}\n","function_prediction":"unsigned char nmea_get_checksum_name_conflict(const char *sentence) {\n  unsigned char checksum = 0;\n  const char *p = sentence + 1;\n\n  while (*p != '*' && *p != '\\r' && *p != '\\0') {\n    checksum ^= *p++;\n  }\n\n  return checksum;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"int nmea_has_checksum(const char *sentence, size_t length) {\n    if ('*' == sentence[length - 5]) {\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"int nmea_has_checksum_name_conflict(const char *sentence, size_t len) {\n  if (sentence[len - 5] == '*')\n    return 0;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"int nmea_validate(const char *sentence, size_t length, int check_checksum) {\n    const char *n;\n    if (9 > length) {\n        return -1;\n    }\n    if (82 < length) {\n        return -1;\n    }\n    if ('$' != *sentence) {\n        return -1;\n    }\n    if ('\\n' != sentence[length - 1] || '\\r' != sentence[length - 2]) {\n        return -1;\n    }\n    n = sentence;\n    while (++n < sentence + 6)\n        {\n            if (*n < 'A' || *n > 'Z') {\n                return -1;\n            }\n        }\n    if (',' != sentence[6]) {\n        return -1;\n    }\n    if (1 == check_checksum && 0 == nmea_has_checksum(sentence, length)) {\n        uint8_t actual_chk;\n        uint8_t expected_chk;\n        char checksum[3];\n        checksum[0] = sentence[length - 4];\n        checksum[1] = sentence[length - 3];\n        checksum[2] = '\\x00';\n        actual_chk = nmea_get_checksum(sentence);\n        expected_chk = (uint8_t)strtol(checksum, ((void *)0), 16);\n        if (expected_chk != actual_chk) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int nmea_validate_name_conflict(const char *buf, size_t len, int checksum) {\n  const char *p = buf;\n\n  if (len < 9 || len > 82 || *p != '$' || buf[len - 1] != '\\n' ||\n      buf[len - 2] != '\\r')\n    return -1;\n\n  for (p++; p < buf + 7; p++)\n    if (*p < '@' || *p > '[')\n      return -1;\n\n  if (*p++ != ',')\n    return -1;\n\n  if (checksum == 1 && !nmea_has_checksum(buf, len)) {\n    char cs[3];\n    cs[0] = buf[len - 4];\n    cs[1] = buf[len - 3];\n    cs[2] = '\\0';\n    if (strtol(cs, NULL, 16) != nmea_get_checksum(buf))\n      return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"nmea_s *nmea_parse(char *sentence, size_t length, int check_checksum) {\n    unsigned int n_vals, val_index;\n    char *value, *val_string;\n    char *values[255];\n    nmea_parser_module_s *parser;\n    nmea_t type;\n    if (-1 == nmea_validate(sentence, length, check_checksum)) {\n        return (nmea_s *)((void *)0);\n    }\n    type = nmea_get_type(sentence);\n    if (NMEA_UNKNOWN == type) {\n        return (nmea_s *)((void *)0);\n    }\n    val_string = _crop_sentence(sentence, length);\n    if (((void *)0) == val_string) {\n        return (nmea_s *)((void *)0);\n    }\n    n_vals = _split_string_by_comma(val_string, values, (sizeof values / sizeof (values[0])));\n    if (0 == n_vals) {\n        return (nmea_s *)((void *)0);\n    }\n    parser = nmea_get_parser_by_type(type);\n    if (((void *)0) == parser) {\n        return (nmea_s *)((void *)0);\n    }\n    parser->allocate_data((nmea_parser_s *)parser);\n    if (((void *)0) == parser->parser.data) {\n        return (nmea_s *)((void *)0);\n    }\n    parser->set_default((nmea_parser_s *)parser);\n    parser->errors = 0;\n    for (val_index = 0; val_index < n_vals; val_index++) {\n        value = values[val_index];\n        if (-1 == _is_value_set(value)) {\n            continue;\n        }\n        if (-1 == parser->parse((nmea_parser_s *)parser, value, val_index)) {\n            parser->errors++;\n        }\n    }\n    parser->parser.data->type = type;\n    parser->parser.data->errors = parser->errors;\n    return parser->parser.data;\n}\n","function_prediction":"nmea_sentence_t *nmea_parse_name_conflict(const char *sentence, size_t len, int checksum) {\n  if (nmea_validate(sentence, len, checksum) == -1)\n    return NULL;\n\n  nmea_type_t type = nmea_get_type(sentence);\n  if (type == 0)\n    return NULL;\n\n  char *cropped = _crop_sentence(sentence, len);\n  if (cropped == NULL)\n    return NULL;\n\n  char *parts[255];\n  unsigned int parts_count = _split_string_by_comma(cropped, parts, 255);\n  if (parts_count == 0)\n    return NULL;\n\n  nmea_parse_name_conflictr_t *parser = nmea_get_parser_by_type(type);\n  if (parser == NULL)\n    return NULL;\n\n  parser->reset(parser);\n  if (parser->sentence == NULL)\n    return NULL;\n\n  parser->parse_start(parser);\n  parser->error_count = 0;\n\n  for (unsigned int i = 0; i < parts_count; i++) {\n    char *part = parts[i];\n    if (_is_value_set(part) != -1) {\n      if (parser->parse_part(parser, part, i) == -1)\n        parser->error_count++;\n    }\n  }\n\n  parser->sentence->type = type;\n  parser->sentence->error_count = parser->error_count;\n\n  return parser->sentence;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static int _get_so_files(const char *path, char **files) {\n    int j, i = 0;\n    size_t len;\n    char *name;\n    DIR *d = ((void *)0);\n    struct dirent *dir;\n    d = opendir(path);\n    if (((void *)0) == d) {\n        return -1;\n    }\n    while (((void *)0) != (dir = readdir(d)))\n        {\n            if ('.' == dir->d_name[0]) {\n                continue;\n            }\n            len = strlen(dir->d_name);\n            if (len < 3) {\n                continue;\n            }\n            if (0 != strncmp(dir->d_name + len - 3, \".so\", 3)) {\n                continue;\n            }\n            name = malloc(255);\n            if (((void *)0) == name) {\n                goto fail;\n            }\n            strcpy(name, path);\n            strcat(name, dir->d_name);\n            files[i++] = name;\n        }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return i;\n  fail:\n    for (j = 0; j < i; i++) {\n        free(files[j]);\n    }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return -1;\n}\n","function_prediction":"int _get_so_files_name_conflict(char *path, char **so_files) {\n  int i = 0;\n  DIR *dir;\n  struct dirent *ent;\n\n  if ((dir = opendir(path)) != NULL) {\n    while ((ent = readdir(dir)) != NULL) {\n      if (ent->d_name[0] == '.')\n        continue;\n\n      size_t len = strlen(ent->d_name);\n      if (len < 3)\n        continue;\n\n      if (!strncmp(ent->d_name + len - 3, \".so\", 3)) {\n        char *so_file = malloc(255);\n        if (so_file == NULL) {\n          for (; i > 0; i++)\n            free(so_files[i]);\n          if (dir != NULL)\n            closedir(dir);\n          return -1;\n        }\n        strcpy(so_file, path);\n        strcat(so_file, ent->d_name);\n        so_files[i] = so_file;\n        i++;\n      }\n    }\n    if (dir != NULL)\n      closedir(dir);\n  } else {\n    i = -1;\n  }\n\n  return i;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"int nmea_load_parsers() {\n    int i;\n    char *files[255];\n    char *parser_path;\n    nmea_parser_module_s *parser;\n    parser_path = getenv(\"NMEA_PARSER_PATH\");\n    if (((void *)0) == parser_path) {\n        parser_path = \"/usr/lib/nmea/\";\n    }\n    n_parsers = _get_so_files(parser_path, files);\n    if (1 > n_parsers) {\n        return -1;\n    }\n    parsers = malloc((sizeof(nmea_parser_module_s *)) * n_parsers);\n    if (((void *)0) == parsers) {\n        return -1;\n    }\n    memset(parsers, 0, (sizeof(nmea_parser_module_s *)) * n_parsers);\n    i = n_parsers;\n    while (i-- > 0)\n        {\n            parser = nmea_init_parser(files[i]);\n            free(files[i]);\n            if (((void *)0) == parser) {\n                return -1;\n            }\n            parsers[i] = parser;\n        }\n    return n_parsers;\n}\n","function_prediction":"int nmea_load_parsers_name_conflict(void) {\n  char *path;\n  char *so_files[255];\n  int i;\n  struct nmea_parser *parser;\n\n  path = getenv(\"NMEA_PARSER_PATH\");\n  if (path == NULL)\n    path = \"/usr/lib/nmea/\";\n\n  n_parsers = _get_so_files(path, so_files);\n  if (n_parsers <= 0)\n    return -1;\n\n  parsers = malloc(n_parsers * sizeof(struct nmea_parser *));\n  if (parsers == NULL)\n    return -1;\n\n  memset(parsers, 0, n_parsers * sizeof(struct nmea_parser *));\n\n  for (i = n_parsers; i > 0; i--) {\n    parser = nmea_init_parser(so_files[i - 1]);\n    free(so_files[i - 1]);\n    if (parser == NULL)\n      return -1;\n    parsers[i - 1] = parser;\n  }\n\n  return n_parsers;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"uint8_t usart_recv(uint16_t usart) {\n    return (*(volatile uint8_t *)(usart + 1));\n}\n","function_prediction":"unsigned char usart_recv_name_conflict(unsigned short usart) {\n  return (*((volatile unsigned char *)(usart + 1)));\n}","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv_blocking(uint16_t usart) {\n    usart_wait_recv_ready(usart);\n    return usart_recv(usart);\n}\n","function_prediction":"unsigned char usart_recv_blocking_name_conflict(unsigned short usart) {\n  usart_wait_recv_ready(usart);\n  return usart_recv(usart);\n}","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv(uint16_t usart) {\n    return (*(volatile uint8_t *)(usart + 1));\n}\n","function_prediction":"unsigned char usart_recv_name_conflict(unsigned short usart) {\n  return (*((volatile unsigned char *)(usart + 1)));\n}","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv_blocking(uint16_t usart) {\n    usart_wait_recv_ready(usart);\n    return usart_recv(usart);\n}\n","function_prediction":"unsigned char usart_recv_blocking_name_conflict(unsigned short usart) {\n  usart_wait_recv_ready(usart);\n  return usart_recv(usart);\n}","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"char *replace_str(char *str, char *orig, char *rep) {\n    static char buffer[4096];\n    char *p;\n    int i = 0;\n    while (str[i])\n        {\n            if (!(p = strstr(str + i, orig)))\n                return str;\n            strncpy(buffer + strlen(buffer), str + i, (p - str) - i);\n            buffer[p - str] = '\\x00';\n            strcat(buffer, rep);\n            printf(\"STR:%s\\n\", buffer);\n            i = (p - str) + strlen(orig);\n        }\n    return buffer;\n}\n","function_prediction":"char *replace_str_name_conflict(char *str, char *old_str, char *new_str) {\n  int i = 0;\n  char *p = NULL;\n  while (str[i] != '\\0') {\n    p = strstr(str + i, old_str);\n    if (p == NULL) {\n      return str;\n    }\n    strncpy(buffer_0 + strlen(buffer_0), str + i, p - str - i);\n    buffer_0[p - str] = '\\0';\n    strcat(buffer_0, new_str);\n    printf(\"STR:%s\\n\", buffer_0);\n    i = p - str + strlen(old_str);\n  }\n  return buffer_0;\n}","pass":0,"source_file":"C_COMPILE/cwkx_cgim/prc/cg_prc.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 1;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 500000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  int hash = GetWordHash(word);\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 500000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int i;\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(str, argv[i])) {\n      if (i == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      } else\n        return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 0;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 30000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  unsigned int hash;\n\n  len = strlen(word) + 1;\n  if (len > 100)\n    len = 100;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1) {\n      vocab_hash[hash] = vocab_size - 1;\n      break;\n    }\n    hash = (hash + 1) % 30000000;\n  }\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int i;\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(str, argv[i])) {\n      if (i == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      } else\n        return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":1,"function":"int read_pid(char *pidfile) {\n    FILE *f;\n    int pid;\n    if (!(f = fopen(pidfile, \"r\")))\n        return 0;\n    fscanf(f, \"%d\", &pid);\n    fclose(f);\n    return pid;\n}\n","function_prediction":"int read_pid_name_conflict(char *pid_file) {\n  FILE *f;\n  int pid;\n\n  f = fopen(pid_file, \"r\");\n  if (f == NULL)\n    return 0;\n\n  __isoc99_fscanf(f, \"%d\", &pid);\n  fclose(f);\n\n  return pid;\n}","pass":0,"source_file":"C_COMPILE/danielsen_boxstats/src/process-cpu.c"}
{"compilable":0,"function":"int get_usage(const pid_t pid, struct pstat *result) {\n    char pid_s[20];\n    snprintf(pid_s, sizeof (pid_s), \"%d\", pid);\n    char stat_filepath[30] = \"/proc/\";\n    strncat(stat_filepath, pid_s, sizeof (stat_filepath) - strlen(stat_filepath) - 1);\n    strncat(stat_filepath, \"/stat\", sizeof (stat_filepath) - strlen(stat_filepath) - 1);\n    FILE *fpstat = fopen(stat_filepath, \"r\");\n    if (fpstat == ((void *)0)) {\n        perror(\"FOPEN ERROR \");\n        return -1;\n    }\n    FILE *fstat = fopen(\"/proc/stat\", \"r\");\n    if (fstat == ((void *)0)) {\n        perror(\"FOPEN ERROR \");\n        fclose(fstat);\n        return -1;\n    }\n    memset(result, 0, sizeof(struct pstat));\n    long rss;\n    if (fscanf(fpstat, \"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %lu%lu %ld %ld %*d %*d %*d %*d %*u %lu %ld\", &result->utime_ticks, &result->stime_ticks, &result->cutime_ticks, &result->cstime_ticks, &result->vsize, &rss) == (-1)) {\n        fclose(fpstat);\n        return -1;\n    }\n    fclose(fpstat);\n    result->rss = rss * sysconf(_SC_PAGESIZE);\n    unsigned long cpu_time[10];\n    memset(cpu_time, 0, sizeof (cpu_time));\n    if (fscanf(fstat, \"%*s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\", &cpu_time[0], &cpu_time[1], &cpu_time[2], &cpu_time[3], &cpu_time[4], &cpu_time[5], &cpu_time[6], &cpu_time[7], &cpu_time[8], &cpu_time[9]) == (-1)) {\n        fclose(fstat);\n        return -1;\n    }\n    fclose(fstat);\n    for (int i = 0; i < 10; i++)\n        result->cpu_total_time += cpu_time[i];\n    return 0;\n}\n","function_prediction":"int get_usage_name_conflict(int pid, struct proc_stat *ps) {\n  char pid_str[20];\n  snprintf(pid_str, sizeof(pid_str), \"%d\", pid);\n\n  char path[30] = \"/proc/\";\n  strncat(path, pid_str, sizeof(path) - strlen(path) - 1);\n  strncat(path, \"/stat\", sizeof(path) - strlen(path) - 1);\n\n  FILE *fp = fopen(path, \"r\");\n  if (fp == NULL) {\n    perror(\"FOPEN ERROR \");\n    return -1;\n  }\n\n  FILE *fp_stat = fopen(\"/proc/stat\", \"r\");\n  if (fp_stat == NULL) {\n    perror(\"FOPEN ERROR \");\n    fclose(fp_stat);\n    return -1;\n  }\n\n  memset(ps, 0, sizeof(struct proc_stat));\n  if (__isoc99_fscanf(fp,\n                      \"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u \"\n                      \"%lu%lu %ld %ld %*d %*d %*d %*d %*u %lu %ld\",\n                      &ps->utime, &ps->stime, &ps->cutime, &ps->cstime,\n                      &ps->starttime, &ps->vsize) == -1) {\n    fclose(fp);\n    return -1;\n  }\n  fclose(fp);\n\n  ps->vsize *= sysconf(_SC_PAGESIZE);\n\n  struct proc_stat_stat stat;\n  memset(&stat, 0, sizeof(struct proc_stat_stat));\n    if (__isoc99_fscanf(fp_stat, \"%*s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\",\n                        &stat.utime, &stat.ntime, &stat.stime, &stat.cstime, &stat.cutime","pass":0,"source_file":"C_COMPILE/danielsen_boxstats/src/process-cpu.c"}
{"compilable":1,"function":"pid_t launch(int argc, char **argv) {\n    int pid = fork();\n    if (pid != 0) {\n        if (pid < 0) {\n            die(\"fork\");\n        }\n        return pid;\n    }\n    sigset_t set;\n    sigfillset(&set);\n    sigprocmask(1, &set, 0);\n    setsid();\n    setpgid(0, 0);\n    char **argvn = __builtin_alloca(sizeof (argv[0]) * (argc + 1));\n    memcpy(argvn, argv, sizeof (argv[0]) * argc);\n    argvn[argc] = ((void *)0);\n    if (putenv(\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\")) {\n        die(\"putenv\");\n    }\n    execvpe(argvn[0], argvn, (char **)default_envp);\n    die2(\"execvpe\", argvn[0]);\n}\n","function_prediction":"pid_t launch_name_conflict(int argc, char *argv[]) {\n  pid_t pid;\n  sigset_t mask;\n\n  pid = fork();\n  if (pid == 0) {\n\n    sigfillset(&mask);\n    sigprocmask(SIG_SETMASK, &mask, NULL);\n\n    setsid();\n    setpgid(0, 0);\n\n    char *new_argv[argc + 1];\n    memcpy(new_argv, argv, argc * sizeof(char *));\n    new_argv[argc] = NULL;\n\n    if (putenv(\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\"))\n      die(\"putenv\");\n\n    execvpe(new_argv[0], new_argv, default_envp);\n    die2(\"execvpe\", new_argv[0]);\n  } else if (pid < 0) {\n    die(\"fork\");\n  }\n\n  return pid;\n}","pass":1,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/init/init.c"}
{"compilable":1,"function":"int reap_until(pid_t until_pid) {\n    for (;;) {\n        int status;\n        pid_t pid = wait(&status);\n        if (pid < 0) {\n            die(\"wait\");\n        }\n        if (pid == until_pid) {\n            if ((((status) & 127) == 0)) {\n                if ((((status) & 65280) >> 8) != 0) {\n                    fputs(\"child exited with error\\n\", stderr);\n                }\n                return (((status) & 65280) >> 8);\n            }\n            fputs(\"child exited by signal\\n\", stderr);\n            return 128 + ((status) & 127);\n        }\n    }\n}\n","function_prediction":"int reap_until_name_conflict(pid_t pid) {\n  int status;\n  pid_t reaped;\n\n  do {\n    reaped = wait(&status);\n    if (reaped < 0)\n      die(\"wait\");\n  } while (reaped != pid);\n\n  if (status & 0x7F) {\n    fputs(\"child exited by signal\\n\", stderr);\n    return (status & 0x7F) + 128;\n  }\n\n  if (status >> 8)\n    fputs(\"child exited with error\\n\", stderr);\n\n  return status >> 8;\n}","pass":1,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/init/init.c"}
{"compilable":0,"function":"static int openvsock(unsigned int cid, unsigned int port) {\n    int s = socket(40, SOCK_STREAM, 0);\n    if (s < 0) {\n        perror(\"socket: AF_VSOCK\");\n        return -1;\n    }\n    struct sockaddr_vm addr = {0};\n    addr.svm_family = 40;\n    addr.svm_port = port;\n    addr.svm_cid = cid;\n    if (connect(s, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        fprintf(stderr, \"connect: port %u: %s\", port, strerror((*__errno_location())));\n        return -1;\n    }\n    return s;\n}\n","function_prediction":"int openvsock_name_conflict(uint32_t cid, uint32_t port) {\n  int fd;\n  struct sockaddr_vm sa;\n\n  fd = socket(0x28, 1, 0);\n  if (fd < 0) {\n    perror(\"socket: AF_VSOCK\");\n    return -1;\n  }\n\n  sa.svm_family = 0x28;\n  sa.svm_reserved = 0;\n  sa.svm_port = port;\n  sa.svm_cid = cid;\n\n  if (connect(fd, (struct sockaddr *)&sa, sizeof(sa)) < 0) {\n    fprintf(stderr, \"connect: port %u: %s\", port,\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  return fd;\n}","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/vsockexec/vsockexec.c"}
{"compilable":1,"function":"static int opentcp(unsigned short port) {\n    int s = socket(2, SOCK_STREAM, 0);\n    if (s < 0) {\n        perror(\"socket: AF_INET\");\n        return -1;\n    }\n    struct sockaddr_in addr = {0};\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = htonl(((in_addr_t)2130706433));\n    if (connect(s, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        fprintf(stderr, \"connect: port %u: %s\\n\", port, strerror((*__errno_location())));\n        return -1;\n    }\n    return s;\n}\n","function_prediction":"int opentcp_name_conflict(unsigned short port) {\n  int sock;\n  struct sockaddr_in addr;\n\n  if ((sock = socket(2, 1, 0)) < 0) {\n    perror(\"socket: AF_INET\");\n    return -1;\n  }\n\n  addr.sin_family = 2;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = htonl(0x7f000001);\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n    fprintf(stderr, \"connect: port %u: %s\\n\", port,\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  return sock;\n}","pass":1,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/vsockexec/vsockexec.c"}
{"compilable":1,"function":"int fib_rec(int n) {\n    int result;\n    if (n == 0 || n == 1) {\n        result = 1;\n    } else {\n        result = fib_rec(n - 1) + fib_rec(n - 2);\n    }\n    return result;\n}\n","function_prediction":"int fib_rec_name_conflict(int n) {\n  if (n == 0 || n == 1) {\n    return 1;\n  }\n  return fib_rec_name_conflict(n - 1) + fib_rec_name_conflict(n - 2);\n}","pass":1,"source_file":"C_COMPILE/jstolarek_sandbox/c/fibonacci.c"}
{"compilable":1,"function":"int fib_it(int n) {\n    int result;\n    if (n == 0 || n == 1) {\n        result = 1;\n    } else {\n        int a = 1, b = 1, c = 1;\n        for (int i = 1; i < n; i++) {\n            a = b;\n            b = c;\n            c = a + b;\n        }\n        result = c;\n    }\n    return result;\n}\n","function_prediction":"int fib_it_name_conflict(int n) {\n  if (n == 0 || n == 1) {\n    return 1;\n  }\n\n  int a = 1;\n  int b = 1;\n  int c;\n  for (int i = 1; i < n; i++) {\n    c = a + b;\n    a = b;\n    b = c;\n  }\n\n  return b;\n}","pass":1,"source_file":"C_COMPILE/jstolarek_sandbox/c/fibonacci.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 1;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 500000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  int hash = GetWordHash(word);\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 500000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int i;\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(str, argv[i])) {\n      if (i == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      } else\n        return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 0;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 30000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  unsigned int hash;\n\n  len = strlen(word) + 1;\n  if (len > 100)\n    len = 100;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1) {\n      vocab_hash[hash] = vocab_size - 1;\n      break;\n    }\n    hash = (hash + 1) % 30000000;\n  }\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int i;\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(str, argv[i])) {\n      if (i == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      } else\n        return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":1,"function":"static char *xstrdup(const char *s) {\n    char *p = xmalloc(strlen(s) + 1);\n    strcpy(p, s);\n    return p;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p = xmalloc(strlen(s) + 1);\n  strcpy(p, s);\n  return p;\n}","pass":1,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":1,"function":"static int writen(int fd, const char *buffer, size_t length) {\n    while (length)\n        {\n            int nwritten = write(fd, buffer, length);\n            if (nwritten < 0) {\n                if ((*__errno_location()) == 4)\n                    continue;\n                return -1;\n            }\n            length -= nwritten;\n            buffer += nwritten;\n        }\n    return 0;\n}\n","function_prediction":"int writen_name_conflict(int fd, const void *vptr, size_t n) {\n  size_t nleft;\n  ssize_t nwritten;\n  const char *ptr;\n\n  ptr = vptr;\n  nleft = n;\n  while (nleft > 0) {\n    if ((nwritten = write(fd, ptr, nleft)) < 0) {\n      if (*__errno_location() == 4) {\n        nwritten = 0;\n      } else {\n        return -1;\n      }\n    }\n\n    nleft -= nwritten;\n    ptr += nwritten;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static char *read_assuan(int fd) {\n    static char pending[2048];\n    static size_t pending_len;\n    size_t nleft = sizeof recv_line;\n    char *buf = recv_line;\n    char *p;\n    while (nleft > 0)\n        {\n            int n;\n            if (pending_len) {\n                if (pending_len >= nleft)\n                    (die)(\"%s: received line too large\", __func__);\n                memcpy(buf, pending, pending_len);\n                n = pending_len;\n                pending_len = 0;\n            } else {\n                do {\n                    n = read(fd, buf, nleft);\n                } while (n < 0 && (*__errno_location()) == 4);\n            }\n            if (opt_verbose && n >= 0) {\n                int i;\n                printf(\"%s: read \\\"\", __func__);\n                for (i = 0; i < n; i++)\n                    putc(buf[i], stdout);\n                printf(\"\\\"\\n\");\n            }\n            if (n < 0)\n                (die)(\"%s: reading fd %d failed: %s\", __func__, (fd), (strerror((*__errno_location()))));\n            else if (!n)\n                (die)(\"%s: received incomplete line on fd %d\", __func__, (fd));\n            p = buf;\n            nleft -= n;\n            buf += n;\n            for (; n && *p != '\\n'; n-- , p++)\n                ;\n            if (n) {\n                if (n > 1) {\n                    n--;\n                    memcpy(pending, p + 1, n);\n                    pending_len = n;\n                }\n                *p = '\\x00';\n                break;\n            }\n        }\n    if (!nleft)\n        (die)(\"%s: received line too large\", __func__);\n    p = recv_line;\n    if (p[0] == 'O' && p[1] == 'K' && (p[2] == ' ' || !p[2])) {\n        recv_type = LINE_OK;\n        p += 3;\n    } else if (p[0] == 'E' && p[1] == 'R' && p[2] == 'R' && (p[3] == ' ' || !p[3])) {\n        recv_type = LINE_ERR;\n        p += 4;\n    } else if (p[0] == 'S' && (p[1] == ' ' || !p[1])) {\n        recv_type = LINE_STAT;\n        p += 2;\n    } else if (p[0] == 'D' && p[1] == ' ') {\n        recv_type = LINE_DATA;\n        p += 2;\n    } else if (p[0] == 'E' && p[1] == 'N' && p[2] == 'D' && !p[3]) {\n        recv_type = LINE_END;\n        p += 3;\n    } else\n        (die)(\"%s: invalid line type (%.5s)\", __func__, (p));\n    return p;\n}\n","function_prediction":"char *read_assuan_name_conflict(int fd) {\n  static char pending[1024];\n  static size_t pending_len;\n  char *buf = &recv_line;\n  size_t buf_len = 2048;\n  int i;\n\n  while (buf_len) {\n    if (pending_len) {\n      if (buf_len <= pending_len)\n        die(\"%s: received line too large\", \"read_assuan_name_conflict\");\n      memcpy(buf, pending, pending_len);\n      buf_len -= pending_len;\n      buf += pending_len;\n      pending_len = 0;\n    } else {\n      int ret;\n      do {\n        ret = read(fd, buf, buf_len);\n      } while (ret < 0 && *__errno_location() == 4);\n      if (opt_verbose && ret >= 0) {\n        printf(\"%s: read \\\"\", \"read_assuan_name_conflict\");\n        for (i = 0; i < ret; i++)\n          putc(buf[i], stdout);\n        printf(\"\\\"\\n\");\n      }\n      if (ret < 0)\n        die(\"%s: reading fd %d failed: %s\", \"read_assuan_name_conflict\", fd,\n            strerror(*__errno_location()));\n      if (ret == 0)\n        die(\"%s: received incomplete line on fd %d\", \"read_assuan_name_conflict\", fd);\n      buf_len -= ret;\n      buf += ret;\n    }\n\n    while (ret && *buf != '\\n') {\n      ret--;\n      buf++;\n    }\n  }\n  if (ret > 1) {\n    memcpy(pending, buf + 1, ret - 1);\n    pending_len = ret - 1;\n  }\n  *buf = '\\0';\n\n  if (buf_len == 0)\n    die(\"%s: received line too large\", \"read_assuan_name_conflict\");\n  buf = &recv_line;\n\n  if (!strcmp(buf, \"OK \")) {\n    recv_type = 0;\n    buf += 3;\n    } else if (!strcmp(","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static const char *get_var(const char *name) {\n    VARIABLE var;\n    for (var = variable_list; var && strcmp(var->name, name); var = var->next)\n        ;\n    if (!var)\n        return ((void *)0);\n    if (var->type == VARTYPE_COUNTER && var->value) {\n        char *p = var->value + strlen(var->value) + 1;\n        sprintf(p, \"%u\", var->count);\n        return p;\n    } else\n        return var->value;\n}\n","function_prediction":"char *get_var_name_conflict(char *name) {\n  struct variable *v;\n\n  for (v = variable_list; v; v = v->next) {\n    if (!strcmp(v->name, name))\n      break;\n  }\n\n  if (!v)\n    return NULL;\n\n  if (v->type == 2 && v->value) {\n    char *p = v->value + strlen(v->value) + 1;\n    sprintf(p, \"%u\", v->uvalue);\n    return p;\n  }\n\n  return v->value;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":1,"function":"static char *expand_line(char *buffer) {\n    char *line = buffer;\n    char *p, *pend;\n    const char *value;\n    size_t valuelen, n;\n    char *result = ((void *)0);\n    while (*line)\n        {\n            p = strchr(line, '$');\n            if (!p)\n                return result;\n            if (p[1] == '$') {\n                memmove(p, p + 1, strlen(p + 1) + 1);\n                line = p + 1;\n                continue;\n            }\n            for (pend = p + 1; *pend && !(*(pend) == ' ' || *(pend) == '\\t') && *pend != '$' && *pend != '/'; pend++)\n                ;\n            if (*pend) {\n                int save = *pend;\n                *pend = 0;\n                value = get_var(p + 1);\n                *pend = save;\n            } else\n                value = get_var(p + 1);\n            if (!value)\n                value = \"\";\n            valuelen = strlen(value);\n            if (valuelen <= pend - p) {\n                memcpy(p, value, valuelen);\n                p += valuelen;\n                n = pend - p;\n                if (n)\n                    memmove(p, p + n, strlen(p + n) + 1);\n                line = p;\n            } else {\n                char *src = result ? result : buffer;\n                char *dst;\n                dst = xmalloc(strlen(src) + valuelen + 1);\n                n = p - src;\n                memcpy(dst, src, n);\n                memcpy(dst + n, value, valuelen);\n                n += valuelen;\n                strcpy(dst + n, pend);\n                line = dst + n;\n                free(result);\n                result = dst;\n            }\n        }\n    return result;\n}\n","function_prediction":"char *expand_line_name_conflict(char *line) {\n  char *new_line = NULL;\n  char *p, *q, *r, *s;\n  size_t len;\n\n  for (p = line; *p; p = q) {\n    if ((q = strchr(p, '$')) == NULL)\n      break;\n    if (q[1] == '$') {\n      memmove(q, q + 1, strlen(q + 1) + 1);\n      q++;\n    } else {\n      for (r = q + 1; *r && *r != ' ' && *r != '\\t'; r++)\n        if (*r == '$' || *r == '/')\n          break;\n      if (*r) {\n        s = *r;\n        *r = '\\0';\n        s = get_var(p + 1);\n        *r = s;\n      } else\n        s = get_var(p + 1);\n      if (s == NULL)\n        s = \"\";\n      len = strlen(s);\n      if (len > r - p) {\n        s = new_line ? new_line : line;\n        len = strlen(s);\n        r = xmalloc(len + len + len + 1);\n        memcpy(r, s, p - s);\n        memcpy(r + (p - s), s, len);\n        strcpy(r + (p - s) + len, r + (p - s) + (r - p));\n        p = r + (p - s) + len;\n        free(new_line);\n        new_line = r;\n      } else {\n        memcpy(p, s, len);\n        p += len;\n        if (r - p)\n          memmove(p, p + (r - p), strlen(p + (r - p)) + 1);\n      }\n    }\n  }\n  return (new_line);\n}","pass":1,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":1,"function":"static int eval_boolean(const char *cond) {\n    int true = 1;\n    for (; *cond == '!'; cond++)\n        true = !true;\n    if (!*cond || (*cond == '0' && !cond[1]))\n        return !true;\n    return true;\n}\n","function_prediction":"int eval_boolean_name_conflict(char *s) {\n  int b = 1;\n  while (*s == '!') {\n    b = !b;\n    s++;\n  }\n  if (*s == '\\0' || (*s == '0' && s[1] == '\\0'))\n    b = !b;\n  return b;\n}","pass":1,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static int interpreter(char *line) {\n    static struct {\n        const char *name;\n        void (*fnc)(const char *, char *);\n    } cmdtbl[] = {{\"let\", cmd_let}, {\"echo\", cmd_echo}, {\"send\", cmd_send}, {\"expect-ok\", cmd_expect_ok}, {\"expect-err\", cmd_expect_err}, {\"count-status\", cmd_count_status}, {\"openfile\", cmd_openfile}, {\"createfile\", cmd_createfile}, {\"pipeserver\", cmd_pipeserver}, {\"quit\", ((void *)0)}, {\"quit-if\", cmd_quit_if}, {\"fail-if\", cmd_fail_if}, {\"cmpfiles\", cmd_cmpfiles}, {\"getenv\", cmd_getenv}, {((void *)0)}};\n    char *p, *save_p;\n    int i, save_c;\n    char *stmt = ((void *)0);\n    char *assign_to = ((void *)0);\n    char *must_free = ((void *)0);\n    for (; (*(line) == ' ' || *(line) == '\\t'); line++)\n        ;\n    if (!*line || *line == '#')\n        return 0;\n    p = expand_line(line);\n    if (p) {\n        must_free = p;\n        line = p;\n        for (; (*(line) == ' ' || *(line) == '\\t'); line++)\n            ;\n        if (!*line || *line == '#') {\n            free(must_free);\n            return 0;\n        }\n    }\n    for (p = line; *p && !(*(p) == ' ' || *(p) == '\\t') && *p != '='; p++)\n        ;\n    if (*p == '=') {\n        *p = 0;\n        assign_to = line;\n    } else if (*p) {\n        for (*p++ = 0; (*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (*p == '=')\n            assign_to = line;\n    }\n    if (!*line)\n        (die)(\"%s: syntax error\", __func__);\n    stmt = line;\n    save_c = 0;\n    save_p = ((void *)0);\n    if (assign_to) {\n        for (p++; (*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (!*p) {\n            unset_var(assign_to);\n            free(must_free);\n            return 0;\n        }\n        stmt = p;\n        for (; *p && !(*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (*p) {\n            save_p = p;\n            save_c = *p;\n            for (*p++ = 0; (*(p) == ' ' || *(p) == '\\t'); p++)\n                ;\n        }\n    }\n    for (i = 0; cmdtbl[i].name && strcmp(stmt, cmdtbl[i].name); i++)\n        ;\n    if (!cmdtbl[i].name) {\n        if (!assign_to)\n            (die)(\"%s: invalid statement '%s'\\n\", __func__, (stmt));\n        if (save_p)\n            *save_p = save_c;\n        set_var(assign_to, stmt);\n        free(must_free);\n        return 0;\n    }\n    if (cmdtbl[i].fnc)\n        cmdtbl[i].fnc(assign_to, p);\n    free(must_free);\n    return cmdtbl[i].fnc ? 0 : 1;\n}\n","function_prediction":"int interpreter_name_conflict(char *line) {\n  char *var = NULL, *val = NULL, *orig_line = NULL;\n  char *cmd, *arg, *p;\n  int i;\n\n  while (*line == ' ' || *line == '\\t')\n    line++;\n  if (*line == '\\0' || *line == '#')\n    return 0;\n\n  orig_line = line;\n  line = expand_line(line);\n  if (line) {\n    while (*line == ' ' || *line == '\\t')\n      line++;\n    if (*line == '\\0' || *line == '#') {\n      free(line);\n      return 0;\n    }\n  }\n\n  for (p = line; *p && *p != ' ' && *p != '\\t' && *p != '='; p++)\n    ;\n  if (*p == '=') {\n    *p = '\\0';\n    var = line;\n  } else if (*p) {\n    *p = '\\0';\n    for (p++; *p == ' ' || *p == '\\t'; p++)\n      ;\n    if (*p == '=')\n      var = line;\n  }\n  if (!*line)\n    die(\"%s: syntax error\", \"interpreter_name_conflict\");\n\n  cmd = line;\n  arg = NULL;\n  p = NULL;\n  char save_char = '\\0';\n  if (var) {\n    for (p = cmd; *p == ' ' || *p == '\\t'; p++)\n      ;\n    if (!*p) {\n      unset_var(var);\n      free(orig_line);\n      return 0;\n    }\n    cmd = p;\n    for (; *p && *p != ' ' && *p != '\\t'; p++)\n      ;\n    if (*p) {\n      arg = p;\n      save_char = *p;\n      *p = '\\0';\n      for (p++; *p == ' ' || *p == '\\t'; p++)\n        ;\n    }\n  }\n\n    for (i = 0","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":1,"function":"static char *xstrdup(const char *string) {\n    void *p = malloc(strlen(string) + 1);\n    if (!p)\n        die(\"out of core: %s\", strerror((*__errno_location())));\n    strcpy(p, string);\n    return p;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p = malloc(strlen(s) + 1);\n  if (!p)\n    die(\"out of core: %s\", strerror(*__errno_location()));\n  strcpy(p, s);\n  return p;\n}","pass":1,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":1,"function":"static char *ascii_strupr(char *string) {\n    char *p;\n    for (p = string; *p; p++)\n        if (!(*p & 128))\n            *p = toupper(*p);\n    return string;\n}\n","function_prediction":"char *ascii_strupr_name_conflict(char *str) {\n  char *p = str;\n\n  while (*p) {\n    if (*p & 0x80) {\n      p++;\n      continue;\n    }\n    *p = toupper(*p);\n    p++;\n  }\n\n  return str;\n}","pass":1,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"const char *isodatestring(void) {\n    static char buffer[16];\n    struct tm *tp;\n    time_t atime = time(((void *)0));\n    if (atime < 0)\n        strcpy(buffer, \"????-??-??\");\n    else {\n        tp = gmtime(&atime);\n        sprintf(buffer, \"%04d-%02d-%02d\", 1900 + tp->tm_year, tp->tm_mon + 1, tp->tm_mday);\n    }\n    return buffer;\n}\n","function_prediction":"char *isodatestring_name_conflict(void) {\n  time_t t;\n  struct tm *tm;\n\n  t = time(NULL);\n  if (t < 0) {\n    buffer[0] = '?';\n    buffer[1] = '?';\n    buffer[2] = '-';\n    buffer[3] = '?';\n    buffer[4] = '?';\n    buffer[5] = '-';\n    buffer[6] = '?';\n    buffer[7] = '?';\n    buffer[8] = '?';\n    buffer[9] = '?';\n    buffer[10] = '?';\n    buffer[11] = '?';\n    return buffer;\n  }\n  tm = gmtime(&t);\n  sprintf(buffer, \"%04d-%02d-%02d\", tm->tm_year + 1900, tm->tm_mon + 1,\n          tm->tm_mday);\n  return buffer;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":1,"function":"static int is_standard_section(const char *name) {\n    int i;\n    const char *s;\n    for (i = 0; (s = standard_sections[i]); i++)\n        if (!strcmp(s, name))\n            return 1;\n    return 0;\n}\n","function_prediction":"int is_standard_section_name_conflict(char *name) {\n  int i;\n\n  for (i = 0; standard_sections[i]; i++)\n    if (!strcmp(standard_sections[i], name))\n      return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"static const char *pcsc_error_string(long err) {\n    const char *s;\n    if (!err)\n        return \"okay\";\n    if ((err & 2148532224U) != 2148532224U)\n        return \"invalid PC/SC error code\";\n    err &= 65535;\n    switch (err) {\n      case 2:\n        s = \"cancelled\";\n        break;\n      case 14:\n        s = \"can't dispose\";\n        break;\n      case 8:\n        s = \"insufficient buffer\";\n        break;\n      case 21:\n        s = \"invalid ATR\";\n        break;\n      case 3:\n        s = \"invalid handle\";\n        break;\n      case 4:\n        s = \"invalid parameter\";\n        break;\n      case 5:\n        s = \"invalid target\";\n        break;\n      case 17:\n        s = \"invalid value\";\n        break;\n      case 6:\n        s = \"no memory\";\n        break;\n      case 19:\n        s = \"comm error\";\n        break;\n      case 1:\n        s = \"internal error\";\n        break;\n      case 20:\n        s = \"unknown error\";\n        break;\n      case 7:\n        s = \"waited too long\";\n        break;\n      case 9:\n        s = \"unknown reader\";\n        break;\n      case 10:\n        s = \"timeout\";\n        break;\n      case 11:\n        s = \"sharing violation\";\n        break;\n      case 12:\n        s = \"no smartcard\";\n        break;\n      case 13:\n        s = \"unknown card\";\n        break;\n      case 15:\n        s = \"proto mismatch\";\n        break;\n      case 16:\n        s = \"not ready\";\n        break;\n      case 18:\n        s = \"system cancelled\";\n        break;\n      case 22:\n        s = \"not transacted\";\n        break;\n      case 23:\n        s = \"reader unavailable\";\n        break;\n      case 101:\n        s = \"unsupported card\";\n        break;\n      case 102:\n        s = \"unresponsive card\";\n        break;\n      case 103:\n        s = \"unpowered card\";\n        break;\n      case 104:\n        s = \"reset card\";\n        break;\n      case 105:\n        s = \"removed card\";\n        break;\n      case 106:\n        s = \"inserted card\";\n        break;\n      case 31:\n        s = \"unsupported feature\";\n        break;\n      case 25:\n        s = \"PCI too small\";\n        break;\n      case 26:\n        s = \"reader unsupported\";\n        break;\n      case 27:\n        s = \"duplicate reader\";\n        break;\n      case 28:\n        s = \"card unsupported\";\n        break;\n      case 29:\n        s = \"no service\";\n        break;\n      case 30:\n        s = \"service stopped\";\n        break;\n      default:\n        s = \"unknown PC/SC error code\";\n        break;\n    }\n    return s;\n}\n","function_prediction":"const char *pcsc_error_string_name_conflict(unsigned long error) {\n  const char *str;\n\n  if (error == 0)\n    str = \"okay\";\n  else if ((error & 0x80100000) == 0x80100000) {\n    switch (error & 0x0000ffff) {\n    case 0x00000001:\n      str = \"internal error\";\n      break;\n    case 0x00000002:\n      str = \"cancelled\";\n      break;\n    case 0x00000003:\n      str = \"invalid handle\";\n      break;\n    case 0x00000004:\n      str = \"invalid parameter\";\n      break;\n    case 0x00000005:\n      str = \"invalid target\";\n      break;\n    case 0x00000006:\n      str = \"no memory\";\n      break;\n    case 0x00000007:\n      str = \"waited too long\";\n      break;\n    case 0x00000008:\n      str = \"insufficient buffer\";\n      break;\n    case 0x00000009:\n      str = \"unknown reader\";\n      break;\n    case 0x0000000a:\n      str = \"timeout\";\n      break;\n    case 0x0000000b:\n      str = \"sharing violation\";\n      break;\n    case 0x0000000c:\n      str = \"no smartcard\";\n      break;\n    case 0x0000000d:\n      str = \"unknown card\";\n      break;\n    case 0x0000000e:\n      str = \"can't dispose\";\n      break;\n    case 0x0000000f:\n      str = \"proto mismatch\";\n      break;\n    case 0x00000010:\n      str = \"not ready\";\n      break;\n    case 0x00000011:\n      str = \"invalid value\";\n      break;\n    case 0x00000012:\n      str = \"system canc","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/scd/pcsc-wrapper.c"}
{"compilable":0,"function":"static unsigned int convert_le_u32(const unsigned char *buf) {\n    return buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}\n","function_prediction":"uint32_t convert_le_u32_name_conflict(const uint8_t *buf) { return *(uint32_t *)buf; }","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tools/ccidmon.c"}
{"compilable":0,"function":"static unsigned int convert_le_u16(const unsigned char *buf) {\n    return buf[0] | (buf[1] << 8);\n}\n","function_prediction":"uint16_t convert_le_u16_name_conflict(const void *p) {\n  const uint8_t *a = (const uint8_t *)p;\n  return (uint16_t)((((uint16_t)(a[0])) | ((uint16_t)(a[1]) << 8)));\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tools/ccidmon.c"}
{"compilable":0,"function":"unsigned int libplayer_version(void) {\n    return (2 << 16 | 0 << 8 | 2);\n}\n","function_prediction":"int libplayer_version_name_conflict(void) { return 0x020002; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_enabled(player_type_t type) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int libplayer_wrapper_enabled_name_conflict(int wrapper) { return wrapper == 4; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_supported_res(player_type_t type, mrl_resource_t res) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return pl_supported_resources_dummy(res);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int libplayer_wrapper_supported_res_name_conflict(int player, int res) {\n  switch (player) {\n  case 4:\n    return pl_supported_resources_dummy(res);\n  default:\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int pl_supported_resources_dummy(__attribute__((unused)) mrl_resource_t mrl) {\n    return 1;\n}\n","function_prediction":"int pl_supported_resources_dummy_name_conflict(void) { return 1; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/wrapper_dummy.c"}
{"compilable":0,"function":"mrl_metadata_dvd_title_t *mrl_metadata_dvd_title_new(void) {\n    mrl_metadata_dvd_title_t *title;\n    title = calloc(1, sizeof(mrl_metadata_dvd_title_t));\n    return title;\n}\n","function_prediction":"MRLMetadataDVDTitle *mrl_metadata_dvd_title_new_name_conflict(void) {\n  return calloc(1, sizeof(MRLMetadataDVDTitle));\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/mrl_internal.c"}
{"compilable":0,"function":"static uint32_t getch(void) {\n    struct termios oldt, newt;\n    uint32_t ch = 0;\n    uint32_t val = 0;\n    int n;\n    tcgetattr(0, &oldt);\n    newt = oldt;\n    newt.c_lflag &= ~(2 | 8);\n    tcsetattr(0, 0, &newt);\n    n = read(0, &ch, sizeof (ch));\n    if (!n)\n        return 0;\n    putchar('\\n');\n    while (ch)\n        {\n            val <<= 8;\n            val += ch & 255;\n            ch >>= 8;\n        }\n    tcsetattr(0, 0, &oldt);\n    return val;\n}\n","function_prediction":"int getch_name_conflict() {\n  int c = 0;\n  int r = 0;\n  struct termios oldt, newt;\n\n  tcgetattr(0, &oldt);\n  newt = oldt;\n  newt.c_lflag &= ~(ICANON | ECHO);\n  tcsetattr(0, 0, &newt);\n\n  r = read(0, &c, sizeof(c));\n  if (r == 0)\n    return 0;\n\n  putchar('\\n');\n  while (c) {\n    r = (r << 8) + (c & 0xFF);\n    c >>= 8;\n  }\n\n  tcsetattr(0, 0, &oldt);\n  return r;\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/libplayer-test.c"}
{"compilable":0,"function":"unsigned int libplayer_version(void) {\n    return (2 << 16 | 0 << 8 | 2);\n}\n","function_prediction":"int libplayer_version_name_conflict(void) { return 0x020002; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_enabled(player_type_t type) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int libplayer_wrapper_enabled_name_conflict(int wrapper) { return wrapper == 4; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_supported_res(player_type_t type, mrl_resource_t res) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return pl_supported_resources_dummy(res);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int libplayer_wrapper_supported_res_name_conflict(int player, int res) {\n  switch (player) {\n  case 4:\n    return pl_supported_resources_dummy(res);\n  default:\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int pl_supported_resources_dummy(__attribute__((unused)) mrl_resource_t mrl) {\n    return 1;\n}\n","function_prediction":"int pl_supported_resources_dummy_name_conflict(void) { return 1; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/wrapper_dummy.c"}
{"compilable":0,"function":"mrl_metadata_dvd_title_t *mrl_metadata_dvd_title_new(void) {\n    mrl_metadata_dvd_title_t *title;\n    title = calloc(1, sizeof(mrl_metadata_dvd_title_t));\n    return title;\n}\n","function_prediction":"MRLMetadataDVDTitle *mrl_metadata_dvd_title_new_name_conflict(void) {\n  return calloc(1, sizeof(MRLMetadataDVDTitle));\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/mrl_internal.c"}
{"compilable":0,"function":"static uint32_t getch(void) {\n    struct termios oldt, newt;\n    uint32_t ch = 0;\n    uint32_t val = 0;\n    int n;\n    tcgetattr(0, &oldt);\n    newt = oldt;\n    newt.c_lflag &= ~(2 | 8);\n    tcsetattr(0, 0, &newt);\n    n = read(0, &ch, sizeof (ch));\n    putchar('\\n');\n    while (ch)\n        {\n            val <<= 8;\n            val += ch & 255;\n            ch >>= 8;\n        }\n    tcsetattr(0, 0, &oldt);\n    return val;\n}\n","function_prediction":"int getch_name_conflict() {\n  int c = 0;\n  int ret = 0;\n  struct termios oldt, newt;\n  tcgetattr(0, &oldt);\n  newt = oldt;\n  newt.c_lflag &= ~(ICANON | ECHO);\n  tcsetattr(0, 0, &newt);\n  ret = read(0, &c, sizeof(c));\n  putchar('\\n');\n  while (c) {\n    ret = ret * 256 + (c & 0xFF);\n    c = c >> 8;\n  }\n  tcsetattr(0, 0, &oldt);\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/libplayer-testvdr.c"}
{"compilable":0,"function":"int f(int u, int v) {\n    if (v > 0)\n        return 5 * u + 3 * v;\n    return u;\n}\n","function_prediction":"int f_name_conflict(int a, int b) {\n  if_name_conflict (b > 0)\n    return a * 5 + b * 3;\n  else\n    return a;\n}","pass":0,"source_file":"C_COMPILE/andrewburger_c-and-c-plus-plus/hw9f02.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 1;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 500000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  int hash = GetWordHash(word);\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 500000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int i;\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(str, argv[i])) {\n      if (i == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      } else\n        return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"unsigned long GetWordHash_name_conflict(char *word) {\n  unsigned long hash = 0;\n  unsigned long i;\n\n  for (i = 0; i < strlen(word); i++)\n    hash = (hash << 8) + word[i];\n\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned int hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1)\n      return -1;\n    if (!strcmp(word, vocab[vocab_hash[hash]].word))\n      return vocab_hash[hash];\n    hash = (hash + 1) % 30000000;\n  }\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  int len;\n  unsigned int hash;\n\n  len = strlen(word) + 1;\n  if (len > 100)\n    len = 100;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  hash = GetWordHash(word);\n  while (1) {\n    if (vocab_hash[hash] == -1) {\n      vocab_hash[hash] = vocab_size - 1;\n      break;\n    }\n    hash = (hash + 1) % 30000000;\n  }\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int i;\n  for (i = 1; i < argc; ++i) {\n    if (!strcmp(str, argv[i])) {\n      if (i == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      } else\n        return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":0,"function":"WinMsgTokState *wmtok_init(WinMsgTokState *st) {\n    if (st == ((void *)0)) {\n        st = malloc(sizeof(WinMsgTokState));\n        st->_dofree = 1;\n    }\n    return st;\n}\n","function_prediction":"wmtok_t *wmtok_init_name_conflict(wmtok_t *tok) {\n  if (tok == NULL) {\n    tok = malloc(sizeof(wmtok_t) + 1);\n    tok->buf[0] = 1;\n  }\n  return tok;\n}","pass":0,"source_file":"C_COMPILE/swegener_screen/src/winmsgtok.c"}
{"compilable":1,"function":"int parsemac(char *str, unsigned char *mac) {\n    char *s;\n    while ((s = strsep(&str, \":\")) != ((void *)0))\n        {\n            unsigned int byte;\n            if (sscanf(s, \"%x\", &byte) != 1 || byte > 255)\n                return -1;\n            *mac++ = byte;\n        }\n    return 0;\n}\n","function_prediction":"int parsemac_name_conflict(char *mac, unsigned char *macaddr) {\n  char *p, *q;\n  unsigned int i;\n\n  p = mac;\n  while ((q = strsep(&p, \":\")) != NULL) {\n    if (__isoc99_sscanf(q, \"%x\", &i) != 1 || i > 0xff)\n      return -1;\n    *macaddr++ = i;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":0,"function":"int setname(char *oldname, char *newname) {\n    struct ifreq ifr;\n    opensock();\n    memset(&ifr, 0, sizeof(struct ifreq));\n    strcpy(ifr.ifr_ifrn.ifrn_name, oldname);\n    strcpy(ifr.ifr_ifru.ifru_newname, newname);\n    return ioctl(ctl_sk, 35107, &ifr);\n}\n","function_prediction":"void setname_name_conflict(char *ifname, char *ifalias) {\n  struct ifreq ifr;\n\n  opensock();\n  memset(&ifr, 0, sizeof(ifr));\n  strcpy(ifr.ifr_name, ifname);\n  strcpy(ifr.ifr_ifrn.ifrn_name, ifalias);\n  ioctl(ctl_sk, 0x8923, &ifr);\n}","pass":0,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":1,"function":"int getmac(char *name, unsigned char *mac) {\n    int r;\n    struct ifreq ifr;\n    opensock();\n    memset(&ifr, 0, sizeof(struct ifreq));\n    strcpy(ifr.ifr_ifrn.ifrn_name, name);\n    r = ioctl(ctl_sk, 35111, &ifr);\n    memcpy(mac, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    return r;\n}\n","function_prediction":"int getmac_name_conflict(char *ifname, char *mac) {\n  int ret;\n  struct ifreq ifr;\n\n  opensock();\n\n  memset(&ifr, 0, sizeof(ifr));\n  strcpy(ifr.ifr_name, ifname);\n\n  ret = ioctl(ctl_sk, 0x8927, &ifr);\n  memcpy(mac, ifr.ifr_hwaddr.sa_data, 6);\n\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":0,"function":"char *MakeCRC(char *BitString) {\n    static char Res[6];\n    char CRC[5];\n    int i;\n    char DoInvert;\n    for (i = 0; i < 5; ++i)\n        CRC[i] = 0;\n    for (i = 0; i < strlen(BitString); ++i) {\n        DoInvert = ('1' == BitString[i]) ^ CRC[4];\n        printf(\"%i %i %i\\t\", i, ('1' == BitString[i]), DoInvert);\n        CRC[4] = CRC[3];\n        CRC[3] = CRC[2];\n        CRC[2] = CRC[1] ^ DoInvert;\n        CRC[1] = CRC[0];\n        CRC[0] = DoInvert;\n        printf(\"%i %i %i %i %i\\n\", CRC[0], CRC[1], CRC[2], CRC[3], CRC[4]);\n    }\n    for (i = 0; i < 5; ++i)\n        Res[4 - i] = CRC[i] ? '1' : '0';\n    Res[5] = 0;\n    return (Res);\n}\n","function_prediction":"char *MakeCRC_name_conflict(char *data) {\n  char Res[5];\n  char tmp;\n  int i;\n  for (i = 0; i < 5; i++)\n    Res[i] = 0;\n  for (i = 0; i < strlen(data); i++) {\n    tmp = Res[4] ^ (data[i] == '1');\n    printf(\"%i %i %i\\t\", i, data[i] == '1', tmp);\n    Res[4] = Res[3];\n    Res[3] = Res[2];\n    Res[2] = Res[1] ^ tmp;\n    Res[1] = Res[0];\n    Res[0] = tmp;\n    printf(\"%i %i %i %i %i\\n\", tmp, Res[1], Res[2], Res[3], Res[4]);\n  }\n  for (i = 0; i < 5; i++)\n    Res_0[4 - i] = Res[i] ? '1' : '0';\n  Res_0[5] = 0;\n  return Res_0;\n}","pass":0,"source_file":"C_COMPILE/aeburriel_tetrapol-kit/misc/crc.c"}
{"compilable":1,"function":"uint8_t ReadUint8(void) {\n    uint8_t temp;\n    int data_read = read(0, &temp, 1);\n    if (data_read != 1) {\n        exit(-1);\n    }\n    return temp;\n}\n","function_prediction":"uint8_t ReadUint8_name_conflict() {\n  uint8_t value;\n  int n = read(0, &value, 1);\n  if (n != 1)\n    exit(-1);\n  return value;\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":1,"function":"uint8_t IntToHexChar(uint8_t val) {\n    if (val < 10)\n        return '0' + val;\n    else\n        return 'a' + (val - 10);\n}\n","function_prediction":"char IntToHexChar_name_conflict(unsigned char b) {\n  if (b < 10)\n    return '0' + b;\n  else\n    return 'A' + b - 10;\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":0,"function":"char *ConvertDataBytes(char *pszData, uint8_t foodTotal, uint8_t maxConvert) {\n    uint32_t outIdx = 0;\n    uint32_t i;\n    int bTruncated = 0;\n    if (foodTotal > maxConvert) {\n        bTruncated = 1;\n        foodTotal = maxConvert;\n    }\n    for (i = 0; i < maxConvert; i++) {\n        g_displayFoodString[outIdx++] = IntToHexChar((pszData[i] >> 4) & 15);\n        g_displayFoodString[outIdx++] = IntToHexChar((pszData[i]) & 15);\n    }\n    g_displayFoodString[outIdx] = '\\x00';\n    if (bTruncated)\n        strcpy(g_displayFoodString + outIdx, \"...\");\n    return g_displayFoodString;\n}\n","function_prediction":"char *ConvertDataBytes(unsigned char *data, unsigned char dataLength,\n                       unsigned char numBytes) {\n  unsigned int i;\n  unsigned int j = 0;\n\n  for (i = 0; i < numBytes; i++) {\n    g_displayFoodString[j++] = IntToHexChar(data[i] >> 4);\n    g_displayFoodString[j++] = IntToHexChar(data[i] & 0x0F);\n  }\n\n  g_displayFoodString[j] = '\\0';\n\n  if (numBytes < dataLength) {\n    g_displayFoodString[j] = '.';\n    g_displayFoodString[j + 1] = '.';\n    g_displayFoodString[j + 2] = '.';\n  }\n\n  return g_displayFoodString;\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":1,"function":"uint8_t GetFood(void) {\n    char szEchoData[32];\n    uint8_t foodTotal;\n    printf(\"FEED ME!\\n\");\n    foodTotal = ReadUint8();\n    ReadData(szEchoData, foodTotal);\n    printf(\"ATE %s\\n\", ConvertDataBytes(szEchoData, foodTotal, 16));\n    return foodTotal;\n}\n","function_prediction":"uint8_t GetFood_name_conflict(void) {\n  uint8_t food_size;\n  uint8_t food_data[16];\n\n  printf(\"FEED ME!\\n\");\n\n  food_size = ReadUint8();\n  ReadData(food_data, food_size);\n\n  printf(\"ATE %s\\n\", ConvertDataBytes(food_data, food_size, 16));\n\n  return food_size;\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":1,"function":"uint64_t exp_l(uint64_t base, uint64_t power) {\n    int i = 0;\n    uint64_t j = base;\n    if (power == 0) {\n        return 1;\n    }\n    for (i = 0; i < power - 1; i++) {\n        j *= base;\n    }\n    return j;\n}\n","function_prediction":"long exp_l_name_conflict(long base, long exp) {\n  long result;\n  int i;\n\n  if (exp == 0)\n    return 1;\n\n  result = base;\n  for (i = 0; i < exp - 1; i++)\n    result *= base;\n\n  return result;\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t xor(uint64_t a, uint64_t b) {\n    return a ^ b;\n}\n","function_prediction":"uint64_t xor_name_conflict (uint64_t a, uint64_t b) { return a ^ b; }","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t shla(uint64_t a, uint64_t dabits) {\n    uint64_t high = 0;\n    uint64_t low = 0;\n    dabits = dabits % 64;\n    if (dabits == 0) {\n        return a;\n    }\n    high = a << dabits;\n    low = a >> (64 - dabits);\n    return high | low;\n}\n","function_prediction":"uint64_t shla_name_conflict(uint64_t a, uint64_t b) {\n  b &= 0x3f;\n  if (b == 0)\n    return a;\n  return (a << b) | (a >> (64 - b));\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t shra(uint64_t a, uint64_t dabits) {\n    uint64_t high = 0;\n    uint64_t low = 0;\n    dabits = dabits % 64;\n    if (dabits == 0) {\n        return a;\n    }\n    low = a >> dabits;\n    high = a << (64 - dabits);\n    return high | low;\n}\n","function_prediction":"uint64_t shra_name_conflict(uint64_t a, uint64_t b) {\n  b &= 63;\n  if (b == 0)\n    return a;\n  return (a >> b) | (a << (64 - b));\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t swap_bytes(uint64_t value) {\n    uint64_t final = 0;\n    final |= ((value & 255) << 24);\n    final |= ((value & 65280) << 24);\n    final |= ((value & 16711680) << 40);\n    final |= ((value & 4278190080U) << 16);\n    final |= ((value & 1095216660480L) >> 16);\n    final |= ((value & 280375465082880L) >> 40);\n    final |= ((value & 71776119061217280L) >> 40);\n    final |= ((value & 18374686479671623680UL) >> 8);\n    return final;\n}\n","function_prediction":"uint64_t swap_bytes_name_conflict(uint64_t x) {\n  return (((x) & 0x00000000000000FFULL) << 56) |\n         (((x) & 0x000000000000FF00ULL) << 40) |\n         (((x) & 0x0000000000FF0000ULL) << 24) |\n         (((x) & 0x00000000FF000000ULL) << 8) |\n         (((x) & 0x000000FF00000000ULL) >> 8) |\n         (((x) & 0x0000FF0000000000ULL) >> 24) |\n         (((x) & 0x00FF000000000000ULL) >> 40) |\n         (((x) & 0xFF00000000000000ULL) >> 56);\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t swap_two(uint64_t value, uint64_t one, uint64_t two) {\n    uint64_t t_one = 0;\n    uint64_t t_two = 0;\n    uint64_t mask_one = 255;\n    uint64_t mask_two = 255;\n    mask_one <<= one * 8;\n    mask_two <<= two * 8;\n    mask_one ^= 18446744073709551615UL;\n    mask_two ^= 18446744073709551615UL;\n    t_one = (value >> (one * 8)) & 255;\n    t_two = (value >> (two * 8)) & 255;\n    value &= (mask_one & mask_two);\n    value |= (t_two << (one * 8));\n    value |= (t_one << (two * 8));\n    return value;\n}\n","function_prediction":"uint64_t swap_two_name_conflict(uint64_t x, int i, int j) {\n  uint64_t a = (x >> (i * 8)) & 0xff;\n  uint64_t b = (x >> (j * 8)) & 0xff;\n  return (x & ~(0xffULL << (i * 8))) | (b << (i * 8)) | (a << (j * 8));\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t xor_neighbor(uint64_t value) {\n    int i = 0;\n    uint64_t t = 0;\n    t |= ((value & 18374686479671623680UL) >> 8) ^ (value & 71776119061217280L);\n    t |= ((value & 71776119061217280L) >> 8) ^ (value & 280375465082880L);\n    t |= ((value & 280375465082880L) >> 8) ^ (value & 1095216660480L);\n    t |= ((value & 1095216660480L) >> 8) ^ (value & 4278190080U);\n    t |= ((value & 4278190080U) >> 8) ^ (value & 16711680);\n    t |= ((value & 16711680) >> 8) ^ (value & 65280);\n    t |= ((value & 65280) >> 8) ^ (value & 255);\n    t |= ((value & 255) << 56) ^ (value & 18374686479671623680UL);\n    return t;\n}\n","function_prediction":"uint64_t xor_neighbor_name_conflict(uint64_t x) {\n  uint64_t y = x >> 8;\n  return (x ^ y) | (x << 56);\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_one(uint64_t value) {\n    value = xor(value, 3861390726976975706L);\n    value = swap_two(value, 2, 0);\n    value = xor(value, 9943296405002333681UL);\n    value = xor(value, 16857834378267756394UL);\n    value = swap_two(value, 2, 3);\n    value = xor(value, 13674338511762446054UL);\n    value = shla(value, 16);\n    value = shla(value, 35);\n    value = shra(value, 19);\n    value = xor_neighbor(value);\n    value = shla(value, 36);\n    value = shra(value, 40);\n    value = swap_two(value, 1, 0);\n    value = xor(value, 6765015749217278743L);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = swap_two(value, 2, 1);\n    value = xor(value, 7686949068708848117L);\n    value = swap_two(value, 3, 0);\n    value = swap_bytes(value);\n    value = xor(value, 6401935715922169987L);\n    value = shra(value, 22);\n    value = xor_neighbor(value);\n    value = xor(value, 5166993816397978483L);\n    value = xor_neighbor(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 6, 5);\n    value = shla(value, 59);\n    value = swap_two(value, 5, 2);\n    value = swap_two(value, 2, 3);\n    value = shla(value, 12);\n    value = xor(value, 12476431667104729879UL);\n    value = xor(value, 5234710379464860866L);\n    value = shla(value, 6);\n    value = swap_two(value, 6, 5);\n    value = shra(value, 11);\n    value = swap_bytes(value);\n    value = xor(value, 9697206415216557238UL);\n    value = swap_bytes(value);\n    value = shra(value, 2);\n    value = xor(value, 4649309708712362587L);\n    value = shla(value, 35);\n    value = shla(value, 9);\n    value = xor_neighbor(value);\n    value = shla(value, 7);\n    value = shla(value, 38);\n    value = xor_neighbor(value);\n    value = xor(value, 16065139371609640475UL);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = swap_two(value, 2, 7);\n    value = shra(value, 51);\n    value = swap_bytes(value);\n    value = shra(value, 19);\n    value = xor(value, 10799149603522670113UL);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = shra(value, 16);\n    return value;\n}\n","function_prediction":"uint64_t munge_one_name_conflict(uint64_t x) {\n  x = xor(x, 0x35966a685c73335aULL);\n  x = swap_two(x, 2, 0);\n  x = xor(x, 0x89fdaf6604952df1ULL);\n  x = xor(x, 0xe9f30f0ce704876aULL);\n  x = swap_two(x, 2, 3);\n  x = xor(x, 0xbdc5026d3c0b56e6ULL);\n  x = shla(x, 16);\n  x = shla(x, 35);\n  x = shra(x, 19);\n  x = xor_neighbor(x);\n  x = shla(x, 36);\n  x = shra(x, 40);\n  x = swap_two(x, 1, 0);\n  x = xor(x, 0x5de229fb3804db17ULL);\n  x = swap_bytes(x);\n  x = swap_bytes(x);\n  x = swap_two(x, 2, 1);\n  x = xor(x, 0x6aad877366e921f5ULL);\n  x = swap_two(x, 3, 0);\n  x = swap_bytes(x);\n  x = xor(x, 0x58d83e9d5e6d5083ULL);\n  x = shra(x, 22);\n  x = xor_neighbor(x);\n  x = xor(x, 0x47b4d980070a9b73ULL);\n  x = xor_neighbor(x);\n  x = xor_neighbor(x);\n  x = swap_two(x, 6, 5);\n    x = shla(x,","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_two(uint64_t value) {\n    value = shla(value, 22);\n    value = swap_bytes(value);\n    value = swap_two(value, 4, 1);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shla(value, 35);\n    value = swap_two(value, 2, 6);\n    value = xor(value, 9271198935367831530UL);\n    value = shla(value, 3);\n    value = swap_two(value, 0, 1);\n    value = swap_two(value, 1, 2);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 5, 1);\n    value = shra(value, 24);\n    value = shla(value, 39);\n    value = swap_two(value, 2, 4);\n    value = xor(value, 7462025471038891063L);\n    value = swap_two(value, 4, 3);\n    value = swap_two(value, 0, 7);\n    value = shla(value, 62);\n    value = swap_bytes(value);\n    value = swap_two(value, 7, 6);\n    value = swap_two(value, 2, 6);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 5, 2);\n    value = xor_neighbor(value);\n    value = swap_two(value, 1, 7);\n    value = xor(value, 4749710960471120103L);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 1, 4);\n    value = shla(value, 10);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = shra(value, 24);\n    value = swap_two(value, 0, 4);\n    value = shra(value, 61);\n    value = swap_two(value, 3, 4);\n    value = shra(value, 35);\n    value = shla(value, 55);\n    value = shla(value, 34);\n    value = xor_neighbor(value);\n    value = xor_neighbor(value);\n    value = shra(value, 23);\n    value = shla(value, 59);\n    value = shra(value, 20);\n    value = shla(value, 28);\n    value = xor(value, 14007489205149181901UL);\n    value = xor_neighbor(value);\n    value = shra(value, 13);\n    return value;\n}\n","function_prediction":"uint64_t munge_two_name_conflict(uint64_t x) {\n  x = shla(x, 22);\n  x = swap_bytes(x);\n  x = swap_two(x, 4, 1);\n  x = swap_bytes(x);\n  x = xor_neighbor(x);\n  x = shla(x, 35);\n  x = swap_two(x, 2, 6);\n  x = xor(x, 0x80a9ea4f90944fea);\n  x = shla(x, 3);\n  x = swap_two(x, 0, 1);\n  x = swap_two(x, 1, 2);\n  x = swap_bytes(x);\n  x = xor_neighbor(x);\n  x = swap_two(x, 5, 1);\n  x = shra(x, 24);\n  x = shla(x, 39);\n  x = swap_two(x, 2, 4);\n  x = xor(x, 0x678e70a16230a437);\n  x = swap_two(x, 4, 3);\n  x = swap_two(x, 0, 7);\n  x = shla(x, 62);\n  x = swap_bytes(x);\n  x = swap_two(x, 7, 6);\n  x = swap_two(x, 2, 6);\n  x = swap_bytes(x);\n  x = xor_neighbor(x);\n  x = swap_two(x, 5, 2);\n  x = xor_neighbor(x);\n  x = swap_two(x, 1, 7);\n  x = xor(x, 0x41ea5cf418a918e7);\n  x = swap_bytes(x);\n  x = xor_neighbor(x);\n  x = swap_two(x, 1, 4);\n  x = sh","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_three(uint64_t value) {\n    value = shla(value, 18);\n    value = shla(value, 29);\n    value = swap_two(value, 5, 3);\n    value = swap_two(value, 0, 7);\n    value = shla(value, 18);\n    value = xor(value, 14531814500985747629UL);\n    value = shra(value, 33);\n    value = swap_two(value, 0, 4);\n    value = xor_neighbor(value);\n    value = swap_two(value, 6, 2);\n    value = shra(value, 13);\n    value = shra(value, 20);\n    value = xor(value, 6368261268581873766L);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = shra(value, 46);\n    value = swap_two(value, 2, 3);\n    value = shra(value, 44);\n    value = shra(value, 3);\n    value = swap_two(value, 4, 3);\n    value = xor_neighbor(value);\n    value = swap_two(value, 7, 6);\n    value = shra(value, 59);\n    value = shra(value, 38);\n    value = swap_bytes(value);\n    value = swap_two(value, 1, 5);\n    value = swap_bytes(value);\n    value = shla(value, 27);\n    value = xor(value, 13751028607104816751UL);\n    value = shra(value, 14);\n    value = shla(value, 7);\n    value = shla(value, 18);\n    value = shla(value, 57);\n    value = xor(value, 12989550924262916891UL);\n    value = xor(value, 929788566303591270L);\n    value = xor(value, 10714451137995436577UL);\n    value = xor(value, 9637405481907436618UL);\n    value = swap_two(value, 5, 1);\n    value = shla(value, 20);\n    value = shla(value, 24);\n    value = shra(value, 46);\n    value = shra(value, 13);\n    value = xor(value, 14510136432192624501UL);\n    value = shla(value, 7);\n    value = xor(value, 641209893495219690L);\n    value = xor(value, 6473287570272602621L);\n    value = xor_neighbor(value);\n    value = swap_two(value, 4, 7);\n    value = xor_neighbor(value);\n    value = shra(value, 22);\n    value = shra(value, 50);\n    value = xor_neighbor(value);\n    return value;\n}\n","function_prediction":"uint64_t munge_three_name_conflict(uint64_t x) {\n  x = shla(x, 18);\n  x = shla(x, 29);\n  x = swap_two(x, 5, 3);\n  x = swap_two(x, 0, 7);\n  x = shla(x, 18);\n  x = xor(x, 0xC9AB604BB92038AD);\n  x = shra(x, 33);\n  x = swap_two(x, 0, 4);\n  x = xor_neighbor(x);\n  x = swap_two(x, 6, 2);\n  x = shra(x, 13);\n  x = shra(x, 20);\n  x = xor(x, 0x58609BE21EB37866);\n  x = xor_neighbor(x);\n  x = swap_bytes(x);\n  x = shra(x, 46);\n  x = swap_two(x, 2, 3);\n  x = shra(x, 44);\n  x = shra(x, 3);\n  x = swap_two(x, 4, 3);\n  x = xor_neighbor(x);\n  x = swap_two(x, 7, 6);\n  x = shra(x, 59);\n  x = shra(x, 38);\n  x = swap_bytes(x);\n  x = swap_two(x, 1, 5);\n  x = swap_bytes(x);\n  x = shla(x, 27);\n  x = xor(x, 0xBED577A97EB7966F);\n  x = shra(x, 14);\n  x = shla(x, 7);\n  x = shla(x, 18);\n  x = shla(x, 57);\n  x = xor(x, 0x","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_four(uint64_t value) {\n    value = swap_two(value, 1, 7);\n    value = shla(value, 6);\n    value = swap_two(value, 2, 5);\n    value = shra(value, 57);\n    value = xor(value, 902179681853661902L);\n    value = swap_two(value, 5, 1);\n    value = shla(value, 1);\n    value = xor_neighbor(value);\n    value = xor(value, 6764338754798371998L);\n    value = xor_neighbor(value);\n    value = shla(value, 6);\n    value = xor_neighbor(value);\n    value = shla(value, 33);\n    value = shra(value, 25);\n    value = xor_neighbor(value);\n    value = xor(value, 762415417889401952L);\n    value = swap_two(value, 6, 2);\n    value = xor_neighbor(value);\n    value = xor(value, 14722425112553694635UL);\n    value = xor(value, 9800422926138268860UL);\n    value = xor_neighbor(value);\n    value = xor(value, 9644430456772077073UL);\n    value = shra(value, 8);\n    value = shra(value, 43);\n    value = xor(value, 7150187182015826299L);\n    value = swap_two(value, 3, 1);\n    value = swap_two(value, 5, 7);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shra(value, 59);\n    value = shra(value, 10);\n    value = xor_neighbor(value);\n    value = swap_two(value, 2, 1);\n    value = swap_two(value, 7, 2);\n    value = xor_neighbor(value);\n    value = xor(value, 7246290916701591349L);\n    value = xor(value, 18203423676804128435UL);\n    value = xor(value, 18403139030640123059UL);\n    value = swap_two(value, 2, 4);\n    value = swap_two(value, 5, 4);\n    value = shra(value, 11);\n    value = xor_neighbor(value);\n    value = shla(value, 39);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = xor(value, 14382479493256805148UL);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shla(value, 35);\n    value = swap_two(value, 3, 5);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    return value;\n}\n","function_prediction":"uint64_t munge_four_name_conflict(uint64_t x) {\n  x = swap_two(x, 1, 7);\n  x = shla(x, 6);\n  x = swap_two(x, 2, 5);\n  x = shra(x, 57);\n  x = xor(x, 0x47662ce47662ce47ull);\n  x = swap_two(x, 5, 1);\n  x = shla(x, 1);\n  x = xor_neighbor(x);\n  x = xor(x, 0x449e2a2a2a2a2a2aull);\n  x = xor_neighbor(x);\n  x = shla(x, 6);\n  x = xor_neighbor(x);\n  x = shla(x, 33);\n  x = shra(x, 25);\n  x = xor_neighbor(x);\n  x = xor(x, 0x2c2a449e2c2a449eull);\n  x = swap_two(x, 6, 2);\n  x = xor_neighbor(x);\n  x = xor(x, 0xda5ab33333333333ull);\n  x = xor(x, 0xdcbc888888888888ull);\n  x = xor_neighbor(x);\n  x = xor(x, 0xa611d7d7d7d7d7d7ull);\n  x = shra(x, 8);\n  x = shra(x, 43);\n  x = xor(x, 0x9ac97b9ac97b9ac9ull);\n  x = swap_two(x, 3, 1);\n  x = swap_two(x, 5, 7);\n  x = swap_bytes(x);\n  x = xor_neighbor(x);\n  x","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"int munge_all(unsigned char *data) {\n    int i = 0;\n    uint64_t *base = ((void *)0);\n    uint64_t one;\n    uint64_t two;\n    uint64_t thr;\n    uint64_t fou;\n    read(0, data, 32);\n    for (i = 0; i < 32; i++) {\n        if (((data[i] < 65) || (122 < data[i])) && (data[i] != 32)) {\n            return 0;\n        } else if (data[i] == ']') {\n            return 0;\n        } else if (data[i] == '\\\\') {\n            return 0;\n        } else if (data[i] == '^') {\n            return 0;\n        } else if (data[i] == '`') {\n            return 0;\n        } else if (data[i] == '[') {\n            return 0;\n        }\n    }\n    base = (uint64_t *)data;\n    one = munge_one(base[0]);\n    two = munge_two(base[1]);\n    thr = munge_three(base[2]);\n    fou = munge_four(base[3]);\n    one = one ^ two ^ thr ^ fou;\n    if (one == 12754495720971571466UL) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int munge_all_name_conflict(char *buf) {\n  int i;\n  unsigned long long munge;\n\n  read(0, buf, 32);\n\n  for (i = 0; i < 32; i++) {\n    if (buf[i] < 'A' || buf[i] > 'z' || buf[i] == ' ' || buf[i] == ']' ||\n        buf[i] == '\\\\' || buf[i] == '^' || buf[i] == '`' || buf[i] == '[')\n      return 0;\n  }\n\n  munge = munge_one(buf) ^ munge_two(buf + 4) ^ munge_three(buf + 8) ^\n          munge_four(buf + 12);\n\n  return munge == 0xb101124831c0110aULL;\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"int countLiveNeighbors(int x, int y) {\n    int ret = 0;\n    int bit = ((y * 110) + x);\n    if (y > 0) {\n        if ((bit_field[(bit - 110) / 8] & (1 << (7 - ((bit - 110) % 8)))))\n            ret++;\n        if ((x > 0) && (bit_field[((bit - 110) - 1) / 8] & (1 << (7 - (((bit - 110) - 1) % 8)))))\n            ret++;\n        if ((x < (110 - 1)) && (bit_field[((bit - 110) + 1) / 8] & (1 << (7 - (((bit - 110) + 1) % 8)))))\n            ret++;\n    }\n    if ((x > 0) && (bit_field[(bit - 1) / 8] & (1 << (7 - ((bit - 1) % 8)))))\n        ret++;\n    if ((x < (110 - 1)) && (bit_field[(bit + 1) / 8] & (1 << (7 - ((bit + 1) % 8)))))\n        ret++;\n    if (y < (110 - 1)) {\n        if ((bit_field[(bit + 110) / 8] & (1 << (7 - ((bit + 110) % 8)))))\n            ret++;\n        if ((x > 0) && (bit_field[((bit + 110) - 1) / 8] & (1 << (7 - (((bit + 110) - 1) % 8)))))\n            ret++;\n        if ((x < (110 - 1)) && (bit_field[((bit + 110) + 1) / 8] & (1 << (7 - (((bit + 110) + 1) % 8)))))\n            ret++;\n    }\n    return ret;\n}\n","function_prediction":"char countLiveNeighbors_name_conflict(int x, int y) {\n  char liveNeighbors = 0;\n\n  if (y > 0) {\n    if (x > 0) {\n      if (bit_field[((y - 1) * 110 + (x - 1)) / 8] &\n          (1 << (7 - ((y - 1) * 110 + (x - 1)) % 8))) {\n        liveNeighbors++;\n      }\n    }\n    if (x < 110 - 1) {\n      if (bit_field[((y - 1) * 110 + (x + 1)) / 8] &\n          (1 << (7 - ((y - 1) * 110 + (x + 1)) % 8))) {\n        liveNeighbors++;\n      }\n    }\n    if (bit_field[((y - 1) * 110 + (x)) / 8] &\n        (1 << (7 - ((y - 1) * 110 + (x)) % 8))) {\n      liveNeighbors++;\n    }\n  }\n  if (x > 0) {\n    if (bit_field[((y) * 110 + (x - 1)) / 8] &\n        (1 << (7 - ((y) * 110 + (x - 1)) % 8))) {\n      liveNeighbors++;\n    }\n  }\n  if (x < 110 - 1) {\n    if (bit_field[((y) * 110 + (x + 1)) / 8] &\n        (1 << (7 - ((y) * 110 + (x + 1)) % 8))) {\n      liveNeighbors++;\n    }\n  }\n  if (y < 110 - 1) {\n    if (x > 0) {\n            if (bit_field[((y + 1) * 110 + (x - 1)) / 8]","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_b3s23/files/b3s23.c"}
{"compilable":1,"function":"int processCoord(int x, int y) {\n    int ret;\n    if (x < 0 || y < 0) {\n        printf(\"Illegal Coordinate!\\n\");\n        fflush(stdout);\n        exit(-1);\n    }\n    if ((x >= 110) || (y >= 110)) {\n        printf(\"Illegal Coordinate!\\n\");\n        fflush(stdout);\n        exit(-1);\n    }\n    ret = (y * 110) + x;\n    return ret;\n}\n","function_prediction":"int processCoord_name_conflict(int x, int y) {\n  if (x < 0 || y < 0) {\n    puts(\"Illegal Coordinate!\");\n    fflush(stdout);\n    exit(-1);\n  }\n  if (x >= 110 || y >= 110) {\n    puts(\"Illegal Coordinate!\");\n    fflush(stdout);\n    exit(-1);\n  }\n  return x + y * 110;\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_b3s23/files/b3s23.c"}
{"compilable":1,"function":"unsigned int FindRoot(unsigned int *set, unsigned int node) {\n    if (set[node] == node)\n        return node;\n    else\n        return FindRoot(set, set[node]);\n}\n","function_prediction":"int FindRoot_name_conflict(int *parent, int x) {\n  if (parent[x] == x)\n    return x;\n  else\n    return FindRoot_name_conflict(parent, parent[x]);\n}","pass":1,"source_file":"C_COMPILE/arnikz_netclust/src/netclust.c"}
{"compilable":1,"function":"int udp_epoll_add(int epollfd, int fd, U32 u32flag) {\n    int ret = -1;\n    int block_opt = 0;\n    struct epoll_event event;\n    if (epollfd == 0 || fd == 0) {\n        ;\n        return (-1);\n    }\n    event.data.fd = fd;\n    event.events = u32flag;\n    ret = epoll_ctl(epollfd, 1, fd, &event);\n    if (ret < 0) {\n        ;\n        return (-1);\n    }\n    block_opt = fcntl(fd, 3) | 2048;\n    fcntl(fd, 4, block_opt);\n    return (0);\n}\n","function_prediction":"int udp_epoll_add_name_conflict(int epfd, int fd, uint32_t events) {\n  struct epoll_event ev = {0};\n  int ret = -1;\n\n  if (epfd == 0 || fd == 0)\n    return -1;\n\n  ev.events = events;\n  ev.data.fd = fd;\n  ret = epoll_ctl(epfd, 1, fd, &ev);\n  if (ret < 0)\n    return -1;\n\n  ev.events |= (1 << 11);\n  ev.events |= fcntl(fd, 3);\n  fcntl(fd, 4, ev.events);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_setup(INSTANCE_T *pinst) {\n    int ret = -1;\n    if (!pinst) {\n        ;\n        return (-1);\n    }\n    pinst->epollfd = epoll_create(5);\n    if (pinst->epollfd == -1) {\n        ;\n        return (-1);\n    }\n    ret = socketpair(1, SOCK_STREAM, 0, pinst->pipefd);\n    if (ret != (0)) {\n        ;\n        return (-1);\n    }\n    ret |= udp_epoll_add(pinst->epollfd, pinst->pipefd[0], EPOLLIN | EPOLLET);\n    if (ret != (0)) {\n        ;\n        return (-1);\n    }\n    int block_opt = fcntl(pinst->pipefd[1], 3) | 2048;\n    fcntl(pinst->pipefd[1], 4, block_opt);\n    g_sig_fd = pinst->pipefd[1];\n    return (0);\n}\n","function_prediction":"int udp_epoll_setup_name_conflict(struct udp_epoll_t *epoll) {\n  if (epoll == NULL)\n    return -1;\n\n  epoll->epoll_fd = epoll_create(5);\n  if (epoll->epoll_fd == -1)\n    return -1;\n\n  if (socketpair(1, 1, 0, epoll->sig_fd))\n    return -1;\n\n  if (udp_epoll_add(epoll->epoll_fd, epoll->sig_fd[0], 0x00000001 | 0x08000000))\n    return -1;\n\n  fcntl(epoll->udp_fd, 4, fcntl(epoll->udp_fd, 3) | 0x00000800);\n\n  g_sig_fd = epoll->udp_fd;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_shutdown(const INSTANCE_T *pinst) {\n    if (!pinst) {\n        ;\n        return (-1);\n    }\n    close(pinst->pipefd[0]);\n    close(pinst->pipefd[1]);\n    close(pinst->epollfd);\n    return (0);\n}\n","function_prediction":"int udp_epoll_shutdown_name_conflict(struct udp_epoll_t *udp_epoll) {\n  if (udp_epoll == NULL) {\n    return -1;\n  }\n\n  close(udp_epoll->epoll_fd);\n  close(udp_epoll->udp_fd);\n  close(udp_epoll->udp_fd_recv);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_core_listen(INSTANCE_T *pinst) {\n    int ret = 0;\n    int reuseaddr = 1;\n    int recv_buf_size = 65535;\n    int send_buf_size = 65535;\n    struct sockaddr_in lsn_addr = {0};\n    if (!pinst) {\n        ;\n        goto _E1;\n    }\n    pinst->lsn_fd = socket(2, SOCK_DGRAM, 0);\n    if (pinst->lsn_fd < 0) {\n        ;\n        goto _E1;\n    }\n    ret = setsockopt(pinst->lsn_fd, 1, 2, &reuseaddr, sizeof (reuseaddr));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    memset(&lsn_addr, 0, sizeof (lsn_addr));\n    lsn_addr.sin_family = 2;\n    lsn_addr.sin_port = pinst->task.nlsn_port;\n    lsn_addr.sin_addr.s_addr = pinst->task.u32lsn_ip;\n    ret = bind(pinst->lsn_fd, (struct sockaddr *)&lsn_addr, sizeof(struct sockaddr_in));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    goto _S0;\n  _E2:\n    close(pinst->lsn_fd);\n  _E1:\n    pinst->lsn_fd = 0;\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"int udp_core_listen_name_conflict(udp_core_t *udp) {\n  int ret = 0;\n  int on = 1;\n  struct sockaddr_in addr;\n\n  if (udp == NULL) {\n    return -1;\n  }\n\n  udp->fd = socket(2, 2, 0);\n  if (udp->fd < 0) {\n    goto err;\n  }\n\n  ret = setsockopt(udp->fd, 1, 2, &on, sizeof(on));\n  if (ret < 0) {\n    goto err;\n  }\n\n  memset(&addr, 0, sizeof(addr));\n  addr.sin_family = 2;\n  addr.sin_port = udp->port;\n  addr.sin_addr.s_addr = udp->ip;\n\n  ret = bind(udp->fd, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret < 0) {\n    goto err;\n  }\n\n  return 0;\n\nerr:\n  if (udp->fd > 0) {\n    close(udp->fd);\n  }\n  udp->fd = 0;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_core_connect(struct sockaddr_in *psrv_addr, struct sockaddr_in *plcl_addr, int *psrv_fd) {\n    int ret = 0;\n    int reuseaddr = 1;\n    int recv_buf_size = 65535;\n    int send_buf_size = 65535;\n    socklen_t socklen = sizeof(struct sockaddr_in);\n    if (!psrv_addr || !plcl_addr) {\n        ;\n        goto _E1;\n    }\n    *psrv_fd = socket(2, SOCK_DGRAM, 0);\n    if (*psrv_fd < 0) {\n        ;\n        goto _E1;\n    }\n    ret = bind(*psrv_fd, (struct sockaddr *)plcl_addr, socklen);\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ret = setsockopt(*psrv_fd, 1, 2, &reuseaddr, sizeof (reuseaddr));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ret = connect(*psrv_fd, (struct sockaddr *)psrv_addr, socklen);\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ;\n    int block_opt = fcntl(*psrv_fd, 3) | 2048;\n    fcntl(*psrv_fd, 4, block_opt);\n    goto _S0;\n  _E2:\n    close(*psrv_fd);\n  _E1:\n    *psrv_fd = 0;\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"int udp_core_connect(struct sockaddr_in *addr, struct sockaddr_in *bindaddr,\n                     int *sock) {\n  int ret = 0;\n  int on = 1;\n  int flags;\n  socklen_t addrlen;\n\n  addrlen = sizeof(struct sockaddr_in);\n\n  if (addr == NULL || bindaddr == NULL)\n    return -1;\n\n  *sock = socket(2, 2, 0);\n  if (*sock < 0)\n    goto err;\n\n  ret = bind(*sock, (struct sockaddr *)bindaddr, addrlen);\n  if (ret < 0)\n    goto err;\n\n  ret = setsockopt(*sock, 1, 2, &on, sizeof(on));\n  if (ret < 0)\n    goto err;\n\n  ret = connect(*sock, (struct sockaddr *)addr, addrlen);\n  if (ret < 0)\n    goto err;\n\n  flags = fcntl(*sock, 3);\n  flags |= (1 << 11);\n  fcntl(*sock, 4, flags);\n\n  return 0;\n\nerr:\n  if (*sock >= 0)\n    close(*sock);\n  *sock = 0;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":1,"function":"int udp_send_nonblock(int fd, const char *pbuf, size_t bufsize) {\n    int ret = (-1);\n    if (!pbuf) {\n        ;\n        return (-1);\n    }\n    while (ret < 0)\n        {\n            ret = send(fd, pbuf, bufsize, 0);\n            if (ret < 0) {\n                if ((*__errno_location()) == 11) {\n                    ;\n                    usleep(10);\n                    continue;\n                } else {\n                    return (-1);\n                }\n            }\n        }\n    return ret;\n}\n","function_prediction":"int udp_send_nonblock_name_conflict(int sock, const void *buf, size_t len) {\n  int ret = -1;\n\n  if (buf == NULL)\n    return -1;\n\n  while (ret < 0) {\n    ret = send(sock, buf, len, 0);\n    if (ret < 0) {\n      if (*__errno_location() == 11) {\n        usleep(10);\n      } else {\n        return -1;\n      }\n    }\n  }\n\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_snat_add(PROXY_APP_T *proxy_app) {\n    char cmd[512] = {0};\n    char srv_ip[16] = {0};\n    char clt_ip[16] = {0};\n    if (!proxy_app) {\n        ;\n        return (-1);\n    }\n    snprintf(cmd, sizeof (cmd), \"iptables -t nat -A POSTROUTING -p udp -d %s --sport %d -j SNAT --to %s:%u\", ip_ntoa(proxy_app->srv_ip, srv_ip), ntohs(proxy_app->lcl_port), ip_ntoa(proxy_app->clt_ip, clt_ip), ntohs(proxy_app->clt_port));\n    ;\n    system(cmd);\n    return (0);\n}\n","function_prediction":"int udp_snat_add_name_conflict(struct udp_snat_t *snat) {\n  char cmd[512] = {0};\n  char src_ip[64] = {0};\n  char dst_ip[64] = {0};\n\n  if (snat == NULL)\n    return -1;\n\n  snprintf(cmd, sizeof(cmd),\n           \"iptables -t nat -A POSTROUTING -p udp -d %s --sport %d -j SNAT \"\n           \"--to %s:%u\",\n           ip_ntoa(snat->dst_ip, dst_ip), ntohs(snat->dst_port),\n           ip_ntoa(snat->src_ip, src_ip), ntohs(snat->src_port));\n\n  system(cmd);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_snat_del(PROXY_APP_T *proxy_app) {\n    char cmd[512] = {0};\n    char srv_ip[16] = {0};\n    char clt_ip[16] = {0};\n    if (!proxy_app) {\n        ;\n        return (-1);\n    }\n    if (proxy_app->udp_type & UDP_TYPE_CLIENT) {\n        snprintf(cmd, sizeof (cmd), \"iptables -t nat -D POSTROUTING -p udp -d %s --sport %d -j SNAT --to %s:%u\", ip_ntoa(proxy_app->srv_ip, srv_ip), ntohs(proxy_app->lcl_port), ip_ntoa(proxy_app->clt_ip, clt_ip), ntohs(proxy_app->clt_port));\n        ;\n    }\n    system(cmd);\n    return (0);\n}\n","function_prediction":"int udp_snat_del_name_conflict(struct udp_snat *snat) {\n  char cmd[512] = {0};\n  char src_ip[64] = {0};\n  char dst_ip[64] = {0};\n\n  if (snat == NULL)\n    return -1;\n\n  if (snat->flags & (1 << 3)) {\n    snprintf(cmd, sizeof(cmd),\n             \"iptables -t nat -D POSTROUTING -p udp -d %s --sport %d -j SNAT \"\n             \"--to %s:%u\",\n             ip_ntoa(snat->dst_ip, dst_ip), ntohs(snat->dst_port),\n             ip_ntoa(snat->src_ip, src_ip), ntohs(snat->src_port));\n  }\n\n  system(cmd);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler_request(const INSTANCE_T *pinst, char *pbuf) {\n    int ret = 0;\n    int srv_fd = 0;\n    int recv_byte = 0;\n    int send_byte = 0;\n    char debug[16] = {0};\n    char *pdata = ((void *)0);\n    UDP_HEAD *phead = ((void *)0);\n    TIMER_T *ptimer = ((void *)0);\n    struct sockaddr_in clt_addr = {0};\n    socklen_t clt_len = sizeof (clt_addr);\n    dsp_time(385, \"\");\n    if (!pbuf) {\n        ;\n        goto _E1;\n    }\n    phead = (UDP_HEAD *)pbuf;\n    pdata = pbuf + sizeof(UDP_HEAD);\n    memset(phead, 0, sizeof(UDP_HEAD));\n    if (recv_byte < 0) {\n        ;\n        goto _E1;\n    }\n    ;\n    ptimer = time_wheel_search_by_addr(clt_addr);\n    if (!ptimer) {\n        ptimer = udp_connection_setup(pinst, phead, &clt_addr, &srv_fd);\n        if (!ptimer) {\n            ;\n            goto _E1;\n        }\n        dsp_time(417, \"udp_connection_setup\");\n    } else {\n        srv_fd = ptimer->proxy_app.srv_fd;\n        ret = time_wheel_refresh(ptimer, 2);\n        if (!ptimer) {\n            ;\n            goto _E2;\n        }\n        dsp_time(426, \"time_wheel_refresh\");\n    }\n    if (send_byte < 0) {\n        ;\n        goto _E2;\n    }\n    dsp_time(443, \"udp_epoll_handler_request\");\n    goto _S0;\n  _E2:\n    time_wheel_del(&ptimer);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"int udp_epoll_handler_request(struct udp_server *udp_server,\n                              struct udp_request *udp_request) {\n  int ret = 0;\n  int fd = 0;\n  int epoll_fd = 0;\n  int epoll_event_num = 0;\n  int epoll_timeout = 0;\n  int udp_request_size = 0;\n  int udp_request_len = 0;\n  int udp_request_type = 0;\n  int udp_request_id = 0;\n  int udp_request_data_len = 0;\n  int udp_request_data_type = 0;\n  int udp_request_data_id = 0;\n  int udp_request_data_size = 0;\n  int udp_request_data_len_size = 0;\n  int udp_request_data_len_type = 0;\n  int udp_request_data_len_id = 0;\n  int udp_request_data_len_len = 0;\n  int udp_request_data_len_data_len = 0;\n  int udp_request_data_len_data_type = 0;\n  int udp_request_data_len_data_id = 0;\n  int udp_request_data_len_data_size = 0;\n  int udp_request_data_len_data_len_size = 0;\n  int udp_request_data_len_data_len_type = 0;\n  int udp_request_data_len_data_len_id = 0;\n  int udp_request_data_len_data_len_len = 0;\n  int udp_request_data_len_data_len_data_len = 0;\n  int udp_request_data_len_data_len_data_type = 0;\n  int udp_request_data_len_data_len_data_id = 0;\n  int udp_request_data_len_data_len_data","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler_respone(const INSTANCE_T *pinst, int srv_fd, char *pbuf) {\n    int ret = 0;\n    int clt_fd = 0;\n    int recv_byte = 0;\n    int send_byte = 0;\n    struct sockaddr_in srv_addr = {0};\n    socklen_t clt_len = sizeof(struct sockaddr_in);\n    TIMER_T *ptimer = ((void *)0);\n    recv_byte = recv(srv_fd, pbuf, 65535, 0);\n    if (recv_byte <= 0) {\n        ;\n        goto _E2;\n    }\n    ;\n    ptimer = time_wheel_search_by_fd(srv_fd);\n    if (!ptimer) {\n        ;\n        goto _E2;\n    }\n    ret = time_wheel_refresh(ptimer, 2);\n    if (!ptimer) {\n        ;\n        goto _E3;\n    }\n    clt_fd = ptimer->proxy_app.clt_fd;\n    send_byte = sendto(clt_fd, pbuf, recv_byte, 0, (struct sockaddr *)&ptimer->proxy_app.clt_addr, clt_len);\n    if (send_byte <= 0) {\n        ;\n        goto _E3;\n    }\n    goto _S0;\n  _E3:\n    time_wheel_del(&ptimer);\n  _E2:\n    close(srv_fd);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"int udp_epoll_handler_respone_name_conflict(int fd, int epoll_fd, char *buf) {\n  int ret = 0;\n  int recv_len = 0;\n  int send_len = 0;\n  int sock_fd = 0;\n  struct sockaddr_in client_addr;\n  socklen_t client_addr_len = sizeof(client_addr);\n  struct time_wheel_node *node = NULL;\n\n  recv_len = recv(fd, buf, 65535, 0);\n  if (recv_len <= 0) {\n    goto err;\n  }\n\n  node = time_wheel_search_by_fd(fd);\n  if (node == NULL) {\n    goto err;\n  }\n\n  ret = time_wheel_refresh(node, 2);\n  if (node == NULL) {\n    goto err;\n  }\n\n  sock_fd = node->fd;\n  send_len = sendto(sock_fd, buf, recv_len, 0, (struct sockaddr *)&node->addr,\n                    client_addr_len);\n  if (send_len <= 0) {\n    goto err;\n  }\n\n  return 0;\n\nerr:\n  if (node != NULL) {\n    time_wheel_del(&node);\n  }\n\n  close(fd);\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":1,"function":"int udp_epoll_handler_signal(int pipefd) {\n    int ret = 0;\n    int sig = 0;\n    int jx = 0;\n    char signals[1024];\n    ret = recv(pipefd, signals, sizeof (signals), 0);\n    if (ret <= 0) {\n        ;\n        return (-1);\n    } else {\n        for (jx = 0; jx < ret; jx++) {\n            switch (signals[jx]) {\n              case 14:\n                g_timeout = 1;\n                break;\n              case 2:\n              case 15:\n                ;\n                g_enable = 0;\n                break;\n              default:\n                break;\n            }\n        }\n    }\n    return (0);\n}\n","function_prediction":"int udp_epoll_handler_signal_name_conflict(int fd) {\n  int i = 0;\n  int n = 0;\n  char buf[1024];\n\n  n = recv(fd, buf, 1024, 0);\n  if (n <= 0)\n    return -1;\n\n  for (i = 0; i < n; i++) {\n    switch (buf[i]) {\n    case 0x02:\n      g_enable = 0;\n      break;\n    case 0x0F:\n      g_enable = 0;\n      break;\n    case 0x0E:\n      g_timeout = 1;\n      break;\n    default:\n      break;\n    }\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler(const INSTANCE_T *pinst) {\n    char *buffer = ((void *)0);\n    int ret = 0;\n    int ix = 0;\n    int sockfd = 0;\n    int timeout = 0;\n    if (!pinst) {\n        ;\n        goto _E1;\n    }\n    buffer = (char *)malloc(sizeof(char) * 65535);\n    if (!buffer) {\n        ;\n        goto _E1;\n    }\n    int epoll_num = 0;\n    struct epoll_event events[65535] = {0};\n    while (g_enable)\n        {\n            epoll_num = epoll_wait(pinst->epollfd, events, 65535, -1);\n            if (epoll_num < 0 && (*__errno_location()) != 4) {\n                ;\n                goto _E2;\n            }\n            for (ix = 0; ix < epoll_num; ix++) {\n                sockfd = events[ix].data.fd;\n                if (sockfd == pinst->lsn_fd) {\n                    ret = udp_epoll_handler_request(pinst, buffer);\n                    if (ret != (0)) {\n                        ;\n                    }\n                } else if (sockfd == pinst->pipefd[0]) {\n                    ret = udp_epoll_handler_signal(pinst->pipefd[0]);\n                    if (ret != (0)) {\n                        ;\n                        goto _E2;\n                    }\n                } else if (events[ix].events & EPOLLIN) {\n                    ret = udp_epoll_handler_respone(pinst, sockfd, buffer);\n                    if (ret != (0)) {\n                        ;\n                        goto _E2;\n                    }\n                } else {\n                }\n                if (g_timeout) {\n                    time_wheel_tick();\n                    alarm(10);\n                    g_timeout = 0;\n                    continue;\n                }\n            }\n        }\n    goto _S0;\n  _E2:\n    free(buffer);\n    buffer = ((void *)0);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"int udp_epoll_handler_name_conflict(udp_epoll_t *epoll) {\n  int i, j, n;\n  int fd;\n  int ret;\n  int len;\n  int sig;\n  char *buf;\n  struct epoll_event ev[65535];\n  struct sockaddr_in addr;\n  socklen_t addr_len;\n  time_wheel_t *tw;\n  udp_connection_t *conn;\n\n  dsp_time(400, \"udp_epoll_handler_name_conflict\");\n\n  if (epoll == NULL)\n    return -1;\n\n  if ((buf = malloc(65535)) == NULL)\n    return -1;\n\n  memset(buf, 0, 65535);\n\n  while (g_enable) {\n    n = epoll_wait(epoll->epfd, ev, 65535, -1);\n    if (n < 0 && *__errno_location() != 4) {\n      free(buf);\n      return -1;\n    }\n\n    for (i = 0; i < n; i++) {\n      fd = ev[i].data.fd;\n      if (fd == epoll->fd_request) {\n        udp_epoll_handler_name_conflict_request(epoll, buf);\n      } else if (fd == epoll->fd_signal) {\n        udp_epoll_handler_name_conflict_signal(epoll->fd_signal);\n      } else if (ev[i].events & 0x01) {\n        udp_epoll_handler_name_conflict_respone(epoll, fd, buf);\n      }\n\n      if (g_timeout) {\n        time_wheel_tick();\n        alarm(10);\n        g_timeout = 0;\n      }\n    }\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":1,"function":"int ip_aton(char *sip) {\n    int ix = 0;\n    int rv = 0;\n    U8 val[4] = {0};\n    if (sip == ((void *)0)) {\n        return 0;\n    }\n    sscanf(sip, \"%hhu.%hhu.%hhu.%hhu\", &val[3], &val[2], &val[1], &val[0]);\n    do {\n        rv <<= 8;\n        rv |= val[ix] & 255;\n    } while (++ix < 4);\n    return rv;\n}\n","function_prediction":"uint32_t ip_aton_name_conflict(const char *ip) {\n  uint32_t ip_addr = 0;\n  uint8_t ip_octets[4] = {0};\n  int i = 0;\n\n  if (ip == NULL)\n    return 0;\n\n  __isoc99_sscanf(ip, \"%hhu.%hhu.%hhu.%hhu\", &ip_octets[3], &ip_octets[2],\n                  &ip_octets[1], &ip_octets[0]);\n\n  for (i = 0; i < 4; i++) {\n    ip_addr <<= 8;\n    ip_addr |= ip_octets[i];\n  }\n\n  return ip_addr;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":1,"function":"int ip_atoh(char *sip) {\n    int ix = 0;\n    int rv = 0;\n    U8 val[4] = {0};\n    if (sip == ((void *)0)) {\n        return 0;\n    }\n    sscanf(sip, \"%hhu.%hhu.%hhu.%hhu\", &val[0], &val[1], &val[2], &val[3]);\n    do {\n        rv <<= 8;\n        rv |= val[ix] & 255;\n    } while (++ix < 4);\n    return rv;\n}\n","function_prediction":"uint32_t ip_atoh_name_conflict(const char *ip) {\n  uint32_t ip_addr = 0;\n  uint8_t ip_octets[4] = {0};\n  int i = 0;\n\n  if (ip == NULL)\n    return 0;\n\n  __isoc99_sscanf(ip, \"%hhu.%hhu.%hhu.%hhu\", &ip_octets[0], &ip_octets[1],\n                  &ip_octets[2], &ip_octets[3]);\n\n  for (i = 0; i < 4; i++) {\n    ip_addr <<= 8;\n    ip_addr |= ip_octets[i];\n  }\n\n  return ip_addr;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":1,"function":"char *ip_htoa(int sip, char *rvip) {\n    if (rvip == ((void *)0)) {\n        return rvip;\n    }\n    sprintf(rvip, \"%d.%d.%d.%d\", sip >> 24 & 255, sip >> 16 & 255, sip >> 8 & 255, sip & 255);\n    return rvip;\n}\n","function_prediction":"char *ip_htoa_name_conflict(uint32_t ip, char *buf) {\n  if (buf)\n    sprintf(buf, \"%d.%d.%d.%d\", (ip >> 24) & 0xff, (ip >> 16) & 0xff,\n            (ip >> 8) & 0xff, ip & 0xff);\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":1,"function":"char *ip_ntoa(int sip, char *rvip) {\n    if (rvip == ((void *)0)) {\n        return rvip;\n    }\n    sprintf(rvip, \"%d.%d.%d.%d\", sip & 255, sip >> 8 & 255, sip >> 16 & 255, sip >> 24 & 255);\n    return rvip;\n}\n","function_prediction":"char *ip_ntoa_name_conflict(uint32_t ip, char *buf) {\n  if (buf)\n    sprintf(buf, \"%d.%d.%d.%d\", (ip & 0xff), ((ip >> 8) & 0xff),\n            ((ip >> 16) & 0xff), ((ip >> 24) & 0xff));\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":1,"function":"int time_wheel_create() {\n    int i;\n    g_cur_slot = 0;\n    for (i = 0; i < 4; i++) {\n        gp_slots[i] = ((void *)0);\n    }\n    return (0);\n}\n","function_prediction":"int time_wheel_create_name_conflict() {\n  int i;\n  g_cur_slot = 0;\n  for (i = 0; i < 4; i++) {\n    gp_slots[i] = NULL;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":0,"function":"int time_wheel_destroy() {\n    int i;\n    TIMER_T *pt = ((void *)0);\n    for (i = 0; i < 4; i++) {\n        pt = gp_slots[i];\n        while (pt)\n            {\n                gp_slots[i] = pt->next;\n                free(pt);\n                pt = gp_slots[i];\n            }\n    }\n    return (0);\n}\n","function_prediction":"int time_wheel_destroy_name_conflict() {\n  int i;\n  for (i = 0; i < 4; i++) {\n    struct time_wheel_node *p = gp_slots[i];\n    while (p) {\n      gp_slots[i] = p->next;\n      free(p);\n      p = gp_slots[i];\n    }\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":0,"function":"int time_wheel_tick() {\n    TIMER_T *pt = gp_slots[g_cur_slot];\n    TIMER_T *pn = ((void *)0);\n    ;\n    while (pt)\n        {\n            ;\n            if (pt->rotation > 0) {\n                pt->rotation--;\n                pt = pt->next;\n            } else {\n                ;\n                pt->cb_func(&pt->proxy_app);\n                if (pt == gp_slots[g_cur_slot]) {\n                    gp_slots[g_cur_slot] = pt->next;\n                    free(pt);\n                    if (gp_slots[g_cur_slot]) {\n                        gp_slots[g_cur_slot]->prev = ((void *)0);\n                    }\n                    pt = gp_slots[g_cur_slot];\n                } else {\n                    pt->prev->next = pt->next;\n                    if (pt->next) {\n                        pt->next->prev = pt->prev;\n                    }\n                    pn = pt->next;\n                    free(pt);\n                    pt = pn;\n                }\n            }\n        }\n    g_cur_slot = ++g_cur_slot % 4;\n    return (0);\n}\n","function_prediction":"int time_wheel_tick_name_conflict() {\n  struct slot *p_slot = gp_slots[g_cur_slot];\n  while (p_slot != NULL) {\n    if (p_slot->timeout > 0) {\n      p_slot->timeout--;\n      p_slot = p_slot->next;\n    } else {\n      p_slot->callback(p_slot);\n      if (p_slot == gp_slots[g_cur_slot]) {\n        gp_slots[g_cur_slot] = p_slot->next;\n        free(p_slot);\n        if (gp_slots[g_cur_slot] != NULL) {\n          gp_slots[g_cur_slot]->prev = NULL;\n        }\n        p_slot = gp_slots[g_cur_slot];\n      } else {\n        p_slot->prev->next = p_slot->next;\n        if (p_slot->next != NULL) {\n          p_slot->next->prev = p_slot->prev;\n        }\n        struct slot *p_tmp = p_slot->next;\n        free(p_slot);\n        p_slot = p_tmp;\n      }\n    }\n  }\n  g_cur_slot = (g_cur_slot + 1) % 4;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":1,"function":"int *make(int rows, int cols) {\n    return (int *)malloc(rows * cols * sizeof(int));\n}\n","function_prediction":"int *make_name_conflict(int n, int m) { return malloc(n * m * sizeof(int)); }","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":1,"function":"int penalty(int *lhs, int *rhs, int mwidth, int *individuum) {\n    int *l = make(mwidth, mwidth);\n    eval(lhs, mwidth, individuum, l);\n    int *r = make(mwidth, mwidth);\n    eval(rhs, mwidth, individuum, r);\n    int s = 0;\n    for (int row = 0; row < mwidth; row++) {\n        for (int col = 0; col < mwidth; col++) {\n            int x = l[row * mwidth + col];\n            int y = r[row * mwidth + col];\n            int p = 0;\n            if ((row == 0) && (col == mwidth - 1)) {\n                p = (x > y) ? 0 : 10000 * (y - x + 1);\n            } else {\n                p = (x >= y) ? 0 : y * y - x * x;\n            }\n            if (p > 1000000)\n                p = 1000000;\n            s += p;\n        }\n    }\n    free(l);\n    free(r);\n    return s;\n}\n","function_prediction":"int penalty_name_conflict(int *a, int *b, int n, int *p) {\n  int *ea = make(n, n);\n  eval(a, n, p, ea);\n  int *eb = make(n, n);\n  eval(b, n, p, eb);\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      int ea_ij = ea[i * n + j];\n      int eb_ij = eb[i * n + j];\n      int diff;\n      if (i == 0 && j == n - 1) {\n        diff = eb_ij > ea_ij ? 10000 * (eb_ij - ea_ij + 1) : 0;\n      } else {\n        diff = eb_ij > ea_ij ? eb_ij * eb_ij - ea_ij * ea_ij : 0;\n      }\n      if (diff > 1000000) {\n        diff = 1000000;\n      }\n      sum += diff;\n    }\n  }\n  free(ea);\n  free(eb);\n  return sum;\n}","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":1,"function":"int anneal(int total, int *lhs, int *rhs, int mcount, int mwidth, int *individuum) {\n    int best = penalty(lhs, rhs, mwidth, individuum);\n    if (0 == best)\n        return 0;\n    size_t s = mcount * mwidth * mwidth * sizeof(int);\n    int *candidate = malloc(s);\n    for (int steps = 0; steps < total; steps++) {\n        memcpy(candidate, individuum, s);\n        mutate(mcount, mwidth, candidate);\n        int p = penalty(lhs, rhs, mwidth, candidate);\n        int luck = 0 == random() % total;\n        if (p <= best || luck) {\n            memcpy(individuum, candidate, s);\n            best = p;\n        }\n    }\n    free(candidate);\n    return best;\n}\n","function_prediction":"int anneal_name_conflict(int steps, int *a, int *b, int n, int m, int *c) {\n  int i, p, q, r;\n  int *d;\n\n  p = penalty(a, b, m, c);\n  if (p == 0)\n    return 0;\n\n  d = malloc(sizeof(int) * n * m * m);\n  for (i = 0; i < steps; i++) {\n    memcpy(d, c, sizeof(int) * n * m * m);\n    mutate(n, m, d);\n    q = penalty(a, b, m, d);\n    if (q <= p || random() % steps == 0) {\n      memcpy(c, d, sizeof(int) * n * m * m);\n      p = q;\n    }\n  }\n  free(d);\n  return p;\n}","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":1,"function":"int bits(int x) {\n    int c = 0;\n    while (x > 0)\n        {\n            x >>= 1;\n            c++;\n        }\n    return c;\n}\n","function_prediction":"int bits_name_conflict(int n) {\n  int i;\n  for (i = 0; n > 0; n >>= 1) {\n    i++;\n  }\n  return i;\n}","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":0,"function":"static inline int timespec_subtract(struct timespec *result, struct timespec *after, struct timespec *before) {\n    result->tv_nsec = after->tv_nsec - before->tv_nsec;\n    if (result->tv_nsec < 0) {\n        result->tv_nsec += 1000000000;\n        result->tv_sec = after->tv_sec - before->tv_sec - 1;\n        return 1;\n    } else {\n        result->tv_sec = after->tv_sec - before->tv_sec;\n        return 0;\n    }\n}\n","function_prediction":"int timespec_subtract(struct timespec *result, struct timespec *x,\n                      struct timespec *y) {\n  result->tv_sec = x->tv_sec - y->tv_sec;\n  if (result->tv_sec < 0) {\n    result->tv_sec += 1000000000;\n    result->tv_nsec = x->tv_nsec - y->tv_nsec - 1;\n  } else {\n    result->tv_nsec = x->tv_nsec - y->tv_nsec;\n  }\n\n  return (result->tv_sec < 0);\n}","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":0,"function":"char control_letter(size_t rest) {\n    const char sequence[] = \"TRWAGMYFPDXBNJZSQVHLCKE\";\n    if (rest >= sizeof (sequence)) {\n        return '.';\n    } else {\n        return sequence[rest];\n    }\n}\n","function_prediction":"char control_letter_name_conflict(uint8_t control) {\n  const char letters[] =\n      \"TRWMGFAZSJNBXDPQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHVQEKCLHV","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"int nif_detect_type(const char *nif) {\n    char pos_zero = nif[0];\n    if (((*__ctype_b_loc())[(int)((pos_zero))] & (unsigned short)_ISdigit)) {\n        return 10;\n    } else if (pos_zero == 'X' || pos_zero == 'Y' || pos_zero == 'Z') {\n        return 20;\n    } else {\n        return -20;\n    }\n}\n","function_prediction":"int nif_detect_type_name_conflict(char *s) {\n  if (__ctype_b_loc()[(unsigned char)s[0]] & 0x0800)\n    return 10;\n  if (s[0] == 'X' || s[0] == 'Y' || s[0] == 'Z')\n    return 20;\n  return -20;\n}","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":1,"function":"char nie_convert_init_letter(const char *nie) {\n    char ret_val = -1;\n    switch (nie[0]) {\n      case 'X':\n        ret_val = '0';\n        break;\n      case 'Y':\n        ret_val = '1';\n        break;\n      case 'Z':\n        ret_val = '2';\n        break;\n      default:\n        break;\n    }\n    return ret_val;\n}\n","function_prediction":"unsigned char nie_convert_init_letter_name_conflict(const char *nie) {\n  unsigned char letter = 0xFF;\n\n  switch (nie[0]) {\n  case 'X':\n    letter = 0x30;\n    break;\n  case 'Y':\n    letter = 0x31;\n    break;\n  case 'Z':\n    letter = 0x32;\n    break;\n  }\n\n  return letter;\n}","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":1,"function":"long prepare_nif(const char *nif) {\n    char buf_nif_no_letter[9];\n    memset(buf_nif_no_letter, 0, sizeof (buf_nif_no_letter));\n    for (size_t i = 0; i < sizeof (buf_nif_no_letter) - 1; ++i) {\n        buf_nif_no_letter[i] = nif[i];\n    }\n    int nif_type = nif_detect_type(nif);\n    if (nif_type == 20) {\n        buf_nif_no_letter[0] = nie_convert_init_letter(nif);\n    }\n    char *error_str;\n    long result = strtol(buf_nif_no_letter, &error_str, 10);\n    if (error_str[0]) {\n        result = -20;\n    }\n    return result;\n}\n","function_prediction":"long prepare_nif_name_conflict(char *nif) {\n  char nif_copy[9];\n  char *endptr;\n  long nif_long;\n  int nif_type;\n\n  memset(nif_copy, 0, 9);\n  for (size_t i = 0; i < 8; i++) {\n    nif_copy[i] = nif[i];\n  }\n\n  nif_type = nif_detect_type(nif);\n  if (nif_type == 20) {\n    nif_copy[0] = nie_convert_init_letter(nif);\n  }\n\n  nif_long = strtol(nif_copy, &endptr, 10);\n  if (*endptr != '\\0') {\n    nif_long = -20;\n  }\n\n  return nif_long;\n}","pass":1,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":1,"function":"int nif_check_integrity(const char *nif) {\n    size_t nif_size = strlen(nif);\n    if (nif_size != 9) {\n        return -10;\n    }\n    long num_nif = prepare_nif(nif);\n    if (num_nif == -20) {\n        return -20;\n    }\n    int rest = num_nif % 23;\n    return nif[8] == control_letter(rest) ? 1 : 0;\n}\n","function_prediction":"int nif_check_integrity_name_conflict(const char *nif) {\n  if (strlen(nif) != 9)\n    return -10;\n\n  long nif_number = prepare_nif(nif);\n\n  if (nif_number == -20)\n    return -20;\n\n  return nif[8] == control_letter(nif_number % 23);\n}","pass":1,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"struct Node *newNode(struct Node *sentinel) {\n    struct Node *p;\n    p = (struct Node *)malloc(sizeof(struct Node));\n    if (p == ((void *)0)) {\n        fprintf(stderr, \"Memory allocation error...\\n\");\n        exit(1);\n    }\n    p->label = 0;\n    p->data = 0;\n    p->leftSon = sentinel;\n    p->rightSon = sentinel;\n    p->father = sentinel;\n    p->colour = 0;\n    return p;\n}\n","function_prediction":"Node *newNode_name_conflict(void *data) {\n  Node *node = (Node *)malloc(sizeof(Node));\n  if (node == NULL) {\n    fwrite(\"Memory allocation error...\\n\", 1, 27, stderr);\n    exit(1);\n  }\n  node->prev = NULL;\n  node->next = NULL;\n  node->data = data;\n  node->key = data;\n  node->value = data;\n  node->hash = 0;\n  return node;\n}","pass":0,"source_file":"C_COMPILE/akrzemi1_Mach7/code/msvc/RedBlackTree/AnotherRBTree.c"}
{"compilable":0,"function":"cpu_t init_cpu(uint8_t *opcodes, uint16_t size, uint16_t start_address) {\n    cpu_t cpu = {};\n    int i = 0;\n    cpu.memory_pointer = start_address;\n    while (cpu.memory_pointer < start_address + size && cpu.memory_pointer < 65535)\n        {\n            cpu.memory[cpu.memory_pointer++] = opcodes[i++];\n        }\n    cpu.memory_pointer = start_address;\n    return cpu;\n}\n","function_prediction":"void *init_cpu(void *cpu, void *rom, unsigned short rom_size,\n               unsigned short ram_size) {\n  unsigned char ram[0x20000];\n  memset(ram, 0, 0x20000);\n\n  unsigned short i = 0;\n  for (unsigned short j = ram_size; j < rom_size + ram_size && j != 0xFFFF;\n       j++) {\n    ram[j] = ((unsigned char *)rom)[i];\n    i++;\n  }\n\n  memcpy(cpu, ram, 0x20000);\n  return cpu;\n}","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"uint16_t concat_numbers(uint8_t arg1, uint8_t arg2) {\n    return (arg1 << 8) + arg2;\n}\n","function_prediction":"uint16_t concat_numbers_name_conflict(uint8_t high, uint8_t low) { return (high << 8) + low; }","pass":1,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"uint16_t get_address_from_registers(cpu_t *cpu, register_t r1, register_t r2) {\n    return concat_numbers(cpu->registers[r1], cpu->registers[r2]);\n}\n","function_prediction":"int get_address_from_registers_name_conflict(char *registers, int reg1, int reg2) {\n  return concat_numbers(registers[reg1], registers[reg2]);\n}","pass":1,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"uint8_t pop_stack(cpu_t *cpu) {\n    return cpu->stack[cpu->stack_pointer--];\n}\n","function_prediction":"char pop_stack_name_conflict(char *stack) {\n  unsigned short *sp = (unsigned short *)(stack + 0x20000);\n  unsigned short *sp_val = (unsigned short *)(stack + 0x10000);\n  unsigned short sp_val_val = *sp;\n  *sp -= 1;\n  return sp_val[sp_val_val];\n}","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":0,"function":"int execute_command(cpu_t *cpu, code_t command) {\n    uint16_t b_address = get_address_from_registers(cpu, REG_C, REG_B);\n    uint16_t d_address = get_address_from_registers(cpu, REG_E, REG_D);\n    uint16_t h_address = get_address_from_registers(cpu, REG_L, REG_H);\n    uint8_t next_byte = cpu->memory[cpu->memory_pointer + 1];\n    switch (command) {\n      case ADD_A:\n        cpu->registers[REG_A] += cpu->registers[REG_A];\n        break;\n      case ADD_B:\n        cpu->registers[REG_A] += cpu->registers[REG_B];\n        break;\n      case ADD_C:\n        cpu->registers[REG_A] += cpu->registers[REG_C];\n        break;\n      case ADD_D:\n        cpu->registers[REG_A] += cpu->registers[REG_D];\n        break;\n      case ADD_E:\n        cpu->registers[REG_A] += cpu->registers[REG_E];\n        break;\n      case ADD_H:\n        cpu->registers[REG_A] += cpu->registers[REG_H];\n        break;\n      case ADD_L:\n        cpu->registers[REG_A] += cpu->registers[REG_L];\n        break;\n      case ADD_M:\n        cpu->registers[REG_A] += cpu->memory[h_address];\n        break;\n      case ADI_D8:\n        cpu->registers[REG_A] += cpu->memory[++cpu->memory_pointer];\n        break;\n      case ADC_A:\n        cpu->registers[REG_A] += cpu->registers[REG_A] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_B:\n        cpu->registers[REG_A] += cpu->registers[REG_B] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_C:\n        cpu->registers[REG_A] += cpu->registers[REG_C] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_D:\n        cpu->registers[REG_A] += cpu->registers[REG_D] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_E:\n        cpu->registers[REG_A] += cpu->registers[REG_E] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_H:\n        cpu->registers[REG_A] += cpu->registers[REG_H] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_L:\n        cpu->registers[REG_A] += cpu->registers[REG_L] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_M:\n        cpu->registers[REG_A] += cpu->memory[h_address] + cpu->flags[CARRY_FLAG];\n        break;\n      case ACI_D8:\n        cpu->registers[REG_A] += cpu->memory[++cpu->memory_pointer] + cpu->flags[CARRY_FLAG];\n        break;\n      case ANA_A:\n        cpu->registers[REG_A] &= cpu->registers[REG_A];\n        break;\n      case ANA_B:\n        cpu->registers[REG_A] &= cpu->registers[REG_B];\n        break;\n      case ANA_C:\n        cpu->registers[REG_A] &= cpu->registers[REG_C];\n        break;\n      case ANA_D:\n        cpu->registers[REG_A] &= cpu->registers[REG_D];\n        break;\n      case ANA_E:\n        cpu->registers[REG_A] &= cpu->registers[REG_E];\n        break;\n      case ANA_H:\n        cpu->registers[REG_A] &= cpu->registers[REG_H];\n        break;\n      case ANA_L:\n        cpu->registers[REG_A] &= cpu->registers[REG_L];\n        break;\n      case ANA_M:\n        cpu->registers[REG_A] &= cpu->memory[h_address];\n        break;\n      case ANI_D8:\n        cpu->registers[REG_A] &= cpu->memory[++cpu->memory_pointer];\n        break;\n      case CALL_A16:\n        break;\n      case CZ_A16:\n        break;\n      case CNZ_A16:\n        break;\n      case CP_A16:\n        break;\n      case CM_A16:\n        break;\n      case CC_A16:\n        break;\n      case CNC_A16:\n        break;\n      case CPE_A16:\n        break;\n      case CPO_A16:\n        break;\n      case CMA:\n        cpu->registers[REG_A] = ~cpu->registers[REG_A];\n        break;\n      case CMC:\n        cpu->flags[CARRY_FLAG] = ~cpu->flags[CARRY_FLAG];\n        break;\n      case CMP_A:\n        set_flag(cpu, ZERO_FLAG, 1);\n        break;\n      case CMP_B:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_B] - cpu->registers[REG_A]));\n        break;\n      case CMP_C:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_C] - cpu->registers[REG_A]));\n        break;\n      case CMP_D:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_D] - cpu->registers[REG_A]));\n        break;\n      case CMP_E:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_C] - cpu->registers[REG_A]));\n        break;\n      case CMP_H:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_H] - cpu->registers[REG_A]));\n        break;\n      case CMP_L:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_L] - cpu->registers[REG_A]));\n        break;\n      case CMP_M:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->memory[h_address] - cpu->registers[REG_A]));\n        break;\n      case CPI_D8:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->memory[++cpu->memory_pointer] - cpu->registers[REG_A]));\n        break;\n      case DAA:\n        break;\n      case DAD_B:\n        b_address += h_address;\n        break;\n      case DAD_D:\n        d_address += h_address;\n        break;\n      case DAD_H:\n        h_address += h_address;\n        break;\n      case DAD_SP:\n        cpu->stack_pointer += h_address;\n        break;\n      case DCR_A:\n        cpu->registers[REG_A]--;\n        break;\n      case DCR_B:\n        cpu->registers[REG_B]--;\n        break;\n      case DCR_C:\n        cpu->registers[REG_C]--;\n        break;\n      case DCR_D:\n        cpu->registers[REG_D]--;\n        break;\n      case DCR_E:\n        cpu->registers[REG_E]--;\n        break;\n      case DCR_H:\n        cpu->registers[REG_H]--;\n        break;\n      case DCR_L:\n        cpu->registers[REG_L]--;\n        break;\n      case DCR_M:\n        cpu->memory[h_address]--;\n        break;\n      case DCX_B:\n        b_address--;\n        break;\n      case DCX_D:\n        d_address--;\n        break;\n      case DCX_H:\n        h_address--;\n        break;\n      case DCX_SP:\n        cpu->stack_pointer--;\n        break;\n      case DI:\n        cpu->interrupts_enabled = 0;\n        break;\n      case EI:\n        cpu->interrupts_enabled = 1;\n        break;\n      case IN_PP:\n        break;\n      case INR_A:\n        cpu->registers[REG_A]++;\n        break;\n      case INR_B:\n        cpu->registers[REG_B]++;\n        break;\n      case INR_C:\n        cpu->registers[REG_C]++;\n        break;\n      case INR_D:\n        cpu->registers[REG_D]++;\n        break;\n      case INR_E:\n        cpu->registers[REG_E]++;\n        break;\n      case INR_H:\n        cpu->registers[REG_H]++;\n        break;\n      case INR_L:\n        cpu->registers[REG_L]++;\n        break;\n      case INR_M:\n        cpu->memory[h_address]++;\n        break;\n      case INX_B:\n        b_address++;\n        break;\n      case INX_D:\n        d_address++;\n        break;\n      case INX_H:\n        h_address++;\n        break;\n      case INX_SP:\n        cpu->stack_pointer++;\n        break;\n      case JMP_A16:\n        cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JZ_A16:\n        if (cpu->flags[ZERO_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JNZ_A16:\n        if (!cpu->flags[ZERO_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JP_A16:\n        break;\n      case JM_A16:\n        break;\n      case JC_A16:\n        if (cpu->flags[CARRY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JNC_A16:\n        if (!cpu->flags[CARRY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JPE_A16:\n        if (cpu->flags[PARITY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JPO_A16:\n        if (!cpu->flags[PARITY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case LDA_A16:\n        cpu->registers[REG_A] = cpu->memory[concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer])];\n        break;\n      case LDAX_B:\n        cpu->registers[REG_A] = cpu->memory[b_address];\n        break;\n      case LDAX_D:\n        cpu->registers[REG_A] = cpu->memory[d_address];\n        break;\n      case LHLD_A16:\n        cpu->registers[REG_L] = (uint8_t)(cpu->memory[h_address] & 255);\n        cpu->registers[REG_H] = (uint8_t)(cpu->memory[h_address] >> 8);\n        break;\n      case LXI_B_D16:\n        cpu->registers[REG_C] = cpu->memory[++cpu->memory_pointer];\n        cpu->registers[REG_B] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case LXI_H_D16:\n        cpu->registers[REG_L] = cpu->memory[++cpu->memory_pointer];\n        cpu->registers[REG_H] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case LXI_SP_D16:\n        cpu->stack_pointer = concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer]);\n        break;\n      case MOV_A_A:\n        cpu->registers[REG_A] = cpu->registers[REG_A];\n        break;\n      case MOV_A_B:\n        cpu->registers[REG_A] = cpu->registers[REG_B];\n        break;\n      case MOV_A_C:\n        cpu->registers[REG_A] = cpu->registers[REG_C];\n        break;\n      case MOV_A_D:\n        cpu->registers[REG_A] = cpu->registers[REG_D];\n        break;\n      case MOV_A_E:\n        cpu->registers[REG_A] = cpu->registers[REG_E];\n        break;\n      case MOV_A_H:\n        cpu->registers[REG_A] = cpu->registers[REG_H];\n        break;\n      case MOV_A_L:\n        cpu->registers[REG_A] = cpu->registers[REG_L];\n        break;\n      case MOV_A_M:\n        cpu->registers[REG_A] = cpu->memory[h_address];\n        break;\n      case MOV_B_A:\n        cpu->registers[REG_B] = cpu->registers[REG_A];\n        break;\n      case MOV_B_B:\n        cpu->registers[REG_B] = cpu->registers[REG_B];\n        break;\n      case MOV_B_C:\n        cpu->registers[REG_B] = cpu->registers[REG_C];\n        break;\n      case MOV_B_D:\n        cpu->registers[REG_B] = cpu->registers[REG_D];\n        break;\n      case MOV_B_E:\n        cpu->registers[REG_B] = cpu->registers[REG_E];\n        break;\n      case MOV_B_H:\n        cpu->registers[REG_B] = cpu->registers[REG_H];\n        break;\n      case MOV_B_L:\n        cpu->registers[REG_B] = cpu->registers[REG_L];\n        break;\n      case MOV_B_M:\n        cpu->registers[REG_B] = cpu->memory[h_address];\n        break;\n      case MOV_C_A:\n        cpu->registers[REG_C] = cpu->registers[REG_A];\n        break;\n      case MOV_C_B:\n        cpu->registers[REG_C] = cpu->registers[REG_B];\n        break;\n      case MOV_C_C:\n        cpu->registers[REG_C] = cpu->registers[REG_C];\n        break;\n      case MOV_C_D:\n        cpu->registers[REG_C] = cpu->registers[REG_D];\n        break;\n      case MOV_C_E:\n        cpu->registers[REG_C] = cpu->registers[REG_E];\n        break;\n      case MOV_C_H:\n        cpu->registers[REG_C] = cpu->registers[REG_H];\n        break;\n      case MOV_C_L:\n        cpu->registers[REG_C] = cpu->registers[REG_L];\n        break;\n      case MOV_C_M:\n        cpu->registers[REG_C] = cpu->memory[h_address];\n        break;\n      case MOV_D_A:\n        cpu->registers[REG_D] = cpu->registers[REG_A];\n        break;\n      case MOV_D_B:\n        cpu->registers[REG_D] = cpu->registers[REG_B];\n        break;\n      case MOV_D_C:\n        cpu->registers[REG_D] = cpu->registers[REG_C];\n        break;\n      case MOV_D_D:\n        cpu->registers[REG_D] = cpu->registers[REG_D];\n        break;\n      case MOV_D_E:\n        cpu->registers[REG_D] = cpu->registers[REG_E];\n        break;\n      case MOV_D_H:\n        cpu->registers[REG_D] = cpu->registers[REG_H];\n        break;\n      case MOV_D_L:\n        cpu->registers[REG_D] = cpu->registers[REG_L];\n        break;\n      case MOV_D_M:\n        cpu->registers[REG_D] = cpu->memory[h_address];\n        break;\n      case MOV_E_A:\n        cpu->registers[REG_E] = cpu->registers[REG_A];\n        break;\n      case MOV_E_B:\n        cpu->registers[REG_E] = cpu->registers[REG_B];\n        break;\n      case MOV_E_C:\n        cpu->registers[REG_E] = cpu->registers[REG_C];\n        break;\n      case MOV_E_D:\n        cpu->registers[REG_E] = cpu->registers[REG_D];\n        break;\n      case MOV_E_E:\n        cpu->registers[REG_E] = cpu->registers[REG_E];\n        break;\n      case MOV_E_H:\n        cpu->registers[REG_E] = cpu->registers[REG_H];\n        break;\n      case MOV_E_L:\n        cpu->registers[REG_E] = cpu->registers[REG_L];\n        break;\n      case MOV_E_M:\n        cpu->registers[REG_E] = cpu->memory[h_address];\n        break;\n      case MOV_H_A:\n        cpu->registers[REG_H] = cpu->registers[REG_A];\n        break;\n      case MOV_H_B:\n        cpu->registers[REG_H] = cpu->registers[REG_B];\n        break;\n      case MOV_H_C:\n        cpu->registers[REG_H] = cpu->registers[REG_C];\n        break;\n      case MOV_H_D:\n        cpu->registers[REG_H] = cpu->registers[REG_D];\n        break;\n      case MOV_H_E:\n        cpu->registers[REG_H] = cpu->registers[REG_E];\n        break;\n      case MOV_H_H:\n        cpu->registers[REG_H] = cpu->registers[REG_H];\n        break;\n      case MOV_H_L:\n        cpu->registers[REG_H] = cpu->registers[REG_L];\n        break;\n      case MOV_H_M:\n        cpu->registers[REG_H] = cpu->memory[h_address];\n        break;\n      case MOV_L_A:\n        cpu->registers[REG_L] = cpu->registers[REG_A];\n        break;\n      case MOV_L_B:\n        cpu->registers[REG_L] = cpu->registers[REG_B];\n        break;\n      case MOV_L_C:\n        cpu->registers[REG_L] = cpu->registers[REG_C];\n        break;\n      case MOV_L_D:\n        cpu->registers[REG_L] = cpu->registers[REG_D];\n        break;\n      case MOV_L_E:\n        cpu->registers[REG_L] = cpu->registers[REG_E];\n        break;\n      case MOV_L_H:\n        cpu->registers[REG_L] = cpu->registers[REG_H];\n        break;\n      case MOV_L_L:\n        cpu->registers[REG_L] = cpu->registers[REG_L];\n        break;\n      case MOV_L_M:\n        cpu->registers[REG_L] = cpu->memory[h_address];\n        break;\n      case MOV_M_A:\n        cpu->memory[h_address] = cpu->registers[REG_A];\n        break;\n      case MOV_M_B:\n        cpu->memory[h_address] = cpu->registers[REG_B];\n        break;\n      case MOV_M_C:\n        cpu->memory[h_address] = cpu->registers[REG_C];\n        break;\n      case MOV_M_D:\n        cpu->memory[h_address] = cpu->registers[REG_D];\n        break;\n      case MOV_M_E:\n        cpu->memory[h_address] = cpu->registers[REG_E];\n        break;\n      case MOV_M_H:\n        cpu->memory[h_address] = cpu->registers[REG_H];\n        break;\n      case MOV_M_L:\n        cpu->memory[h_address] = cpu->registers[REG_L];\n        break;\n      case MVI_A_D8:\n        cpu->registers[REG_A] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_B_D8:\n        cpu->registers[REG_B] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_C_D8:\n        cpu->registers[REG_C] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_D_D8:\n        cpu->registers[REG_D] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_E_D8:\n        cpu->registers[REG_E] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_H_D8:\n        cpu->registers[REG_H] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_L_D8:\n        cpu->registers[REG_L] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_M_D8:\n        cpu->memory[h_address] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case ORA_A:\n        cpu->registers[REG_A] |= cpu->registers[REG_A];\n        break;\n      case ORA_B:\n        cpu->registers[REG_A] |= cpu->registers[REG_B];\n        break;\n      case ORA_C:\n        cpu->registers[REG_A] |= cpu->registers[REG_C];\n        break;\n      case ORA_D:\n        cpu->registers[REG_A] |= cpu->registers[REG_D];\n        break;\n      case ORA_E:\n        cpu->registers[REG_A] |= cpu->registers[REG_E];\n        break;\n      case ORA_H:\n        cpu->registers[REG_A] |= cpu->registers[REG_H];\n        break;\n      case ORA_L:\n        cpu->registers[REG_A] |= cpu->registers[REG_L];\n        break;\n      case ORA_M:\n        cpu->registers[REG_A] |= cpu->memory[h_address];\n        break;\n      case ORI_D8:\n        cpu->registers[REG_A] |= cpu->memory[++cpu->memory_pointer];\n        break;\n      case OUT_PP:\n        break;\n      case PCHL:\n        break;\n      case POP_B:\n        break;\n      case POP_D:\n        break;\n      case POP_H:\n        break;\n      case POP_PSW:\n        break;\n      case PUSH_B:\n        break;\n      case PUSH_D:\n        break;\n      case PUSH_H:\n        break;\n      case PUSH_PSW:\n        break;\n      case RAL:\n        break;\n      case RAR:\n        break;\n      case RLC:\n        break;\n      case RRC:\n        break;\n      case RIM:\n        break;\n      case RET:\n        break;\n      case RZ:\n        break;\n      case RNZ:\n        break;\n      case RP:\n        break;\n      case RM:\n        break;\n      case RC:\n        break;\n      case RNC:\n        break;\n      case RPE:\n        break;\n      case RPO:\n        break;\n      case RST_0:\n        break;\n      case RST_1:\n        break;\n      case RST_2:\n        break;\n      case RST_3:\n        break;\n      case RST_4:\n        break;\n      case RST_5:\n        break;\n      case RST_6:\n        break;\n      case RST_7:\n        break;\n      case SIM:\n        break;\n      case SPHL:\n        cpu->stack_pointer = h_address;\n        break;\n      case SHLD_A16:\n        cpu->memory[++cpu->memory_pointer] = cpu->registers[REG_L];\n        cpu->memory[++cpu->memory_pointer] = cpu->registers[REG_H];\n        break;\n      case STA_A16:\n        cpu->memory[concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer])] = cpu->registers[REG_A];\n        break;\n      case STAX_B:\n        cpu->memory[b_address] = cpu->registers[REG_A];\n        break;\n      case STAX_D:\n        cpu->memory[d_address] = cpu->registers[REG_A];\n        break;\n      case STC:\n        set_flag(cpu, CARRY_FLAG, 1);\n        break;\n      case SUB_A:\n        cpu->registers[REG_A] -= cpu->registers[REG_A];\n        break;\n      case SUB_B:\n        cpu->registers[REG_A] -= cpu->registers[REG_B];\n        break;\n      case SUB_C:\n        cpu->registers[REG_A] -= cpu->registers[REG_C];\n        break;\n      case SUB_D:\n        cpu->registers[REG_A] -= cpu->registers[REG_D];\n        break;\n      case SUB_E:\n        cpu->registers[REG_A] -= cpu->registers[REG_E];\n        break;\n      case SUB_H:\n        cpu->registers[REG_A] -= cpu->registers[REG_H];\n        break;\n      case SUB_L:\n        cpu->registers[REG_A] -= cpu->registers[REG_E];\n        break;\n      case SUB_M:\n        cpu->registers[REG_A] -= cpu->memory[h_address];\n        break;\n      case SUI_D8:\n        cpu->registers[REG_A] -= cpu->memory[++cpu->memory_pointer];\n        break;\n      case SBB_A:\n        break;\n      case SBB_B:\n        break;\n      case SBB_C:\n        break;\n      case SBB_D:\n        break;\n      case SBB_E:\n        break;\n      case SBB_H:\n        break;\n      case SBB_L:\n        break;\n      case SBB_M:\n        break;\n      case SBI_D8:\n        break;\n      case XCHG:\n        push_stack(cpu, cpu->registers[REG_E]);\n        push_stack(cpu, cpu->registers[REG_D]);\n        cpu->registers[REG_E] = cpu->registers[REG_L];\n        cpu->registers[REG_D] = cpu->registers[REG_H];\n        cpu->registers[REG_L] = pop_stack(cpu);\n        cpu->registers[REG_H] = pop_stack(cpu);\n        break;\n      case XTHL:\n        break;\n      case XRA_A:\n        cpu->registers[REG_A] ^= cpu->registers[REG_A];\n        break;\n      case XRA_B:\n        cpu->registers[REG_A] ^= cpu->registers[REG_B];\n        break;\n      case XRA_C:\n        cpu->registers[REG_A] ^= cpu->registers[REG_C];\n        break;\n      case XRA_D:\n        cpu->registers[REG_A] ^= cpu->registers[REG_D];\n        break;\n      case XRA_E:\n        cpu->registers[REG_A] ^= cpu->registers[REG_E];\n        break;\n      case XRA_H:\n        cpu->registers[REG_A] ^= cpu->registers[REG_H];\n        break;\n      case XRA_L:\n        cpu->registers[REG_A] ^= cpu->registers[REG_L];\n        break;\n      case XRA_M:\n        cpu->registers[REG_A] ^= cpu->memory[h_address];\n        break;\n      case XRI_D8:\n        cpu->registers[REG_A] ^= cpu->memory[++cpu->memory_pointer];\n        break;\n      case NOP:\n      case HLT:\n        return 0;\n    }\n    cpu->program_counter = cpu->memory_pointer++;\n    return 0;\n}\n","function_prediction":"int execute_command_name_conflict(struct cpu_state *cpu, unsigned char command) {\n  unsigned short address_1 = get_address_from_registers(cpu, 2, 1);\n  unsigned short address_2 = get_address_from_registers(cpu, 4, 3);\n  unsigned short address_3 = get_address_from_registers(cpu, 6, 5);\n\n  switch (command) {\n  case 0x00:\n  case 0x76:\n    break;\n  case 0x01:\n    cpu->a = cpu->memory[cpu->pc + cpu->pc_offset + 1];\n    cpu->pc_offset++;\n    cpu->a = cpu->memory[cpu->pc + cpu->pc_offset + 1];\n    cpu->pc_offset++;\n    break;\n  case 0x02:\n    cpu->memory[address_1] = cpu->a;\n    break;\n  case 0x03:\n    break;\n  case 0x04:\n    cpu->b++;\n    break;\n  case 0x05:\n    cpu->b--;\n    break;\n  case 0x06:\n    cpu->b = cpu->memory[cpu->pc + cpu->pc_offset + 1];\n    cpu->pc_offset++;\n    break;\n  case 0x09:\n    break;\n  case 0x0A:\n    cpu->a = cpu->memory[address_1];\n    break;\n  case 0x0B:\n    break;\n  case 0x0C:\n    cpu->c++;\n    break;\n  case 0x0D:\n    cpu->c--;\n    break;\n  case 0x0E:\n    cpu->c = cpu->memory[cpu->pc + cpu->pc_offset + 1];\n    cpu->pc_offset++;\n","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":0,"function":"int execute(cpu_t *cpu) {\n    while (cpu->memory[cpu->memory_pointer] != HLT && cpu->memory_pointer < 65535)\n        {\n            execute_command(cpu, (code_t)cpu->memory[cpu->memory_pointer]);\n        }\n    return 0;\n}\n","function_prediction":"int execute_name_conflict(struct vm *vm) {\n  while (vm->memory[0x20014 + (int)vm->memory[0x20014 + 1]] != 'v' &&\n         vm->memory[0x20014] != -1) {\n    execute_name_conflict_command(vm, vm->memory[0x20014 + (int)vm->memory[0x20014 + 1]]);\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"int k_errno_name_conflict(void) { return *__errno_location(); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"char *k_strerr_name_conflict(void) { return strerror(*__errno_location()); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"int k_chbindir_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len <= 0)\n    return 1;\n\n  int i;\n  for (i = len - 1; i >= 0; i--) {\n    if (path[i] == '/')\n      break;\n    path[i] = 0;\n  }\n\n  if (path[i] != '/')\n    return 1;\n\n  if (i > 0)\n    path[i] = 0;\n\n  return chdir(path);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"int k_core_dump_name_conflict(void) {\n  struct rlimit rlim;\n  struct sigaction act;\n\n  k_chbindir();\n\n  rlim.rlim_max = rlim.rlim_cur = -1;\n  setrlimit(RLIMIT_CORE, &rlim);\n\n  getrlimit(RLIMIT_NPROC, &rlim);\n\n  act.sa_flags = -0x80000000;\n  act.sa_handler = k_core_handler;\n  sigemptyset(&act.sa_mask);\n  sigaction(8, &act, NULL);\n  sigaction(11, &act, NULL);\n\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"int k_demon_name_conflict(void) {\n  struct sigaction act;\n  pid_t pid;\n  int sid = 0;\n\n  act.sa_handler = k_demon_name_conflict_handler;\n  act.sa_flags = 0;\n  sigemptyset(&act.sa_mask);\n  sigaction(15, &act, 0);\n\n  pid = fork();\n  if (pid < 0) {\n    printf(\"fork %d\\n\", *__errno_location());\n    exit(1);\n  }\n  if (pid > 0) {\n    exit(0);\n  }\n\n  umask(0);\n  sid = setsid();\n  if (sid < 0) {\n    printf(\"setsid %d\\n\", *__errno_location());\n    exit(1);\n  }\n\n  close(0);\n  close(2);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"int ksock_init_name_conflict() {\n  struct rlimit rl;\n  struct sigaction sa;\n  memset(&sa, 0, sizeof(sa));\n  sa.sa_handler = 1;\n  sigaction(13, &sa, NULL);\n  rl.rlim_max = 10240;\n  rl.rlim_cur = 10240;\n  setrlimit(RLIMIT_NOFILE, &rl);\n  getrlimit(RLIMIT_NOFILE, &rl);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_non_blocking_name_conflict(int fd) {\n  int flags;\n\n  flags = fcntl(fd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 11);\n\n  return fcntl(fd, 4, flags);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_close_onexec_name_conflict(int sockfd) {\n  int flags = fcntl(sockfd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 0);\n  if (fcntl(sockfd, 4, flags) == -1)\n    return 1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_shutdown_name_conflict(int sock, int how) {\n  if (shutdown(sock, how) != 0)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"int ksock_close_name_conflict(int fd) {\n  int ret;\n  while ((ret = close(fd)) == -1 && *__errno_location() == 4)\n    ;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_ioctl_name_conflict(int sock, int cmd, void *arg) {\n  int ret;\n\n  ret = ioctl(sock, cmd, arg);\n  if (ret)\n    printf(\"ioctl :%s\\n\", k_strerr());\n  return ret ? 1 : 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"int ksock_from_addr_name_conflict(struct sockaddr_in addr, char *ip, int *port) {\n  strcpy(ip, inet_ntoa(addr.sin_addr));\n  *port = ntohs(addr.sin_port);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"int ksock_to_addr_name_conflict(struct sockaddr_in *addr, char *ip, int port) {\n  addr->sin_family = 2;\n  addr->sin_port = htons(port);\n  addr->sin_addr.s_addr = inet_addr(ip);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_reuse_name_conflict(int fd) {\n  int on = 1;\n  if (setsockopt(fd, 1, 2, &on, sizeof(on)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_sendbuf_name_conflict(int fd, int size) {\n  if (setsockopt(fd, 1, 7, &size, sizeof(size)) == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_alive_name_conflict(int fd, int idle, int interval, int count) {\n  int optval = 1;\n\n  if (setsockopt(fd, 1, 9, &optval, sizeof(optval)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 4, &idle, sizeof(idle)) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 5, &interval, sizeof(interval)) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 6, &count, sizeof(count)) == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int ksock_init_fd_name_conflict() {\n  int fd = socket(2, 1, 0);\n  if (fd == -1) {\n    printf(\"socket :%d\\n\", k_errno());\n    return -1;\n  }\n\n  if (!ksock_set_reuse(fd)) {\n    return fd;\n  }\n\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_bind_name_conflict(int sock, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = 0;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_listen_at_name_conflict(int sock, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = 0;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", k_errno());\n    return 1;\n  }\n\n  if (listen(sock, 4096) == -1) {\n    printf(\"listen :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"int ksock_accept_name_conflict(int fd, char *ip, int *port) {\n  int ret;\n  struct sockaddr_in client;\n  socklen_t len = sizeof(client);\n  ret = accept(fd, (struct sockaddr *)&client, &len);\n  if (ret == -1) {\n    printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n    return -1;\n  }\n  strcpy(ip, inet_ntoa(client.sin_addr));\n  *port = ntohs(client.sin_port);\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_connect_name_conflict(int sock, const char *ip, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = inet_addr(ip);\n\n  int ret = connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret == -1) {\n    printf(\"connect :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"uint32_t hash_str_name_conflict(const char *str, uint32_t len, uint32_t seed) {\n  uint32_t a, b, c;\n  uint32_t tmp, tmp2, tmp3;\n\n  a = b = 0x9e3779b9;\n  c = seed;\n\n  while (len >= 12) {\n    a += (str[0] + ((uint32_t)str[1] << 8) + ((uint32_t)str[2] << 16) +\n          ((uint32_t)str[3] << 24));\n    b += (str[4] + ((uint32_t)str[5] << 8) + ((uint32_t)str[6] << 16) +\n          ((uint32_t)str[7] << 24));\n    c += (str[8] + ((uint32_t)str[9] << 8) + ((uint32_t)str[10] << 16) +\n          ((uint32_t)str[11] << 24));\n\n    tmp = c;\n    c = a;\n    a = b ^ (((b ^ tmp) << 11) | ((b ^ tmp) >> 21));\n    b = c + tmp;\n\n    tmp2 = a;\n    a = b;\n    b = tmp2 ^ (((tmp2 ^ a) >> 8) | ((tmp2 ^ a) << 24));\n    tmp3 = b;\n    b = c;\n    c = tmp3 ^ (((tmp3 ^ b) << 10) | ((tmp3 ^ b) >> 22));\n\n    str += 12;\n    len -= 12;\n  }\n\n  c += len;\n\n  switch (len) {\n  case 11:\n    c += ((uint32_t)str[10] << 24);\n  case 10:\n    c += ((uint32_t)str[9] << 16);\n  case 9:\n    c += ((uint32_t)str[8] << 8);","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"unsigned int khash_fit_capacity_name_conflict(unsigned int capacity) {\n  unsigned int new_capacity = 1;\n  while (new_capacity < capacity) {\n    new_capacity <<= 1;\n  }\n  return new_capacity;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"int k_quicksort_cmp_name_conflict(const void *a, const void *b) {\n  return *(int *)a - *(int *)b;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"int k_errno_name_conflict(void) { return *__errno_location(); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"char *k_strerr_name_conflict(void) { return strerror(*__errno_location()); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"int k_chbindir_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len <= 0)\n    return 1;\n\n  int i;\n  for (i = len - 1; i >= 0; i--) {\n    if (path[i] == '/')\n      break;\n    path[i] = 0;\n  }\n\n  if (path[i] != '/')\n    return 1;\n\n  if (i > 0)\n    path[i] = 0;\n\n  return chdir(path);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"int k_core_dump_name_conflict(void) {\n  struct rlimit rlim;\n  struct sigaction act;\n\n  k_chbindir();\n\n  rlim.rlim_max = rlim.rlim_cur = -1;\n  setrlimit(RLIMIT_CORE, &rlim);\n\n  getrlimit(RLIMIT_NPROC, &rlim);\n\n  act.sa_flags = -0x80000000;\n  act.sa_handler = k_core_handler;\n  sigemptyset(&act.sa_mask);\n  sigaction(8, &act, NULL);\n  sigaction(11, &act, NULL);\n\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"int k_demon_name_conflict(void) {\n  struct sigaction act;\n  pid_t pid;\n  int sid = 0;\n\n  act.sa_handler = k_demon_name_conflict_handler;\n  act.sa_flags = 0;\n  sigemptyset(&act.sa_mask);\n  sigaction(15, &act, 0);\n\n  pid = fork();\n  if (pid < 0) {\n    printf(\"fork %d\\n\", *__errno_location());\n    exit(1);\n  }\n  if (pid > 0) {\n    exit(0);\n  }\n\n  umask(0);\n  sid = setsid();\n  if (sid < 0) {\n    printf(\"setsid %d\\n\", *__errno_location());\n    exit(1);\n  }\n\n  close(0);\n  close(2);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"int ksock_init_name_conflict() {\n  struct rlimit rl;\n  struct sigaction sa;\n  memset(&sa, 0, sizeof(sa));\n  sa.sa_handler = 1;\n  sigaction(13, &sa, NULL);\n  rl.rlim_max = 10240;\n  rl.rlim_cur = 10240;\n  setrlimit(RLIMIT_NOFILE, &rl);\n  getrlimit(RLIMIT_NOFILE, &rl);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_non_blocking_name_conflict(int fd) {\n  int flags;\n\n  flags = fcntl(fd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 11);\n\n  return fcntl(fd, 4, flags);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_close_onexec_name_conflict(int sockfd) {\n  int flags = fcntl(sockfd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 0);\n  if (fcntl(sockfd, 4, flags) == -1)\n    return 1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_shutdown_name_conflict(int sock, int how) {\n  if (shutdown(sock, how) != 0)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"int ksock_close_name_conflict(int fd) {\n  int ret;\n  while ((ret = close(fd)) == -1 && *__errno_location() == 4)\n    ;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_ioctl_name_conflict(int sock, int cmd, void *arg) {\n  int ret;\n\n  ret = ioctl(sock, cmd, arg);\n  if (ret)\n    printf(\"ioctl :%s\\n\", k_strerr());\n  return ret ? 1 : 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"int ksock_from_addr_name_conflict(struct sockaddr_in addr, char *ip, int *port) {\n  strcpy(ip, inet_ntoa(addr.sin_addr));\n  *port = ntohs(addr.sin_port);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"int ksock_to_addr_name_conflict(struct sockaddr_in *addr, char *ip, int port) {\n  addr->sin_family = 2;\n  addr->sin_port = htons(port);\n  addr->sin_addr.s_addr = inet_addr(ip);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_reuse_name_conflict(int fd) {\n  int on = 1;\n  if (setsockopt(fd, 1, 2, &on, sizeof(on)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_sendbuf_name_conflict(int fd, int size) {\n  if (setsockopt(fd, 1, 7, &size, sizeof(size)) == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_alive_name_conflict(int fd, int idle, int interval, int count) {\n  int optval = 1;\n\n  if (setsockopt(fd, 1, 9, &optval, sizeof(optval)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 4, &idle, sizeof(idle)) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 5, &interval, sizeof(interval)) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 6, &count, sizeof(count)) == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int ksock_init_fd_name_conflict() {\n  int fd = socket(2, 1, 0);\n  if (fd == -1) {\n    printf(\"socket :%d\\n\", k_errno());\n    return -1;\n  }\n\n  if (!ksock_set_reuse(fd)) {\n    return fd;\n  }\n\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_bind_name_conflict(int sock, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = 0;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_listen_at_name_conflict(int sock, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = 0;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", k_errno());\n    return 1;\n  }\n\n  if (listen(sock, 4096) == -1) {\n    printf(\"listen :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"int ksock_accept_name_conflict(int fd, char *ip, int *port) {\n  int ret;\n  struct sockaddr_in client;\n  socklen_t len = sizeof(client);\n  ret = accept(fd, (struct sockaddr *)&client, &len);\n  if (ret == -1) {\n    printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n    return -1;\n  }\n  strcpy(ip, inet_ntoa(client.sin_addr));\n  *port = ntohs(client.sin_port);\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_connect_name_conflict(int sock, const char *ip, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = inet_addr(ip);\n\n  int ret = connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret == -1) {\n    printf(\"connect :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"uint32_t hash_str_name_conflict(const char *str, uint32_t len, uint32_t seed) {\n  uint32_t a, b, c;\n  uint32_t tmp, tmp2, tmp3;\n\n  a = b = 0x9e3779b9;\n  c = seed;\n\n  while (len >= 12) {\n    a += (str[0] + ((uint32_t)str[1] << 8) + ((uint32_t)str[2] << 16) +\n          ((uint32_t)str[3] << 24));\n    b += (str[4] + ((uint32_t)str[5] << 8) + ((uint32_t)str[6] << 16) +\n          ((uint32_t)str[7] << 24));\n    c += (str[8] + ((uint32_t)str[9] << 8) + ((uint32_t)str[10] << 16) +\n          ((uint32_t)str[11] << 24));\n\n    tmp = c;\n    c = a;\n    a = b ^ (((b ^ tmp) << 11) | ((b ^ tmp) >> 21));\n    b = c + tmp;\n\n    tmp2 = a;\n    a = b;\n    b = tmp2 ^ (((tmp2 ^ a) >> 8) | ((tmp2 ^ a) << 24));\n    tmp3 = b;\n    b = c;\n    c = tmp3 ^ (((tmp3 ^ b) << 10) | ((tmp3 ^ b) >> 22));\n\n    str += 12;\n    len -= 12;\n  }\n\n  c += len;\n\n  switch (len) {\n  case 11:\n    c += ((uint32_t)str[10] << 24);\n  case 10:\n    c += ((uint32_t)str[9] << 16);\n  case 9:\n    c += ((uint32_t)str[8] << 8);","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"unsigned int khash_fit_capacity_name_conflict(unsigned int capacity) {\n  unsigned int new_capacity = 1;\n  while (new_capacity < capacity) {\n    new_capacity <<= 1;\n  }\n  return new_capacity;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"int k_quicksort_cmp_name_conflict(const void *a, const void *b) {\n  return *(int *)a - *(int *)b;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"int k_errno_name_conflict(void) { return *__errno_location(); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"char *k_strerr_name_conflict(void) { return strerror(*__errno_location()); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"int k_chbindir_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len <= 0)\n    return 1;\n\n  int i;\n  for (i = len - 1; i >= 0; i--) {\n    if (path[i] == '/')\n      break;\n    path[i] = 0;\n  }\n\n  if (path[i] != '/')\n    return 1;\n\n  if (i > 0)\n    path[i] = 0;\n\n  return chdir(path);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"int k_core_dump_name_conflict(void) {\n  struct rlimit rlim;\n  struct sigaction act;\n\n  k_chbindir();\n\n  rlim.rlim_max = rlim.rlim_cur = -1;\n  setrlimit(RLIMIT_CORE, &rlim);\n\n  getrlimit(RLIMIT_NPROC, &rlim);\n\n  act.sa_flags = -0x80000000;\n  act.sa_handler = k_core_handler;\n  sigemptyset(&act.sa_mask);\n  sigaction(8, &act, NULL);\n  sigaction(11, &act, NULL);\n\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"int k_demon_name_conflict(void) {\n  struct sigaction act;\n  pid_t pid;\n  int sid = 0;\n\n  act.sa_handler = k_demon_name_conflict_handler;\n  act.sa_flags = 0;\n  sigemptyset(&act.sa_mask);\n  sigaction(15, &act, 0);\n\n  pid = fork();\n  if (pid < 0) {\n    printf(\"fork %d\\n\", *__errno_location());\n    exit(1);\n  }\n  if (pid > 0) {\n    exit(0);\n  }\n\n  umask(0);\n  sid = setsid();\n  if (sid < 0) {\n    printf(\"setsid %d\\n\", *__errno_location());\n    exit(1);\n  }\n\n  close(0);\n  close(2);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"int ksock_init_name_conflict() {\n  struct rlimit rl;\n  struct sigaction sa;\n  memset(&sa, 0, sizeof(sa));\n  sa.sa_handler = 1;\n  sigaction(13, &sa, NULL);\n  rl.rlim_max = 10240;\n  rl.rlim_cur = 10240;\n  setrlimit(RLIMIT_NOFILE, &rl);\n  getrlimit(RLIMIT_NOFILE, &rl);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_non_blocking_name_conflict(int fd) {\n  int flags;\n\n  flags = fcntl(fd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 11);\n\n  return fcntl(fd, 4, flags);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_close_onexec_name_conflict(int sockfd) {\n  int flags = fcntl(sockfd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 0);\n  if (fcntl(sockfd, 4, flags) == -1)\n    return 1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_shutdown_name_conflict(int sock, int how) {\n  if (shutdown(sock, how) != 0)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"int ksock_close_name_conflict(int fd) {\n  int ret;\n  while ((ret = close(fd)) == -1 && *__errno_location() == 4)\n    ;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_ioctl_name_conflict(int sock, int cmd, void *arg) {\n  int ret;\n\n  ret = ioctl(sock, cmd, arg);\n  if (ret)\n    printf(\"ioctl :%s\\n\", k_strerr());\n  return ret ? 1 : 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"int ksock_from_addr_name_conflict(struct sockaddr_in addr, char *ip, int *port) {\n  strcpy(ip, inet_ntoa(addr.sin_addr));\n  *port = ntohs(addr.sin_port);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"int ksock_to_addr_name_conflict(struct sockaddr_in *addr, char *ip, int port) {\n  addr->sin_family = 2;\n  addr->sin_port = htons(port);\n  addr->sin_addr.s_addr = inet_addr(ip);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_reuse_name_conflict(int fd) {\n  int on = 1;\n  if (setsockopt(fd, 1, 2, &on, sizeof(on)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_sendbuf_name_conflict(int fd, int size) {\n  if (setsockopt(fd, 1, 7, &size, sizeof(size)) == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_alive_name_conflict(int fd, int idle, int interval, int count) {\n  int optval = 1;\n\n  if (setsockopt(fd, 1, 9, &optval, sizeof(optval)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 4, &idle, sizeof(idle)) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 5, &interval, sizeof(interval)) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 6, &count, sizeof(count)) == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int ksock_init_fd_name_conflict() {\n  int fd = socket(2, 1, 0);\n  if (fd == -1) {\n    printf(\"socket :%d\\n\", k_errno());\n    return -1;\n  }\n\n  if (!ksock_set_reuse(fd)) {\n    return fd;\n  }\n\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_bind_name_conflict(int sock, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = 0;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_listen_at_name_conflict(int sock, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = 0;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", k_errno());\n    return 1;\n  }\n\n  if (listen(sock, 4096) == -1) {\n    printf(\"listen :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"int ksock_accept_name_conflict(int fd, char *ip, int *port) {\n  int ret;\n  struct sockaddr_in client;\n  socklen_t len = sizeof(client);\n  ret = accept(fd, (struct sockaddr *)&client, &len);\n  if (ret == -1) {\n    printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n    return -1;\n  }\n  strcpy(ip, inet_ntoa(client.sin_addr));\n  *port = ntohs(client.sin_port);\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_connect_name_conflict(int sock, const char *ip, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = inet_addr(ip);\n\n  int ret = connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret == -1) {\n    printf(\"connect :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"uint32_t hash_str_name_conflict(const char *str, uint32_t len, uint32_t seed) {\n  uint32_t a, b, c;\n  uint32_t tmp, tmp2, tmp3;\n\n  a = b = 0x9e3779b9;\n  c = seed;\n\n  while (len >= 12) {\n    a += (str[0] + ((uint32_t)str[1] << 8) + ((uint32_t)str[2] << 16) +\n          ((uint32_t)str[3] << 24));\n    b += (str[4] + ((uint32_t)str[5] << 8) + ((uint32_t)str[6] << 16) +\n          ((uint32_t)str[7] << 24));\n    c += (str[8] + ((uint32_t)str[9] << 8) + ((uint32_t)str[10] << 16) +\n          ((uint32_t)str[11] << 24));\n\n    tmp = c;\n    c = a;\n    a = b ^ (((b ^ tmp) << 11) | ((b ^ tmp) >> 21));\n    b = c + tmp;\n\n    tmp2 = a;\n    a = b;\n    b = tmp2 ^ (((tmp2 ^ a) >> 8) | ((tmp2 ^ a) << 24));\n    tmp3 = b;\n    b = c;\n    c = tmp3 ^ (((tmp3 ^ b) << 10) | ((tmp3 ^ b) >> 22));\n\n    str += 12;\n    len -= 12;\n  }\n\n  c += len;\n\n  switch (len) {\n  case 11:\n    c += ((uint32_t)str[10] << 24);\n  case 10:\n    c += ((uint32_t)str[9] << 16);\n  case 9:\n    c += ((uint32_t)str[8] << 8);","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"unsigned int khash_fit_capacity_name_conflict(unsigned int capacity) {\n  unsigned int new_capacity = 1;\n  while (new_capacity < capacity) {\n    new_capacity <<= 1;\n  }\n  return new_capacity;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"int k_quicksort_cmp_name_conflict(const void *a, const void *b) {\n  return *(int *)a - *(int *)b;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"int k_errno_name_conflict(void) { return *__errno_location(); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"char *k_strerr_name_conflict(void) { return strerror(*__errno_location()); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"int k_chbindir_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len <= 0)\n    return 1;\n\n  int i;\n  for (i = len - 1; i >= 0; i--) {\n    if (path[i] == '/')\n      break;\n    path[i] = 0;\n  }\n\n  if (path[i] != '/')\n    return 1;\n\n  if (i > 0)\n    path[i] = 0;\n\n  return chdir(path);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"int k_core_dump_name_conflict(void) {\n  struct rlimit rlim;\n  struct sigaction act;\n\n  k_chbindir();\n\n  rlim.rlim_max = rlim.rlim_cur = -1;\n  setrlimit(RLIMIT_CORE, &rlim);\n\n  getrlimit(RLIMIT_NPROC, &rlim);\n\n  act.sa_flags = -0x80000000;\n  act.sa_handler = k_core_handler;\n  sigemptyset(&act.sa_mask);\n  sigaction(8, &act, NULL);\n  sigaction(11, &act, NULL);\n\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"int k_demon_name_conflict(void) {\n  struct sigaction act;\n  pid_t pid;\n  int sid = 0;\n\n  act.sa_handler = k_demon_name_conflict_handler;\n  act.sa_flags = 0;\n  sigemptyset(&act.sa_mask);\n  sigaction(15, &act, 0);\n\n  pid = fork();\n  if (pid < 0) {\n    printf(\"fork %d\\n\", *__errno_location());\n    exit(1);\n  }\n  if (pid > 0) {\n    exit(0);\n  }\n\n  umask(0);\n  sid = setsid();\n  if (sid < 0) {\n    printf(\"setsid %d\\n\", *__errno_location());\n    exit(1);\n  }\n\n  close(0);\n  close(2);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"int ksock_init_name_conflict() {\n  struct rlimit rl;\n  struct sigaction sa;\n  memset(&sa, 0, sizeof(sa));\n  sa.sa_handler = 1;\n  sigaction(13, &sa, NULL);\n  rl.rlim_max = 10240;\n  rl.rlim_cur = 10240;\n  setrlimit(RLIMIT_NOFILE, &rl);\n  getrlimit(RLIMIT_NOFILE, &rl);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_non_blocking_name_conflict(int fd) {\n  int flags;\n\n  flags = fcntl(fd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 11);\n\n  return fcntl(fd, 4, flags);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_close_onexec_name_conflict(int sockfd) {\n  int flags = fcntl(sockfd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 0);\n  if (fcntl(sockfd, 4, flags) == -1)\n    return 1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_shutdown_name_conflict(int sock, int how) {\n  if (shutdown(sock, how) != 0)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"int ksock_close_name_conflict(int fd) {\n  int ret;\n  while ((ret = close(fd)) == -1 && *__errno_location() == 4)\n    ;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_ioctl_name_conflict(int sock, int cmd, void *arg) {\n  int ret;\n\n  ret = ioctl(sock, cmd, arg);\n  if (ret)\n    printf(\"ioctl :%s\\n\", k_strerr());\n  return ret ? 1 : 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"int ksock_from_addr_name_conflict(struct sockaddr_in addr, char *ip, int *port) {\n  strcpy(ip, inet_ntoa(addr.sin_addr));\n  *port = ntohs(addr.sin_port);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"int ksock_to_addr_name_conflict(struct sockaddr_in *addr, char *ip, int port) {\n  addr->sin_family = 2;\n  addr->sin_port = htons(port);\n  addr->sin_addr.s_addr = inet_addr(ip);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_reuse_name_conflict(int fd) {\n  int on = 1;\n  if (setsockopt(fd, 1, 2, &on, sizeof(on)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_sendbuf_name_conflict(int fd, int size) {\n  if (setsockopt(fd, 1, 7, &size, sizeof(size)) == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_alive_name_conflict(int fd, int idle, int interval, int count) {\n  int optval = 1;\n\n  if (setsockopt(fd, 1, 9, &optval, sizeof(optval)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 4, &idle, sizeof(idle)) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 5, &interval, sizeof(interval)) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 6, &count, sizeof(count)) == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int ksock_init_fd_name_conflict() {\n  int fd = socket(2, 1, 0);\n  if (fd == -1) {\n    printf(\"socket :%d\\n\", k_errno());\n    return -1;\n  }\n\n  if (!ksock_set_reuse(fd)) {\n    return fd;\n  }\n\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_bind_name_conflict(int sock, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = 0;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_listen_at_name_conflict(int sock, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = 0;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", k_errno());\n    return 1;\n  }\n\n  if (listen(sock, 4096) == -1) {\n    printf(\"listen :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"int ksock_accept_name_conflict(int fd, char *ip, int *port) {\n  int ret;\n  struct sockaddr_in client;\n  socklen_t len = sizeof(client);\n  ret = accept(fd, (struct sockaddr *)&client, &len);\n  if (ret == -1) {\n    printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n    return -1;\n  }\n  strcpy(ip, inet_ntoa(client.sin_addr));\n  *port = ntohs(client.sin_port);\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_connect_name_conflict(int sock, const char *ip, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = inet_addr(ip);\n\n  int ret = connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret == -1) {\n    printf(\"connect :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"uint32_t hash_str_name_conflict(const char *str, uint32_t len, uint32_t seed) {\n  uint32_t a, b, c;\n  uint32_t tmp, tmp2, tmp3;\n\n  a = b = 0x9e3779b9;\n  c = seed;\n\n  while (len >= 12) {\n    a += (str[0] + ((uint32_t)str[1] << 8) + ((uint32_t)str[2] << 16) +\n          ((uint32_t)str[3] << 24));\n    b += (str[4] + ((uint32_t)str[5] << 8) + ((uint32_t)str[6] << 16) +\n          ((uint32_t)str[7] << 24));\n    c += (str[8] + ((uint32_t)str[9] << 8) + ((uint32_t)str[10] << 16) +\n          ((uint32_t)str[11] << 24));\n\n    tmp = c;\n    c = a;\n    a = b ^ (((b ^ tmp) << 11) | ((b ^ tmp) >> 21));\n    b = c + tmp;\n\n    tmp2 = a;\n    a = b;\n    b = tmp2 ^ (((tmp2 ^ a) >> 8) | ((tmp2 ^ a) << 24));\n    tmp3 = b;\n    b = c;\n    c = tmp3 ^ (((tmp3 ^ b) << 10) | ((tmp3 ^ b) >> 22));\n\n    str += 12;\n    len -= 12;\n  }\n\n  c += len;\n\n  switch (len) {\n  case 11:\n    c += ((uint32_t)str[10] << 24);\n  case 10:\n    c += ((uint32_t)str[9] << 16);\n  case 9:\n    c += ((uint32_t)str[8] << 8);","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"unsigned int khash_fit_capacity_name_conflict(unsigned int capacity) {\n  unsigned int new_capacity = 1;\n  while (new_capacity < capacity) {\n    new_capacity <<= 1;\n  }\n  return new_capacity;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"int k_quicksort_cmp_name_conflict(const void *a, const void *b) {\n  return *(int *)a - *(int *)b;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"int k_errno_name_conflict(void) { return *__errno_location(); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"char *k_strerr_name_conflict(void) { return strerror(*__errno_location()); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"int k_chbindir_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len <= 0)\n    return 1;\n\n  int i;\n  for (i = len - 1; i >= 0; i--) {\n    if (path[i] == '/')\n      break;\n    path[i] = 0;\n  }\n\n  if (path[i] != '/')\n    return 1;\n\n  if (i > 0)\n    path[i] = 0;\n\n  return chdir(path);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"int k_core_dump_name_conflict(void) {\n  struct rlimit rlim;\n  struct sigaction act;\n\n  k_chbindir();\n\n  rlim.rlim_max = rlim.rlim_cur = -1;\n  setrlimit(RLIMIT_CORE, &rlim);\n\n  getrlimit(RLIMIT_NPROC, &rlim);\n\n  act.sa_flags = -0x80000000;\n  act.sa_handler = k_core_handler;\n  sigemptyset(&act.sa_mask);\n  sigaction(8, &act, NULL);\n  sigaction(11, &act, NULL);\n\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"int k_demon_name_conflict(void) {\n  struct sigaction act;\n  pid_t pid;\n  int sid = 0;\n\n  act.sa_handler = k_demon_name_conflict_handler;\n  act.sa_flags = 0;\n  sigemptyset(&act.sa_mask);\n  sigaction(15, &act, 0);\n\n  pid = fork();\n  if (pid < 0) {\n    printf(\"fork %d\\n\", *__errno_location());\n    exit(1);\n  }\n  if (pid > 0) {\n    exit(0);\n  }\n\n  umask(0);\n  sid = setsid();\n  if (sid < 0) {\n    printf(\"setsid %d\\n\", *__errno_location());\n    exit(1);\n  }\n\n  close(0);\n  close(2);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"int ksock_init_name_conflict() {\n  struct rlimit rl;\n  struct sigaction sa;\n  memset(&sa, 0, sizeof(sa));\n  sa.sa_handler = 1;\n  sigaction(13, &sa, NULL);\n  rl.rlim_max = 10240;\n  rl.rlim_cur = 10240;\n  setrlimit(RLIMIT_NOFILE, &rl);\n  getrlimit(RLIMIT_NOFILE, &rl);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_non_blocking_name_conflict(int fd) {\n  int flags;\n\n  flags = fcntl(fd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 11);\n\n  return fcntl(fd, 4, flags);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_close_onexec_name_conflict(int sockfd) {\n  int flags = fcntl(sockfd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 0);\n  if (fcntl(sockfd, 4, flags) == -1)\n    return 1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_shutdown_name_conflict(int sock, int how) {\n  if (shutdown(sock, how) != 0)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"int ksock_close_name_conflict(int fd) {\n  int ret;\n  while ((ret = close(fd)) == -1 && *__errno_location() == 4)\n    ;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_ioctl_name_conflict(int sock, int cmd, void *arg) {\n  int ret;\n\n  ret = ioctl(sock, cmd, arg);\n  if (ret)\n    printf(\"ioctl :%s\\n\", k_strerr());\n  return ret ? 1 : 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"int ksock_from_addr_name_conflict(struct sockaddr_in addr, char *ip, int *port) {\n  strcpy(ip, inet_ntoa(addr.sin_addr));\n  *port = ntohs(addr.sin_port);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"int ksock_to_addr_name_conflict(struct sockaddr_in *addr, char *ip, int port) {\n  addr->sin_family = 2;\n  addr->sin_port = htons(port);\n  addr->sin_addr.s_addr = inet_addr(ip);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_reuse_name_conflict(int fd) {\n  int on = 1;\n  if (setsockopt(fd, 1, 2, &on, sizeof(on)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_sendbuf_name_conflict(int fd, int size) {\n  if (setsockopt(fd, 1, 7, &size, sizeof(size)) == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_alive_name_conflict(int fd, int idle, int interval, int count) {\n  int optval = 1;\n\n  if (setsockopt(fd, 1, 9, &optval, sizeof(optval)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 4, &idle, sizeof(idle)) == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 5, &interval, sizeof(interval)) == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  if (setsockopt(fd, 6, 6, &count, sizeof(count)) == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int ksock_init_fd_name_conflict() {\n  int fd = socket(2, 1, 0);\n  if (fd == -1) {\n    printf(\"socket :%d\\n\", k_errno());\n    return -1;\n  }\n\n  if (!ksock_set_reuse(fd)) {\n    return fd;\n  }\n\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_bind_name_conflict(int sock, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = 0;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_listen_at_name_conflict(int sock, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = 0;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", k_errno());\n    return 1;\n  }\n\n  if (listen(sock, 4096) == -1) {\n    printf(\"listen :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"int ksock_accept_name_conflict(int fd, char *ip, int *port) {\n  int ret;\n  struct sockaddr_in client;\n  socklen_t len = sizeof(client);\n  ret = accept(fd, (struct sockaddr *)&client, &len);\n  if (ret == -1) {\n    printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n    return -1;\n  }\n  strcpy(ip, inet_ntoa(client.sin_addr));\n  *port = ntohs(client.sin_port);\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_connect_name_conflict(int sock, const char *ip, int port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = inet_addr(ip);\n\n  int ret = connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret == -1) {\n    printf(\"connect :%d\\n\", k_errno());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"uint32_t hash_str_name_conflict(const char *str, uint32_t len, uint32_t seed) {\n  uint32_t a, b, c;\n  uint32_t tmp, tmp2, tmp3;\n\n  a = b = 0x9e3779b9;\n  c = seed;\n\n  while (len >= 12) {\n    a += (str[0] + ((uint32_t)str[1] << 8) + ((uint32_t)str[2] << 16) +\n          ((uint32_t)str[3] << 24));\n    b += (str[4] + ((uint32_t)str[5] << 8) + ((uint32_t)str[6] << 16) +\n          ((uint32_t)str[7] << 24));\n    c += (str[8] + ((uint32_t)str[9] << 8) + ((uint32_t)str[10] << 16) +\n          ((uint32_t)str[11] << 24));\n\n    tmp = c;\n    c = a;\n    a = b ^ (((b ^ tmp) << 11) | ((b ^ tmp) >> 21));\n    b = c + tmp;\n\n    tmp2 = a;\n    a = b;\n    b = tmp2 ^ (((tmp2 ^ a) >> 8) | ((tmp2 ^ a) << 24));\n    tmp3 = b;\n    b = c;\n    c = tmp3 ^ (((tmp3 ^ b) << 10) | ((tmp3 ^ b) >> 22));\n\n    str += 12;\n    len -= 12;\n  }\n\n  c += len;\n\n  switch (len) {\n  case 11:\n    c += ((uint32_t)str[10] << 24);\n  case 10:\n    c += ((uint32_t)str[9] << 16);\n  case 9:\n    c += ((uint32_t)str[8] << 8);","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"unsigned int khash_fit_capacity_name_conflict(unsigned int capacity) {\n  unsigned int new_capacity = 1;\n  while (new_capacity < capacity) {\n    new_capacity <<= 1;\n  }\n  return new_capacity;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"int k_quicksort_cmp_name_conflict(const void *a, const void *b) {\n  return *(int *)a - *(int *)b;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
