{"compilable":1,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"size_t strlcpy_name_conflict(char *dst, const char *src, size_t siz) {\n  char *d = dst;\n  const char *s = src;\n  size_t n = siz;\n\n  if (n != 0) {\n    while (--n != 0) {\n      if ((*d++ = *s++) == '\\0')\n        break;\n    }\n  }\n\n  if (n == 0) {\n    if (siz != 0)\n      *d = '\\0';\n    while (*s++)\n      ;\n  }\n\n  return (s - src - 1);\n}","pass":1,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":1,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"size_t strlcpy_name_conflict(char *dst, const char *src, size_t siz) {\n  char *d = dst;\n  const char *s = src;\n  size_t n = siz;\n\n  if (n != 0) {\n    while (--n != 0) {\n      if ((*d++ = *s++) == '\\0')\n        break;\n    }\n  }\n\n  if (n == 0) {\n    if (siz != 0)\n      *d = '\\0';\n    while (*s++)\n      ;\n  }\n\n  return (s - src - 1);\n}","pass":1,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":1,"function":"unsigned long strlcpy(char *dst, const char *src, size_t siz) {\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n    if (n != 0) {\n        while (--n != 0)\n            {\n                if ((*d++ = *s++) == '\\x00')\n                    break;\n            }\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"size_t strlcpy_name_conflict(char *dst, const char *src, size_t siz) {\n  char *d = dst;\n  const char *s = src;\n  size_t n = siz;\n\n  if (n != 0) {\n    while (--n != 0) {\n      if ((*d++ = *s++) == '\\0')\n        break;\n    }\n  }\n\n  if (n == 0) {\n    if (siz != 0)\n      *d = '\\0';\n    while (*s++)\n      ;\n  }\n\n  return (s - src - 1);\n}","pass":1,"source_file":"C_COMPILE/Jtfinlay_C379/assn2/strlcpy.c"}
{"compilable":0,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/montiainen_BROS/package/x11r7/mcookie/mcookie.c"}
{"compilable":0,"function":"pid_t getppidof(const pid_t pid) {\n    int ppid;\n    char buffer[8192];\n    size_t size;\n    FILE *fp;\n    sprintf(buffer, \"/proc/%d/stat\", pid);\n    fp = fopen(buffer, \"r\");\n    if (fp) {\n        size = fread(buffer, sizeof(char), sizeof (buffer), fp);\n        if (size > 0) {\n            strtok(buffer, \" \");\n            strtok(((void *)0), \" \");\n            strtok(((void *)0), \" \");\n            ppid = atoi(strtok(((void *)0), \" \"));\n        }\n        fclose(fp);\n    }\n    return ppid;\n}\n","function_prediction":"int getppidof_name_conflict(int pid) {\n  char buf[8192];\n  sprintf(buf, \"/proc/%d/stat\", pid);\n  FILE *fp = fopen(buf, \"r\");\n  if (fp == NULL)\n    return 0;\n  if (fread(buf, 1, 8192, fp) == 0)\n    return 0;\n  strtok(buf, \" \");\n  strtok(NULL, \" \");\n  strtok(NULL, \" \");\n  char *ppid = strtok(NULL, \" \");\n  int ppid_int = strtol(ppid, NULL, 10);\n  fclose(fp);\n  return ppid_int;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"char *getnameof(const pid_t pid) {\n    static char buffer[8192];\n    char *old_buffer, *new_buffer;\n    FILE *fp;\n    size_t size;\n    sprintf(buffer, \"/proc/%d/cmdline\", pid);\n    fp = fopen(buffer, \"r\");\n    if (fp) {\n        size = fread(buffer, sizeof(char), sizeof (buffer), fp);\n        if (size > 0) {\n            new_buffer = strtok(buffer, \"/\");\n            while (new_buffer != ((void *)0))\n                {\n                    old_buffer = new_buffer;\n                    new_buffer = strtok(((void *)0), \"/\");\n                }\n        }\n        fclose(fp);\n    }\n    return old_buffer;\n}\n","function_prediction":"char *getnameof_name_conflict(int pid) {\n  static char buffer[8192];\n  FILE *fp;\n  char *p, *name;\n\n  sprintf(buffer, \"/proc/%d/cmdline\", pid);\n  fp = fopen(buffer, \"r\");\n  if (fp == NULL)\n    return NULL;\n\n  if (fread(buffer, 1, 8192, fp) == 0)\n    return NULL;\n\n  p = strtok(buffer, \"/\");\n  if (p == NULL)\n    return NULL;\n\n  name = p;\n  while ((p = strtok(NULL, \"/\")))\n    name = p;\n\n  fclose(fp);\n  return name;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"char *_prisma_trytogettermname() {\n    static char _prisma_termname[64];\n    char *tmp = getnameof(getppidof(getsid(getpid())));\n    if (tmp) {\n        strncpy(_prisma_termname, tmp, 64);\n        if (!strncmp(_prisma_termname, \"initdline\", 64) || !strncmp(_prisma_termname, \"konsole\", 64))\n            return _prisma_termname;\n    }\n    strncpy(_prisma_termname, getenv(\"TERM\"), 64);\n    return _prisma_termname;\n}\n","function_prediction":"char *_prisma_trytogettermname_name_conflict() {\n  static char _prisma_termname[64];\n  char *token;\n  FILE *fp;\n\n  sprintf(buffer, \"/proc/%d/cmdline\", getppidof(getsid(getpid())));\n  if ((fp = fopen(buffer, \"r\"))) {\n    if (fread(buffer, 1, 8192, fp)) {\n      token = strtok(buffer, \"/\");\n      while (token) {\n        token = strtok(NULL, \"/\");\n      }\n    }\n    fclose(fp);\n    strncpy(_prisma_termname, token, 64);\n    if (!strcmp(_prisma_termname, \"niniltd\") ||\n        !strcmp(_prisma_termname, \"ninilte\"))\n      return _prisma_termname;\n    if (!strcmp(_prisma_termname, \"snok\"))\n      return _prisma_termname;\n  }\n  strncpy(_prisma_termname, getenv(\"TERM\"), 64);\n  return _prisma_termname;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"int8_t prisma_adapt(int8_t adaptation) {\n    char *termname;\n    if (adaptation == -1) {\n        termname = _prisma_trytogettermname();\n        if (!strcmp(termname, \"xterm\"))\n            _prisma_adaptation = 2;\n        else if (!strcmp(termname, \"konsole\"))\n            _prisma_adaptation = 1;\n        else if (!strcmp(termname, \"linux\") || !strcmp(termname, \"initdline\"))\n            _prisma_adaptation = 3;\n        else if (!strncmp(termname, \"windows\", 7))\n            _prisma_adaptation = 4;\n        else\n            _prisma_adaptation = 0;\n    } else\n        _prisma_adaptation = adaptation;\n    return _prisma_adaptation;\n}\n","function_prediction":"int prisma_adapt_name_conflict(int adapt) {\n  if (adapt == -1) {\n    char *termname = _prisma_trytogettermname();\n    if (!strcmp(termname, \"xterm\"))\n      adapt = 2;\n    else if (!strcmp(termname, \"konsole\"))\n      adapt = 1;\n    else if (!strcmp(termname, \"linux\"))\n      adapt = 3;\n    else if (!strcmp(termname, \"initdline\"))\n      adapt = 0;\n    else if (!strncmp(termname, \"windows\", 7))\n      adapt = 4;\n  }\n  _prisma_adapt_name_conflictation = adapt;\n  return adapt;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint8_t prisma_argbto8color(uint32_t argb) {\n    argb = ((argb & 16711680) >= 8323072 ? 16711680 : 0) | ((argb & 65280) >= 32512 ? 65280 : 0) | ((argb & 255) >= 127 ? 255 : 0);\n    switch (argb) {\n      case 0:\n        return 0;\n      case 16711680:\n        return 1;\n      case 65280:\n        return 2;\n      case 16776960:\n        return 3;\n      case 255:\n        return 4;\n      case 16711935:\n        return 5;\n      case 65535:\n        return 6;\n      case 16777215:\n        return 7;\n    }\n}\n","function_prediction":"uint8_t prisma_argbto8color_name_conflict(uint32_t argb) {\n  uint8_t r = (argb & 0x00FF0000) >> 16;\n  uint8_t g = (argb & 0x0000FF00) >> 8;\n  uint8_t b = (argb & 0x000000FF);\n\n  if (r > 127 && g > 127 && b > 127)\n    return 1;\n  else if (r > 127 && g > 127)\n    return 2;\n  else if (r > 127)\n    return 3;\n  else if (g > 127)\n    return 4;\n  else if (b > 127)\n    return 5;\n  else\n    return 0;\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint32_t prisma_8colortoargb(uint8_t src) {\n    switch (src) {\n      case 0:\n        return 4278190080U;\n      case 1:\n        return 4294901760U;\n      case 2:\n        return 4278255360U;\n      case 3:\n        return 4294967040U;\n      case 4:\n        return 4278190335U;\n      case 5:\n        return 4294902015U;\n      case 6:\n        return 4278255615U;\n      case 7:\n        return 4294967295U;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"uint32_t prisma_8colortoargb_name_conflict(uint8_t color) {\n  switch (color) {\n  case 0:\n    return 0x00000000;\n  case 1:\n    return 0x000000FF;\n  case 2:\n    return 0x0000FF00;\n  case 3:\n    return 0x0000FFFF;\n  case 4:\n    return 0x00FF0000;\n  case 5:\n    return 0x00FF00FF;\n  case 6:\n    return 0x00FFFF00;\n  case 7:\n    return 0x00FFFFFF;\n  default:\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint8_t prisma_argbtoxterm(uint32_t argb) {\n    uint8_t r, g, b;\n    prisma_argbtobytes(argb, ((void *)0), &r, &g, &b);\n    return ((r >= 4 && r <= 246 && r == g && g == b) ? (232 + ((r - 8) * 24 / 238)) : (16 + (36 * (r / 51)) + (6 * (g / 51)) + (b / 51)));\n}\n","function_prediction":"unsigned short prisma_argbtoxterm_name_conflict(unsigned int argb) {\n  unsigned char r = (argb >> 16) & 0xff;\n  unsigned char g = (argb >> 8) & 0xff;\n  unsigned char b = (argb >> 0) & 0xff;\n\n  if (r == g && g == b && r >= 4 && r <= 255) {\n    return ((((r)-4) * 8) / 238) + 24;\n  }\n\n  return (((r) / 51) * 36) + (((g) / 51) * 6) + (((b) / 51) * 1);\n}","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"uint32_t prisma_xtermtoargb(uint8_t index) {\n    uint32_t argb;\n    if (index < 8) {\n        argb = prisma_8colortoargb(index);\n        if (argb == 4294967295U)\n            argb = 4290822336U;\n        else\n            argb = 4278190080U | ((argb & 16711680) != 0 ? 8388608 : 0) | ((argb & 65280) != 0 ? 32768 : 0) | ((argb & 255) != 0 ? 128 : 0);\n    } else if (index < 16) {\n        index -= 8;\n        argb = prisma_8colortoargb(index);\n        if (argb == 0)\n            argb = 4286611584U;\n    } else if (index < 232) {\n        index -= 16;\n        argb = 4278190080U | ((51 * (index / 36)) << 16) | ((51 * ((index % 36) / 6)) << 8) | (51 * (index % 6));\n    } else {\n        index -= 232;\n        argb = (8 + (10 * index));\n        argb |= 4278190080U | (argb << 16) | (argb << 8);\n    }\n    return argb;\n}\n","function_prediction":"unsigned int prisma_xtermtoargb_name_conflict(unsigned char c) {\n  unsigned int r, g, b;\n  unsigned int rgb;\n\n  switch (c) {\n  case 0:\n  case 1:\n  case 2:\n  case 3:\n  case 4:\n  case 5:\n  case 6:\n  case 7:\n    rgb = CSWTCH_32[c];\n    if (rgb != 0xffffffff) {\n      r = (rgb & 0xff0000) ? 0xff : 0;\n      g = (rgb & 0x00ff00) ? 0xff : 0;\n      b = (rgb & 0x0000ff) ? 0xff : 0;\n      rgb = (r << 24) | (g << 16) | (b << 8) | 0xff;\n    } else {\n      rgb = 0xffc0c0c0;\n    }\n    break;\n  case 8:\n  case 9:\n  case 10:\n  case 11:\n  case 12:\n  case 13:\n  case 14:\n  case 15:\n    rgb = CSWTCH_32[c - 8];\n    if (rgb == 0) {\n      rgb = 0xff808080;\n    }\n    break;\n  case 16:\n  case 17:\n  case 18:\n  case 19:\n  case 20:\n  case 21:\n  case 22:\n  case 23:\n  case 24:\n  case 25:\n  case 26:\n  case 27:\n  case 28:\n  case 29:\n  case 30:\n  case 31:\n  case 32:\n  case 33:\n  case 34:\n  case 35:\n  case 36:\n  case 37:","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":0,"function":"const uint32_t *prisma_gradient(uint8_t resolution, uint32_t argb_first, uint32_t argb_last) {\n    static uint32_t gradient[256];\n    float i, a, r, g, b, offset;\n    memset(gradient, 0, 256 * sizeof(uint32_t));\n    if (resolution == 0)\n        return gradient;\n    if (resolution == 1) {\n        gradient[0] = argb_first;\n        return gradient;\n    }\n    gradient[0] = argb_first;\n    i = 1.F;\n    do {\n        if ((((argb_first) & 4278190080U) >> 24) < (((argb_last) & 4278190080U) >> 24)) {\n            offset = ((float)((((argb_last) & 4278190080U) >> 24) - (((argb_first) & 4278190080U) >> 24))) / (float)resolution;\n            a = (((argb_first) & 4278190080U) >> 24) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 4278190080U) >> 24) - (((argb_last) & 4278190080U) >> 24))) / (float)resolution;\n            a = (((argb_last) & 4278190080U) >> 24) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if ((((argb_first) & 16711680) >> 16) < (((argb_last) & 16711680) >> 16)) {\n            offset = ((float)((((argb_last) & 16711680) >> 16) - (((argb_first) & 16711680) >> 16))) / (float)resolution;\n            r = (((argb_first) & 16711680) >> 16) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 16711680) >> 16) - (((argb_last) & 16711680) >> 16))) / (float)resolution;\n            r = (((argb_last) & 16711680) >> 16) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if ((((argb_first) & 65280) >> 8) < (((argb_last) & 65280) >> 8)) {\n            offset = ((float)((((argb_last) & 65280) >> 8) - (((argb_first) & 65280) >> 8))) / (float)resolution;\n            g = (((argb_first) & 65280) >> 8) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)((((argb_first) & 65280) >> 8) - (((argb_last) & 65280) >> 8))) / (float)resolution;\n            g = (((argb_last) & 65280) >> 8) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        if (((argb_first) & 255) < ((argb_last) & 255)) {\n            offset = ((float)(((argb_last) & 255) - ((argb_first) & 255))) / (float)resolution;\n            b = ((argb_first) & 255) + ceilf((i + i / ((float)resolution - 1)) * offset);\n        } else {\n            offset = ((float)(((argb_first) & 255) - ((argb_last) & 255))) / (float)resolution;\n            b = ((argb_last) & 255) - ceilf((i + i / ((float)resolution - 1)) * offset);\n        }\n        gradient[(uint8_t)i] = (((((uint8_t)a) << 24) & 4278190080U) | ((((uint8_t)r) << 16) & 16711680) | ((((uint8_t)g) << 8) & 65280) | (((uint8_t)b) & 255));\n        i++;\n    } while (i <= resolution && i != 0.F);\n    gradient[((uint8_t)i) - 2] = argb_last;\n    return gradient;\n}\n","function_prediction":"uint32_t *prisma_gradient_name_conflict(uint8_t n, uint32_t start, uint32_t end) {\n  uint8_t i;\n  uint8_t r, g, b, a;\n  uint8_t r_start, g_start, b_start, a_start;\n  uint8_t r_end, g_end, b_end, a_end;\n  float step;\n  float step_r, step_g, step_b, step_a;\n  float r_step, g_step, b_step, a_step;\n  float r_cur, g_cur, b_cur, a_cur;\n\n  for (i = 0; i < 128; i++)\n    gradient_0[i] = 0;\n\n  if (n == 0)\n    return gradient_0;\n\n  if (n == 1) {\n    gradient_0[0] = start;\n    return gradient_0;\n  }\n\n  r_start = (start >> 24) & 0xFF;\n  g_start = (start >> 16) & 0xFF;\n  b_start = (start >> 8) & 0xFF;\n  a_start = start & 0xFF;\n\n  r_end = (end >> 24) & 0xFF;\n  g_end = (end >> 16) & 0xFF;\n  b_end = (end >> 8) & 0xFF;\n  a_end = end & 0xFF;\n\n  step = (float)n;\n  step_r = (float)(r_end - r_start) / step;\n  step_g = (float)(g_end - g_start) / step;\n  step_b = (float)(b_end - b_start) / step;\n  step_a = (float)(a_end - a_start) / step;\n\n  r_cur = r_start;\n  g_cur = g_start;\n  b_cur = b_start;\n  a_cur = a_start;\n","pass":0,"source_file":"C_COMPILE/yoanlcq_prisma/src/prisma.c"}
{"compilable":1,"function":"static int main_ea_cycles(void) {\n    int l;\n    if (main_size == 4)\n        l = 4;\n    else\n        l = 0;\n    switch (main_eamode) {\n      case aind:\n        return (l + 4);\n      case ainc:\n        return (l + 4);\n      case adec:\n        return (l + 6);\n      case adsp:\n        return (l + 8);\n      case axdp:\n        return (l + 10);\n      case absw:\n        return (l + 8);\n      case absl:\n        return (l + 12);\n      case pcdp:\n        return (l + 8);\n      case pcxd:\n        return (l + 10);\n      case immd:\n        return (l + 4);\n      default:\n        break;\n    }\n    return 0;\n}\n","function_prediction":"int main_ea_cycles_name_conflict(void) {\n  int cycles = 0;\n\n  switch (main_eamode) {\n  case 0:\n  case 1:\n  case 2:\n  case 3:\n  case 4:\n  case 5:\n  case 6:\n  case 7:\n  case 8:\n  case 9:\n  case 10:\n  case 11:\n    cycles += 4;\n    break;\n  }\n\n  if (main_size == 4)\n    cycles += 4;\n\n  return cycles;\n}","pass":0,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":0,"function":"static int main_ea_cycles_nofetch(void) {\n    switch (main_eamode) {\n      case aind:\n        return (2);\n      case ainc:\n        return (4);\n      case adec:\n        return (4);\n      case adsp:\n        return (4);\n      case axdp:\n        return (8);\n      case absw:\n        return (4);\n      case absl:\n        return (8);\n      default:\n        break;\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":1,"function":"static int test(int n, int m, int op) {\n    int t;\n    if ((n & m) != op)\n        return 0;\n    for (t = op & 61440; t < n; t++) {\n        if ((!unique[t]) && ((t & m) == (n & m))) {\n            rproc[n] = t;\n            return 2;\n        }\n    }\n    unique[n] = (m >> 16) & 1;\n    rproc[n] = n;\n    t = (m ^ 65535) & 4095;\n    if (!t) {\n        emit(\"; Opcode %04X\\n\", n);\n    } else {\n        emit(\"; Opcodes %04X - %04X\\n\", n, op + t);\n    }\n    emit(\"%c%03X:\\n\", ((n >> 12) & 15) + 'K', n & 4095);\n    routine_counter++;\n    return 1;\n}\n","function_prediction":"int test_name_conflict(int opc, int mask, int opc2) {\n  int i;\n\n  if ((opc & mask) != opc2)\n    return 0;\n\n  for (i = opc2 & 0xf000; i < opc; i++)\n    if (unique[i] == 0 && (opc ^ i) & mask == 0) {\n      rproc[opc] = i;\n      return 2;\n    }\n\n  unique[opc] = (mask >> 16) & 1;\n  rproc[opc] = opc;\n  opc2 &= 0xfff;\n  if (opc2)\n    emit(\"; Opcodes %04X - %04X\\n\", opc, opc2 + opc);\n  else\n    emit(\"; Opcode %04X\\n\", opc);\n  emit(\"%c%03X:\\n\", 'K' + ((opc >> 12) & 0xf), opc & 0xfff);\n  routine_counter++;\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":1,"function":"static char *getparameter(int *ip, int argc, char **argv) {\n    int i;\n    (*ip)++;\n    i = (*ip);\n    if (i >= argc) {\n        fprintf(stderr, \"Invalid use of %s option\\n\", argv[i - 1]);\n        return ((void *)0);\n    }\n    return argv[i];\n}\n","function_prediction":"char *getparameter_name_conflict(int *i, int argc, char *argv[]) {\n  (*i)++;\n  if (*i < argc)\n    return argv[*i];\n  else {\n    fprintf(stderr, \"Invalid use of %s option\\n\", argv[*i - 1]);\n    return NULL;\n  }\n}","pass":1,"source_file":"C_COMPILE/ProfessorKaos64_gngeo/src/star/star.c"}
{"compilable":0,"function":"int set_interface_attribs(int fd, int speed, int parity) {\n    struct termios tty;\n    memset(&tty, 0, sizeof tty);\n    if (tcgetattr(fd, &tty) != 0) {\n        printf(\"error %d from tcgetattr\", (*__errno_location()));\n        return -1;\n    }\n    cfsetospeed(&tty, speed);\n    cfsetispeed(&tty, speed);\n    tty.c_cflag = (tty.c_cflag & ~48) | 48;\n    tty.c_iflag &= ~1;\n    tty.c_lflag = 0;\n    tty.c_oflag = 0;\n    tty.c_cc[6] = 0;\n    tty.c_cc[5] = 5;\n    tty.c_iflag &= ~(1024 | 4096 | 2048);\n    tty.c_cflag |= (2048 | 128);\n    tty.c_cflag &= ~(256 | 512);\n    tty.c_cflag |= parity;\n    tty.c_cflag &= ~64;\n    tty.c_cflag &= ~2147483648U;\n    if (tcsetattr(fd, 0, &tty) != 0) {\n        printf(\"error %d from tcsetattr\", (*__errno_location()));\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int set_interface_attribs_name_conflict(int fd, int speed, int parity) {\n  struct termios tty;\n  if (tcgetattr(fd, &tty) != 0) {\n    printf(\"error %d from tcgetattr\", errno);\n    return -1;\n  }\n\n  cfsetospeed(&tty, speed);\n  cfsetispeed(&tty, speed);\n\n  tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8;\n  tty.c_iflag &= ~IGNBRK;\n  tty.c_lflag = 0;\n  tty.c_oflag = 0;\n  tty.c_cc[VMIN] = 0;\n  tty.c_cc[VTIME] = 5;\n\n  tty.c_iflag &= ~(IXON | IXOFF | IXANY);\n\n  tty.c_cflag |= (CLOCAL | CREAD);\n  tty.c_cflag &= ~(PARENB | PARODD);\n  tty.c_cflag |= parity;\n  tty.c_cflag &= ~CSTOPB;\n  tty.c_cflag &= ~CRTSCTS;\n\n  if (tcsetattr(fd, 0, &tty) != 0) {\n    printf(\"error %d from tcsetattr\", errno);\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/abradner_homely/ard/tools/stdin-to-serial/serial.c"}
{"compilable":1,"function":"int extractLineNum(char *input) {\n    int n = strlen(input);\n    char *p = input + n - 1;\n    while (*p != ' ')\n        p--;\n    p++;\n    int lno = atoi(p);\n    *p = '\\x00';\n    return lno;\n}\n","function_prediction":"int extractLineNum_name_conflict(char *line) {\n  int len = strlen(line);\n  char *p = line + len - 1;\n  while (*p != ' ')\n    p--;\n  int lineNum = strtol(p + 1, NULL, 10);\n  *p = '\\0';\n  return lineNum;\n}","pass":0,"source_file":"C_COMPILE/anantsubramanian_graphL-compiler/src/parsetree_generator.c"}
{"compilable":1,"function":"char rotate(char dir) {\n    return (dir + 2) % 12;\n}\n","function_prediction":"char rotate_name_conflict(char c) { return (c + 2) % 12; }","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char flip(char dir) {\n    return (12 - dir) % 12;\n}\n","function_prediction":"char flip_name_conflict(char c) { return (12 - c) % 12; }","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"char shift(char cell, char dir) {\n    switch (dir) {\n      case 0:\n        return cell + 1;\n      case 1:\n        if ((cell / 5) % 2)\n            return cell + 7;\n        else\n            return cell + 6;\n      case 2:\n        if ((cell / 5) % 2)\n            return cell + 6;\n        else\n            return cell + 5;\n      case 3:\n        return cell + 10;\n      case 4:\n        if ((cell / 5) % 2)\n            return cell + 5;\n        else\n            return cell + 4;\n      case 5:\n        if ((cell / 5) % 2)\n            return cell + 4;\n        else\n            return cell + 3;\n      case 6:\n        return cell - 1;\n      case 7:\n        if ((cell / 5) % 2)\n            return cell - 6;\n        else\n            return cell - 7;\n      case 8:\n        if ((cell / 5) % 2)\n            return cell - 5;\n        else\n            return cell - 6;\n      case 9:\n        return cell - 10;\n      case 10:\n        if ((cell / 5) % 2)\n            return cell - 4;\n        else\n            return cell - 5;\n      case 11:\n        if ((cell / 5) % 2)\n            return cell - 3;\n        else\n            return cell - 4;\n      default:\n        return cell;\n    }\n}\n","function_prediction":"int shift_cold(int x) { return x; }","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"char out_of_bounds(char cell, char dir) {\n    char i;\n    switch (dir) {\n      case 0:\n        return cell % 5 == 4;\n      case 1:\n        i = cell % 10;\n        return i == 4 || i == 8 || i == 9 || cell >= 45;\n      case 2:\n        return cell % 10 == 9 || cell >= 45;\n      case 3:\n        return cell >= 40;\n      case 4:\n        return cell % 10 == 0 || cell >= 45;\n      case 5:\n        i = cell % 10;\n        return i == 0 || i == 1 || i == 5 || cell >= 45;\n      case 6:\n        return cell % 5 == 0;\n      case 7:\n        i = cell % 10;\n        return i == 0 || i == 1 || i == 5 || cell < 5;\n      case 8:\n        return cell % 10 == 0 || cell < 5;\n      case 9:\n        return cell < 10;\n      case 10:\n        return cell % 10 == 9 || cell < 5;\n      case 11:\n        i = cell % 10;\n        return i == 4 || i == 8 || i == 9 || cell < 5;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int out_of_bounds_cold(int *p) {\n  int *q = p + 1;\n  if (*q == 0)\n    return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int cells_fit_on_board(char *cell, int piece) {\n    return (!out_of_bounds(cell[0], piece_def[piece][0]) && !out_of_bounds(cell[1], piece_def[piece][1]) && !out_of_bounds(cell[2], piece_def[piece][2]) && !out_of_bounds(cell[3], piece_def[piece][3]));\n}\n","function_prediction":"int cells_fit_on_board(struct board *board, int piece_index,\n                       struct cell *cells) {\n  int i;\n  for (i = 0; i < 4; i++) {\n    if (out_of_bounds(board->width, board->height, cells[i].x, cells[i].y)) {\n      return 0;\n    }\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char minimum_of_cells(char *cell) {\n    char minimum = cell[0];\n    minimum = cell[1] < minimum ? cell[1] : minimum;\n    minimum = cell[2] < minimum ? cell[2] : minimum;\n    minimum = cell[3] < minimum ? cell[3] : minimum;\n    minimum = cell[4] < minimum ? cell[4] : minimum;\n    return minimum;\n}\n","function_prediction":"char minimum_of_cells_name_conflict(char *cells) {\n  char min = cells[0];\n  for (int i = 1; i < 5; i++) {\n    if (cells[i] < min) {\n      min = cells[i];\n    }\n  }\n  return min;\n}","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"char first_empty_cell(char *cell, char minimum) {\n    char first_empty = minimum;\n    while (first_empty == cell[0] || first_empty == cell[1] || first_empty == cell[2] || first_empty == cell[3] || first_empty == cell[4])\n        first_empty++;\n    return first_empty;\n}\n","function_prediction":"int first_empty_cell_name_conflict(char *board, char player) {\n  int i;\n  for (i = 0;\n       board[i] == player || board[i] == player + 1 || board[i] == player + 2 ||\n       board[i] == player + 3 || board[i] == player + 4;\n       i++)\n    ;\n  return i;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"unsigned long long bitmask_from_cells(char *cell) {\n    unsigned long long piece_mask = 0ULL;\n    int i;\n    for (i = 0; i < 5; i++)\n        piece_mask |= 1ULL << cell[i];\n    return piece_mask;\n}\n","function_prediction":"uint64_t bitmask_from_cells_name_conflict(const char *cells) {\n  return (1ULL << (cells[0] & 0x3F)) | (1ULL << (cells[1] & 0x3F)) |\n         (1ULL << (cells[2] & 0x3F)) | (1ULL << (cells[3] & 0x3F)) |\n         (1ULL << (cells[4] & 0x3F));\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int has_island(char *cell, int piece) {\n    char temp_board[50];\n    char c;\n    int i;\n    for (i = 0; i < 50; i++)\n        temp_board[i] = 0;\n    for (i = 0; i < 5; i++)\n        temp_board[((int)cell[i])] = 1;\n    i = 49;\n    while (temp_board[i] == 1)\n        i--;\n    fill_contiguous_space(temp_board, i);\n    c = 0;\n    for (i = 0; i < 50; i++)\n        if (temp_board[i] == 0)\n            c++;\n    if (c == 0 || (c == 5 && piece == 8) || (c == 40 && piece == 8) || (c % 5 == 0 && piece == 0))\n        return 0;\n    else\n        return 1;\n}\n","function_prediction":"int has_island_name_conflict(char *line, int len) {\n  int i, island_size = 0;\n  char island_map[16] = {0};\n\n  for (i = 0; i < 5; i++)\n    island_map[line[i]] = 1;\n\n  for (i = 0; i < 16; i++)\n    if (island_map[i] == 1)\n      island_size = i;\n\n  island_size = fill_contiguous_space(0, island_map, island_size);\n\n  island_size = psadbw(island_map, island_size);\n\n  if (island_size == 0 || island_size == 5 || island_size == 42 ||\n      (len == 8 && island_size == 1))\n    return 0;\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int rows_bad(char row1, char row2, int even) {\n    int i, in_zeroes, group_okay;\n    char block, row2_shift;\n    if (even)\n        row2_shift = ((row2 << 1) & 31) | 1;\n    else\n        row2_shift = (row2 >> 1) | 16;\n    block = ((row1 ^ row2) & row2) & ((row1 ^ row2_shift) & row2_shift);\n    in_zeroes = 0;\n    group_okay = 0;\n    for (i = 0; i < 5; i++) {\n        if (row1 & (1 << i)) {\n            if (in_zeroes) {\n                if (!group_okay)\n                    return 1;\n                in_zeroes = 0;\n                group_okay = 0;\n            }\n        } else {\n            if (!in_zeroes)\n                in_zeroes = 1;\n            if (!(block & (1 << i)))\n                group_okay = 1;\n        }\n    }\n    if (in_zeroes)\n        return !group_okay;\n    else\n        return 0;\n}\n","function_prediction":"int rows_bad_name_conflict(unsigned char row, unsigned char col, int side) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  unsigned char a, b, c, d, e, f, g, h, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1,\n      s1, t1, u1, v1, w1, x1, y1, z1;\n  unsigned char a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2,\n      q2, r2, s2, t2, u2, v2, w2, x2, y2, z2;\n  unsigned char a3, b3, c3, d3, e3, f3, g3, h3, i3, j3, k3, l3, m3, n3, o3, p3,\n      q3, r3, s3, t3, u3, v3, w3, x3, y3, z3;\n  unsigned char a4, b4, c4, d4, e4, f4, g4, h4, i4, j4, k4, l4, m4, n4, o4, p4,\n      q4, r4, s4, t4, u4, v4, w4, x4, y4, z4;\n  unsigned char a5, b5, c5, d5, e5, f5, g5, h5, i5, j5, k5, l5, m5, n5, o5, p5,\n      q5, r5, s5, t5, u5, v5, w5, x5, y5, z5;\n  unsigned char a6, b6, c6, d6, e6, f6, g6, h6, i6, j6, k6, l6, m6, n6, o6, p6,\n      q","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":1,"function":"int triple_is_okay(char row1, char row2, char row3, int even) {\n    if (even) {\n        return ((row1 == 3) && (row2 == 11) && ((row3 & 28) == 12)) || ((row1 == 1) && (row2 == 5) && (row3 == 6)) || ((row1 == 25) && (row2 == 17)) || ((row1 == 21) && (row2 == 17));\n    } else {\n        return ((row1 == 19) && (row2 == 17)) || ((row1 == 21) && (row2 == 17));\n    }\n}\n","function_prediction":"int triple_is_okay_name_conflict(char a, char b, char c, int is_triple_double) {\n  if (is_triple_double) {\n    if (a == 0x03 && b == 0x05 && (c == 0x06 || c == 0x0C))\n      return 1;\n    if (a == 0x01 && b == 0x05 && c == 0x06)\n      return 1;\n    if (a == 0x11 && (b == 0x13 || b == 0x14 || b == 0x15 || b == 0x16))\n      return 1;\n  } else {\n    if (a == 0x11 && (b == 0x13 || b == 0x14 || b == 0x15 || b == 0x16))\n      return 1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"int boardHasIslands(char cell) {\n    if (cell >= 40)\n        return 0;\n    int current_triple = (board >> ((cell / 5) * 5)) & 32767;\n    if ((cell / 5) % 2)\n        return bad_odd_triple[current_triple];\n    else\n        return bad_even_triple[current_triple];\n}\n","function_prediction":"int boardHasIslands_name_conflict(char c) {\n  if (c < '(')\n    return (c / 5) % 2 ? bad_odd_triple[board.islands & 0x7fff]\n                       : bad_even_triple[board.islands & 0x7fff];\n  else\n    return 0;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/meteor-contest.c"}
{"compilable":0,"function":"static long fannkuch(int n) {\n    int *perm;\n    int *perm1;\n    int *count;\n    long flips;\n    long flipsMax;\n    int r;\n    int i;\n    int k;\n    int didpr;\n    const int n1 = n - 1;\n    if (n < 1)\n        return 0;\n    perm = calloc(n, sizeof (*perm));\n    perm1 = calloc(n, sizeof (*perm1));\n    count = calloc(n, sizeof (*count));\n    for (i = 0; i < n; ++i)\n        perm1[i] = i;\n    r = n;\n    didpr = 0;\n    flipsMax = 0;\n    for (;;) {\n        if (didpr < 30) {\n            for (i = 0; i < n; ++i)\n                printf(\"%d\", (int)(1 + perm1[i]));\n            printf(\"\\n\");\n            ++didpr;\n        }\n        for (; r != 1; --r) {\n            count[r - 1] = r;\n        }\n        if (!(perm1[0] == 0 || perm1[n1] == n1)) {\n            flips = 0;\n            for (i = 1; i < n; ++i) {\n                perm[i] = perm1[i];\n            }\n            k = perm1[0];\n            do {\n                int j;\n                for (i = 1 , j = k - 1; i < j; ++i , --j) {\n                    {\n                        int t_mp;\n                        t_mp = (perm[i]);\n                        (perm[i]) = (perm[j]);\n                        (perm[j]) = t_mp;\n                    }\n                }\n                ++flips;\n                j = perm[k];\n                perm[k] = k;\n                k = j;\n            } while (k);\n            if (flipsMax < flips) {\n                flipsMax = flips;\n            }\n        }\n        for (;;) {\n            if (r == n) {\n                return flipsMax;\n            }\n            {\n                int perm0 = perm1[0];\n                i = 0;\n                while (i < r)\n                    {\n                        k = i + 1;\n                        perm1[i] = perm1[k];\n                        i = k;\n                    }\n                perm1[r] = perm0;\n            }\n            if ((count[r] -= 1) > 0) {\n                break;\n            }\n            ++r;\n        }\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/fannkuch.c"}
{"compilable":1,"function":"int errex(char *s, int n) {\n    fprintf(stderr, \"\\n*** Error: %s [%d]!\\n\", s, n);\n    return 1;\n}\n","function_prediction":"int errex_name_conflict(char *msg, int err) {\n  fprintf(stderr, \"\\n*** Error: %s [%d]!\\n\", msg, err);\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/reverse-complement.c"}
{"compilable":0,"function":"treeNode *NewTreeNode(treeNode *left, treeNode *right, long item) {\n    treeNode *new;\n    new = (treeNode *)malloc(sizeof(treeNode));\n    new->left = left;\n    new->right = right;\n    new->item = item;\n    return new;\n}\n","function_prediction":"TreeNode *NewTreeNode_name_conflict(char *token, TreeNode *left, TreeNode *right) {\n  TreeNode *node = (TreeNode *)malloc(sizeof(TreeNode));\n  node->token = token;\n  node->left = left;\n  node->right = right;\n  return node;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":0,"function":"long ItemCheck(treeNode *tree) {\n    if (tree->left == ((void *)0))\n        return tree->item;\n    else\n        return tree->item + ItemCheck(tree->left) - ItemCheck(tree->right);\n}\n","function_prediction":"long ItemCheck_name_conflict(Item *item) {\n  long sum = 0;\n  long sign = 1;\n  Item *i;\n\n  for (i = item->first; i; i = i->next) {\n    sum += sign * i->value;\n    sign = -sign;\n  }\n\n  return sum;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":0,"function":"treeNode *BottomUpTree(long item, unsigned int depth) {\n    if (depth > 0)\n        return NewTreeNode(BottomUpTree(2 * item - 1, depth - 1), BottomUpTree(2 * item, depth - 1), item);\n    else\n        return NewTreeNode(((void *)0), ((void *)0), item);\n}\n","function_prediction":"struct TreeLinkNode *BottomUpTree_name_conflict(int label, int height) {\n  if (height == 0) {\n    struct TreeLinkNode *node =\n        (struct TreeLinkNode *)malloc(sizeof(struct TreeLinkNode));\n    node->label = label;\n    node->left = node->right = node->next = NULL;\n    return node;\n  }\n\n  struct TreeLinkNode *root =\n      (struct TreeLinkNode *)malloc(sizeof(struct TreeLinkNode));\n  root->left = BottomUpTree_name_conflict(2 * label - 1, height - 1);\n  root->right = BottomUpTree_name_conflict(2 * label, height - 1);\n  root->label = label;\n  root->next = NULL;\n  return root;\n}","pass":0,"source_file":"C_COMPILE/shishkander_go/test/bench/shootout/binary-tree.c"}
{"compilable":0,"function":"INT32 HTTPSendFile(HTTP_SESSION_HANDLE pSession, CHAR *FilePath) {\n    UINT32 ret = 0;\n    char *buf, p;\n    int buf_size = 0, sent_size;\n    FILE *f;\n    buf = (char *)malloc(65536);\n    f = fopen(FilePath, \"rb\");\n    if (!f) {\n        ret = 1;\n        return ret;\n    }\n    while ((buf_size = fread(buf, 1, 65536, f)) != 0)\n        {\n            ret = HTTPClientWriteData(pSession, buf, buf_size, 5);\n            if (ret != 0) {\n                break;\n            }\n        }\n    return ret;\n}\n","function_prediction":"int HTTPSendFile_name_conflict(HTTPClient *client, const char *filename) {\n  char *buffer = malloc(65536);\n  FILE *file = fopen(filename, \"rb\");\n  if (file == NULL)\n    return 1;\n  int bytes;\n  while ((bytes = fread(buffer, 1, 65536, file)) != 0) {\n    int error = HTTPClientWriteData(client, buffer, bytes, 5);\n    if (error != 0)\n      return error;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSample.c"}
{"compilable":0,"function":"INT32 HTTPParseCommandLineArgs(UINT32 argc, CHAR *argv[], HTTPParameters *pClientParams) {\n    UINT32 nArg;\n    UINT32 nResult;\n    CHAR *pSearchPtr = ((void *)0);\n    CHAR PortNum[64];\n    if (argc <= 1) {\n        HTTPDumpHelp(\"Error: did not get key parameters.\");\n        return -1;\n    }\n    ;\n    for (nArg = 1; nArg < argc; nArg++) {\n        if (strncasecmp(argv[nArg], \"/?\", 2) == 0) {\n            HTTPDumpHelp(((void *)0));\n            return -1;\n        }\n        if (strncasecmp(argv[nArg], \"/V\", 2) == 0) {\n            pClientParams->Verbose = 1;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H:\", 3) == 0) {\n            strcpy(pClientParams->Uri, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/R:\", 3) == 0) {\n            strcpy(pClientParams->ProxyHost, argv[nArg] + 3);\n            pClientParams->UseProxy = 1;\n            pSearchPtr = strstr(pClientParams->ProxyHost, \":\");\n            if (pSearchPtr) {\n                PortNum[0] = 0;\n                nResult = (int)(pSearchPtr - pClientParams->ProxyHost);\n                strcpy(PortNum, pClientParams->ProxyHost + nResult + 1);\n                pClientParams->ProxyHost[nResult] = 0;\n                pClientParams->ProxyPort = atol(PortNum);\n            } else {\n                pClientParams->ProxyPort = 8080;\n            }\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/C:\", 3) == 0) {\n            strcpy(pClientParams->UserName, argv[nArg] + 3);\n            pSearchPtr = strstr(pClientParams->UserName, \":\");\n            if (!pSearchPtr) {\n                HTTPDumpHelp(\"Error: /C argument must be in the form of user:password\");\n                return -1;\n            }\n            nResult = (int)(pSearchPtr - pClientParams->UserName);\n            strcpy(pClientParams->Password, pClientParams->UserName + nResult + 1);\n            pClientParams->UserName[nResult] = 0;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/A:\", 3) == 0) {\n            pSearchPtr = argv[nArg] + 3;\n            if (*pSearchPtr == 'b' || *pSearchPtr == 'B') {\n                pClientParams->AuthType = AuthSchemaBasic;\n                continue;\n            }\n            if (*pSearchPtr == 'd' || *pSearchPtr == 'D') {\n                pClientParams->AuthType = AuthSchemaDigest;\n                continue;\n            }\n            if (pClientParams->AuthType == AuthSchemaNone) {\n                HTTPDumpHelp(\"Error: /A argument must be 'b' (for basic) or 'd' (for digest)\");\n                return -1;\n            }\n        }\n        if (strncasecmp(argv[nArg], \"/D:\", 3) == 0) {\n            strcpy(pClientParams->PostData, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/F:\", 3) == 0) {\n            strcpy(pClientParams->PutFilePath, argv[nArg] + 3);\n            continue;\n        }\n    }\n    if (strlen(pClientParams->Uri) == 0) {\n        HTTPDumpHelp(\"Error: /H argument is missing\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int HTTPParseCommandLineArgs(int argc, char *argv[],\n                             HTTP_CLIENT_PARAMS *pParams) {\n  int i;\n  char *p;\n  char *pPort;\n  char *pUser;\n  char *pPass;\n  char *pAuth;\n  char *pHost;\n  char *pProxy;\n  char *pCred;\n  char *pArg;\n  char *pArg2;\n  char *pArg3;\n  char *pArg4;\n  char *pArg5;\n  char *pArg6;\n  char *pArg7;\n  char *pArg8;\n  char *pArg9;\n  char *pArg10;\n  char *pArg11;\n  char *pArg12;\n  char *pArg13;\n  char *pArg14;\n  char *pArg15;\n  char *pArg16;\n  char *pArg17;\n  char *pArg18;\n  char *pArg19;\n  char *pArg20;\n  char *pArg21;\n  char *pArg22;\n  char *pArg23;\n  char *pArg24;\n  char *pArg25;\n  char *pArg26;\n  char *pArg27;\n  char *pArg28;\n  char *pArg29;\n  char *pArg30;\n  char *pArg31;\n  char *pArg32;\n  char *pArg33;\n  char *pArg34;\n  char *pArg35;\n  char *pArg36;\n  char *pArg37;\n  char *pArg38;\n  char *pArg39;\n  char *pArg40;\n  char *pArg41;\n  char *pArg42;\n  char *pArg43;\n  char *pArg44;\n  char *pArg45;\n  char *pArg46;\n  char *pArg47;\n  char *pArg48;","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSample.c"}
{"compilable":0,"function":"BOOL HTTPStrInsensitiveCompare(CHAR *pSrc, CHAR *pDest, UINT32 nLength) {\n    UINT32 nPosition;\n    UINT32 nDestLength;\n    CHAR *pSrcIn, *pDestIn;\n    CHAR a, b;\n    pSrcIn = pSrc;\n    pDestIn = pDest;\n    nPosition = 0;\n    nDestLength = strlen(pDest);\n    if (nLength == 0) {\n        nLength = strlen(pSrc);\n    }\n    if (nDestLength != nLength) {\n        return 0;\n    }\n    while (pSrcIn || pDestIn)\n        {\n            if (nLength > 0 && nPosition == nLength) {\n                return 1;\n            }\n            a = *pSrcIn;\n            b = *pDestIn;\n            if (*pSrcIn >= 64 && *pSrcIn <= 90) {\n                a = *pSrcIn + 32;\n            }\n            if (*pDestIn >= 64 && *pDestIn <= 90) {\n                b = *pDestIn + 32;\n            }\n            if (a != b) {\n                return 0;\n            }\n            pSrcIn++;\n            pDestIn++;\n            nPosition++;\n        }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR HTTPStrExtract(CHAR *pParam, UINT32 nOffset, CHAR Restore) {\n    CHAR Replaced;\n    if (!pParam) {\n        return 0;\n    }\n    if (Restore != 0) {\n        pParam[nOffset] = Restore;\n        return Restore;\n    } else {\n        Replaced = pParam[nOffset];\n        pParam[nOffset] = 0;\n        return Replaced;\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrCaseStr(const char *pSrc, UINT32 nSrcLength, const char *pFind) {\n    const char *ptr = pSrc;\n    const char *ptr2;\n    UINT32 iLength = 0;\n    while (1)\n        {\n            if (iLength >= nSrcLength) {\n                break;\n            }\n            ptr = strchr((char *)pSrc, toupper((int)*pFind));\n            ptr2 = strchr((char *)pSrc, tolower((int)*pFind));\n            if (!ptr) {\n                ptr = ptr2;\n            }\n            if (!ptr) {\n                break;\n            }\n            if (ptr2 && (ptr2 < ptr)) {\n                ptr = ptr2;\n            }\n            if (!strncasecmp(ptr, pFind, strlen(pFind))) {\n                return (char *)ptr;\n            }\n            pSrc = ptr + 1;\n            iLength++;\n        }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrGetToken(CHAR *pSrc, UINT32 nSrcLength, CHAR *pDest, UINT32 *nDestLength) {\n    CHAR *pStart = pSrc;\n    CHAR *pEnd;\n    UINT32 nTokenLength = 0;\n    UINT32 nPosition = 0;\n    pStart = strchr(pSrc, ':') + 1;\n    if (pStart) {\n        pEnd = pStart;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    nTokenLength++;\n                }\n                if (nSrcLength && nPosition > nSrcLength) {\n                    break;\n                }\n                pEnd++;\n                nPosition++;\n            }\n        if (nTokenLength > *(nDestLength)) {\n            *(nDestLength) = nTokenLength;\n            pDest = ((void *)0);\n            return pDest;\n        }\n        pEnd = pStart;\n        *(nDestLength) = nTokenLength;\n        nTokenLength = 0;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    pDest[nTokenLength++] = *pEnd;\n                }\n                pEnd++;\n            }\n        pDest[nTokenLength] = 0;\n    }\n    return pDest;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"UINT32 HTTPStrHToL(CHAR *s) {\n    UINT32 i, nn, digit;\n    UINT32 n;\n    n = i = nn = 0;\n    do {\n        if (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalnum)) {\n            s[i] = toupper((int)s[i]);\n            if (s[i] == 'X')\n                nn = n = 0;\n            else {\n                digit = (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalpha) ? (s[i] - 'A' + 10) : s[i] - '0');\n                if (digit > 15)\n                    digit = 15;\n                n = n * 16 + digit;\n                if (n |= 0)\n                    nn++;\n                if (nn == 8)\n                    break;\n            }\n        }\n        i++;\n    } while (s[i] |= 0);\n    return n;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrLToH(CHAR *dest, UINT32 nSrc) {\n    char *hex = \"0123456789abcdef\";\n    int i;\n    if (nSrc == 0) {\n        dest[0] = '0';\n        dest[1] = 0;\n    } else {\n        for (i = 28; ((nSrc >> i) && 15) == 0; i -= 4)\n            ;\n        for (; i >= 0; i -= 4) {\n            *dest++ = hex[(nSrc >> i) & 15];\n        }\n        *dest = 0;\n    }\n    return dest;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"int HTTPWrapperIsAscii(int c) {\n    return (!(c & ~127));\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToUpper(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 97 && c <= 122) {\n            return (c - 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToLower(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 65 && c <= 90) {\n            return (c + 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlpha(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90)) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlNum(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (HTTPWrapperIsAlpha(c) > 0) {\n            return c;\n        }\n        if (c >= 48 && c <= 57) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"char *HTTPWrapperItoa(char *s, int a) {\n    unsigned int b;\n    if (a > 2147483647) {\n        return 0;\n    }\n    if (a < 0)\n        b = -a , *s++ = '-';\n    else\n        b = a;\n    for (; a; a = a / 10)\n        s++;\n    for (*s = '\\x00'; b; b = b / 10)\n        *--s = b % 10 + '0';\n    return s;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperShutDown(int s, int how) {\n    return shutdown(s, how);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetSocketError(int s) {\n    return (*__errno_location());\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetHostByName(char *name, UINT32 *address) {\n    HTTP_HOSTNET *HostEntry;\n    int iPos = 0, iLen = 0, iNumPos = 0, iDots = 0;\n    long iIPElement;\n    char c = 0;\n    char Num[4];\n    int iHostType = 0;\n    iLen = strlen(name);\n    for (iPos = 0; iPos <= iLen; iPos++) {\n        c = name[iPos];\n        if ((c >= 48 && c <= 57) || (c == '.')) {\n            if (c != '.') {\n                if (iNumPos > 3) {\n                    iHostType++;\n                    break;\n                }\n                Num[iNumPos] = c;\n                Num[iNumPos + 1] = 0;\n                iNumPos++;\n            } else {\n                iNumPos = 0;\n                iDots++;\n                iIPElement = atol(Num);\n                if (iIPElement > 256 || iDots > 3) {\n                    return -1;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n    if (c == 0 && iHostType == 0 && iDots == 3) {\n        iIPElement = atol(Num);\n        if (iIPElement > 256) {\n            return -1;\n        }\n    } else {\n        iHostType++;\n    }\n    if (iHostType > 0) {\n        struct addrinfo hints;\n        struct addrinfo *result = ((void *)0);\n        int ret;\n        memset((void *)&hints, 0, sizeof(struct addrinfo));\n        hints.ai_family = 2;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = 0;\n        hints.ai_protocol = 0;\n        ret = getaddrinfo(name, ((void *)0), &hints, &result);\n        if (ret == 0) {\n            *(address) = ((struct sockaddr_in *)result->ai_addr)->sin_addr.s_addr;\n            freeaddrinfo(result);\n            return 0;\n        } else {\n            fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(ret));\n            return -1;\n        }\n    } else {\n        *(address) = inet_addr(name);\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetRandomeNumber() {\n    int num;\n    num = (int)(((double)rand() / ((double)2147483647 + 1)) * 16);\n    return num;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int64_t HTTPWrapperGetUpTime() {\n    struct timespec tp;\n    clock_gettime(1, &tp);\n    return (int64_t)tp.tv_sec;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLConnect(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLNegotiate(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLSend(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecv(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecvPending(int s) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLClose(int s) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int sktSetNonblocking(int socket, int on_off) {\n    int flags_orig, flags_new;\n    flags_orig = fcntl(socket, 3, 0);\n    if (flags_orig < 0)\n        return -1;\n    if (on_off != 0)\n        flags_new = flags_orig | 2048;\n    else\n        flags_new = flags_orig & ~2048;\n    if (fcntl(socket, 4, flags_new) < 0) {\n        fcntl(socket, 4, flags_orig);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int sktSetNonblocking_name_conflict(int sock, int on) {\n  int flags;\n\n  if ((flags = fcntl(sock, 3, 0)) < 0)\n    return -1;\n\n  if (on)\n    flags |= (1 << 11);\n  else\n    flags &= ~(1 << 11);\n\n  if (fcntl(sock, 4, flags) < 0) {\n    fcntl(sock, 4, flags);\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetLocalConnection(HTTP_SESSION_HANDLE pSession, UINT32 nPort) {\n    return 0;\n}\n","function_prediction":"int HTTPClientSetLocalConnection_name_conflict(HTTPClient *client, int sock) {\n# 100 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmimu/libhttp/refs/heads/master/src/http_client.c\"\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"HTTP_SESSION_HANDLE HTTPClientOpenRequest(HTTP_CLIENT_SESSION_FLAGS Flags) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nAllocationSize;\n    pHTTPSession = (P_HTTP_SESSION)malloc(((sizeof(HTTP_SESSION) & 4294967292U) + ((sizeof(HTTP_SESSION) & 3) ? 4 : 0)));\n    if (!pHTTPSession) {\n        return 0;\n    }\n    memset(pHTTPSession, 0, sizeof(HTTP_SESSION));\n    if (0) {\n        nAllocationSize = (((2048) < (2048)) ? (2048) : (2048));\n    } else {\n        nAllocationSize = 2048;\n    }\n    pHTTPSession->HttpHeaders.HeadersBuffer.pParam = (CHAR *)malloc(((nAllocationSize & 4294967292U) + ((nAllocationSize & 3) ? 4 : 0)));\n    if (!pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession);\n        return 0;\n    }\n    memset(pHTTPSession->HttpHeaders.HeadersBuffer.pParam, 0, nAllocationSize);\n    pHTTPSession->HttpHeaders.HeadersBuffer.nLength = nAllocationSize;\n    HTTPClientSetVerb((HTTP_SESSION_HANDLE)pHTTPSession, (HTTP_VERB)0);\n    pHTTPSession->HttpUrl.nPort = 80;\n    pHTTPSession->HttpConnection.HttpSocket = (-1);\n    pHTTPSession->HttpHeaders.HeadersOut.pParam = pHTTPSession->HttpHeaders.HeadersBuffer.pParam;\n    pHTTPSession->HttpState = 1;\n    pHTTPSession->HttpFlags = Flags;\n    pHTTPSession->HttpHeadersInfo.nHTTPStatus = 0;\n    pHTTPSession->HttpNameCache.port = 80;\n    return (HTTP_SESSION_HANDLE)pHTTPSession;\n}\n","function_prediction":"HTTPClient *HTTPClientOpenRequest_name_conflict(int sock) {\n  HTTPClient *client;\n\n  client = calloc(sizeof(HTTPClient), 1);\n  if (client == NULL)\n    return NULL;\n\n  client->buffer = calloc(2048, 1);\n  if (client->buffer == NULL) {\n    free(client);\n    return NULL;\n  }\n\n  client->buffer_size = 2048;\n  client->method =\n      (((((unsigned int)('G')) << 24) | (((unsigned int)('E')) << 16) |\n        (((unsigned int)('T')) << 8) | ((unsigned int)(' '))));\n  client->version =\n      (((((unsigned int)('P')) << 24) | (((unsigned int)('T')) << 16) |\n        (((unsigned int)(' ')) << 8) | ((unsigned int)('1'))));\n  client->content_length = -1;\n  client->content_buffer = client->buffer;\n  client->content_buffer_size = 1;\n  client->sock = sock;\n  client->state =\n      (((((unsigned int)('P')) << 24) | (((unsigned int)('T')) << 16) |\n        (((unsigned int)(' ')) << 8) | ((unsigned int)('1'))));\n\n  return client;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientReset(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    return HTTPIntrnSessionReset(pHTTPSession, 1);\n}\n","function_prediction":"int HTTPClientReset_name_conflict(HTTPClient *client) {\n  int i;\n\n  if (client == NULL)\n    return 2;\n\n  memset(client->request, 0, client->request_size);\n  client->request_size = 0;\n  client->request_length = 0;\n  client->request_content_length = 0;\n  client->request_content_remaining = 0;\n  client->request_content_offset = 0;\n  client->request_content_type = NULL;\n  client->request_content_type_length = 0;\n  client->request_content_type_offset = 0;\n  client->request_content_type_remaining = 0;\n  client->request_content_encoding = NULL;\n  client->request_content_encoding_length = 0;\n  client->request_content_encoding_offset = 0;\n  client->request_content_encoding_remaining = 0;\n  client->request_content_boundary = NULL;\n  client->request_content_boundary_length = 0;\n  client->request_content_boundary_offset = 0;\n  client->request_content_boundary_remaining = 0;\n  client->request_content_disposition = NULL;\n  client->request_content_disposition_length = 0;\n  client->request_content_disposition_offset = 0;\n  client->request_content_disposition_remaining = 0;\n  client->request_content_disposition_filename = NULL;\n  client->request_content_disposition_filename_length = 0;\n  client->request_content_disposition_filename_offset = 0;\n  client->request_content_disposition_filename_remaining = 0;\n  client->request_content_disposition_filename_quoted = 0;\n  client->request_content_disposition_filename_quoted_length = 0;\n  client->request_content_disposition_filename_quoted_offset = 0;\n  client->request_content_disposition_filename_quoted_remaining = 0","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientCloseRequest(HTTP_SESSION_HANDLE *pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)*(pSession);\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession->HttpHeaders.HeadersBuffer.pParam);\n    }\n    HTTPIntrnConnectionClose(pHTTPSession);\n    free(pHTTPSession);\n    pHTTPSession = 0;\n    *(pSession) = 0;\n    return 0;\n}\n","function_prediction":"int HTTPClientCloseRequest_name_conflict(HTTPClientRequest **request) {\n  HTTPClientRequest *req = *request;\n  if (req == NULL)\n    return 2;\n\n  if (req->response.body != NULL)\n    free(req->response.body);\n\n  if (req->socket.fd != -1) {\n    if (req->socket.flags & 0x0010)\n      HTTPWrapperSSLClose(req->socket.ssl);\n\n    shutdown(req->socket.fd, 1);\n    close(req->socket.fd);\n  }\n\n  free(req);\n  *request = NULL;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetConnection(HTTP_SESSION_HANDLE pSession, BOOL Connection) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeadersInfo.Connection = Connection;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetConnection_name_conflict(HTTPClient *client, int connection) {\n  if (client == NULL)\n    return 2;\n\n  client->connection = connection;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetVerb(HTTP_SESSION_HANDLE pSession, HTTP_VERB HttpVerb) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.HttpVerb = HttpVerb;\n    switch (HttpVerb) {\n      case VerbGet:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"GET\");\n        break;\n      case VerbHead:\n        if (!0) {\n            return 18;\n        }\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"HEAD\");\n        break;\n      case VerbPost:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"POST\");\n        break;\n      case VerbPut:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"PUT\");\n        break;\n      default:\n        return 18;\n    }\n    ;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetVerb_name_conflict(HTTPClient *client, int verb) {\n  if (client == NULL)\n    return 2;\n\n  client->verb = verb;\n\n  switch (verb) {\n  case 0:\n    client->verb_str[0] = 'G';\n    client->verb_str[1] = 'E';\n    client->verb_str[2] = 'T';\n    client->verb_str[3] = 0;\n    break;\n\n  case 2:\n    client->verb_str[0] = 'P';\n    client->verb_str[1] = 'O';\n    client->verb_str[2] = 'S';\n    client->verb_str[3] = 'T';\n    client->verb_str[4] = 0;\n    break;\n\n  case 3:\n    client->verb_str[0] = 'P';\n    client->verb_str[1] = 'U';\n    client->verb_str[2] = 'T';\n    client->verb_str[3] = 0;\n    break;\n\n  default:\n    return 18;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetProxy(HTTP_SESSION_HANDLE pSession, CHAR *pProxyHost, UINT16 nPort, CHAR *pUserName, CHAR *pPassword) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    strncpy(pHTTPSession->HttpProxy.ProxyHost, pProxyHost, 64);\n    if (pUserName) {\n        strncpy(pHTTPSession->HttpProxy.ProxtUser, pUserName, 16);\n    }\n    if (pPassword) {\n        strncpy(pHTTPSession->HttpProxy.ProxyPassword, pPassword, 16);\n    }\n    pHTTPSession->HttpProxy.nProxyPort = nPort;\n    pHTTPSession->HttpFlags = pHTTPSession->HttpFlags | 128;\n    if (pPassword && pUserName) {\n        pHTTPSession->HttpProxy.ProxyAuthSchema = 1;\n    }\n    return 0;\n}\n","function_prediction":"int HTTPClientSetProxy(HTTP_CLIENT *httpClient, const char *proxy,\n                       unsigned short port, const char *user,\n                       const char *password) {\n  if (httpClient == NULL)\n    return 2;\n\n  strncpy(httpClient->proxy, proxy, 64);\n\n  if (user != NULL) {\n    strncpy(httpClient->proxyUser, user, 16);\n\n    if (password != NULL) {\n      strncpy(httpClient->proxyPassword, password, 16);\n      httpClient->proxyPort = port;\n      httpClient->flags |= 0x00000080;\n      httpClient->proxyAuth = 1;\n    } else {\n      httpClient->proxyPort = port;\n      httpClient->flags |= 0x00000080;\n    }\n  } else {\n    if (password != NULL)\n      strncpy(httpClient->proxyPassword, password, 16);\n\n    httpClient->flags |= 0x00000080;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetCredentials(HTTP_SESSION_HANDLE pSession, CHAR *pUserName, CHAR *pPassword) {\n    UINT32 nLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nLength = strlen(pUserName);\n    if (nLength > 16) {\n        return 19;\n    }\n    nLength = strlen(pPassword);\n    if (nLength > 16) {\n        return 19;\n    }\n    strcpy(pHTTPSession->HttpCredentials.CredUser, pUserName);\n    strcpy(pHTTPSession->HttpCredentials.CredPassword, pPassword);\n    pHTTPSession->HttpHeadersInfo.HaveCredentials = 1;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetCredentials(HTTPClient *client, const char *username,\n                             const char *password) {\n  if (client == NULL)\n    return 2;\n\n  if (strlen(username) > 16)\n    return 19;\n\n  if (strlen(password) > 16)\n    return 19;\n\n  memcpy(&client->credentials.username, username, strlen(username) + 1);\n  strcpy(&client->credentials.password, password);\n  client->credentials.set = 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientAddRequestHeaders(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderName, CHAR *pHeaderData, BOOL nInsert) {\n    UINT32 nRetCode;\n    UINT32 nHeaderLength, nDataLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nHeaderLength = strlen(pHeaderName);\n    nDataLength = strlen(pHeaderData);\n    nRetCode = HTTPIntrnHeadersAdd(pHTTPSession, pHeaderName, nHeaderLength, pHeaderData, nDataLength);\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientAddRequestHeaders(HTTPClient *http, const char *key,\n                                const char *value) {\n  int keyLen, valueLen, headerLen;\n  char *header;\n\n  if (http == NULL)\n    return 2;\n\n  keyLen = strlen(key);\n  valueLen = strlen(value);\n  headerLen = keyLen + valueLen + 4;\n\n  if (http->headers.contentLength + headerLen >\n          http->headers.maxContentLength ||\n      http->headers.contentLength + headerLen + http->headers.contentLength >\n          2048)\n    return 3;\n\n  if (http->headers.content != NULL) {\n    memcpy(http->headers.content + headerLen, http->headers.content,\n           http->headers.contentLength);\n    memset(http->headers.content + http->headers.contentLength, 0, headerLen);\n  }\n\n  header =\n      memcpy(http->headers.content + http->headers.contentLength, key, keyLen);\n  header = memcpy(header + keyLen, \": \", 2);\n  header = memcpy(header + 2, value, valueLen);\n  header = memcpy(header + valueLen, \"\\r\\n\", 2);\n\n  http->headers.contentLength += headerLen;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientRecvResponse(HTTP_SESSION_HANDLE pSession, UINT32 nTimeout) {\n    UINT32 nRetCode;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    do {\n        if ((nRetCode = HTTPIntrnHeadersReceive(pHTTPSession, nTimeout)) != 0) {\n            break;\n        }\n    } while (0);\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientRecvResponse_name_conflict(HTTPClient *client) {\n  if (client == NULL)\n    return 2;\n\n  return HTTPIntrnHeadersReceive_part_0(client);\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetInfo(HTTP_SESSION_HANDLE pSession, HTTP_CLIENT *HTTPClient) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    memset(HTTPClient, 0, sizeof(HTTP_CLIENT));\n    HTTPClient->HTTPStatusCode = pHTTPSession->HttpHeadersInfo.nHTTPStatus;\n    HTTPClient->RequestBodyLengthSent = pHTTPSession->HttpCounters.nSentBodyBytes;\n    HTTPClient->ResponseBodyLengthReceived = pHTTPSession->HttpCounters.nRecivedBodyLength;\n    HTTPClient->TotalResponseBodyLength = pHTTPSession->HttpHeadersInfo.nHTTPContentLength;\n    HTTPClient->HttpState = pHTTPSession->HttpState;\n    return 0;\n}\n","function_prediction":"int HTTPClientGetInfo_name_conflict(HTTPClient *client, HTTPClientInfo *info) {\n  if (client == NULL) {\n    return 2;\n  }\n\n  info->ip.addr = 0;\n  info->ip.port = 0;\n  info->ip.addr = client->ip.addr;\n  info->ip.port = client->ip.port;\n  info->status = client->status;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindFirstHeader(HTTP_SESSION_HANDLE pSession, CHAR *pSearchClue, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nClueLength;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nClueLength = strlen(pSearchClue);\n    if (nClueLength >= 1024) {\n        return 13;\n    } else {\n        strcpy(pHTTPSession->HttpHeaders.SearchClue, pSearchClue);\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    }\n    return 0;\n}\n","function_prediction":"int HTTPClientFindFirstHeader_name_conflict(HTTP_CLIENT *http, const char *header) {\n  UINT i;\n  // Validate arguments\n  if (http == NULL) {\n    return 2;\n  }\n\n  i = strlen(header);\n  if (i >= 1024) {\n    return 13;\n  }\n\n  memcpy(&http->Header[0], header, i + 1);\n  http->HeaderSize = 0;\n  http->HeaderPos = 0;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindCloseHeader(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.SearchClue[0] = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    return 0;\n}\n","function_prediction":"int HTTPClientFindCloseHeader_name_conflict(HTTP_CLIENT *client) {\n  // Validate arguments\n  if (client == NULL) {\n    return 2;\n  }\n\n  client->HttpHeader.CloseHeader = 0;\n  client->HttpHeader.CloseHeaderSize = 0;\n  client->HttpHeader.CloseHeaderPos = 0;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetNextHeader(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nOffset = 0;\n    UINT32 nRetCode;\n    HTTP_PARAM HttpHeader;\n    CHAR *pPtr;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeaderSearch.nLength > 0) {\n        nOffset = pHTTPSession->HttpHeaders.HeaderSearch.pParam - pHTTPSession->HttpHeaders.HeadersIn.pParam;\n    }\n    nRetCode = HTTPIntrnHeadersFind(pHTTPSession, pHTTPSession->HttpHeaders.SearchClue, &HttpHeader, 1, nOffset);\n    if (nRetCode == 0) {\n        if (HttpHeader.nLength > *(nLength)) {\n            *(nLength) = HttpHeader.nLength;\n            pHeaderBuffer[0] = 0;\n            return 3;\n        }\n        pPtr = HttpHeader.pParam;\n        nOffset = 0;\n        if (*pPtr == 13) {\n            nOffset++;\n            pPtr++;\n        }\n        if (*pPtr == 10) {\n            nOffset++;\n            pPtr++;\n        }\n        strncpy(pHeaderBuffer, pPtr, HttpHeader.nLength - nOffset);\n        pHeaderBuffer[HttpHeader.nLength - nOffset] = 0;\n        *(nLength) = HttpHeader.nLength - nOffset;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = HttpHeader.pParam + HttpHeader.nLength;\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength++;\n        return 0;\n    }\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientGetNextHeader_name_conflict(HTTPClient *http, char *header, int *header_len) {\n  int len;\n  char *p;\n  char *q;\n  int cr;\n\n  if (http == NULL)\n    return 2;\n\n  if (http->headers_pos == 0)\n    len = 0;\n  else\n    len = http->headers_end - http->headers_pos;\n\n  p = NULL;\n  if (strlen(http->headers) >= 1024 - 1)\n    return 13;\n\n  if (HTTPIntrnHeadersFind_part_0_constprop_0(http, http->headers, &p, 1,\n                                              len) != 0)\n    return 0;\n\n  if (p == NULL)\n    return 0;\n\n  if (*header_len >= (int)(p - http->headers)) {\n    cr = 0;\n    if (*p == '\\r') {\n      p++;\n      cr = 1;\n    }\n    if (*p == '\\n') {\n      p++;\n      cr = 1;\n    }\n    q = p + (p - http->headers) - cr;\n    len = p - q;\n    strncpy(header, q, len);\n    header[len] = '\\0';\n    *header_len = len;\n    http->headers_pos = p;\n    http->headers_pos_num++;\n    return 3;\n  }\n\n  *header_len = p - http->headers;\n  header[0] = '\\0';\n  return 3;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPIntrnSessionGetUpTime(void) {\n    return HTTPWrapperGetUpTime();\n}\n","function_prediction":"uint32_t HTTPIntrnSessionGetUpTime_name_conflict(HTTP_SESSION *pSession) {\n  return HTTPWrapperGetUpTime();\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"int HTTPBase64Decoder(char *out, const char *in) {\n    int len = 0;\n    register unsigned char digit1, digit2, digit3, digit4;\n    if (in[0] == '+' && in[1] == ' ')\n        in += 2;\n    if (*in == '\\r')\n        return (0);\n    do {\n        digit1 = in[0];\n        if (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) == -1)\n            return (-1);\n        digit2 = in[1];\n        if (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) == -1)\n            return (-1);\n        digit3 = in[2];\n        if (digit3 != '=' && ((((digit3) & ~127) == 0) ? base64val[digit3] : -1) == -1)\n            return (-1);\n        digit4 = in[3];\n        if (digit4 != '=' && ((((digit4) & ~127) == 0) ? base64val[digit4] : -1) == -1)\n            return (-1);\n        in += 4;\n        *out++ = (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) << 2) | (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) >> 4);\n        ++len;\n        if (digit3 != '=') {\n            *out++ = ((((((digit2) & ~127) == 0) ? base64val[digit2] : -1) << 4) & 240) | (((((digit3) & ~127) == 0) ? base64val[digit3] : -1) >> 2);\n            ++len;\n            if (digit4 != '=') {\n                *out++ = ((((((digit3) & ~127) == 0) ? base64val[digit3] : -1) << 6) & 192) | ((((digit4) & ~127) == 0) ? base64val[digit4] : -1);\n                ++len;\n            }\n        }\n    } while (*in && *in != '\\r' && digit4 != '=');\n    return (len);\n}\n","function_prediction":"int HTTPBase64Decoder_name_conflict(unsigned char *out, const char *in) {\n  int val1, val2, val3, val4, val5, val6, val7, val8;\n  int i, j, k;\n\n  if (in[0] == '+' && in[1] == ' ')\n    in += 2;\n\n  for (i = 0, j = 0; in[i] != '\\r'; i += 4) {\n    if (in[i] < 0 || (val1 = base64val[(unsigned char)in[i]]) == -1 ||\n        in[i + 1] < 0 || (val2 = base64val[(unsigned char)in[i + 1]]) == -1 ||\n        in[i + 2] < 0 || (val3 = base64val[(unsigned char)in[i + 2]]) == -1 ||\n        in[i + 3] < 0 || (val4 = base64val[(unsigned char)in[i + 3]]) == -1)\n      return -1;\n\n    val5 = (val1 << 2) | (val2 >> 4);\n    out[j++] = val5;\n\n    if (in[i + 2] == '=')\n      break;\n\n    val6 = (val2 << 4) | (val3 >> 2);\n    out[j++] = val6;\n\n    if (in[i + 3] == '=')\n      break;\n\n    val7 = (val3 << 6) | val4;\n    out[j++] = val7;\n  }\n\n  return j;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientAuth.c"}
{"compilable":0,"function":"INT32 HTTPSendFile(HTTP_SESSION_HANDLE pSession, CHAR *FilePath) {\n    UINT32 ret = 0;\n    char *buf, p;\n    int buf_size = 0, sent_size;\n    FILE *f;\n    buf = (char *)malloc(65536);\n    f = fopen(FilePath, \"rb\");\n    if (!f) {\n        ret = 1;\n        return ret;\n    }\n    while ((buf_size = fread(buf, 1, 65536, f)) != 0)\n        {\n            ret = HTTPClientWriteData(pSession, buf, buf_size, 5);\n            if (ret != 0) {\n                break;\n            }\n        }\n    return ret;\n}\n","function_prediction":"int HTTPSendFile_name_conflict(HTTPClient *client, const char *filename) {\n  char *buffer = malloc(65536);\n  FILE *file = fopen(filename, \"rb\");\n  if (file == NULL)\n    return 1;\n  int bytes;\n  while ((bytes = fread(buffer, 1, 65536, file)) != 0) {\n    int error = HTTPClientWriteData(client, buffer, bytes, 5);\n    if (error != 0)\n      return error;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"INT32 HTTPParseCommandLineArgs(UINT32 argc, CHAR *argv[], HTTPParameters *pClientParams) {\n    UINT32 nArg;\n    UINT32 nResult;\n    CHAR *pSearchPtr = ((void *)0);\n    CHAR PortNum[64];\n    if (argc <= 1) {\n        HTTPDumpHelp(\"Error: did not get key parameters.\");\n        return -1;\n    }\n    ;\n    for (nArg = 1; nArg < argc; nArg++) {\n        if (strncasecmp(argv[nArg], \"/?\", 2) == 0) {\n            HTTPDumpHelp(((void *)0));\n            return -1;\n        }\n        if (strncasecmp(argv[nArg], \"/V\", 2) == 0) {\n            pClientParams->Verbose = 1;\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H:\", 3) == 0) {\n            strcpy(pClientParams->Uri, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/H2:\", 3) == 0) {\n            strcpy(pClientParams->Uri2, argv[nArg] + 4);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/D:\", 3) == 0) {\n            strcpy(pClientParams->PostData, argv[nArg] + 3);\n            continue;\n        }\n        if (strncasecmp(argv[nArg], \"/F:\", 3) == 0) {\n            strcpy(pClientParams->PutFilePath, argv[nArg] + 3);\n            continue;\n        }\n    }\n    if (strlen(pClientParams->Uri) == 0 || strlen(pClientParams->Uri2) == 0) {\n        HTTPDumpHelp(\"Error: /H or /H2 argument is missing\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int HTTPParseCommandLineArgs(int argc, char *argv[],\n                             HTTP_CLIENT_CONFIG *pConfig) {\n  int i;\n  char *p;\n\n  if (argc < 2) {\n    printf(\"\\nUsage: HTTPClientSample_keepalive [/H:URL1] [/H2:URL2] [/D: post \"\n           \"data] [/F: file path]\\n\\n\");\n    printf(\"For example:\\n HTTPClient /H:http://www.myhost.com:82 \"\n           \"/R:www.myproxy.com:8080 \\n [/V]\");\n    printf(\"\\tWill get http://www.myhost.com on TCP port 82 using the \"\n           \"myproxy.com amd basic authentication\\n\\n\");\n    printf(\"%s\\n\\n\", \"Error: did not get key parameters.\");\n    return -1;\n  }\n\n  for (i = 1; i < argc; i++) {\n    p = argv[i];\n\n    if (!strncasecmp(p, \"/?\", 2)) {\n      printf(\"\\nUsage: HTTPClientSample_keepalive [/H:URL1] [/H2:URL2] [/D: \"\n             \"post data] [/F: file path]\\n\\n\");\n      printf(\"For example:\\n HTTPClient /H:http://www.myhost.com:82 \"\n             \"/R:www.myproxy.com:8080 \\n [/V]\");\n      printf(\"\\tWill get http://www.myhost.com on TCP port 82 using the \"\n             \"myproxy.com amd basic authentication\\n\\n\");\n      return -1;\n    }\n\n    if (!strncasecmp(p, \"/V\", 2)) {\n      pConfig->verbose = 1;\n    } else if (!strncasecmp(p, \"/H:\", 3)) {\n      strcpy(pConfig->host, p + 3);\n    } else if (!strncasecmp(p, \"/H2:\", 3)) {\n            strcpy(pConfig->host2, p +","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"int handle_http_request(HTTP_SESSION_HANDLE pHTTP, CHAR *uri, HTTPParameters *ClientParams) {\n    CHAR Buffer[8193];\n    INT32 nRetCode;\n    UINT32 nSize, nTotal = 0;\n    INT32 status_code;\n    HTTP_CLIENT HTTPClient;\n    do {\n        memset(&HTTPClient, 0, sizeof(HTTP_CLIENT));\n        if (strlen(ClientParams->PostData) != 0) {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbPost)) != 0) {\n                break;\n            }\n        } else if (strlen(ClientParams->PutFilePath) != 0) {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbPut)) != 0) {\n                break;\n            }\n        } else {\n            if ((nRetCode = HTTPClientSetVerb(pHTTP, VerbGet)) != 0) {\n                break;\n            }\n        }\n        if (strlen(ClientParams->PostData) != 0) {\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ClientParams->PostData, strlen(ClientParams->PostData), 1, 5, 0)) != 0) {\n                break;\n            }\n        } else if (strlen(ClientParams->PutFilePath) != 0) {\n            int ret;\n            struct stat stat_buf;\n            char file_size_str[32];\n            memset(&stat_buf, 0, sizeof(struct stat));\n            memset(file_size_str, 0, 32);\n            ret = stat(ClientParams->PutFilePath, &stat_buf);\n            if (ret) {\n                nRetCode = 19;\n                break;\n            }\n            HTTPWrapperItoa(file_size_str, (int)stat_buf.st_size);\n            if ((nRetCode = HTTPClientAddRequestHeaders(pHTTP, \"Content-Length\", file_size_str, 0)) != 0) {\n                break;\n            }\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ((void *)0), 0, 0, 5, 0)) != 0) {\n                break;\n            }\n            if ((nRetCode = HTTPSendFile(pHTTP, ClientParams->PutFilePath)) != 0) {\n                break;\n            }\n        } else {\n            if ((nRetCode = HTTPClientSendRequest(pHTTP, uri, ((void *)0), 0, 0, 5, 0)) != 0) {\n                break;\n            }\n        }\n        if ((nRetCode = HTTPClientRecvResponse(pHTTP, 3)) != 0) {\n            break;\n        }\n        if ((nRetCode = HTTPClientGetInfo(pHTTP, &HTTPClient)) != 0) {\n            break;\n        }\n        while (nRetCode == 0 || nRetCode != 1000)\n            {\n                if (nTotal >= HTTPClient.TotalResponseBodyLength) {\n                    break;\n                }\n                nSize = 8192;\n                nRetCode = HTTPClientReadData(pHTTP, Buffer, nSize, 5, &nSize);\n                nTotal += nSize;\n                Buffer[nSize] = 0;\n                printf(\"%s\", Buffer);\n            }\n    } while (0);\n    printf(\"\\n\");\n    if (ClientParams->Verbose == 1) {\n        printf(\"\\n\\nHTTP Client terminated %d (got %d bytes, status_code %d)\\n\\n\", (int)nRetCode, (int)(nTotal), HTTPClient.HTTPStatusCode);\n    }\n    return nRetCode;\n}\n","function_prediction":"int handle_http_request(HTTP_CLIENT *http_client, const char *host,\n                        const char *argv[]) {\n  int ret = 0;\n  int status_code = 0;\n  int bytes_read = 0;\n  int bytes_written = 0;\n  int bytes_to_read = 0;\n  int bytes_to_write = 0;\n  int verb = 0;\n  int i = 0;\n  int len = 0;\n  char *data = NULL;\n  char *data_ptr = NULL;\n  char *data_end = NULL;\n  char *data_buf = NULL;\n  char *data_buf_end = NULL;\n  char *data_buf_ptr = NULL;\n  char *data_buf_size = NULL;\n  char *data_buf_size_end = NULL;\n  char *data_buf_size_ptr = NULL;\n  char *data_buf_size_ptr_end = NULL;\n  char *data_buf_size_ptr_end_end = NULL;\n  char *data_buf_size_ptr_end_end_end = NULL;\n  char *data_buf_size_ptr_end_end_end_end = NULL;\n  char *data_buf_size_ptr_end_end_end_end_end = NULL;\n  char *data_buf_size_ptr_end_end_end_end_end_end = NULL;\n  char *data_buf_size_ptr_end_end_end_end_end_end_end = NULL;\n  char *data_buf_size_ptr_end_end_end_end_end_end_end_end = NULL;\n  char *data_buf_size_ptr_end_end_end_end_end_end_end_end_end = NULL;\n  char *data_buf_size_ptr_end_end_end_end_end_end_end_end_end_end = NULL;\n  char *data_buf_size_ptr_end_end_end_end_end_end_end_end_end_end_end = NULL;\n  char *data_buf_size_ptr_end_end_end","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/samples/HTTPClientSampleKeepalive.c"}
{"compilable":0,"function":"BOOL HTTPStrInsensitiveCompare(CHAR *pSrc, CHAR *pDest, UINT32 nLength) {\n    UINT32 nPosition;\n    UINT32 nDestLength;\n    CHAR *pSrcIn, *pDestIn;\n    CHAR a, b;\n    pSrcIn = pSrc;\n    pDestIn = pDest;\n    nPosition = 0;\n    nDestLength = strlen(pDest);\n    if (nLength == 0) {\n        nLength = strlen(pSrc);\n    }\n    if (nDestLength != nLength) {\n        return 0;\n    }\n    while (pSrcIn || pDestIn)\n        {\n            if (nLength > 0 && nPosition == nLength) {\n                return 1;\n            }\n            a = *pSrcIn;\n            b = *pDestIn;\n            if (*pSrcIn >= 64 && *pSrcIn <= 90) {\n                a = *pSrcIn + 32;\n            }\n            if (*pDestIn >= 64 && *pDestIn <= 90) {\n                b = *pDestIn + 32;\n            }\n            if (a != b) {\n                return 0;\n            }\n            pSrcIn++;\n            pDestIn++;\n            nPosition++;\n        }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR HTTPStrExtract(CHAR *pParam, UINT32 nOffset, CHAR Restore) {\n    CHAR Replaced;\n    if (!pParam) {\n        return 0;\n    }\n    if (Restore != 0) {\n        pParam[nOffset] = Restore;\n        return Restore;\n    } else {\n        Replaced = pParam[nOffset];\n        pParam[nOffset] = 0;\n        return Replaced;\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrCaseStr(const char *pSrc, UINT32 nSrcLength, const char *pFind) {\n    const char *ptr = pSrc;\n    const char *ptr2;\n    UINT32 iLength = 0;\n    while (1)\n        {\n            if (iLength >= nSrcLength) {\n                break;\n            }\n            ptr = strchr((char *)pSrc, toupper((int)*pFind));\n            ptr2 = strchr((char *)pSrc, tolower((int)*pFind));\n            if (!ptr) {\n                ptr = ptr2;\n            }\n            if (!ptr) {\n                break;\n            }\n            if (ptr2 && (ptr2 < ptr)) {\n                ptr = ptr2;\n            }\n            if (!strncasecmp(ptr, pFind, strlen(pFind))) {\n                return (char *)ptr;\n            }\n            pSrc = ptr + 1;\n            iLength++;\n        }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrGetToken(CHAR *pSrc, UINT32 nSrcLength, CHAR *pDest, UINT32 *nDestLength) {\n    CHAR *pStart = pSrc;\n    CHAR *pEnd;\n    UINT32 nTokenLength = 0;\n    UINT32 nPosition = 0;\n    pStart = strchr(pSrc, ':') + 1;\n    if (pStart) {\n        pEnd = pStart;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    nTokenLength++;\n                }\n                if (nSrcLength && nPosition > nSrcLength) {\n                    break;\n                }\n                pEnd++;\n                nPosition++;\n            }\n        if (nTokenLength > *(nDestLength)) {\n            *(nDestLength) = nTokenLength;\n            pDest = ((void *)0);\n            return pDest;\n        }\n        pEnd = pStart;\n        *(nDestLength) = nTokenLength;\n        nTokenLength = 0;\n        while ((*pEnd) && (*pEnd != '\\r') && (*pEnd != '\\n'))\n            {\n                if (*pEnd != 32) {\n                    pDest[nTokenLength++] = *pEnd;\n                }\n                pEnd++;\n            }\n        pDest[nTokenLength] = 0;\n    }\n    return pDest;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"UINT32 HTTPStrHToL(CHAR *s) {\n    UINT32 i, nn, digit;\n    UINT32 n;\n    n = i = nn = 0;\n    do {\n        if (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalnum)) {\n            s[i] = toupper((int)s[i]);\n            if (s[i] == 'X')\n                nn = n = 0;\n            else {\n                digit = (((*__ctype_b_loc())[(int)(((int)s[i]))] & (unsigned short)_ISalpha) ? (s[i] - 'A' + 10) : s[i] - '0');\n                if (digit > 15)\n                    digit = 15;\n                n = n * 16 + digit;\n                if (n |= 0)\n                    nn++;\n                if (nn == 8)\n                    break;\n            }\n        }\n        i++;\n    } while (s[i] |= 0);\n    return n;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"CHAR *HTTPStrLToH(CHAR *dest, UINT32 nSrc) {\n    char *hex = \"0123456789abcdef\";\n    int i;\n    if (nSrc == 0) {\n        dest[0] = '0';\n        dest[1] = 0;\n    } else {\n        for (i = 28; ((nSrc >> i) && 15) == 0; i -= 4)\n            ;\n        for (; i >= 0; i -= 4) {\n            *dest++ = hex[(nSrc >> i) & 15];\n        }\n        *dest = 0;\n    }\n    return dest;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientString.c"}
{"compilable":0,"function":"int HTTPWrapperIsAscii(int c) {\n    return (!(c & ~127));\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToUpper(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 97 && c <= 122) {\n            return (c - 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperToLower(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (c >= 65 && c <= 90) {\n            return (c + 32);\n        }\n    }\n    return c;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlpha(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if ((c >= 97 && c <= 122) || (c >= 65 && c <= 90)) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperIsAlNum(int c) {\n    if (HTTPWrapperIsAscii(c) > 0) {\n        if (HTTPWrapperIsAlpha(c) > 0) {\n            return c;\n        }\n        if (c >= 48 && c <= 57) {\n            return c;\n        }\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"char *HTTPWrapperItoa(char *s, int a) {\n    unsigned int b;\n    if (a > 2147483647) {\n        return 0;\n    }\n    if (a < 0)\n        b = -a , *s++ = '-';\n    else\n        b = a;\n    for (; a; a = a / 10)\n        s++;\n    for (*s = '\\x00'; b; b = b / 10)\n        *--s = b % 10 + '0';\n    return s;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperShutDown(int s, int how) {\n    return shutdown(s, how);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetSocketError(int s) {\n    return (*__errno_location());\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetHostByName(char *name, UINT32 *address) {\n    HTTP_HOSTNET *HostEntry;\n    int iPos = 0, iLen = 0, iNumPos = 0, iDots = 0;\n    long iIPElement;\n    char c = 0;\n    char Num[4];\n    int iHostType = 0;\n    iLen = strlen(name);\n    for (iPos = 0; iPos <= iLen; iPos++) {\n        c = name[iPos];\n        if ((c >= 48 && c <= 57) || (c == '.')) {\n            if (c != '.') {\n                if (iNumPos > 3) {\n                    iHostType++;\n                    break;\n                }\n                Num[iNumPos] = c;\n                Num[iNumPos + 1] = 0;\n                iNumPos++;\n            } else {\n                iNumPos = 0;\n                iDots++;\n                iIPElement = atol(Num);\n                if (iIPElement > 256 || iDots > 3) {\n                    return -1;\n                }\n            }\n        } else {\n            break;\n        }\n    }\n    if (c == 0 && iHostType == 0 && iDots == 3) {\n        iIPElement = atol(Num);\n        if (iIPElement > 256) {\n            return -1;\n        }\n    } else {\n        iHostType++;\n    }\n    if (iHostType > 0) {\n        struct addrinfo hints;\n        struct addrinfo *result = ((void *)0);\n        int ret;\n        memset((void *)&hints, 0, sizeof(struct addrinfo));\n        hints.ai_family = 2;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = 0;\n        hints.ai_protocol = 0;\n        ret = getaddrinfo(name, ((void *)0), &hints, &result);\n        if (ret == 0) {\n            *(address) = ((struct sockaddr_in *)result->ai_addr)->sin_addr.s_addr;\n            freeaddrinfo(result);\n            return 0;\n        } else {\n            fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(ret));\n            return -1;\n        }\n    } else {\n        *(address) = inet_addr(name);\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperGetRandomeNumber() {\n    int num;\n    num = (int)(((double)rand() / ((double)2147483647 + 1)) * 16);\n    return num;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int64_t HTTPWrapperGetUpTime() {\n    struct timespec tp;\n    clock_gettime(1, &tp);\n    return (int64_t)tp.tv_sec;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLConnect(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLNegotiate(int s, const struct sockaddr *name, int namelen, char *hostname) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLSend(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecv(int s, char *buf, int len, int flags) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLRecvPending(int s) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int HTTPWrapperSSLClose(int s) {\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientWrapper.c"}
{"compilable":0,"function":"int sktSetNonblocking(int socket, int on_off) {\n    int flags_orig, flags_new;\n    flags_orig = fcntl(socket, 3, 0);\n    if (flags_orig < 0)\n        return -1;\n    if (on_off != 0)\n        flags_new = flags_orig | 2048;\n    else\n        flags_new = flags_orig & ~2048;\n    if (fcntl(socket, 4, flags_new) < 0) {\n        fcntl(socket, 4, flags_orig);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int sktSetNonblocking_name_conflict(int sock, int on) {\n  int flags;\n\n  if ((flags = fcntl(sock, 3, 0)) < 0)\n    return -1;\n\n  if (on)\n    flags |= (1 << 11);\n  else\n    flags &= ~(1 << 11);\n\n  if (fcntl(sock, 4, flags) < 0) {\n    fcntl(sock, 4, flags);\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetLocalConnection(HTTP_SESSION_HANDLE pSession, UINT32 nPort) {\n    return 0;\n}\n","function_prediction":"int HTTPClientSetLocalConnection_name_conflict(HTTPClient *client, int sock) {\n# 100 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmimu/libhttp/refs/heads/master/src/http_client.c\"\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"HTTP_SESSION_HANDLE HTTPClientOpenRequest(HTTP_CLIENT_SESSION_FLAGS Flags) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nAllocationSize;\n    pHTTPSession = (P_HTTP_SESSION)malloc(((sizeof(HTTP_SESSION) & 4294967292U) + ((sizeof(HTTP_SESSION) & 3) ? 4 : 0)));\n    if (!pHTTPSession) {\n        return 0;\n    }\n    memset(pHTTPSession, 0, sizeof(HTTP_SESSION));\n    if (0) {\n        nAllocationSize = (((2048) < (2048)) ? (2048) : (2048));\n    } else {\n        nAllocationSize = 2048;\n    }\n    pHTTPSession->HttpHeaders.HeadersBuffer.pParam = (CHAR *)malloc(((nAllocationSize & 4294967292U) + ((nAllocationSize & 3) ? 4 : 0)));\n    if (!pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession);\n        return 0;\n    }\n    memset(pHTTPSession->HttpHeaders.HeadersBuffer.pParam, 0, nAllocationSize);\n    pHTTPSession->HttpHeaders.HeadersBuffer.nLength = nAllocationSize;\n    HTTPClientSetVerb((HTTP_SESSION_HANDLE)pHTTPSession, (HTTP_VERB)0);\n    pHTTPSession->HttpUrl.nPort = 80;\n    pHTTPSession->HttpConnection.HttpSocket = (-1);\n    pHTTPSession->HttpHeaders.HeadersOut.pParam = pHTTPSession->HttpHeaders.HeadersBuffer.pParam;\n    pHTTPSession->HttpState = 1;\n    pHTTPSession->HttpFlags = Flags;\n    pHTTPSession->HttpHeadersInfo.nHTTPStatus = 0;\n    pHTTPSession->HttpNameCache.port = 80;\n    return (HTTP_SESSION_HANDLE)pHTTPSession;\n}\n","function_prediction":"HTTPClient *HTTPClientOpenRequest_name_conflict(int sock) {\n  HTTPClient *client;\n\n  client = calloc(sizeof(HTTPClient), 1);\n  if (client == NULL)\n    return NULL;\n\n  client->buffer = calloc(2048, 1);\n  if (client->buffer == NULL) {\n    free(client);\n    return NULL;\n  }\n\n  client->buffer_size = 2048;\n  client->method =\n      (((((unsigned int)('G')) << 24) | (((unsigned int)('E')) << 16) |\n        (((unsigned int)('T')) << 8) | ((unsigned int)(' '))));\n  client->version =\n      (((((unsigned int)('P')) << 24) | (((unsigned int)('T')) << 16) |\n        (((unsigned int)(' ')) << 8) | ((unsigned int)('1'))));\n  client->content_length = -1;\n  client->content_buffer = client->buffer;\n  client->content_buffer_size = 1;\n  client->sock = sock;\n  client->state =\n      (((((unsigned int)('P')) << 24) | (((unsigned int)('T')) << 16) |\n        (((unsigned int)(' ')) << 8) | ((unsigned int)('1'))));\n\n  return client;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientReset(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    return HTTPIntrnSessionReset(pHTTPSession, 1);\n}\n","function_prediction":"int HTTPClientReset_name_conflict(HTTPClient *client) {\n  int i;\n\n  if (client == NULL)\n    return 2;\n\n  memset(client->request, 0, client->request_size);\n  client->request_size = 0;\n  client->request_length = 0;\n  client->request_content_length = 0;\n  client->request_content_remaining = 0;\n  client->request_content_offset = 0;\n  client->request_content_type = NULL;\n  client->request_content_type_length = 0;\n  client->request_content_type_offset = 0;\n  client->request_content_type_remaining = 0;\n  client->request_content_encoding = NULL;\n  client->request_content_encoding_length = 0;\n  client->request_content_encoding_offset = 0;\n  client->request_content_encoding_remaining = 0;\n  client->request_content_boundary = NULL;\n  client->request_content_boundary_length = 0;\n  client->request_content_boundary_offset = 0;\n  client->request_content_boundary_remaining = 0;\n  client->request_content_disposition = NULL;\n  client->request_content_disposition_length = 0;\n  client->request_content_disposition_offset = 0;\n  client->request_content_disposition_remaining = 0;\n  client->request_content_disposition_filename = NULL;\n  client->request_content_disposition_filename_length = 0;\n  client->request_content_disposition_filename_offset = 0;\n  client->request_content_disposition_filename_remaining = 0;\n  client->request_content_disposition_filename_quoted = 0;\n  client->request_content_disposition_filename_quoted_length = 0;\n  client->request_content_disposition_filename_quoted_offset = 0;\n  client->request_content_disposition_filename_quoted_remaining = 0","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientCloseRequest(HTTP_SESSION_HANDLE *pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)*(pSession);\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeadersBuffer.pParam) {\n        free(pHTTPSession->HttpHeaders.HeadersBuffer.pParam);\n    }\n    HTTPIntrnConnectionClose(pHTTPSession);\n    free(pHTTPSession);\n    pHTTPSession = 0;\n    *(pSession) = 0;\n    return 0;\n}\n","function_prediction":"int HTTPClientCloseRequest_name_conflict(HTTPClientRequest **request) {\n  HTTPClientRequest *req = *request;\n  if (req == NULL)\n    return 2;\n\n  if (req->response.body != NULL)\n    free(req->response.body);\n\n  if (req->socket.fd != -1) {\n    if (req->socket.flags & 0x0010)\n      HTTPWrapperSSLClose(req->socket.ssl);\n\n    shutdown(req->socket.fd, 1);\n    close(req->socket.fd);\n  }\n\n  free(req);\n  *request = NULL;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetConnection(HTTP_SESSION_HANDLE pSession, BOOL Connection) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeadersInfo.Connection = Connection;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetConnection_name_conflict(HTTPClient *client, int connection) {\n  if (client == NULL)\n    return 2;\n\n  client->connection = connection;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetVerb(HTTP_SESSION_HANDLE pSession, HTTP_VERB HttpVerb) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.HttpVerb = HttpVerb;\n    switch (HttpVerb) {\n      case VerbGet:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"GET\");\n        break;\n      case VerbHead:\n        if (!0) {\n            return 18;\n        }\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"HEAD\");\n        break;\n      case VerbPost:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"POST\");\n        break;\n      case VerbPut:\n        strcpy(pHTTPSession->HttpHeaders.Verb, \"PUT\");\n        break;\n      default:\n        return 18;\n    }\n    ;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetVerb_name_conflict(HTTPClient *client, int verb) {\n  if (client == NULL)\n    return 2;\n\n  client->verb = verb;\n\n  switch (verb) {\n  case 0:\n    client->verb_str[0] = 'G';\n    client->verb_str[1] = 'E';\n    client->verb_str[2] = 'T';\n    client->verb_str[3] = 0;\n    break;\n\n  case 2:\n    client->verb_str[0] = 'P';\n    client->verb_str[1] = 'O';\n    client->verb_str[2] = 'S';\n    client->verb_str[3] = 'T';\n    client->verb_str[4] = 0;\n    break;\n\n  case 3:\n    client->verb_str[0] = 'P';\n    client->verb_str[1] = 'U';\n    client->verb_str[2] = 'T';\n    client->verb_str[3] = 0;\n    break;\n\n  default:\n    return 18;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetProxy(HTTP_SESSION_HANDLE pSession, CHAR *pProxyHost, UINT16 nPort, CHAR *pUserName, CHAR *pPassword) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    strncpy(pHTTPSession->HttpProxy.ProxyHost, pProxyHost, 64);\n    if (pUserName) {\n        strncpy(pHTTPSession->HttpProxy.ProxtUser, pUserName, 16);\n    }\n    if (pPassword) {\n        strncpy(pHTTPSession->HttpProxy.ProxyPassword, pPassword, 16);\n    }\n    pHTTPSession->HttpProxy.nProxyPort = nPort;\n    pHTTPSession->HttpFlags = pHTTPSession->HttpFlags | 128;\n    if (pPassword && pUserName) {\n        pHTTPSession->HttpProxy.ProxyAuthSchema = 1;\n    }\n    return 0;\n}\n","function_prediction":"int HTTPClientSetProxy(HTTP_CLIENT *httpClient, const char *proxy,\n                       unsigned short port, const char *user,\n                       const char *password) {\n  if (httpClient == NULL)\n    return 2;\n\n  strncpy(httpClient->proxy, proxy, 64);\n\n  if (user != NULL) {\n    strncpy(httpClient->proxyUser, user, 16);\n\n    if (password != NULL) {\n      strncpy(httpClient->proxyPassword, password, 16);\n      httpClient->proxyPort = port;\n      httpClient->flags |= 0x00000080;\n      httpClient->proxyAuth = 1;\n    } else {\n      httpClient->proxyPort = port;\n      httpClient->flags |= 0x00000080;\n    }\n  } else {\n    if (password != NULL)\n      strncpy(httpClient->proxyPassword, password, 16);\n\n    httpClient->flags |= 0x00000080;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientSetCredentials(HTTP_SESSION_HANDLE pSession, CHAR *pUserName, CHAR *pPassword) {\n    UINT32 nLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nLength = strlen(pUserName);\n    if (nLength > 16) {\n        return 19;\n    }\n    nLength = strlen(pPassword);\n    if (nLength > 16) {\n        return 19;\n    }\n    strcpy(pHTTPSession->HttpCredentials.CredUser, pUserName);\n    strcpy(pHTTPSession->HttpCredentials.CredPassword, pPassword);\n    pHTTPSession->HttpHeadersInfo.HaveCredentials = 1;\n    return 0;\n}\n","function_prediction":"int HTTPClientSetCredentials(HTTPClient *client, const char *username,\n                             const char *password) {\n  if (client == NULL)\n    return 2;\n\n  if (strlen(username) > 16)\n    return 19;\n\n  if (strlen(password) > 16)\n    return 19;\n\n  memcpy(&client->credentials.username, username, strlen(username) + 1);\n  strcpy(&client->credentials.password, password);\n  client->credentials.set = 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientAddRequestHeaders(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderName, CHAR *pHeaderData, BOOL nInsert) {\n    UINT32 nRetCode;\n    UINT32 nHeaderLength, nDataLength;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nHeaderLength = strlen(pHeaderName);\n    nDataLength = strlen(pHeaderData);\n    nRetCode = HTTPIntrnHeadersAdd(pHTTPSession, pHeaderName, nHeaderLength, pHeaderData, nDataLength);\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientAddRequestHeaders(HTTPClient *http, const char *key,\n                                const char *value) {\n  int keyLen, valueLen, headerLen;\n  char *header;\n\n  if (http == NULL)\n    return 2;\n\n  keyLen = strlen(key);\n  valueLen = strlen(value);\n  headerLen = keyLen + valueLen + 4;\n\n  if (http->headers.contentLength + headerLen >\n          http->headers.maxContentLength ||\n      http->headers.contentLength + headerLen + http->headers.contentLength >\n          2048)\n    return 3;\n\n  if (http->headers.content != NULL) {\n    memcpy(http->headers.content + headerLen, http->headers.content,\n           http->headers.contentLength);\n    memset(http->headers.content + http->headers.contentLength, 0, headerLen);\n  }\n\n  header =\n      memcpy(http->headers.content + http->headers.contentLength, key, keyLen);\n  header = memcpy(header + keyLen, \": \", 2);\n  header = memcpy(header + 2, value, valueLen);\n  header = memcpy(header + valueLen, \"\\r\\n\", 2);\n\n  http->headers.contentLength += headerLen;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientRecvResponse(HTTP_SESSION_HANDLE pSession, UINT32 nTimeout) {\n    UINT32 nRetCode;\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    do {\n        if ((nRetCode = HTTPIntrnHeadersReceive(pHTTPSession, nTimeout)) != 0) {\n            break;\n        }\n    } while (0);\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientRecvResponse_name_conflict(HTTPClient *client) {\n  if (client == NULL)\n    return 2;\n\n  return HTTPIntrnHeadersReceive_part_0(client);\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetInfo(HTTP_SESSION_HANDLE pSession, HTTP_CLIENT *HTTPClient) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    memset(HTTPClient, 0, sizeof(HTTP_CLIENT));\n    HTTPClient->HTTPStatusCode = pHTTPSession->HttpHeadersInfo.nHTTPStatus;\n    HTTPClient->RequestBodyLengthSent = pHTTPSession->HttpCounters.nSentBodyBytes;\n    HTTPClient->ResponseBodyLengthReceived = pHTTPSession->HttpCounters.nRecivedBodyLength;\n    HTTPClient->TotalResponseBodyLength = pHTTPSession->HttpHeadersInfo.nHTTPContentLength;\n    HTTPClient->HttpState = pHTTPSession->HttpState;\n    return 0;\n}\n","function_prediction":"int HTTPClientGetInfo_name_conflict(HTTPClient *client, HTTPClientInfo *info) {\n  if (client == NULL) {\n    return 2;\n  }\n\n  info->ip.addr = 0;\n  info->ip.port = 0;\n  info->ip.addr = client->ip.addr;\n  info->ip.port = client->ip.port;\n  info->status = client->status;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindFirstHeader(HTTP_SESSION_HANDLE pSession, CHAR *pSearchClue, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nClueLength;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    nClueLength = strlen(pSearchClue);\n    if (nClueLength >= 1024) {\n        return 13;\n    } else {\n        strcpy(pHTTPSession->HttpHeaders.SearchClue, pSearchClue);\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    }\n    return 0;\n}\n","function_prediction":"int HTTPClientFindFirstHeader_name_conflict(HTTP_CLIENT *http, const char *header) {\n  UINT i;\n  // Validate arguments\n  if (http == NULL) {\n    return 2;\n  }\n\n  i = strlen(header);\n  if (i >= 1024) {\n    return 13;\n  }\n\n  memcpy(&http->Header[0], header, i + 1);\n  http->HeaderSize = 0;\n  http->HeaderPos = 0;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientFindCloseHeader(HTTP_SESSION_HANDLE pSession) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    pHTTPSession->HttpHeaders.SearchClue[0] = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.nLength = 0;\n    pHTTPSession->HttpHeaders.HeaderSearch.pParam = ((void *)0);\n    return 0;\n}\n","function_prediction":"int HTTPClientFindCloseHeader_name_conflict(HTTP_CLIENT *client) {\n  // Validate arguments\n  if (client == NULL) {\n    return 2;\n  }\n\n  client->HttpHeader.CloseHeader = 0;\n  client->HttpHeader.CloseHeaderSize = 0;\n  client->HttpHeader.CloseHeaderPos = 0;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPClientGetNextHeader(HTTP_SESSION_HANDLE pSession, CHAR *pHeaderBuffer, UINT32 *nLength) {\n    P_HTTP_SESSION pHTTPSession = ((void *)0);\n    UINT32 nOffset = 0;\n    UINT32 nRetCode;\n    HTTP_PARAM HttpHeader;\n    CHAR *pPtr;\n    pHTTPSession = (P_HTTP_SESSION)pSession;\n    if (!pHTTPSession) {\n        return 2;\n    }\n    if (pHTTPSession->HttpHeaders.HeaderSearch.nLength > 0) {\n        nOffset = pHTTPSession->HttpHeaders.HeaderSearch.pParam - pHTTPSession->HttpHeaders.HeadersIn.pParam;\n    }\n    nRetCode = HTTPIntrnHeadersFind(pHTTPSession, pHTTPSession->HttpHeaders.SearchClue, &HttpHeader, 1, nOffset);\n    if (nRetCode == 0) {\n        if (HttpHeader.nLength > *(nLength)) {\n            *(nLength) = HttpHeader.nLength;\n            pHeaderBuffer[0] = 0;\n            return 3;\n        }\n        pPtr = HttpHeader.pParam;\n        nOffset = 0;\n        if (*pPtr == 13) {\n            nOffset++;\n            pPtr++;\n        }\n        if (*pPtr == 10) {\n            nOffset++;\n            pPtr++;\n        }\n        strncpy(pHeaderBuffer, pPtr, HttpHeader.nLength - nOffset);\n        pHeaderBuffer[HttpHeader.nLength - nOffset] = 0;\n        *(nLength) = HttpHeader.nLength - nOffset;\n        pHTTPSession->HttpHeaders.HeaderSearch.pParam = HttpHeader.pParam + HttpHeader.nLength;\n        pHTTPSession->HttpHeaders.HeaderSearch.nLength++;\n        return 0;\n    }\n    return nRetCode;\n}\n","function_prediction":"int HTTPClientGetNextHeader_name_conflict(HTTPClient *http, char *header, int *header_len) {\n  int len;\n  char *p;\n  char *q;\n  int cr;\n\n  if (http == NULL)\n    return 2;\n\n  if (http->headers_pos == 0)\n    len = 0;\n  else\n    len = http->headers_end - http->headers_pos;\n\n  p = NULL;\n  if (strlen(http->headers) >= 1024 - 1)\n    return 13;\n\n  if (HTTPIntrnHeadersFind_part_0_constprop_0(http, http->headers, &p, 1,\n                                              len) != 0)\n    return 0;\n\n  if (p == NULL)\n    return 0;\n\n  if (*header_len >= (int)(p - http->headers)) {\n    cr = 0;\n    if (*p == '\\r') {\n      p++;\n      cr = 1;\n    }\n    if (*p == '\\n') {\n      p++;\n      cr = 1;\n    }\n    q = p + (p - http->headers) - cr;\n    len = p - q;\n    strncpy(header, q, len);\n    header[len] = '\\0';\n    *header_len = len;\n    http->headers_pos = p;\n    http->headers_pos_num++;\n    return 3;\n  }\n\n  *header_len = p - http->headers;\n  header[0] = '\\0';\n  return 3;\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"UINT32 HTTPIntrnSessionGetUpTime(void) {\n    return HTTPWrapperGetUpTime();\n}\n","function_prediction":"uint32_t HTTPIntrnSessionGetUpTime_name_conflict(HTTP_SESSION *pSession) {\n  return HTTPWrapperGetUpTime();\n}","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClient.c"}
{"compilable":0,"function":"int HTTPBase64Decoder(char *out, const char *in) {\n    int len = 0;\n    register unsigned char digit1, digit2, digit3, digit4;\n    if (in[0] == '+' && in[1] == ' ')\n        in += 2;\n    if (*in == '\\r')\n        return (0);\n    do {\n        digit1 = in[0];\n        if (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) == -1)\n            return (-1);\n        digit2 = in[1];\n        if (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) == -1)\n            return (-1);\n        digit3 = in[2];\n        if (digit3 != '=' && ((((digit3) & ~127) == 0) ? base64val[digit3] : -1) == -1)\n            return (-1);\n        digit4 = in[3];\n        if (digit4 != '=' && ((((digit4) & ~127) == 0) ? base64val[digit4] : -1) == -1)\n            return (-1);\n        in += 4;\n        *out++ = (((((digit1) & ~127) == 0) ? base64val[digit1] : -1) << 2) | (((((digit2) & ~127) == 0) ? base64val[digit2] : -1) >> 4);\n        ++len;\n        if (digit3 != '=') {\n            *out++ = ((((((digit2) & ~127) == 0) ? base64val[digit2] : -1) << 4) & 240) | (((((digit3) & ~127) == 0) ? base64val[digit3] : -1) >> 2);\n            ++len;\n            if (digit4 != '=') {\n                *out++ = ((((((digit3) & ~127) == 0) ? base64val[digit3] : -1) << 6) & 192) | ((((digit4) & ~127) == 0) ? base64val[digit4] : -1);\n                ++len;\n            }\n        }\n    } while (*in && *in != '\\r' && digit4 != '=');\n    return (len);\n}\n","function_prediction":"int HTTPBase64Decoder_name_conflict(char *out, const char *in) {\n  int i, j, k, l;\n  char c;\n  char *p;\n\n  p = (char *)in;\n  i = 0;\n  j = 0;\n  k = 0;\n  l = 0;\n\n  if (*p == '+' && *(p + 1) == ' ')\n    p += 2;\n\n  while (*p != '\\r') {\n    if (*p < 0 || base64val[*p] == -1)\n      return -1;\n    c = base64val[*p++];\n    i = (i << 6) | (c & 0x3f);\n    k++;\n    if (k == 4) {\n      p--;\n      c = (char)(i >> 16) & 0xff;\n      *out++ = c;\n      l++;\n      c = (char)(i >> 8) & 0xff;\n      *out++ = c;\n      l++;\n      c = (char)i & 0xff;\n      *out++ = c;\n      l++;\n      i = 0;\n      k = 0;\n    }\n    if (*p == '\\0')\n      break;\n    if (*p == '\\r')\n      break;\n  }\n\n  if (k > 0) {\n    if (k == 1)\n      return -1;\n    if (k == 2) {\n      if (*(p + 1) == '=' && *(p + 2) == '=') {\n        c = (char)(i >> 10) & 0xff;\n        *out++ = c;\n        l++;\n      } else\n        return -1;\n    }\n    if (k == 3) {\n      if (*(p + 1) == '=' && *(p + 2) == '=') {\n        c = (char)(i >> 16) & 0xff;\n        *out++ = c;\n        l++;\n            } else if (*(p + 1) == '=' && *(","pass":0,"source_file":"C_COMPILE/OpenSight_ivt_csdk/libivtutil/http_client/HTTPClientAuth.c"}
{"compilable":0,"function":"static u8 gf_mult(u8 x, u8 y) {\n    u8 result = 0;\n    while (x != 0)\n        {\n            result ^= x & 1 ? y : 0;\n            x >>= 1;\n            y = ((y) & 128 ? ((y) << 1) ^ 27 : ((y) << 1));\n        }\n    return result;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":0,"function":"static u64 F(u64 x) {\n    u8 *temp = (u8 *)&x;\n    u8 a[8] = {};\n    int i, j;\n    for (i = 0; i < 8; i++)\n        temp[i] = sbox[temp[i]];\n    for (i = 0; i < 8; i++) {\n        for (j = 0; j < 8; j++) {\n            a[i] ^= gf_mult(temp[j], mds_matrix[i][j]);\n        }\n    }\n    x = *((u64 *)a);\n    return x;\n}\n","function_prediction":"void FUN_00101020(void) { PTR_00103ff8(); }","pass":0,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":0,"function":"static u8 char_val(char c) {\n    if (c >= '0' && c <= '9')\n        return c - '0';\n    if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    else if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    printf(\"Illegal character \\\"%c\\\"\\n\", c);\n    exit(1);\n    return 0;\n}\n","function_prediction":"void char_val_part_0(char c) {\n  printf(\"Illegal character \\\"%c\\\"\\n\", c);\n  exit(1);\n}","pass":0,"source_file":"C_COMPILE/christiandaley_FALCON/src/FALCON_ref.c"}
{"compilable":0,"function":"char *build_chunked_response(int content_length, int *response_len) {\n    char *response_buffer;\n    char *content_buffer;\n    int buffer_length;\n    int i, n;\n    buffer_length = 256 + content_length + (content_length >> 4);\n    response_buffer = malloc(buffer_length);\n    *response_len = snprintf(response_buffer, buffer_length, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");\n    content_buffer = malloc(content_length);\n    build_content(content_buffer, content_length);\n    i = 0;\n    while (i < content_length)\n        {\n            n = (rand() % 199) + 1;\n            if (i + n > content_length) {\n                n = content_length - i;\n            }\n            *response_len += snprintf(response_buffer + *response_len, buffer_length - *response_len, \"%x\\r\\n\", n);\n            memcpy(response_buffer + *response_len, content_buffer + i, n);\n            *response_len += n;\n            i += n;\n            response_buffer[(*response_len)++] = '\\r';\n            response_buffer[(*response_len)++] = '\\n';\n        }\n    memcpy(response_buffer + *response_len, \"0\\r\\n\\r\\n\", 5);\n    *response_len += 5;\n    free(content_buffer);\n    printf(\"resp_length=%d buffer_length=%d content_length=%d\\n\", *response_len, buffer_length, content_length);\n    return response_buffer;\n}\n","function_prediction":"char *build_chunked_response_name_conflict(int content_length, int *resp_length) {\n  int buffer_length = content_length + (content_length / 64) + 256;\n  char *buffer = malloc(buffer_length);\n  *resp_length = snprintf(buffer, buffer_length,\n                          \"HTTP/1.1 200 OK\\r\\n\"\n                          \"Content-Type: text/plain\\r\\n\"\n                          \"Transfer-Encoding: chunked\\r\\n\"\n                          \"\\r\\n\");\n\n  char *content = malloc(content_length);\n  int i, j;\n  for (i = 0; i < content_length; i += 64) {\n    char line[80];\n    int len = snprintf(\n        line, sizeof(line),\n        \"%04d_ABCDEFGHIJKL_This_line_is_64_bytes_long_ABCDEFGHIJKL_%04d\\r\\n\", i,\n        i);\n    if (len != 64) {\n      fprintf(stderr, \"snprintf() returned %d in build_content()\\n\", len);\n    }\n    memcpy(content + i, line, 64);\n  }\n\n  int offset = 0;\n  while (offset < content_length) {\n    int chunk_length = rand() % 199 + 1;\n    if (offset + chunk_length > content_length) {\n      chunk_length = content_length - offset;\n    }\n    int len = snprintf(buffer + *resp_length, buffer_length - *resp_length,\n                       \"%x\\r\\n\", chunk_length);\n    memcpy(buffer + *resp_length + len, content + offset, chunk_length);\n    *resp_length += len + chunk_length + 2;\n    buffer[*resp_length - 2] = '\\r';\n    buffer[*resp_length - 1] = '\\n';\n    offset += chunk_length;\n  }\n  *resp_length += 5;\n  buffer[*resp_length - 5]","pass":0,"source_file":"C_COMPILE/mdilai_jweegad/external/miniupnpc/minihttptestserver.c"}
{"compilable":0,"function":"unsigned long long fatorial(unsigned int valor) {\n    unsigned long long i, fatorial = 1;\n    for (i = 1; i <= valor; i++) {\n        fatorial *= i;\n    }\n    return fatorial;\n}\n","function_prediction":"unsigned long fatorial_name_conflict(unsigned int n) {\n  unsigned long fat = 1;\n  unsigned int i;\n\n  for (i = 1; i <= n; i++)\n    fat *= i;\n\n  return fat;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_29-05/ex1.c"}
{"compilable":1,"function":"bool comparar(int *v1, int *v2) {\n    if (*v1 > *v2) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int comparar_name_conflict(const void *a, const void *b) { return (*(int *)a > *(int *)b); }","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_31-05/bouble_sort.c"}
{"compilable":0,"function":"char *init_palavra(char *texto_palavra) {\n    char *palavra = (char *)malloc(sizeof(char) * (strlen(texto_palavra) + 1));\n    strcpy(palavra, texto_palavra);\n    return palavra;\n}\n","function_prediction":"palavra *init_palavra_name_conflict(char *str) {\n  palavra *p = malloc(sizeof(palavra) + strlen(str) + 1);\n  memcpy(p, str, strlen(str) + 1);\n  return p;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":0,"function":"char *init_mascara(unsigned int tamanho_palavra) {\n    unsigned int i;\n    char *mascara = (char *)malloc(sizeof(char) * (tamanho_palavra + 1));\n    for (i = 0; i < tamanho_palavra; i++) {\n        mascara[i] = '_';\n    }\n    mascara[i] = '\\x00';\n    return mascara;\n}\n","function_prediction":"char *init_mascara_name_conflict(unsigned int tam) {\n  char *mascara = malloc(tam + 1);\n\n  if (tam) {\n    mascara = memset(mascara, '_', tam);\n    mascara[tam] = '\\0';\n  } else\n    mascara[0] = '\\0';\n\n  return mascara;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":0,"function":"bool existe_letra_na_palavra(char letra, char *palavra) {\n    unsigned int i;\n    for (i = 0; i < strlen(palavra); i++) {\n        if (letra == palavra[i]) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int existe_letra_na_palavra_name_conflict(char letra, char *palavra) {\n  for (size_t i = 0; i < strlen(palavra); i++) {\n    if (palavra[i] == letra) {\n      return 1;\n    }\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_12-06/jogo_forca.c"}
{"compilable":1,"function":"bool eh_palindromo(int *vetor, int tamanho) {\n    int i = 0;\n    for (i = 0; i < tamanho / 2; i++) {\n        if (vetor[i] != vetor[tamanho - 1 - i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"int eh_palindromo_name_conflict(int v[], int n) {\n  int i;\n  for (i = 0; i < n / 2; i++) {\n    if (v[i] != v[n - 1 - i]) {\n      return 0;\n    }\n  }\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_05-06/ex1.c"}
{"compilable":0,"function":"unsigned int calcularTamanhoRegistro(const Registro registro) {\n    unsigned int tamanhoRegistro = strlen(registro.ra) + strlen(registro.nome) + strlen(registro.curso) + strlen(registro.ano);\n    tamanhoRegistro *= sizeof(char);\n    tamanhoRegistro += 5;\n    return tamanhoRegistro;\n}\n","function_prediction":"int calcularTamanhoRegistro_name_conflict() {\n    return strlen(\"00000\") + strlen(\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":0,"function":"LittleEndian toLittleEndian(const unsigned short numero) {\n    unsigned short primeiroByte = (numero & 65280) >> 8;\n    unsigned short segundoByte = (numero & 255);\n    LittleEndian little;\n    little.number[0] = segundoByte;\n    little.number[1] = primeiroByte;\n    return little;\n}\n","function_prediction":"uint32_t toLittleEndian_name_conflict(uint32_t x) { return x; }","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":0,"function":"unsigned short revertLittleEndian(const LittleEndian little) {\n    unsigned short primeiroByte = (little.number[1] & 255) << 8;\n    unsigned short segundoByte = little.number[0] & 255;\n    return primeiroByte | segundoByte;\n}\n","function_prediction":"uint32_t revertLittleEndian_name_conflict(uint32_t value) { return value; }","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T1/main.c"}
{"compilable":1,"function":"int count(char *string) {\n    int length = 0;\n    while (string[length] != '\\x00')\n        {\n            length++;\n        }\n    return length;\n}\n","function_prediction":"int count_name_conflict(char *s) {\n  if (*s == '\\0')\n    return 0;\n  return 1 + strlen(s + 1);\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/08-09/ex3.c"}
{"compilable":1,"function":"int ordenar(const char *nomeBase) {\n    int quantidadeArquivos = 0;\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    quantidadeArquivos = contarArquivos(nomeBase);\n    if (quantidadeArquivos == 0) {\n        fprintf(stderr, \"Nao existe outros arquivos a patir do arquivo base especificado!\\n\");\n        return 1;\n    }\n    return intercalar(nomeBase, quantidadeArquivos);\n}\n","function_prediction":"int ordenar_name_conflict(char *nomeArquivoBase) {\n  int numArquivos;\n  char *nomeArquivo;\n\n  nomeArquivo = (char *)malloc(strlen(nomeArquivoBase + 10));\n  if (nomeArquivo == NULL) {\n    fprintf(stderr,\n            \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n    return 1;\n  }\n\n  numArquivos = contarArquivos(nomeArquivoBase);\n  if (numArquivos == 0) {\n    fprintf(\n        stderr,\n        \"Nao existe outros arquivos a patir do arquivo base especificado!\\n\");\n    return 1;\n  }\n\n  intercalar(nomeArquivoBase, numArquivos);\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":1,"function":"int contarArquivos(const char *nomeBase) {\n    int quantidadeArquivos = 0;\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    for (int i = 0; i < 10; i++) {\n        sprintf(nomeArquivo, \"%s%d\", nomeBase, i);\n        if (existeArquivo(nomeArquivo)) {\n            quantidadeArquivos++;\n        }\n    }\n    free(nomeArquivo);\n    return quantidadeArquivos;\n}\n","function_prediction":"int contarArquivos_name_conflict(char *nomeArquivo) {\n  int i, cont = 0;\n  FILE *arq;\n  char *nome = malloc(strlen(nomeArquivo + 10) * sizeof(char));\n  if (nome == NULL) {\n    fprintf(stderr,\n            \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n    return 1;\n  }\n  for (i = 0; i < 10; i++) {\n    sprintf(nome, \"%s%d\", nomeArquivo, i);\n    arq = fopen(nome, \"rb\");\n    if (arq != NULL) {\n      fclose(arq);\n      cont++;\n    }\n  }\n  free(nome);\n  return cont;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":1,"function":"_Bool existeArquivo(const char *nomeArquivo) {\n    FILE *arquivo = fopen(nomeArquivo, \"rb\");\n    _Bool result = arquivo != ((void *)0);\n    if (result) {\n        fclose(arquivo);\n    }\n    return result;\n}\n","function_prediction":"int existeArquivo_name_conflict(char *nomeArquivo) {\n  FILE *arquivo;\n\n  arquivo = fopen(nomeArquivo, \"rb\");\n  if (arquivo) {\n    fclose(arquivo);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"int intercalar(const char *nomeBase, int quantidadeArquivos) {\n    FILE *arquivosEntrada[10];\n    FILE *arquivoSaida;\n    int buffer[10][5];\n    char *nomeArquivo = malloc(strlen(nomeBase + 10) * sizeof(char));\n    if (nomeArquivo == ((void *)0)) {\n        fprintf(stderr, \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n        return 1;\n    }\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        sprintf(nomeArquivo, \"%s%d\", nomeBase, i);\n        arquivosEntrada[i] = fopen(nomeArquivo, \"rb\");\n        if (arquivosEntrada[i] == ((void *)0)) {\n            fprintf(stderr, \"Problema na abertura do arquivo %s\\n\", nomeArquivo);\n            for (int j = 0; j < i; j++) {\n                fclose(arquivosEntrada[j]);\n            }\n            free(nomeArquivo);\n            return 1;\n        }\n    }\n    arquivoSaida = fopen(nomeBase, \"wb\");\n    if (arquivoSaida == ((void *)0)) {\n        fprintf(stderr, \"Problema na abertura do arquivo %s\\n\", nomeBase);\n        for (int i = 0; i < quantidadeArquivos; i++) {\n            fclose(arquivosEntrada[i]);\n        }\n        free(nomeArquivo);\n        return 1;\n    }\n    while (!leuTodosOsArquivosPorCompleto(arquivosEntrada, quantidadeArquivos))\n        {\n            int lidoAtual[10] = {0};\n            for (int i = 0; i < quantidadeArquivos; i++) {\n                lidoAtual[i] = fread(buffer[i], sizeof(int), 5, arquivosEntrada[i]);\n            }\n            int indices[10] = {0};\n            int min = pegaMenor(buffer, quantidadeArquivos, indices, lidoAtual);\n            while (min != -1)\n                {\n                    fwrite(&buffer[min][indices[min]], sizeof(int), 1, arquivoSaida);\n                    indices[min]++;\n                    if (indices[min] == lidoAtual[min]) {\n                        lidoAtual[min] = fread(buffer[min], sizeof(int), 5, arquivosEntrada[min]);\n                        indices[min] = 0;\n                    }\n                    min = pegaMenor(buffer, quantidadeArquivos, indices, lidoAtual);\n                }\n        }\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        fclose(arquivosEntrada[i]);\n    }\n    fclose(arquivoSaida);\n    free(nomeArquivo);\n    return 0;\n}\n","function_prediction":"int intercalar_name_conflict(char *nome, int n) {\n  FILE *arq[10], *arq_saida;\n  int i, j, k, menor, indice[10], tam[10], fim[10], erro = 0;\n  int vetor[5];\n  char *nome_arq;\n\n  nome_arq = (char *)malloc(strlen(nome + 10) * sizeof(char));\n  if (nome_arq == NULL) {\n    fprintf(stderr,\n            \"Problema com alocacao dinamica! Possivel falta de memoria\\n\");\n    return 1;\n  }\n\n  for (i = 0; i < n; i++) {\n    sprintf(nome_arq, \"%s%d\", nome, i);\n    arq[i] = fopen(nome_arq, \"rb\");\n    if (arq[i] == NULL) {\n      fprintf(stderr, \"Problema na abertura do arquivo %s\\n\", nome_arq);\n      erro = 1;\n      break;\n    }\n  }\n\n  if (erro) {\n    for (j = 0; j < i; j++)\n      fclose(arq[j]);\n    free(nome_arq);\n    return 1;\n  }\n\n  arq_saida = fopen(nome, \"wb\");\n  if (arq_saida == NULL) {\n    fprintf(stderr, \"Problema na abertura do arquivo %s\\n\", nome);\n    for (j = 0; j < i; j++)\n      fclose(arq[j]);\n    free(nome_arq);\n    return 1;\n  }\n\n  for (i = 0; i < n; i++) {\n    while (!feof(arq[i])) {\n      for (j = 0; j < n; j++) {\n                tam[j] = fread(vetor","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":0,"function":"int pegaMenor(const int buffer[][5], const int quantidadeArquivos, const int *indices, const int *lidoAtual) {\n    int min = -1;\n    for (int i = 0; i < quantidadeArquivos; i++) {\n        if (lidoAtual[i] > 0 && indices[i] < lidoAtual[i]) {\n            min = i;\n            break;\n        }\n    }\n    if (min != -1) {\n        for (int i = 0; i < quantidadeArquivos; i++) {\n            if (buffer[min][indices[min]] > buffer[i][indices[i]] && indices[i] < lidoAtual[i]) {\n                min = i;\n            }\n        }\n    }\n    return min;\n}\n","function_prediction":"int pegaMenor_name_conflict(int *matriz, int tam, int *visitados, int *distancias) {\n  int i, j, menor, menor_indice;\n\n  for (i = 0; i < tam; i++) {\n    if (distancias[i] > 0 && distancias[i] > visitados[i]) {\n      menor = matriz[i * 5 + visitados[i]];\n      menor_indice = i;\n      for (j = 0; j < tam; j++) {\n        if (matriz[j * 5 + visitados[j]] < menor &&\n            distancias[j] > visitados[j]) {\n          menor = matriz[j * 5 + visitados[j]];\n          menor_indice = j;\n        }\n      }\n      return menor_indice;\n    }\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2018/ORI/T2/main.c"}
{"compilable":1,"function":"int comprimento(char *string) {\n    unsigned int quantidade = 0;\n    while (*string != '\\x00')\n        {\n            quantidade++;\n            string++;\n        }\n    return quantidade;\n}\n","function_prediction":"int comprimento_name_conflict(char *str) {\n  if (*str == '\\0')\n    return 0;\n  else\n    return 1 + strlen(str + 1);\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":1,"function":"char *maiuscula(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string > 96) {\n            *string -= 32;\n        }\n    }\n    return string;\n}\n","function_prediction":"char *maiuscula_name_conflict(char *str) {\n  int i, tam;\n\n  if (str[0] == '\\0')\n    return str;\n\n  tam = strlen(str + 1);\n  if (tam == -1)\n    return str;\n\n  for (i = 0; i <= tam; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z')\n      str[i] -= 32;\n  }\n\n  return str + tam + 1;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":1,"function":"char *intercala(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    bool foi = 0;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string > 96 && *string < 123) {\n            if (!foi) {\n                *string -= 32;\n                foi = 1;\n            } else {\n                foi = 0;\n            }\n        }\n    }\n    return string;\n}\n","function_prediction":"char *intercala_name_conflict(char *str) {\n  int i, j, k, l;\n  int flag = 0;\n\n  if (str[0] == '\\0')\n    return str;\n\n  l = strlen(str + 1);\n  if (l == -1)\n    return str;\n\n  for (i = 0, j = 1; i < l; i++, j++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      if (flag == 0) {\n        str[i] = str[i] - 32;\n        flag = 1;\n      } else\n        flag = 0;\n    }\n  }\n\n  return str + l + 1;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":1,"function":"char *minuscula(char *string) {\n    unsigned int tamanho = comprimento(string);\n    unsigned int i;\n    for (i = 0; i < tamanho; i++ , string++) {\n        if (*string < 91 && *string > 64) {\n            *string += 32;\n        }\n    }\n    return string;\n}\n","function_prediction":"char *minuscula_name_conflict(char *str) {\n  int i, tam;\n\n  if (str[0] == '\\0')\n    return str;\n\n  tam = strlen(str + 1);\n\n  if (tam == -1)\n    return str;\n\n  for (i = 0; i <= tam; i++) {\n    if (str[i] >= 'A' && str[i] <= 'Z')\n      str[i] += 32;\n  }\n\n  return str + tam + 1;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_17-05/ex1.c"}
{"compilable":1,"function":"int jogar(int ev1, int ev2, int at, int d) {\n    int dado, ganhador;\n    while (ev1 > 0 && ev2 > 0)\n        {\n            dado = aleatorio();\n            if (dado <= at) {\n                ev1 += d;\n                ev2 -= d;\n            } else {\n                ev1 -= d;\n                ev2 += d;\n            }\n            printf(\"Dado %d EV1 %d EV2 %d\\n\", dado, ev1, ev2);\n        }\n    if (ev1 <= 0) {\n        ganhador = 2;\n    } else {\n        ganhador = 1;\n    }\n    return ganhador;\n}\n","function_prediction":"int jogar_name_conflict(int EV1, int EV2, int dado, int valor) {\n  int dado_jogado;\n\n  while (EV1 > 0 && EV2 > 0) {\n    srand(time(NULL));\n    dado_jogado = rand() % 6 + 1;\n\n    if (dado_jogado > dado) {\n      EV1 += valor;\n      EV2 -= valor;\n    } else {\n      EV1 -= valor;\n      EV2 += valor;\n    }\n\n    printf(\"Dado %d EV1 %d EV2 %d\\n\", dado_jogado, EV1, EV2);\n  }\n\n  if (EV1 <= 0)\n    return 1;\n  else\n    return 2;\n}","pass":0,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_03-05/uri-1093.c"}
{"compilable":1,"function":"int aleatorio() {\n    srand(time(((void *)0)));\n    return rand() % 6 + 1;\n}\n","function_prediction":"int aleatorio_name_conflict() {\n  srand(time(NULL));\n  return (rand() % 6) + 1;\n}","pass":1,"source_file":"C_COMPILE/LorhanSohaky_UFSCar/2017/cap/aula_03-05/uri-1093.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"int **new_board_name_conflict() {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"int **clone_name_conflict(int **A) {\n  int **B = (int **)calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    B[i] = (int *)calloc(3, sizeof(int));\n    for (int j = 0; j < 3; j++) {\n      B[i][j] = A[i][j];\n    }\n  }\n  return B;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"int **read_encode_name_conflict(char *encode) {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      if (encode[i * 3 + j] == 'O') {\n        board[i][j] = 2;\n      } else if (encode[i * 3 + j] == 'X') {\n        board[i][j] = 1;\n      } else if (encode[i * 3 + j] == '-') {\n        board[i][j] = 0;\n      }\n    }\n  }\n\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"char turn_name_conflict(int **board) {\n  int i, j, x = 0, o = 0;\n\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      if (board[i][j] == 1)\n        x++;\n      else if (board[i][j] == 2)\n        o++;\n\n  if (x + o == 9)\n    return_name_conflict 0;\n  else if (x > o)\n    return_name_conflict 1;\n  else\n    return_name_conflict 2;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"int **move_name_conflict(int **board, int x, int y) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x1, y1, z, z1, z2, z3, z4,\n      z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20,\n      z21, z22, z23, z24, z25, z26, z27, z28, z29, z30, z31, z32, z33, z34, z35,\n      z36, z37, z38, z39, z40, z41, z42, z43, z44, z45, z46, z47, z48, z49, z50,\n      z51, z52, z53, z54, z55, z56, z57, z58, z59, z60, z61, z62, z63, z64, z65,\n      z66, z67, z68, z69, z70, z71, z72, z73, z74, z75, z76, z77, z78, z79, z80,\n      z81, z82, z83, z84, z85, z86, z87, z88, z89, z90, z91, z92, z93, z94, z95,\n      z96, z97, z98, z99, z100, z101, z102, z103, z104, z105, z106, z107, z108,\n      z109, z110, z111, z112, z113","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"int winner_name_conflict(int **board) {\n  int i, j, k;\n  int win = 0;\n\n  for (i = 0; i < 3; i++) {\n    if (board[0][i] != 0) {\n      for (j = 1; j < 3; j++) {\n        if (board[0][i] != board[j][i]) {\n          break;\n        }\n      }\n      if (j == 3) {\n        win = board[0][i];\n        break;\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[i][0] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[i][0] != board[i][j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[i][0];\n          break;\n        }\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[0][0] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[0][0] != board[j][j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[0][0];\n          break;\n        }\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[0][2] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[0][2] != board[j][2 - j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[0][2];\n          break;\n        }\n      }\n    }\n  }\n\n  return win;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"int cpu_name_conflict(int **board) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g,\n      h, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1, v1, w1, x1, y1, z1,\n      a1, b1, c1, d1, e1, f1, g1, h1, i2, j2, k2, l2, m2, n2, o2, p2, q2, r2,\n      s2, t2, u2, v2, w2, x2, y2, z2, a2, b2, c2, d2, e2, f2, g2, h2, i3, j3,\n      k3, l3, m3, n3, o3, p3, q3, r3, s3, t3, u3, v3, w3, x3, y3, z3, a3, b3,\n      c3, d3, e3, f3, g3, h3, i4, j4, k4, l4, m4, n4, o4, p4, q4, r4, s4, t4,\n      u4, v4, w4, x4, y4, z4, a4, b4, c4, d4, e4, f4, g4, h4, i5, j5, k5, l5,\n      m5, n5, o5, p5, q5, r5, s5, t5, u5, v5, w5, x5, y5, z5, a5, b5, c5, d5,\n      e5, f5, g5, h5, i6, j6, k6, l6, m6, n6, o6, p6, q6, r6, s6, t6, u6, v6,\n      w6, x6, y6, z6, a6, b","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"int **new_board_name_conflict() {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"int **clone_name_conflict(int **A) {\n  int **B = (int **)calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    B[i] = (int *)calloc(3, sizeof(int));\n    for (int j = 0; j < 3; j++) {\n      B[i][j] = A[i][j];\n    }\n  }\n  return B;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"int **read_encode_name_conflict(char *encode) {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      if (encode[i * 3 + j] == 'O') {\n        board[i][j] = 2;\n      } else if (encode[i * 3 + j] == 'X') {\n        board[i][j] = 1;\n      } else if (encode[i * 3 + j] == '-') {\n        board[i][j] = 0;\n      }\n    }\n  }\n\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"char turn_name_conflict(int **board) {\n  int i, j, x = 0, o = 0;\n\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      if (board[i][j] == 1)\n        x++;\n      else if (board[i][j] == 2)\n        o++;\n\n  if (x + o == 9)\n    return_name_conflict 0;\n  else if (x > o)\n    return_name_conflict 1;\n  else\n    return_name_conflict 2;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"int **move_name_conflict(int **board, int x, int y) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x1, y1, z, z1, z2, z3, z4,\n      z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20,\n      z21, z22, z23, z24, z25, z26, z27, z28, z29, z30, z31, z32, z33, z34, z35,\n      z36, z37, z38, z39, z40, z41, z42, z43, z44, z45, z46, z47, z48, z49, z50,\n      z51, z52, z53, z54, z55, z56, z57, z58, z59, z60, z61, z62, z63, z64, z65,\n      z66, z67, z68, z69, z70, z71, z72, z73, z74, z75, z76, z77, z78, z79, z80,\n      z81, z82, z83, z84, z85, z86, z87, z88, z89, z90, z91, z92, z93, z94, z95,\n      z96, z97, z98, z99, z100, z101, z102, z103, z104, z105, z106, z107, z108,\n      z109, z110, z111, z112, z113","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"int winner_name_conflict(int **board) {\n  int i, j, k;\n  int win = 0;\n\n  for (i = 0; i < 3; i++) {\n    if (board[0][i] != 0) {\n      for (j = 1; j < 3; j++) {\n        if (board[0][i] != board[j][i]) {\n          break;\n        }\n      }\n      if (j == 3) {\n        win = board[0][i];\n        break;\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[i][0] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[i][0] != board[i][j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[i][0];\n          break;\n        }\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[0][0] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[0][0] != board[j][j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[0][0];\n          break;\n        }\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[0][2] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[0][2] != board[j][2 - j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[0][2];\n          break;\n        }\n      }\n    }\n  }\n\n  return win;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"int cpu_name_conflict(int **board) {\n\n  int x, y, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x1, y1, z, z1, z2, z3,\n      z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19,\n      z20, z21, z22, z23, z24, z25, z26, z27, z28, z29, z30, z31, z32, z33, z34,\n      z35, z36, z37, z38, z39, z40, z41, z42, z43, z44, z45, z46, z47, z48, z49,\n      z50, z51, z52, z53, z54, z55, z56, z57, z58, z59, z60, z61, z62, z63, z64,\n      z65, z66, z67, z68, z69, z70, z71, z72, z73, z74, z75, z76, z77, z78, z79,\n      z80, z81, z82, z83, z84, z85, z86, z87, z88, z89, z90, z91, z92, z93, z94,\n      z95, z96, z97, z98, z99, z100, z101, z102, z103, z104, z105, z106, z107,\n      z108, z109, z110, z111, z112","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"int **new_board_name_conflict() {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"int **clone_name_conflict(int **A) {\n  int **B = (int **)calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    B[i] = (int *)calloc(3, sizeof(int));\n    for (int j = 0; j < 3; j++) {\n      B[i][j] = A[i][j];\n    }\n  }\n  return B;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"int **read_encode_name_conflict(char *encode) {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      if (encode[i * 3 + j] == 'O') {\n        board[i][j] = 2;\n      } else if (encode[i * 3 + j] == 'X') {\n        board[i][j] = 1;\n      } else if (encode[i * 3 + j] == '-') {\n        board[i][j] = 0;\n      }\n    }\n  }\n\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"char turn_name_conflict(int **board) {\n  int i, j, x = 0, o = 0;\n\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      if (board[i][j] == 1)\n        x++;\n      else if (board[i][j] == 2)\n        o++;\n\n  if (x + o == 9)\n    return_name_conflict 0;\n  else if (x > o)\n    return_name_conflict 1;\n  else\n    return_name_conflict 2;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"int **move_name_conflict(int **board, int x, int y) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x1, y1, z, z1, z2, z3, z4,\n      z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20,\n      z21, z22, z23, z24, z25, z26, z27, z28, z29, z30, z31, z32, z33, z34, z35,\n      z36, z37, z38, z39, z40, z41, z42, z43, z44, z45, z46, z47, z48, z49, z50,\n      z51, z52, z53, z54, z55, z56, z57, z58, z59, z60, z61, z62, z63, z64, z65,\n      z66, z67, z68, z69, z70, z71, z72, z73, z74, z75, z76, z77, z78, z79, z80,\n      z81, z82, z83, z84, z85, z86, z87, z88, z89, z90, z91, z92, z93, z94, z95,\n      z96, z97, z98, z99, z100, z101, z102, z103, z104, z105, z106, z107, z108,\n      z109, z110, z111, z112, z113","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"int winner_name_conflict(int **board) {\n  int i, j, k;\n  int win = 0;\n\n  for (i = 0; i < 3; i++) {\n    if (board[0][i] != 0) {\n      for (j = 1; j < 3; j++) {\n        if (board[0][i] != board[j][i]) {\n          break;\n        }\n      }\n      if (j == 3) {\n        win = board[0][i];\n        break;\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[i][0] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[i][0] != board[i][j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[i][0];\n          break;\n        }\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[0][0] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[0][0] != board[j][j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[0][0];\n          break;\n        }\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[0][2] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[0][2] != board[j][2 - j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[0][2];\n          break;\n        }\n      }\n    }\n  }\n\n  return win;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"int cpu_name_conflict(int **board) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g,\n      h, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1, v1, w1, x1, y1, z1,\n      a1, b1, c1, d1, e1, f1, g1, h1, i2, j2, k2, l2, m2, n2, o2, p2, q2, r2,\n      s2, t2, u2, v2, w2, x2, y2, z2, a2, b2, c2, d2, e2, f2, g2, h2, i3, j3,\n      k3, l3, m3, n3, o3, p3, q3, r3, s3, t3, u3, v3, w3, x3, y3, z3, a3, b3,\n      c3, d3, e3, f3, g3, h3, i4, j4, k4, l4, m4, n4, o4, p4, q4, r4, s4, t4,\n      u4, v4, w4, x4, y4, z4, a4, b4, c4, d4, e4, f4, g4, h4, i5, j5, k5, l5,\n      m5, n5, o5, p5, q5, r5, s5, t5, u5, v5, w5, x5, y5, z5, a5, b5, c5, d5,\n      e5, f5, g5, h5, i6, j6, k6, l6, m6, n6, o6, p6, q6, r6, s6, t6, u6, v6,\n      w6, x6, y6, z6, a6, b","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"int **new_board_name_conflict() {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"int **clone_name_conflict(int **A) {\n  int **B = (int **)calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    B[i] = (int *)calloc(3, sizeof(int));\n    for (int j = 0; j < 3; j++) {\n      B[i][j] = A[i][j];\n    }\n  }\n  return B;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"int **read_encode_name_conflict(char *encode) {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      if (encode[i * 3 + j] == 'O') {\n        board[i][j] = 2;\n      } else if (encode[i * 3 + j] == 'X') {\n        board[i][j] = 1;\n      } else if (encode[i * 3 + j] == '-') {\n        board[i][j] = 0;\n      }\n    }\n  }\n\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"char turn_name_conflict(int **board) {\n  int i, j, x = 0, o = 0;\n\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      if (board[i][j] == 1)\n        x++;\n      else if (board[i][j] == 2)\n        o++;\n\n  if (x + o == 9)\n    return_name_conflict 0;\n  else if (x > o)\n    return_name_conflict 1;\n  else\n    return_name_conflict 2;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"int **move_name_conflict(int **board, int x, int y) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x1, y1, z, z1, z2, z3, z4,\n      z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20,\n      z21, z22, z23, z24, z25, z26, z27, z28, z29, z30, z31, z32, z33, z34, z35,\n      z36, z37, z38, z39, z40, z41, z42, z43, z44, z45, z46, z47, z48, z49, z50,\n      z51, z52, z53, z54, z55, z56, z57, z58, z59, z60, z61, z62, z63, z64, z65,\n      z66, z67, z68, z69, z70, z71, z72, z73, z74, z75, z76, z77, z78, z79, z80,\n      z81, z82, z83, z84, z85, z86, z87, z88, z89, z90, z91, z92, z93, z94, z95,\n      z96, z97, z98, z99, z100, z101, z102, z103, z104, z105, z106, z107, z108,\n      z109, z110, z111, z112, z113","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"int winner_name_conflict(int **board) {\n  int i, j, k;\n  int win = 0;\n\n  for (i = 0; i < 3; i++) {\n    if (board[0][i] != 0) {\n      for (j = 1; j < 3; j++) {\n        if (board[0][i] != board[j][i]) {\n          break;\n        }\n      }\n      if (j == 3) {\n        win = board[0][i];\n        break;\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[i][0] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[i][0] != board[i][j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[i][0];\n          break;\n        }\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[0][0] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[0][0] != board[j][j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[0][0];\n          break;\n        }\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[0][2] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[0][2] != board[j][2 - j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[0][2];\n          break;\n        }\n      }\n    }\n  }\n\n  return win;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"int cpu_name_conflict(int **board) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g,\n      h, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1, v1, w1, x1, y1, z1,\n      a1, b1, c1, d1, e1, f1, g1, h1, i2, j2, k2, l2, m2, n2, o2, p2, q2, r2,\n      s2, t2, u2, v2, w2, x2, y2, z2, a2, b2, c2, d2, e2, f2, g2, h2, i3, j3,\n      k3, l3, m3, n3, o3, p3, q3, r3, s3, t3, u3, v3, w3, x3, y3, z3, a3, b3,\n      c3, d3, e3, f3, g3, h3, i4, j4, k4, l4, m4, n4, o4, p4, q4, r4, s4, t4,\n      u4, v4, w4, x4, y4, z4, a4, b4, c4, d4, e4, f4, g4, h4, i5, j5, k5, l5,\n      m5, n5, o5, p5, q5, r5, s5, t5, u5, v5, w5, x5, y5, z5, a5, b5, c5, d5,\n      e5, f5, g5, h5, i6, j6, k6, l6, m6, n6, o6, p6, q6, r6, s6, t6, u6, v6,\n      w6, x6, y6, z6, a6, b","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board new_board() {\n    board b = (board)calloc(3, sizeof(int *));\n    for (int i = 0; i < 3; i++) {\n        b[i] = (int *)calloc(3, sizeof(int));\n    }\n    return b;\n}\n","function_prediction":"int **new_board_name_conflict() {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board clone(board b) {\n    board copy = (board)calloc(3, sizeof(int *));\n    for (int r = 0; r < 3; r++) {\n        copy[r] = (int *)calloc(3, sizeof(int));\n        for (int c = 0; c < 3; c++) {\n            copy[r][c] = b[r][c];\n        }\n    }\n    return copy;\n}\n","function_prediction":"int **clone_name_conflict(int **A) {\n  int **B = (int **)calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    B[i] = (int *)calloc(3, sizeof(int));\n    for (int j = 0; j < 3; j++) {\n      B[i][j] = A[i][j];\n    }\n  }\n  return B;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"board read_encode(char *s) {\n    board b = new_board();\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (*s) {\n              case 'X':\n                b[r][c] = 1;\n                break;\n              case 'O':\n                b[r][c] = 2;\n                break;\n              case '-':\n                b[r][c] = 0;\n                break;\n            }\n            s++;\n        }\n    return b;\n}\n","function_prediction":"int **read_encode_name_conflict(char *encode) {\n  int **board = calloc(3, sizeof(int *));\n  for (int i = 0; i < 3; i++) {\n    board[i] = calloc(3, sizeof(int));\n  }\n\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      if (encode[i * 3 + j] == 'O') {\n        board[i][j] = 2;\n      } else if (encode[i * 3 + j] == 'X') {\n        board[i][j] = 1;\n      } else if (encode[i * 3 + j] == '-') {\n        board[i][j] = 0;\n      }\n    }\n  }\n\n  return board;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int turn(board b) {\n    int xcount = 0, ocount = 0;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            switch (b[r][c]) {\n              case 1:\n                xcount++;\n                break;\n              case 2:\n                ocount++;\n                break;\n            }\n        }\n    if (ocount + xcount == 9)\n        return 0;\n    else if (ocount < xcount)\n        return 2;\n    else\n        return 1;\n}\n","function_prediction":"char turn_name_conflict(int **board) {\n  int i, j, x = 0, o = 0;\n\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      if (board[i][j] == 1)\n        x++;\n      else if (board[i][j] == 2)\n        o++;\n\n  if (x + o == 9)\n    return_name_conflict 0;\n  else if (x > o)\n    return_name_conflict 1;\n  else\n    return_name_conflict 2;\n}","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"board move(board b, int r, int c) {\n    int t = turn(b);\n    board copy = clone(b);\n    copy[r][c] = t;\n    return copy;\n}\n","function_prediction":"int **move_name_conflict(int **board, int x, int y) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x1, y1, z, z1, z2, z3, z4,\n      z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20,\n      z21, z22, z23, z24, z25, z26, z27, z28, z29, z30, z31, z32, z33, z34, z35,\n      z36, z37, z38, z39, z40, z41, z42, z43, z44, z45, z46, z47, z48, z49, z50,\n      z51, z52, z53, z54, z55, z56, z57, z58, z59, z60, z61, z62, z63, z64, z65,\n      z66, z67, z68, z69, z70, z71, z72, z73, z74, z75, z76, z77, z78, z79, z80,\n      z81, z82, z83, z84, z85, z86, z87, z88, z89, z90, z91, z92, z93, z94, z95,\n      z96, z97, z98, z99, z100, z101, z102, z103, z104, z105, z106, z107, z108,\n      z109, z110, z111, z112, z113","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":1,"function":"int winner(board b) {\n    for (int i = 0; i < 3; i++) {\n        if (b[i][0] && b[i][0] == b[i][1] && b[i][0] == b[i][2])\n            return b[i][0];\n        if (b[0][i] && b[0][i] == b[1][i] && b[0][i] == b[2][i])\n            return b[0][i];\n    }\n    if (b[0][0] && b[0][0] == b[1][1] && b[0][0] == b[2][2])\n        return b[0][0];\n    if (b[2][0] && b[2][0] == b[1][1] && b[2][0] == b[0][2])\n        return b[2][0];\n    ;\n    return 0;\n}\n","function_prediction":"int winner_name_conflict(int **board) {\n  int i, j, k;\n  int win = 0;\n\n  for (i = 0; i < 3; i++) {\n    if (board[0][i] != 0) {\n      for (j = 1; j < 3; j++) {\n        if (board[0][i] != board[j][i]) {\n          break;\n        }\n      }\n      if (j == 3) {\n        win = board[0][i];\n        break;\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[i][0] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[i][0] != board[i][j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[i][0];\n          break;\n        }\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[0][0] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[0][0] != board[j][j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[0][0];\n          break;\n        }\n      }\n    }\n  }\n\n  if (win == 0) {\n    for (i = 0; i < 3; i++) {\n      if (board[0][2] != 0) {\n        for (j = 1; j < 3; j++) {\n          if (board[0][2] != board[j][2 - j]) {\n            break;\n          }\n        }\n        if (j == 3) {\n          win = board[0][2];\n          break;\n        }\n      }\n    }\n  }\n\n  return win;\n}","pass":1,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int cpu(board b) {\n    int t = turn(b), best = -9;\n    int r, c;\n    for (r = 0; r < 3; r++)\n        for (c = 0; c < 3; c++) {\n            if (b[r][c] == 0) {\n                board try = move(b, r, c);\n                int w = winner(try);\n                if (w == t) {\n                    return ((2) * 9 + (r) * 3 + (c));\n                } else if (turn(try) == 0) {\n                    if (1 > ((best) / 9)) {\n                        best = ((1) * 9 + (r) * 3 + (c));\n                    }\n                } else {\n                    int opp = cpu(try);\n                    int s = 2 - ((opp) / 9);\n                    if (s > ((best) / 9)) {\n                        best = ((s) * 9 + (r) * 3 + (c));\n                    }\n                }\n            }\n        }\n    return best;\n}\n","function_prediction":"int cpu_name_conflict(int **board) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g,\n      h, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1, v1, w1, x1, y1, z1,\n      a1, b1, c1, d1, e1, f1, g1, h1, i2, j2, k2, l2, m2, n2, o2, p2, q2, r2,\n      s2, t2, u2, v2, w2, x2, y2, z2, a2, b2, c2, d2, e2, f2, g2, h2, i3, j3,\n      k3, l3, m3, n3, o3, p3, q3, r3, s3, t3, u3, v3, w3, x3, y3, z3, a3, b3,\n      c3, d3, e3, f3, g3, h3, i4, j4, k4, l4, m4, n4, o4, p4, q4, r4, s4, t4,\n      u4, v4, w4, x4, y4, z4, a4, b4, c4, d4, e4, f4, g4, h4, i5, j5, k5, l5,\n      m5, n5, o5, p5, q5, r5, s5, t5, u5, v5, w5, x5, y5, z5, a5, b5, c5, d5,\n      e5, f5, g5, h5, i6, j6, k6, l6, m6, n6, o6, p6, q6, r6, s6, t6, u6, v6,\n      w6, x6, y6, z6, a6, b","pass":0,"source_file":"C_COMPILE/liamboone_bgal/move-explorer/examples/tictactoe/src/tictactoe.c"}
{"compilable":0,"function":"int init_net(char *address, char *port, int *sock) {\n    int s, v, i;\n    struct addrinfo hints, *result, *rp;\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = 0;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = 1 | 4;\n    hints.ai_protocol = IPPROTO_IP;\n    if ((s = getaddrinfo(address, port, &hints, &result)) != 0) {\n        fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(s));\n        exit(1);\n    }\n    for (rp = result , i = 0; rp != ((void *)0) && i < 2; rp = rp->ai_next , ++i) {\n        sock[i] = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n        if (sock[i] == -1) {\n            perror(\"socket\");\n            continue;\n        }\n        v = 1;\n        if (setsockopt(sock[i], 1, 2, &v, sizeof (v)) < 0) {\n            perror(\"setsockopt\");\n            return -1;\n        }\n        if (bind(sock[i], rp->ai_addr, rp->ai_addrlen) < 0) {\n            perror(\"socket\");\n            return -1;\n        }\n        if (listen(sock[i], 5) < 0) {\n            perror(\"listen\");\n            return -1;\n        }\n    }\n    freeaddrinfo(result);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/binarylu_cs631/HW3/net.c"}
{"compilable":1,"function":"int sockaddr2string(struct sockaddr *sa, char *address) {\n    struct sockaddr_in *server;\n    struct sockaddr_in6 *server6;\n    if (sa->sa_family == 2) {\n        server = (struct sockaddr_in *)sa;\n        if (inet_ntop(sa->sa_family, &(server->sin_addr), address, 46) == ((void *)0)) {\n            perror(\"inet_ntop\");\n            return -1;\n        }\n    } else {\n        server6 = (struct sockaddr_in6 *)sa;\n        if (inet_ntop(sa->sa_family, &(server6->sin6_addr), address, 46) == ((void *)0)) {\n            perror(\"inet_ntop\");\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int sockaddr2string_name_conflict(struct sockaddr *sa, char *str) {\n  if (sa->sa_family == 2) {\n    if (inet_ntop(2, &((struct sockaddr_in *)sa)->sin_addr, str, 46) == NULL) {\n      perror(\"inet_ntop\");\n      return -1;\n    }\n  } else {\n    if (inet_ntop(sa->sa_family, &((struct sockaddr_in6 *)sa)->sin6_addr, str,\n                  46) == NULL) {\n      perror(\"inet_ntop\");\n      return -1;\n    }\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/binarylu_cs631/HW3/net.c"}
{"compilable":0,"function":"int is_number(char *str) {\n    int i;\n    int len = strlen(str);\n    for (i = 0; i < len; ++i)\n        if (!((*__ctype_b_loc())[(int)((str[i]))] & (unsigned short)_ISdigit))\n            return 0;\n    return 1;\n}\n","function_prediction":"int is_number_name_conflict(char *str) {\n  int i, len;\n\n  len = strlen(str);\n  for (i = 0; i < len; i++)\n    if (!(__ctype_b_loc()[(unsigned char)(str[i])] & (0x01 << 3)))\n      return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/binarylu_cs631/HW3/main.c"}
{"compilable":0,"function":"int q_isEmpty(enum_q_type t) {\n    int ret = 0;\n    pthread_mutex_t *mutex = ((void *)0);\n    _task_queue_entry **head = ((void *)0);\n    if (t == TASK) {\n        mutex = &task_mutex;\n        head = &task_head;\n    } else if (t == RESPONSE) {\n        mutex = &response_mutex;\n        head = &response_head;\n    } else {\n        return 1;\n    }\n    pthread_mutex_lock(mutex);\n    ret = *head == ((void *)0) ? 1 : 0;\n    pthread_mutex_unlock(mutex);\n    return ret;\n}\n","function_prediction":"int q_isEmpty_name_conflict(int type) {\n  int ret = 0;\n  struct task_node *head;\n  pthread_mutex_t *mutex;\n\n  if (type == 0) {\n    head = &task_head;\n    mutex = &task_mutex;\n  } else if (type == 1) {\n    head = &response_head;\n    mutex = &response_mutex;\n  } else {\n    return 1;\n  }\n\n  pthread_mutex_lock(mutex);\n  if (head->next == NULL) {\n    ret = 1;\n  }\n  pthread_mutex_unlock(mutex);\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/binarylu_cs631/Final/task_queue.c"}
{"compilable":1,"function":"int init_epoll(int sock) {\n    int epfd;\n    struct epoll_event ev;\n    if ((epfd = epoll_create(100)) < 0) {\n        perror(\"epoll_create\");\n        return -1;\n    }\n    ev.events = EPOLLIN | EPOLLET;\n    ev.data.fd = sock;\n    if (epoll_ctl(epfd, 1, sock, &ev) < 0) {\n        perror(\"epoll_ctl\");\n        return -1;\n    }\n    return epfd;\n}\n","function_prediction":"int init_epoll_name_conflict(int listenfd) {\n  int epollfd;\n  struct epoll_event event;\n\n  epollfd = epoll_create(100);\n  if (epollfd < 0) {\n    perror(\"epoll_create\");\n    return -1;\n  }\n\n  event.data.fd = listenfd;\n  event.events = EPOLLIN | EPOLLET;\n  if (epoll_ctl(epollfd, 1, listenfd, &event) < 0) {\n    perror(\"epoll_ctl\");\n    return -1;\n  }\n\n  return epollfd;\n}","pass":1,"source_file":"C_COMPILE/binarylu_cs631/Final/main.c"}
{"compilable":1,"function":"int setnonblocking(int fd) {\n    int flags = fcntl(fd, 3, 0);\n    if (flags < 0) {\n        return -1;\n    }\n    if (fcntl(fd, 4, flags | 2048) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int setnonblocking_name_conflict(int fd) {\n  int opts;\n  opts = fcntl(fd, 3, 0);\n  if (opts < 0)\n    return -1;\n  opts = opts | O_NONBLOCK;\n  if (fcntl(fd, 4, opts) == -1)\n    return -1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/binarylu_cs631/Final/util.c"}
{"compilable":0,"function":"int spawn(char *program, char **arg_list) {\n    pid_t child_pid;\n    child_pid = fork();\n    if (child_pid != 0)\n        return child_pid;\n    else {\n        execvp(program, arg_list);\n        fprintf(stderr, \"an error occurred in execvp\\n\");\n        abort();\n    }\n}\n","function_prediction":"void spawn_name_conflict(char *path, char *argv[]) {\n  if (!fork()) {\n    spawn_name_conflict_part_0(path, argv);\n    halt_baddata();\n  }\n}","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap03/fork-exec.c"}
{"compilable":0,"function":"int f() {\n    return 3;\n}\n","function_prediction":"void frame_dummy(void) {\n  register_tm_clones();\n  f();\n}","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap02/test.c"}
{"compilable":0,"function":"char *xstrdup(const char *s) {\n    char *copy = strdup(s);\n    if (copy == ((void *)0))\n        abort();\n    else\n        return copy;\n}\n","function_prediction":"void xstrdup_cold(void) { abort(); }","pass":0,"source_file":"C_COMPILE/lavenliu_cprogram/chap11/common.c"}
{"compilable":1,"function":"char *get_self_executable_directory() {\n    int rval;\n    char link_target[1024];\n    char *last_slash;\n    size_t result_length;\n    char *result;\n    rval = readlink(\"/proc/self/exe\", link_target, sizeof (link_target));\n    if (rval == -1)\n        abort();\n    else\n        link_target[rval] = '\\x00';\n    last_slash = strrchr(link_target, '/');\n    if (last_slash == ((void *)0) || last_slash == link_target)\n        abort();\n    result_length = last_slash - link_target;\n    result = (char *)xmalloc(result_length + 1);\n    strncpy(result, link_target, result_length);\n    result[result_length] = '\\x00';\n    return result;\n}\n","function_prediction":"char *get_self_executable_directory_cold(void) { abort(); }","pass":1,"source_file":"C_COMPILE/lavenliu_cprogram/chap11/common.c"}
{"compilable":0,"function":"ipstats_t *ip_get(char *ip_txt) {\n    unsigned int ip;\n    ipstats_t *l;\n    int p[4];\n    sscanf(ip_txt, \"%d.%d.%d.%d\", p + 0, p + 1, p + 2, p + 3);\n    ip = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | (p[3]);\n    for (l = ipstats; l; l = l->next) {\n        if (l->ip == ip) {\n            return (l);\n        }\n    }\n    if (ipstats) {\n        for (l = ipstats; l->next; l = l->next) {\n            ;\n        }\n        l->next = malloc(sizeof(ipstats_t));\n        l = l->next;\n    } else {\n        l = malloc(sizeof(ipstats_t));\n        ipstats = l;\n    }\n    memset(l, 0, sizeof(ipstats_t));\n    l->ip = ip;\n    return (l);\n}\n","function_prediction":"ipstat_t *ip_get_name_conflict(char *ip) {\n  int a, b, c, d;\n  unsigned int ipnum;\n  ipstat_t *p;\n\n  __isoc99_sscanf(ip, \"%d.%d.%d.%d\", &a, &b, &c, &d);\n  ipnum = (a << 24) | (b << 16) | (c << 8) | d;\n\n  for (p = ipstats; p; p = p->next) {\n    if (p->ip == ipnum)\n      return p;\n  }\n\n  for (p = ipstats; p->next; p = p->next)\n    ;\n\n  p->next = malloc(sizeof(ipstat_t));\n  p = p->next;\n  p->ip = ipnum;\n  p->count = 0;\n  p->bytes = 0;\n  p->next = NULL;\n\n  return p;\n}","pass":0,"source_file":"C_COMPILE/meh_bitlbee/utils/bitlbeed.c"}
{"compilable":0,"function":"static int *get_arr() {\n    static int arr[50000] = {8};\n    return arr;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/JMWY_sorting_algorithms_compared/array.c"}
{"compilable":0,"function":"static int pop() {\n    int val = heap[0];\n    heap[0] = heap[--sz];\n    heap[sz] = val;\n    heap_adjust(heap, sz, 0);\n    return val;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/JMWY_sorting_algorithms_compared/algorithms/heap_sort.c"}
{"compilable":0,"function":"QueryConnexionResponse callback_new_connexion(QueryConnexion *q) {\n    static int i;\n    static int iter = (int)(16 / 6);\n    for (i = 0; i < 16; i += iter) {\n        if (__anneau->connexion[i] == 0) {\n            break;\n        }\n    }\n    if (i > 16) {\n        for (i = 16; i >= 0; i--) {\n            if (__anneau->connexion[i] == 0) {\n                break;\n            }\n        }\n    }\n    QueryConnexionResponse r;\n    r.type = q->bot.pid;\n    r.pos = i;\n    return r;\n}\n","function_prediction":"struct sockaddr_in callback_new_connexion_name_conflict(struct sockaddr_in *client) {\n  struct sockaddr_in server;\n\n  i_4 = 0;\n  if (__anneau.tab_client[101].sock != 0) {\n    if (__anneau.tab_client[102].sock != 0)\n      i_4 = 2;\n    else if (__anneau.tab_client[103].sock != 0)\n      i_4 = 4;\n    else if (__anneau.tab_client[104].sock != 0)\n      i_4 = 6;\n    else if (__anneau.tab_client[105].sock != 0)\n      i_4 = 8;\n    else if (__anneau.tab_client[106].sock != 0)\n      i_4 = 10;\n    else if (__anneau.tab_client[107].sock != 0) {\n      if (__anneau.tab_client[108].sock != 0)\n        i_4 = 16;\n      else\n        i_4 = 14;\n    } else\n      i_4 = 12;\n  }\n  server.sin_addr.s_addr = client->sin_addr.s_addr;\n  server.sin_port = i_4;\n  server.sin_family = 0;\n  return (server);\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"int ya_til_des_robots_connectes() {\n    static int i;\n    for (i = 0; i < 6; i++) {\n        if (__anneau->connexion[i] != 0 && __anneau->connexion[i] != __pid) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int ya_til_des_robots_connectes_name_conflict(void) {\n  i_2 = 0;\n  if (__anneau.robot[9] != 0 && __anneau.robot[9] != __pid)\n    return 1;\n  i_2 = 1;\n  if (__anneau.robot[10] != 0 && __anneau.robot[10] != __pid)\n    return 1;\n  i_2 = 2;\n  if (__anneau.robot[11] != 0 && __anneau.robot[11] != __pid)\n    return 1;\n  i_2 = 3;\n  if (__anneau.robot[12] != 0 && __anneau.robot[12] != __pid)\n    return 1;\n  i_2 = 4;\n  if (__anneau.robot[13] != 0 && __anneau.robot[13] != __pid)\n    return 1;\n  i_2 = 5;\n  if (__anneau.robot[14] != 0 && __anneau.robot[14] != __pid)\n    return 1;\n  i_2 = 6;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"int puis_je_prendre_produit() {\n    if ((__anneau->cases[16 - 1]).p.etat == -1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int puis_je_prendre_produit_name_conflict() { return __anneau.produit_a_prendre == -1; }","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":1,"function":"int nb_composants_restants() {\n    static int i, num;\n    for (i = 0 , num = 0; i < 4; i++) {\n        num += stockComposants[i];\n    }\n    return num;\n}\n","function_prediction":"int nb_composants_restants_name_conflict() {\n  static int i = 4;\n  static int num = 0;\n  num = stockComposants[i] + num;\n  return num;\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/server.c"}
{"compilable":0,"function":"static int has(char *array, char val) {\n    static int i;\n    for (i = 0; array[i]; i++) {\n        if (array[i] == val) {\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"int puis_je_prendre_composant() {\n    if (has(bot.mode == NORMAL ? bot.prods : bot.prodsDegrades, (__anneau->cases[bot.pos]).c.num)) {\n        static int i;\n        i = ctoi((__anneau->cases[bot.pos]).c.num) - 1;\n        if (bot.stockComposants[i] < 3) {\n            if (bot.stockComposants[i] == (produits[i].nbComp - 1)) {\n                if (bot.stockProduits[i] == 0) {\n                    return 1;\n                }\n            } else {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"int puis_je_prendre_composant(int i, int j, int k, int l, int m, int n, int o,\n                              int p, int q, int r, int s, int t, int u, int v,\n                              int w, int x, int y, int z) {\n  int i_12;\n  int i_13;\n  int i_14;\n  int i_15;\n  int i_16;\n  int i_17;\n  int i_18;\n  int i_19;\n  int i_20;\n  int i_21;\n  int i_22;\n  int i_23;\n  int i_24;\n  int i_25;\n  int i_26;\n  int i_27;\n  int i_28;\n  int i_29;\n  int i_30;\n  int i_31;\n  int i_32;\n  int i_33;\n  int i_34;\n  int i_35;\n  int i_36;\n  int i_37;\n  int i_38;\n  int i_39;\n  int i_40;\n  int i_41;\n  int i_42;\n  int i_43;\n  int i_44;\n  int i_45;\n  int i_46;\n  int i_47;\n  int i_48;\n  int i_49;\n  int i_50;\n  int i_51;\n  int i_52;\n  int i_53;\n  int i_54;\n  int i_55;\n  int i_56;\n  int i_57;\n  int i_58;\n  int i_59;\n  int i_60;\n  int i_61;\n  int i_62;\n  int i_63;\n  int i_64;\n  int i_65;\n  int i_66;\n  int","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"int puis_je_prendre_produit() {\n    if (bot.mode == NORMAL) {\n        if ((__anneau->cases[bot.pos]).p.etat >= 0) {\n            if (bot.stockProduits[ctoi((__anneau->cases[bot.pos]).p.num) - 1] == 0) {\n                if (has(bot.prods, (__anneau->cases[bot.pos]).p.num)) {\n                    if (bot.ops[0] == (__anneau->cases[bot.pos]).p.ops[(__anneau->cases[bot.pos]).p.etat]) {\n                        return 1;\n                    }\n                }\n            }\n        }\n    } else {\n        if ((__anneau->cases[bot.pos]).p.etat >= 0) {\n            if (bot.stockProduits[ctoi((__anneau->cases[bot.pos]).p.num) - 1] == 0) {\n                if (has(bot.prodsDegrades, (__anneau->cases[bot.pos]).p.num)) {\n                    if (has(bot.ops, (__anneau->cases[bot.pos]).p.ops[(__anneau->cases[bot.pos]).p.etat])) {\n                        return 1;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"int puis_je_prendre_produit_name_conflict(void) {\n  static char s[10];\n  int i, j, k;\n\n  if (__anneau[1].type_anneau == 1) {\n    if (__anneau[1].nb_produit > -1) {\n      sprintf(s, \"%c\", __anneau[1].produit);\n      if (!strtol(s, NULL, 10)) {\n        for (i = 0; __anneau[1].produit_dispo[i] != '\\0'; i++) {\n          if (__anneau[1].produit_dispo[i] == \"1234567890\"[i]) {\n            for (j = 0; __anneau[1]\n                            .produit_dispo[__anneau[1].nb_produit]\n                            .\"[1234567890\"[j] != '\\0';\n                 j++) {\n              if (__anneau[1]\n                      .produit_dispo[__anneau[1].nb_produit]\n                      .\"[1234567890\"[j] == \"1234567890\"[j]) {\n                return 1;\n              }\n            }\n          }\n        }\n      }\n    }\n  } else {\n    if (__anneau[1].nb_produit > -1) {\n      sprintf(s, \"%c\", __anneau[1].produit);\n      if (!strtol(s, NULL, 10)) {\n        for (i = 0; __anneau[1].produit_dispo[i].\"[1234567890\"[i] != '\\0';\n             i++) {\n          if (__anneau[1].produit_dispo[i].\"[1234567890\"[i] ==\n              \"1234567890\"[i]) {\n        for(j=0;__anneau[1].produit_dispo[__anneau[1].nb","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"Composant prendre_composant() {\n    static Composant c;\n    c = (__anneau->cases[bot.pos]).c;\n    (__anneau->cases[bot.pos]).type = VIDE;\n    (__anneau->cases[bot.pos]).c.num = 0;\n    return c;\n}\n","function_prediction":"char prendre_composant_name_conflict() {\n  c_6 = __anneau.composants[10];\n  __anneau.composants[10] = '\\0';\n  __anneau.composants[11] = '\\0';\n  return c_6;\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"Produit prendre_produit() {\n    static Produit p;\n    p = (__anneau->cases[bot.pos]).p;\n    (__anneau->cases[bot.pos]).type = VIDE;\n    (__anneau->cases[bot.pos]).p.num = 0;\n    return p;\n}\n","function_prediction":"produit prendre_produit_name_conflict(int i) {\n  produit p;\n  p.prix = __anneau.produits[i].prix;\n  p.poids = __anneau.produits[i].poids;\n  p.valeur = __anneau.produits[i].valeur;\n  p.volume = __anneau.produits[i].volume;\n  __anneau.produits[i].prix = 0;\n  __anneau.produits[i].poids = 0;\n  __anneau.produits[i].valeur = 0;\n  __anneau.produits[i].volume = 0;\n  return p;\n}","pass":0,"source_file":"C_COMPILE/demsking_SchedulerBot/src/robot.c"}
{"compilable":0,"function":"static int bind_local(uint16_t port) {\n    int fd;\n    struct sockaddr_in servaddr;\n    fd = socket(2, SOCK_STREAM, 0);\n    if (fd < 0) {\n        perror(\"socket\");\n        exit(1);\n    }\n    bzero(&servaddr, sizeof (servaddr));\n    servaddr.sin_family = 2;\n    servaddr.sin_port = htons(port);\n    if (inet_pton(2, \"127.0.0.1\", &servaddr.sin_addr) <= 0) {\n        perror(\"inet_pton\");\n        exit(1);\n    }\n    if (bind(fd, (struct sockaddr *)&servaddr, sizeof (servaddr)) < 0) {\n        perror(\"bind\");\n        exit(1);\n    }\n    if (listen(fd, 128) < 0) {\n        perror(\"listen\");\n        exit(1);\n    }\n    return fd;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/sduzh_snippet/src/net/test_epoll.c"}
{"compilable":0,"function":"static int test_hexdigit(char ch) {\n    if (ch >= '0' && ch <= '9')\n        return ch - '0';\n    if (ch >= 'A' && ch <= 'F')\n        return ch - 'A' + 10;\n    if (ch >= 'a' && ch <= 'f')\n        return ch - 'a' + 10;\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"static int test_readhex(uint8_t *buf, const char *str, int maxbytes) {\n    int i, h, l;\n    for (i = 0; i < maxbytes; i++) {\n        h = test_hexdigit(str[2 * i]);\n        if (h < 0)\n            return i;\n        l = test_hexdigit(str[2 * i + 1]);\n        if (l < 0)\n            return i;\n        buf[i] = (h << 4) + l;\n    }\n    return i;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"int test_sha3() {\n    const char *testvec[][2] = {{\"\", \"6B4E03423667DBB73B6E15454F0EB1ABD4597F9A1B078E3F5B5A6BC7\"}, {\"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\", \"2F1A5F7159E34EA19CDDC70EBF9B81F1A66DB40615D7EAD3CC1F1B954D82A3AF\"}, {\"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F80189D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F33E3FBA850D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\", \"D1C0FA85C8D183BEFF99AD9D752B263E286B477F79F0710B010317017397813344B99DAF3BB7B1BC5E8D722BAC85943A\"}, {\"3A3A819C48EFDE2AD914FBF00E18AB6BC4F14513AB27D0C178A188B61431E7F5623CB66B23346775D386B50E982C493ADBBFC54B9A3CD383382336A1A0B2150A15358F336D03AE18F666C7573D55C4FD181C29E6CCFDE63EA35F0ADF5885CFC0A3D84A2B2E4DD24496DB789E663170CEF74798AA1BBCD4574EA0BBA40489D764B2F83AADC66B148B4A0CD95246C127D5871C4F11418690A5DDF01246A0C80A43C70088B6183639DCFDA4125BD113A8F49EE23ED306FAAC576C3FB0C1E256671D817FC2534A52F5B439F72E424DE376F4C565CCA82307DD9EF76DA5B7C4EB7E085172E328807C02D011FFBF33785378D79DC266F6A5BE6BB0E4A92ECEEBAEB1\", \"6E8B8BD195BDD560689AF2348BDC74AB7CD05ED8B9A57711E9BE71E9726FDA4591FEE12205EDACAF82FFBBAF16DFF9E702A708862080166C2FF6BA379BC7FFC2\"}};\n    int i, fails, msg_len, sha_len;\n    uint8_t sha[64], buf[64], msg[256];\n    fails = 0;\n    for (i = 0; i < 4; i++) {\n        memset(sha, 0, sizeof (sha));\n        memset(buf, 0, sizeof (buf));\n        memset(msg, 0, sizeof (msg));\n        msg_len = test_readhex(msg, testvec[i][0], sizeof (msg));\n        sha_len = test_readhex(sha, testvec[i][1], sizeof (sha));\n        sha3(msg, msg_len, buf, sha_len);\n        if (memcmp(sha, buf, sha_len) != 0) {\n            fprintf(stderr, \"[%d] SHA3-%d, len %d test FAILED.\\n\", i, sha_len * 8, msg_len);\n            fails++;\n        }\n    }\n    return fails;\n}\n","function_prediction":"int test_sha3_name_conflict(void) {\n  int i, j, k, ret = 0;\n  char *test_data[] = {\n      \"\", \"6B4E03423667DBB73B6E15454F0EB1ABD4597F9A1B078E3F5B5A6BC7\",\n      \"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\",\n      \"2F1A5F7159E34EA19CDDC70EBF9B81F1A66DB40615D7EAD3CC1F1B954D82A3AF\"};\n  char *test_hash[] = {\n    \"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F80189\"\n    \"D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F33E3FBA8\"\n    \"50D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\",\n    \"D1C0FA85C8D183BEFF99AD9D752B263E286B477F79F0710B010317017397813344B99DAF3B\"\n    \"B7B1BC5E8D722BAC85943A\",\n","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"int test_shake() {\n    const char *testhex[4] = {\"43E41B45A653F2A5C4492C1ADD544512DDA2529833462B71A41A45BE97290B6F\", \"AB0BAE316339894304E35877B0C28A9B1FD166C796B9CC258A064A8F57E27F2A\", \"44C9FB359FD56AC0A9A75A743CFF6862F17D7259AB075216C0699511643B6439\", \"6A1A9D7846436E4DCA5728B6F760EEF0CA92BF0BE5615E96959D767197A0BEEB\"};\n    int i, j, fails;\n    sha3_ctx_t sha3;\n    uint8_t buf[32], ref[32];\n    fails = 0;\n    for (i = 0; i < 4; i++) {\n        if ((i & 1) == 0) {\n            sha3_init(&sha3, 16);\n        } else {\n            sha3_init(&sha3, 32);\n        }\n        if (i >= 2) {\n            memset(buf, 163, 20);\n            for (j = 0; j < 200; j += 20)\n                sha3_update(&sha3, buf, 20);\n        }\n        shake_xof(&sha3);\n        for (j = 0; j < 512; j += 32)\n            shake_out(&sha3, buf, 32);\n        test_readhex(ref, testhex[i], sizeof (ref));\n        if (memcmp(buf, ref, 32) != 0) {\n            fprintf(stderr, \"[%d] SHAKE%d, len %d test FAILED.\\n\", i, i & 1 ? 256 : 128, i >= 2 ? 1600 : 0);\n            fails++;\n        }\n    }\n    return fails;\n}\n","function_prediction":"int test_shake_name_conflict(void) {\n  int i, j, k, ret = 0;\n  const char *ref[4] = {\n      \"43E41B45A653F2A5C4492C1ADD544512DDA2529833462B71A41A45BE97290B6F\",\n      \"AB0BAE316339894304E35877B0C28A9B1FD166C796B9CC258A064A8F57E27F2A\",\n      \"44C9FB359FD56AC0A9A75A743CFF6862F17D7259AB075216C0699511643B6439\",\n      \"6A1A9D7846436E4DCA5728B6F760EEF0CA92BF0BE5615E96959D767197A0BEEB\"};\n  uint8_t buf[64], ref_buf[64];\n  uint8_t *p = buf;\n  SHAKE_CTX ctx;\n\n  for (i = 0; i < 4; i++) {\n    if (i % 2 == 0)\n      sha3_init(&ctx, 16);\n    else\n      sha3_init(&ctx, 32);\n\n    if (i > 1) {\n      uint8_t msg[20] = {0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,\n                         0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,\n                         0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3};","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/main.c"}
{"compilable":0,"function":"int sha3_init(sha3_ctx_t *c, int mdlen) {\n    int i;\n    for (i = 0; i < 25; i++)\n        c->st.q[i] = 0;\n    c->mdlen = mdlen;\n    c->rsiz = 200 - 2 * mdlen;\n    c->pt = 0;\n    return 1;\n}\n","function_prediction":"int sha3_init_name_conflict(sha3_ctx *c, int bits) {\n  size_t i;\n\n  c->a = 0;\n  c->b = 0;\n  c->outlen = 0;\n  c->inlen = 0;\n  for (i = 0; i < (200 - bits) / 8; i++)\n    c->s[i] = 0;\n  c->bitlen = bits;\n  c->idx = 0;\n  c->remainder = 200 - bits;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/mjosaarinen_tiny_sha3/sha3.c"}
{"compilable":1,"function":"int randomTile(int lowerLim, int upperLim) {\n    return rand() % (upperLim - lowerLim + 1) + lowerLim;\n}\n","function_prediction":"int randomTile_name_conflict(int min, int max) { return rand() % (max - min + 1) + min; }","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int swapTile(char grid[6][6], gridcoord tile, char direction) {\n    gridcoord partnertile;\n    char temp;\n    partnertile.x = tile.x;\n    partnertile.y = tile.y;\n    unsigned long score = 0;\n    gridcoord lmatches[36];\n    gridcoord cmatches[36];\n    int linsertat = 0;\n    int cinsertat = 0;\n    int lengtmt = 0;\n    int crossmt = 0;\n    char prompt_resp;\n    switch (direction) {\n      case 'w':\n      case 'W':\n        partnertile.y = tile.y - 1;\n        break;\n      case 's':\n      case 'S':\n        partnertile.y = tile.y + 1;\n        break;\n      case 'a':\n      case 'A':\n        partnertile.x = tile.x - 1;\n        break;\n      case 'd':\n      case 'D':\n        partnertile.x = tile.x + 1;\n        break;\n      default:\n        printf(\"\\n:( ERROR. Unknown command.\");\n    }\n    temp = grid[tile.y][tile.x];\n    grid[tile.y][tile.x] = grid[partnertile.y][partnertile.x];\n    grid[partnertile.y][partnertile.x] = temp;\n    lengtmt = checkmatches_lengthwise(grid, partnertile, lmatches, &linsertat);\n    crossmt = checkmatches_crosswise(grid, partnertile, cmatches, &cinsertat);\n    if (lengtmt >= 2 || crossmt >= 2) {\n        if (lengtmt >= 2) {\n            score += lengtmt;\n            assasinate(grid, lmatches, lengtmt);\n        }\n        if (crossmt >= 2) {\n            score += crossmt;\n            assasinate(grid, cmatches, crossmt);\n        }\n        grid[partnertile.y][partnertile.x] = '\\x00';\n        score += 1;\n    } else {\n        linsertat = 0;\n        cinsertat = 0;\n        lengtmt = checkmatches_lengthwise(grid, tile, lmatches, &linsertat);\n        crossmt = checkmatches_crosswise(grid, tile, cmatches, &cinsertat);\n        if (lengtmt >= 2 || crossmt >= 2) {\n            if (lengtmt >= 2) {\n                score += lengtmt;\n                assasinate(grid, lmatches, lengtmt);\n            }\n            if (crossmt >= 2) {\n                score += crossmt;\n                assasinate(grid, cmatches, crossmt);\n            }\n            grid[tile.y][tile.x] = '\\x00';\n            score += 1;\n        } else {\n            temp = grid[partnertile.y][partnertile.x];\n            grid[partnertile.y][partnertile.x] = grid[tile.y][tile.x];\n            grid[tile.y][tile.x] = temp;\n        }\n    }\n    return score;\n}\n","function_prediction":"int swapTile_name_conflict(char mat[6][6], struct position pos, char command) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g,\n      h, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1, v1, w1, x1, y1, z1,\n      a1, b1, c1, d1, e1, f1, g1, h1, i2, j2, k2, l2, m2, n2, o2, p2, q2, r2,\n      s2, t2, u2, v2, w2, x2, y2, z2, a2, b2, c2, d2, e2, f2, g2, h2, i3, j3,\n      k3, l3, m3, n3, o3, p3, q3, r3, s3, t3, u3, v3, w3, x3, y3, z3, a3, b3,\n      c3, d3, e3, f3, g3, h3, i4, j4, k4, l4, m4, n4, o4, p4, q4, r4, s4, t4,\n      u4, v4, w4, x4, y4, z4, a4, b4, c4, d4, e4, f4, g4, h4, i5, j5, k5, l5,\n      m5, n5, o5, p5, q5, r5, s5, t5, u5, v5, w5, x5, y5, z5, a5, b5, c5, d5,\n      e5, f5, g5, h5, i6, j6, k6, l6, m6, n6, o6, p6, q6, r6, s6, t6, u6, v6,\n      w6, x6","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int popmatches_universal(char grid[6][6]) {\n    int i = 0;\n    int k = 0;\n    int lengtmt = 0;\n    int crossmt = 0;\n    char gridcopy[6][6];\n    gridcoord lmatches[36];\n    gridcoord cmatches[36];\n    gridcoord tile;\n    int didchangel = 0;\n    int didchangec = 0;\n    int tsambapoints = 0;\n    int linsertat = 0;\n    int cinsertat = 0;\n    copymatrix2d(grid, gridcopy);\n    for (k = 0; k < 6; k++) {\n        for (i = 0; i < 6; i++) {\n            tile.x = i;\n            tile.y = k;\n            lengtmt = checkmatches_lengthwise(gridcopy, tile, lmatches, &linsertat);\n            crossmt = checkmatches_crosswise(gridcopy, tile, cmatches, &cinsertat);\n            if (lengtmt >= 2 || crossmt >= 2) {\n                if (lengtmt >= 2) {\n                    didchangel = 1;\n                    tsambapoints += lengtmt;\n                }\n                if (crossmt >= 2) {\n                    didchangec = 1;\n                    tsambapoints += crossmt;\n                }\n                grid[tile.y][tile.x] = '\\x00';\n                tsambapoints += 1;\n            }\n        }\n    }\n    if (didchangel) {\n        assasinate(gridcopy, lmatches, linsertat);\n        copymatrix2d(gridcopy, grid);\n    }\n    if (didchangec) {\n        assasinate(gridcopy, cmatches, cinsertat);\n        copymatrix2d(gridcopy, grid);\n    }\n    fillGaps(grid);\n    if (didchangec == 1 || didchangel == 1) {\n        return tsambapoints += popmatches_universal(grid);\n    }\n    return tsambapoints;\n}\n","function_prediction":"int popmatches_universal_name_conflict(struct board *board) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e, f, g,\n      h, i1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1, t1, u1, v1, w1, x1, y1, z1,\n      a1, b1, c1, d1, e1, f1, g1, h1, i2, j2, k2, l2, m2, n2, o2, p2, q2, r2,\n      s2, t2, u2, v2, w2, x2, y2, z2, a2, b2, c2, d2, e2, f2, g2, h2, i3, j3,\n      k3, l3, m3, n3, o3, p3, q3, r3, s3, t3, u3, v3, w3, x3, y3, z3, a3, b3,\n      c3, d3, e3, f3, g3, h3, i4, j4, k4, l4, m4, n4, o4, p4, q4, r4, s4, t4,\n      u4, v4, w4, x4, y4, z4, a4, b4, c4, d4, e4, f4, g4, h4, i5, j5, k5, l5,\n      m5, n5, o5, p5, q5, r5, s5, t5, u5, v5, w5, x5, y5, z5, a5, b5, c5, d5,\n      e5, f5, g5, h5, i6, j6, k6, l6, m6, n6, o6, p6, q6, r6, s6, t6, u6, v6,\n      w6, x6, y6, z","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int checkmatches_lengthwise(char grid[6][6], gridcoord lastmoved, gridcoord list[36], int *insertat) {\n    int i = 0;\n    int matches = 0;\n    i = lastmoved.y - 1;\n    while (i >= 0)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[i][lastmoved.x]) {\n                matches += 1;\n                list[*insertat].x = lastmoved.x;\n                list[*insertat].y = i;\n                *insertat += 1;\n            } else\n                break;\n            i--;\n        }\n    i = lastmoved.y + 1;\n    while (i < 6)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[i][lastmoved.x]) {\n                matches += 1;\n                list[*insertat].x = lastmoved.x;\n                list[*insertat].y = i;\n                *insertat += 1;\n            } else\n                break;\n            i++;\n        }\n    return matches;\n}\n","function_prediction":"int checkmatches_lengthwise(char *seq, struct coord coord,\n                            struct match *matches, int *nummatches) {\n  int i, j, k, matchcount;\n\n  matchcount = 0;\n\n  for (i = coord.start - 1, j = coord.end + 1; i >= 0 && j < 6; i--, j++) {\n    if (seq[coord.start + i] == seq[coord.end + j]) {\n      matches[*nummatches].start = coord.start;\n      matches[*nummatches].end = i;\n      (*nummatches)++;\n      matchcount++;\n    } else {\n      break;\n    }\n  }\n\n  for (i = coord.start + 1, j = coord.end - 1; i < 6 && j >= 0; i++, j--) {\n    if (seq[coord.start + i] == seq[coord.end + j]) {\n      matches[*nummatches].start = coord.start;\n      matches[*nummatches].end = i;\n      (*nummatches)++;\n      matchcount++;\n    } else {\n      break;\n    }\n  }\n\n  return matchcount;\n}","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int checkmatches_crosswise(char grid[6][6], gridcoord lastmoved, gridcoord list[36], int *insertat) {\n    int i = 0;\n    int matches = 0;\n    i = lastmoved.x - 1;\n    while (i >= 0)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[lastmoved.y][i]) {\n                matches += 1;\n                list[*insertat].x = i;\n                list[*insertat].y = lastmoved.y;\n                *insertat += 1;\n            } else\n                break;\n            i--;\n        }\n    i = lastmoved.x + 1;\n    while (i < 6)\n        {\n            if (grid[lastmoved.y][lastmoved.x] == grid[lastmoved.y][i]) {\n                matches += 1;\n                list[*insertat].x = i;\n                list[*insertat].y = lastmoved.y;\n                *insertat += 1;\n            } else\n                break;\n            i++;\n        }\n    return matches;\n}\n","function_prediction":"int checkmatches_crosswise(char board[6][6], struct move move,\n                           struct match matches[26], int *nummatches) {\n  int i, matchesfound = 0;\n\n  for (i = move.y - 1; i >= 0; i--) {\n    if (board[move.x][move.y] != board[move.x][i])\n      break;\n    matchesfound++;\n    matches[*nummatches].x = i;\n    matches[*nummatches].y = move.y;\n    (*nummatches)++;\n  }\n\n  for (i = move.y + 1; i < 6; i++) {\n    if (board[move.x][move.y] != board[move.x][i])\n      break;\n    matchesfound++;\n    matches[*nummatches].x = i;\n    matches[*nummatches].y = move.y;\n    (*nummatches)++;\n  }\n\n  return matchesfound;\n}","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int isValid(gridcoord move, char direction) {\n    if (move.x == -1 && move.y == -1 && direction == '0') {\n        return 1;\n    }\n    if (move.x == 0 && (direction == 'a' || direction == 'A')) {\n        printf(\"\\tYou can't move that to the left.\\n\");\n        return 0;\n    }\n    if (move.x == 6 - 1 && (direction == 'd' || direction == 'D')) {\n        printf(\"\\tYou can't move that to the right.\\n\");\n        return 0;\n    }\n    if (move.y == 0 && (direction == 'w' || direction == 'W')) {\n        printf(\"\\tYou can't move that up.\\n\");\n        return 0;\n    }\n    if (move.y == 6 - 1 && (direction == 's' || direction == 'S')) {\n        printf(\"\\tYou can't move that down.\\n\");\n        return 0;\n    }\n    if (move.y < 0 || move.x < 0 || move.y >= 6 || move.x >= 6) {\n        printf(\"\\tI can't find those coordinates. Terminals are dumb, huh?\\n\");\n        return 0;\n    }\n    if (direction != 'a' && direction != 'A' && direction != 's' && direction != 'S' && direction != 'd' && direction != 'D' && direction != 'w' && direction != 'W') {\n        printf(\"\\tWrong Directions. Enter W for UP, A for LEFT, S for DOWN, and D for RIGHT.\\n\");\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"int isValid_name_conflict(struct position p, char d) {\n  if (p.x == -1 && p.y == -1 && d == '0')\n    return 1;\n  else if (p.x == -1 && p.y == -1 && d != '0') {\n    puts(\"\\tI can't find those coordinates. Terminals are dumb, huh?\");\n    return 0;\n  } else if (p.x == 0 && d == 'a') {\n    puts(\"\\tYou can't move that to the left.\");\n    return 0;\n  } else if (p.x == 0 && d == 'w') {\n    puts(\"\\tYou can't move that up.\");\n    return 0;\n  } else if (p.x == 0 && d == 's') {\n    puts(\"\\tYou can't move that down.\");\n    return 0;\n  } else if (p.x == 0 && d == 'd') {\n    puts(\"\\tYou can't move that to the right.\");\n    return 0;\n  } else if (p.x == 5 && d == 'a') {\n    puts(\"\\tYou can't move that to the left.\");\n    return 0;\n  } else if (p.x == 5 && d == 'w') {\n    puts(\"\\tYou can't move that up.\");\n    return 0;\n  } else if (p.x == 5 && d == 's') {\n    puts(\"\\tYou can't move that down.\");\n    return 0;\n  } else if (p.x == 5 && d == 'd') {\n    puts(\"\\tYou can't move that to the right.\");\n    return 0;\n  } else if (p.x > 5 || p.x < 0 || p.y > 5 || p.y < 0) {\n    puts(\"\\tI can't find those coordinates. Terminals are dumb, huh?\");\n    return 0;\n    }\n    else if(d != 'w' &&","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int game() {\n    char grid[6][6];\n    gridcoord target;\n    unsigned long gamescore = 0;\n    char direction;\n    do {\n        populate(grid);\n        popmatches_universal(grid);\n    } while (!trymatches(grid));\n    do {\n        drawGrid(grid, gamescore);\n        do {\n            printf(\"\\n\\tMOVE: \");\n            scanf(\"%d %d %c\", &target.x, &target.y, &direction);\n            target.x -= 1;\n            target.y -= 1;\n            if (target.x == -1 && target.y == -1 && direction == '0') {\n                return gamescore;\n            }\n        } while (!isValid(target, direction));\n        gamescore += swapTile(grid, target, direction);\n        gamescore += popmatches_universal(grid);\n    } while ((target.x != -1 && target.y != -1 && direction != '0') && (trymatches(grid) == 1));\n    return gamescore;\n}\n","function_prediction":"int game_name_conflict() {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  int score = 0;\n  int move[3];\n  char grid[6][6];\n  srand(time(NULL));\n  for (i = 0; i < 6; i++) {\n    for (j = 0; j < 6; j++) {\n      grid[i][j] = (rand() % 4) + 35;\n    }\n  }\n  popmatches_universal(grid);\n  while (trymatches(grid) == 0) {\n    for (i = 0; i < 6; i++) {\n      for (j = 0; j < 6; j++) {\n        grid[i][j] = (rand() % 4) + 35;\n      }\n    }\n    popmatches_universal(grid);\n  }\n  do {\n    drawGrid(grid, score);\n    do {\n      printf(\"\\n\\tMOVE: \");\n      scanf(\"%d %d %c\", &move[0], &move[1], &move[2]);\n      if (move[0] == 0 && move[1] == 0 && move[2] == '0') {\n        return score;\n      }\n    } while (isValid(move) == 0);\n    score += swapTile(grid, move);\n    score += popmatches_universal(grid);\n  } while (move[0] != -1 && move[1] != -1 && move[2] != '0' &&\n           trymatches(grid) == 1);\n  return score;\n}","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int trymatches(char grid[6][6]) {\n    int i = 0;\n    int k = 0;\n    gridcoord tile;\n    char prompt_resp;\n    for (k = 0; k < 6; k++) {\n        for (i = 0; i < 6; i++) {\n            tile.x = i;\n            tile.y = k;\n            if (isValid(tile, 'w')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y - 1][tile.x]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y - 1][tile.x], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y - 1][tile.x], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 's')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y + 1][tile.x]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y + 1][tile.x], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y + 1][tile.x], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 'a')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y][tile.x - 1]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y][tile.x - 1], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y][tile.x - 1], &grid[tile.y][tile.x]);\n            }\n            if (isValid(tile, 'd')) {\n                primitSwapTiles(&grid[tile.y][tile.x], &grid[tile.y][tile.x + 1]);\n                if (areThereMatches(grid, tile)) {\n                    primitSwapTiles(&grid[tile.y][tile.x + 1], &grid[tile.y][tile.x]);\n                    return 1;\n                }\n                primitSwapTiles(&grid[tile.y][tile.x + 1], &grid[tile.y][tile.x]);\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"int trymatches_name_conflict(unsigned short board[6][6]) {\n  int i, j, k, l;\n  unsigned short temp;\n  for (i = 0; i < 6; i++) {\n    for (j = 0; j < 6; j++) {\n      if (i == 0) {\n        puts(\"\\tYou can't move that up.\");\n      }\n      if (i == 5) {\n        puts(\"\\tYou can't move that down.\");\n      }\n      if (j == 0) {\n        puts(\"\\tYou can't move that to the left.\");\n      }\n      if (j == 5) {\n        puts(\"\\tYou can't move that to the right.\");\n      }\n      temp = board[i][j];\n      if (i != 0) {\n        board[i][j] = board[i - 1][j];\n        board[i - 1][j] = temp;\n        if (areThereMatches(board, i - 1, j)) {\n          board[i][j] = board[i - 1][j];\n          board[i - 1][j] = temp;\n          return 1;\n        }\n        board[i - 1][j] = board[i][j];\n        board[i][j] = temp;\n      }\n      if (i != 5) {\n        board[i][j] = board[i + 1][j];\n        board[i + 1][j] = temp;\n        if (areThereMatches(board, i + 1, j)) {\n          board[i][j] = board[i + 1][j];\n          board[i + 1][j] = temp;\n          return 1;\n        }\n        board[i + 1][j] = board[i][j];\n        board[i][j] = temp;\n      }\n      if (j != 0) {\n        board[i][j] = board[i][j - 1];\n        board[i][j - 1] = temp;\n                if (areThereMat","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":0,"function":"int areThereMatches(char grid[6][6], gridcoord tile) {\n    gridcoord dummy[36];\n    int dummyinsertat = 0;\n    if (checkmatches_lengthwise(grid, tile, dummy, &dummyinsertat) >= 2) {\n        return 1;\n    }\n    if (checkmatches_crosswise(grid, tile, dummy, &dummyinsertat) >= 2) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int areThereMatches_name_conflict(char *word1, char *word2) {\n  int matches[26];\n  int num_matches = 0;\n  int length_matches =\n      checkmatches_lengthwise(word1, word2, matches, &num_matches);\n  if (length_matches > 1)\n    return 1;\n  int crosswise_matches =\n      checkmatches_crosswise(word1, word2, matches, &num_matches);\n  if (crosswise_matches > 1)\n    return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/vincentfiestada_cx_tilesmatch/source0.9.3.7.2.c"}
{"compilable":1,"function":"int params_finish(struct params *fsm) {\n    if (fsm->cs == params_error)\n        return -1;\n    if (fsm->cs >= params_first_final)\n        return 1;\n    return 0;\n}\n","function_prediction":"int params_finish_name_conflict(unsigned char *buf) {\n  if (!buf[1032])\n    return -1;\n  if (buf[1032] < 23)\n    return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/brson_ragel-dist/examples/params.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"struct nucleotide_counts count_nucleotides_name_conflict(const char *dna) {\n  size_t len = strlen(dna);\n  struct nucleotide_counts counts = {0};\n\n  for (size_t i = 0; i < len; i++) {\n    switch (dna[i]) {\n    case 'A':\n    case 'a':\n      counts.a++;\n      break;\n    case 'C':\n    case 'c':\n      counts.c++;\n      break;\n    case 'G':\n    case 'g':\n      counts.g++;\n      break;\n    case 'T':\n    case 't':\n      counts.t++;\n      break;\n    case 'U':\n    case 'u':\n      counts.u++;\n      break;\n    default:\n      fprintf(stderr, \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\");\n      goto out;\n    }\n  }\n\nout:\n  return counts;\n}","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"char *transcribe_dna_to_rna_name_conflict(const char *dna) {\n  char *rna = strdup(dna);\n  size_t i, len = strlen(rna);\n\n  for (i = 0; i < len; i++) {\n    if (rna[i] == 'T' || rna[i] == 't') {\n      rna[i] = 'U';\n    }\n  }\n\n  return rna;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"char *get_dna_complement_name_conflict(char *dna) {\n  char *complement = strdup(dna);\n  size_t len = strlen(complement);\n  for (size_t i = 0; i < len; i++) {\n    switch (complement[i]) {\n    case 'A':\n    case 'a':\n      complement[i] = 'T';\n      break;\n    case 'C':\n    case 'c':\n      complement[i] = 'G';\n      break;\n    case 'G':\n    case 'g':\n      complement[i] = 'C';\n      break;\n    case 'T':\n    case 't':\n      complement[i] = 'A';\n      break;\n    default:\n      free(complement);\n      return NULL;\n    }\n  }\n  return complement;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"int hamming_distance_name_conflict(const char *s1, const char *s2) {\n  int i, len, distance;\n\n  len = strlen(s1);\n  if (len != strlen(s2))\n    return -1;\n\n  distance = 0;\n  for (i = 0; i < len; i++)\n    if (s1[i] != s2[i])\n      distance++;\n\n  return distance;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"char *strstrip_name_conflict(char *s) {\n  char *p;\n  size_t len;\n\n  len = strlen(s);\n  if (len == 0)\n    return s;\n\n  p = s + len - 1;\n  while (p >= s && ((*__ctype_b_loc())[(unsigned char)(*p)] & (0x0020)))\n    p--;\n  *++p = '\\0';\n\n  p = s;\n  while (*p && ((*__ctype_b_loc())[(unsigned char)(*p)] & (0x0020)))\n    p++;\n\n  return p;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"char *strrev_name_conflict(char *str) {\n  size_t len = strlen(str);\n  char *rev = calloc(len + 1, sizeof(char));\n  if (rev == NULL)\n    return NULL;\n\n  for (size_t i = 0; i < len; i++)\n    rev[i] = str[len - i - 1];\n\n  return rev;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"struct nucleotide_counts count_nucleotides_name_conflict(const char *dna) {\n  size_t len = strlen(dna);\n  struct nucleotide_counts counts = {0};\n\n  for (size_t i = 0; i < len; i++) {\n    switch (dna[i]) {\n    case 'A':\n    case 'a':\n      counts.a++;\n      break;\n    case 'C':\n    case 'c':\n      counts.c++;\n      break;\n    case 'G':\n    case 'g':\n      counts.g++;\n      break;\n    case 'T':\n    case 't':\n      counts.t++;\n      break;\n    case 'U':\n    case 'u':\n      counts.u++;\n      break;\n    default:\n      fprintf(stderr, \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\");\n      goto out;\n    }\n  }\n\nout:\n  return counts;\n}","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"char *transcribe_dna_to_rna_name_conflict(const char *dna) {\n  char *rna = strdup(dna);\n  size_t i, len = strlen(rna);\n\n  for (i = 0; i < len; i++) {\n    if (rna[i] == 'T' || rna[i] == 't') {\n      rna[i] = 'U';\n    }\n  }\n\n  return rna;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"char *get_dna_complement_name_conflict(char *dna) {\n  char *complement = strdup(dna);\n  size_t len = strlen(complement);\n  for (size_t i = 0; i < len; i++) {\n    switch (complement[i]) {\n    case 'A':\n    case 'a':\n      complement[i] = 'T';\n      break;\n    case 'C':\n    case 'c':\n      complement[i] = 'G';\n      break;\n    case 'G':\n    case 'g':\n      complement[i] = 'C';\n      break;\n    case 'T':\n    case 't':\n      complement[i] = 'A';\n      break;\n    default:\n      free(complement);\n      return NULL;\n    }\n  }\n  return complement;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"int hamming_distance_name_conflict(const char *s1, const char *s2) {\n  int i, len, distance = 0;\n\n  len = strlen(s1);\n  if (len != strlen(s2))\n    return -1;\n\n  for (i = 0; i < len; i++)\n    if (s1[i] != s2[i])\n      distance++;\n\n  return distance;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"char *strstrip_name_conflict(char *s) {\n  char *p;\n  size_t len;\n\n  len = strlen(s);\n  if (len == 0)\n    return s;\n\n  p = s + len - 1;\n  while (p >= s && ((*__ctype_b_loc())[(unsigned char)(*p)] & (0x0020)))\n    p--;\n  *++p = '\\0';\n\n  p = s;\n  while (*p && ((*__ctype_b_loc())[(unsigned char)(*p)] & (0x0020)))\n    p++;\n\n  return p;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"char *strrev_name_conflict(char *str) {\n  size_t len = strlen(str);\n  char *rev = calloc(len + 1, sizeof(char));\n  if (rev == NULL)\n    return NULL;\n\n  for (size_t i = 0; i < len; i++)\n    rev[i] = str[len - i - 1];\n\n  return rev;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"struct nucleotide_counts count_nucleotides(char *nucleic_acid_str) {\n    size_t na_strlen = strlen(nucleic_acid_str);\n    struct nucleotide_counts nt_counts = {0};\n    for (size_t i = 0; i < na_strlen; i++) {\n        switch (nucleic_acid_str[i]) {\n          case 'a':\n          case 'A':\n            nt_counts.A++;\n            break;\n          case 'c':\n          case 'C':\n            nt_counts.C++;\n            break;\n          case 'g':\n          case 'G':\n            nt_counts.G++;\n            break;\n          case 't':\n          case 'T':\n            nt_counts.T++;\n            break;\n          case 'u':\n          case 'U':\n            nt_counts.U++;\n            break;\n          default:\n            fprintf(stderr, \"count_nucleotides(): Unexpected character: '%c'\\n\", nucleic_acid_str[i]);\n            i = na_strlen;\n            break;\n        }\n    }\n    return nt_counts;\n}\n","function_prediction":"struct nucleotide_counts count_nucleotides_name_conflict(const char *dna) {\n  size_t len = strlen(dna);\n  struct nucleotide_counts counts = {0};\n\n  for (size_t i = 0; i < len; i++) {\n    switch (dna[i]) {\n    case 'A':\n    case 'a':\n      counts.a++;\n      break;\n    case 'C':\n    case 'c':\n      counts.c++;\n      break;\n    case 'G':\n    case 'g':\n      counts.g++;\n      break;\n    case 'T':\n    case 't':\n      counts.t++;\n      break;\n    case 'U':\n    case 'u':\n      counts.u++;\n      break;\n    default:\n      fprintf(stderr, \"count_nucleotides_name_conflict(): Unexpected character: '%c'\\n\");\n      goto out;\n    }\n  }\n\nout:\n  return counts;\n}","pass":0,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *transcribe_dna_to_rna(char *dna_str) {\n    char *rna_str = strdup(dna_str);\n    size_t len = strlen(rna_str);\n    for (size_t i = 0; i < len; i++) {\n        if (rna_str[i] == 't' || rna_str[i] == 'T') {\n            rna_str[i] += 1;\n        }\n    }\n    return rna_str;\n}\n","function_prediction":"char *transcribe_dna_to_rna_name_conflict(const char *dna) {\n  char *rna = strdup(dna);\n  size_t i, len = strlen(rna);\n\n  for (i = 0; i < len; i++) {\n    if (rna[i] == 'T' || rna[i] == 't') {\n      rna[i] = 'U';\n    }\n  }\n\n  return rna;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *get_dna_complement(char *dna_str) {\n    char *complement = strdup(dna_str);\n    size_t len = strlen(complement);\n    for (size_t i = 0; i < len; i++) {\n        switch (complement[i]) {\n          case 'a':\n          case 'A':\n            complement[i] = 'T';\n            break;\n          case 't':\n          case 'T':\n            complement[i] = 'A';\n            break;\n          case 'c':\n          case 'C':\n            complement[i] = 'G';\n            break;\n          case 'g':\n          case 'G':\n            complement[i] = 'C';\n            break;\n          default:\n            free(complement);\n            return ((void *)0);\n        }\n    }\n    return complement;\n}\n","function_prediction":"char *get_dna_complement_name_conflict(char *dna) {\n  char *complement = strdup(dna);\n  size_t len = strlen(complement);\n  for (size_t i = 0; i < len; i++) {\n    switch (complement[i]) {\n    case 'A':\n    case 'a':\n      complement[i] = 'T';\n      break;\n    case 'C':\n    case 'c':\n      complement[i] = 'G';\n      break;\n    case 'G':\n    case 'g':\n      complement[i] = 'C';\n      break;\n    case 'T':\n    case 't':\n      complement[i] = 'A';\n      break;\n    default:\n      free(complement);\n      return NULL;\n    }\n  }\n  return complement;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"int64_t hamming_distance(char *s, char *t) {\n    size_t slen = strlen(s);\n    size_t tlen = strlen(t);\n    if (slen != tlen) {\n        return (-1);\n    }\n    int64_t hd = 0;\n    for (size_t i = 0; i < slen; i++) {\n        if (s[i] != t[i]) {\n            hd++;\n        }\n    }\n    return hd;\n}\n","function_prediction":"int hamming_distance_name_conflict(const char *s1, const char *s2) {\n  int i, len, distance = 0;\n\n  len = strlen(s1);\n  if (len != strlen(s2))\n    return -1;\n\n  for (i = 0; i < len; i++)\n    if (s1[i] != s2[i])\n      distance++;\n\n  return distance;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/bioinformatics.c"}
{"compilable":1,"function":"char *strstrip(char *s) {\n    size_t len = strlen(s);\n    if (!len) {\n        return s;\n    }\n    char *end = s + len - 1;\n    while (end >= s && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        {\n            end--;\n        }\n    *(end + 1) = '\\x00';\n    while (*s && ((*__ctype_b_loc())[(int)((*s))] & (unsigned short)_ISspace))\n        {\n            s++;\n        }\n    return s;\n}\n","function_prediction":"char *strstrip_name_conflict(char *s) {\n  char *p;\n  size_t len;\n\n  len = strlen(s);\n  if (len == 0)\n    return s;\n\n  p = s + len - 1;\n  while (p >= s && ((*__ctype_b_loc())[(unsigned char)(*p)] & (0x0020)))\n    p--;\n  *++p = '\\0';\n\n  p = s;\n  while (*p && ((*__ctype_b_loc())[(unsigned char)(*p)] & (0x0020)))\n    p++;\n\n  return p;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":1,"function":"char *strrev(char *s) {\n    size_t s_len = strlen(s);\n    char *buf = calloc(s_len + 1, 1);\n    if (!buf) {\n        return ((void *)0);\n    }\n    for (size_t i = 0; i < s_len; i++) {\n        uint64_t s_index = s_len - 1 - i;\n        buf[i] = s[s_index];\n    }\n    return buf;\n}\n","function_prediction":"char *strrev_name_conflict(char *str) {\n  size_t len = strlen(str);\n  char *rev = calloc(len + 1, sizeof(char));\n  if (rev == NULL)\n    return NULL;\n\n  for (size_t i = 0; i < len; i++)\n    rev[i] = str[len - i - 1];\n\n  return rev;\n}","pass":1,"source_file":"C_COMPILE/process1183_rosalind/string_utils.c"}
{"compilable":0,"function":"char rot13(char character) {\n    if (((*__ctype_b_loc())[(int)((character))] & (unsigned short)_ISalpha)) {\n        char c = character - 'A';\n        return hashmap[(int)c];\n    } else {\n        return character;\n    }\n}\n","function_prediction":"char rot13_name_conflict(char c) {\n  if (__ctype_b_loc()[(unsigned char)c] & 0x04)\n    return \"NOPQRSTUVWXYZABCDEFGHIJKLM      nopqrstuvwxyzabcdefghijklm\"\n        [(unsigned char)c - 'A'];\n  return c;\n}","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char *srot13(char *str) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        str[i] = rot13(str[i]);\n    }\n    return str;\n}\n","function_prediction":"char *srot13_name_conflict(char *s) {\n  int i, len;\n  len = strlen(s);\n  for (i = 0; i < len; i++) {\n    if (__ctype_b_loc()->__mb_cur_max[s[i] & 0xFF] & 0x04)\n      s[i] = \"NOPQRSTUVWXYZABCDEFGHIJKLM      nopqrstuvwxyzabcdefghijklm\"[s[i] -\n                                                                          'A'];\n  }\n  return s;\n}","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char rot13(char character) {\n    if (((*__ctype_b_loc())[(int)((character))] & (unsigned short)_ISalpha)) {\n        char c = character - 'A';\n        return hashmap[(int)c];\n    } else {\n        return character;\n    }\n}\n","function_prediction":"char rot13_name_conflict(char c) {\n  if (__ctype_b_loc()[(unsigned char)c] & 0x04)\n    return \"NOPQRSTUVWXYZABCDEFGHIJKLM      nopqrstuvwxyzabcdefghijklm\"\n        [(unsigned char)c - 'A'];\n  return c;\n}","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char *srot13(char *str) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        str[i] = rot13(str[i]);\n    }\n    return str;\n}\n","function_prediction":"char *srot13_name_conflict(char *s) {\n  int i, len;\n  len = strlen(s);\n  for (i = 0; i < len; i++) {\n    if (__ctype_b_loc()->__mb_cur_max[s[i] & 0xFF] & 0x04)\n      s[i] = \"NOPQRSTUVWXYZABCDEFGHIJKLM      nopqrstuvwxyzabcdefghijklm\"[s[i] -\n                                                                          'A'];\n  }\n  return s;\n}","pass":0,"source_file":"C_COMPILE/dannluciano_ROT13/rot13.c"}
{"compilable":0,"function":"char *s_tolower(char *s) {\n    char *cp;\n    if (s == ((void *)0))\n        return ((void *)0);\n    if (!*s)\n        return s;\n    for (cp = s; (*cp = tolower(*cp)); cp++)\n        ;\n    return s;\n}\n","function_prediction":"char *s_tolower_name_conflict(char *s) {\n  if (s == NULL)\n    return NULL;\n\n  if (*s == '\\0')\n    return s;\n\n  const struct _ctype_t *ct = __ctype_tolower_loc();\n  char *p = s;\n  *p = ct->table[*p];\n  while (*++p)\n    *p = ct->table[*p];\n\n  return s;\n}","pass":0,"source_file":"C_COMPILE/Ilias95_Hunt/src/misc.c"}
{"compilable":1,"function":"int s_tokenize(char *s, char *tokens[], int ntoks, const char *delims) {\n    register int i;\n    if (s == ((void *)0) || tokens == ((void *)0) || delims == ((void *)0) || !*s || !*delims || ntoks < 1)\n        return 0;\n    tokens[0] = strtok(s, delims);\n    if (tokens[0] == ((void *)0))\n        return 0;\n    for (i = 1; i < ntoks && (tokens[i] = strtok(((void *)0), delims)) != ((void *)0); i++)\n        ;\n    return i;\n}\n","function_prediction":"int s_tokenize_name_conflict(char *str, char **tokens, int max_tokens, char *delim) {\n  int i;\n\n  if (tokens == NULL || str == NULL || delim == NULL)\n    return 0;\n\n  if (strlen(str) == 0 || strlen(delim) == 0 || max_tokens <= 0)\n    return 0;\n\n  *tokens = strtok(str, delim);\n\n  for (i = 1; i < max_tokens; i++) {\n    *(tokens + i) = strtok(NULL, delim);\n    if (*(tokens + i) == NULL)\n      break;\n  }\n\n  return i;\n}","pass":0,"source_file":"C_COMPILE/Ilias95_Hunt/src/misc.c"}
{"compilable":0,"function":"static inline size_t SCREEN(size_t x, size_t y) {\n    y = min(y, (terminal.rows - 1));\n    if (between(y, terminal.page.top, terminal.page.bottom)) {\n        return PAGE(x, y - terminal.page.top);\n    } else {\n        return y * terminal.cols + min(x, (terminal.cols - 1));\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"static bool term_flushlines() {\n    size_t row;\n    size_t col_start, col_stop, col_this;\n    struct glyph_t *start, *this;\n    bool retval = 0;\n    wchar_t *buffer = emalloc(terminal.cols * sizeof (*buffer));\n    for (row = 0; row < terminal.rows; row++) {\n        col_start = terminal.dirty[row].left;\n        col_stop = terminal.dirty[row].right;\n        start = terminal.text + SCREEN(col_start, row);\n        for (col_this = col_start , this = start; col_this < col_stop; col_this++ , this++) {\n            buffer[col_this] = this->c;\n            if ((start->c != '\\x00') != (this->c != '\\x00') || start->background != this->background || start->foreground != this->foreground || start->attr != this->attr) {\n                term_flush_section(col_start, row, buffer + col_start, col_this - col_start, start->foreground, start->background, start->attr);\n                col_start = col_this;\n                start = this;\n                retval = 1;\n            }\n        }\n        if (col_stop > col_start) {\n            term_flush_section(col_start, row, buffer + col_start, col_this - col_start, start->foreground, start->background, start->attr);\n            retval = 1;\n        }\n        terminal.dirty[row].left = terminal.dirty[row].right = 0;\n    }\n    free(buffer);\n    return retval;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"size_t term_write(char *utf8s) {\n    size_t n;\n    wchar_t ucs2char;\n    char *utf8s_orig = utf8s;\n    do {\n        if (*utf8s == '\\x00') {\n            break;\n        } else if (term_do_control_char(*utf8s)) {\n            n = 1;\n        } else if ((n = utf8towchar(utf8s, &ucs2char)) > 0) {\n            term_writechar(ucs2char);\n        }\n        utf8s += n;\n    } while (n);\n    return utf8s - utf8s_orig;\n}\n","function_prediction":"void term_writechar(wchar_t c) {\n  if ((((struct term_t *)0x113e7c)->mode == (1)) && c >= 0x0061 && c <= 0x007a)\n    c -= 0x005f;\n\n  fprintf(stderr, \"%-10s (%s:%d): \", \"term_writechar\",\n          \"C_COMPILE\"\n          \"/halhen_terma/src/terminal.c\",\n          661);\n  fprintf(stderr, \"%lc (%02x)\", c, c);\n  fputc('\\n', stderr);\n\n  if ((((struct term_t *)0x113e76)->scroll_mode)) {\n    unsigned int scroll_start = (((struct term_t *)0x113e40)->scroll_start);\n    unsigned int scroll_end = (((struct term_t *)0x113e28)->scroll_end);\n    unsigned int scroll_pos = (((struct term_t *)0x113e28)->scroll_pos);\n    unsigned int scroll_size = (((struct term_t *)0x113e30)->scroll_size);\n    unsigned int scroll_max = (((struct term_t *)0x113e40)->scroll_max);\n    unsigned int scroll_min = (((struct term_t *)0x113e40)->scroll_min);\n    unsigned int scroll_diff = scroll_end - scroll_pos;\n    unsigned int scroll_diff_max = scroll_max - scroll_min;\n    unsigned int scroll_diff_min =\n        scroll_diff_max < scroll_diff ? scroll_diff_max : scroll_diff;\n    unsigned int scroll_diff_min_max =\n        scroll_diff_min < scroll_size ? scroll_diff_min : scroll_size;\n    unsigned int scroll_diff_min_max_max = scroll_diff_min_max + scroll_start;\n  unsigned int scroll_diff_min_max_max_max =\n      scroll_diff_min_max_max < scroll_max ? scroll_diff_min","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"bool term_handle_keypress(KeySym key, uint32_t mod) {\n    size_t i;\n    if (mod & (1 << 3)) {\n        term_cb->write_host(\"\\033\", 1);\n    }\n    if (key == 65293) {\n        if (terminal.crlf) {\n            term_cb->write_host(\"\\r\\n\", 2);\n        } else {\n            term_cb->write_host(\"\\r\", 1);\n        }\n        return 1;\n    }\n    for (i = 0; i < (sizeof (keymap) / sizeof (keymap[0])); i++) {\n        if (keymap[i].key == key && keymap[i].mod == (mod & ~(1 << 3))) {\n            term_cb->write_host(keymap[i].out, strlen(keymap[i].out));\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int term_handle_keypress_name_conflict(unsigned long key, int modifiers) {\n  if (modifiers & 0x08)\n    term_cb->send_string(\"\\x1b[?25l\", 7);\n\n  if (key == 0xFF0D) {\n    if (modifiers == 0x00)\n      term_cb->send_string(\"\\r\\n\", 2);\n    else\n      term_cb->send_string(\"\\r\", 1);\n    return 1;\n  }\n\n  for (int i = 0; i < 90; i++) {\n    if (keymap[i].key == key && keymap[i].modifiers == (modifiers & ~0x08)) {\n      term_cb->send_string(keymap[i].string, strlen(keymap[i].string));\n      return 1;\n    }\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/terminal.c"}
{"compilable":0,"function":"static bool esc_state_csi(char c) {\n    if (between(c, 64, 126)) {\n        esc_csi_dispatch(c);\n        esc_clear();\n        return 1;\n    }\n    if (c == 127) {\n        return 1;\n    }\n    if (c >= 32) {\n        esc_collect(c);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int esc_state_csi_name_conflict(char c) {\n  int i, j, k, p[16];\n  char m, n;\n  int err = 0;\n\n  if (c >= 0x40 && c <= 0x7e) {\n    m = n = 0;\n    for (i = 0; i < 16; i++)\n      p[i] = -1;\n    i = j = 0;\n    if (esc_seq.len == 0) {\n      p[0] = 0;\n      i = 0;\n    }\n    while (esc_seq.len > j) {\n      c = esc_seq.buf[j++];\n      if (isdigit(c)) {\n        i = i * 10 + c - '0';\n      } else if (c == ';') {\n        if (i >= 16) {\n          fprintf(stderr, \"%-10s (%s:%d): \", \"esc_csi_dispatch\",\n                  \"C_COMPILE/halhen_terma/src/escparse.c\", 62);\n          fprintf(stderr, \"Too many parameters: %s\", esc_seq.buf);\n          fputc('\\n', stderr);\n          err = 1;\n          break;\n        }\n        p[i++] = k;\n        k = 0;\n      } else if (c == '<' || c == '=' || c == '>' || c == '?') {\n        if (m) {\n          fprintf(stderr, \"%-10s (%s:%d): \", \"esc_csi_dispatch\",\n                  \"C_COMPILE/halhen_terma/src/escparse.c\", 71);\n          fprintf(stderr, \"Private marker already set %s\", esc_seq.buf);\n          fputc('\\n', stderr);\n          err = 1;\n          break;\n        }\n        m = c;\n      } else if (c == ' ' || c == ';' || c == ':') {\n        if (n) {\n                    fprintf(stderr, \"%-10s (%","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_osc(char c) {\n    if (c == BEL) {\n        esc_clear();\n        return 1;\n    }\n    if (between(c, 0, 31)) {\n        return 1;\n    } else {\n        esc_collect(c);\n        return 1;\n    }\n}\n","function_prediction":"int esc_state_osc_name_conflict(unsigned char c) {\n  if (c == 7) {\n    if (esc_seq.osc_callback)\n      esc_seq.osc_callback();\n    esc_seq.osc_params = 0;\n    esc_seq.osc_param_count = 0;\n    esc_seq.osc_callback = NULL;\n    esc_seq.osc_param_buffer_pos = 0;\n    for (int i = 0; i < 256; i++)\n      esc_seq.osc_param_buffer[i] = 0;\n    return 1;\n  }\n  if (c < 32)\n    return 1;\n  if (esc_seq.osc_param_buffer_pos < 1024)\n    esc_seq.osc_param_buffer[esc_seq.osc_param_buffer_pos++] = c;\n  else {\n    do {\n      fprintf(stderr, \"%-10s (%s:%d): \", \"esc_collect\",\n              \"C_COMPILE/halhen_terma/src/escparse.c\", 25);\n      fputs(\"Buffer full\", stderr);\n      fputc('\\n', stderr);\n    } while (0);\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_wait_for_ST(__attribute__((unused)) char c) {\n    return 1;\n}\n","function_prediction":"bool esc_state_wait_for_ST_name_conflict(esc_state_t *state, uint8_t c) { return true; }","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"bool esc_handle(char c) {\n    if (c == ESC || c == SUB || c == CAN) {\n        esc_clear();\n        if (c == ESC) {\n            esc_seq.state = esc_state_escape;\n        }\n        return 1;\n    }\n    if (esc_seq.state == ((void *)0)) {\n        return 0;\n    }\n    return (*esc_seq.state)(c);\n}\n","function_prediction":"void esc_handle_name_conflict(int c) {\n  if (c == '\\033' || c == '\\025' || c == '\\030') {\n    if (esc_seq.end)\n      esc_seq.end();\n    esc_seq.state = NULL;\n    esc_seq.pos = 0;\n    esc_seq.buf[0] = '\\0';\n    esc_seq.buf_len = 0;\n    esc_seq.end = NULL;\n    if (c == '\\033')\n      esc_seq.state = esc_state_escape;\n  } else if (esc_seq.state) {\n    esc_seq.state(c);\n  }\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static inline wchar_t O(size_t col, size_t row) {\n    oflush();\n    return output.text[oindex(col, row)];\n}\n","function_prediction":"int O_name_conflict(size_t x, size_t y) {\n  term_flush();\n  do {\n    if (!(x < (size_t)80)) {\n      do {\n        __assert_fail(\"x < output.cols\",\n                      \"C_CO_name_conflictMPILE/halhen_terma/test/unit/test_terminal.c\", 27,\n                      \"oindex\");\n      } while (0);\n    }\n  } while (0);\n  do {\n    if (!(y < (size_t)25)) {\n      do {\n        oindex_part_0(x, y);\n      } while (0);\n    }\n  } while (0);\n  return output[y * 80 + x];\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline color_t F(size_t col, size_t row) {\n    oflush();\n    return output.fgs[oindex(col, row)];\n}\n","function_prediction":"void FUN_00102020(void) { PTR_00112ff8(); }","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline color_t B(size_t col, size_t row) {\n    oflush();\n    return output.bgs[oindex(col, row)];\n}\n","function_prediction":"int B_name_conflict(size_t x, size_t y) {\n  term_flush();\n  do {\n    if (!(x < (size_t)10)) {\n      do {\n        __assert_fail(\"x < output.cols\",\n                      \"C_COMPILE/halhen_terma/test/unit/test_terminal.c\", 27,\n                      \"oindex\");\n      } while (0);\n    }\n  } while (0);\n  do {\n    if (!(y < (size_t)10)) {\n      do {\n        oindex_part_0(x, y);\n      } while (0);\n    }\n  } while (0);\n  return output.buffer[y * 10 + x];\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static inline uint32_t A(size_t col, size_t row) {\n    oflush();\n    return output.attrs[oindex(col, row)];\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"bool oisempty() {\n    size_t x, y;\n    for (y = 0; y < output.rows; y++) {\n        for (x = 0; x < output.cols; x++) {\n            if (O(x, y) != L'\\x00') {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"int oisempty_name_conflict(void) {\n  size_t x, y;\n  for (y = 0; y < output.rows; y++) {\n    for (x = 0; x < output.cols; x++) {\n      term_flush();\n      do {\n        if (!(x < output.cols)) {\n          __assert_fail(\"x < output.cols\",\n                        \"C_COMPILE/halhen_terma/test/unit/test_terminal.c\", 27,\n                        \"oindex\");\n        }\n      } while (0);\n      do {\n        if (!(y < output.rows)) {\n          __assert_fail(\"y < output.rows\",\n                        \"C_COMPILE/halhen_terma/test/unit/test_terminal.c\", 28,\n                        \"oindex\");\n        }\n      } while (0);\n      if (output.cells[y * output.cols + x].ch != '\\0') {\n        return 0;\n      }\n    }\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_reset\");\n        char *message = test_reset();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_movement\");\n        char *message = test_movement();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_crlf\");\n        char *message = test_crlf();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_erase_line\");\n        char *message = test_erase_line();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_erase_display\");\n        char *message = test_erase_display();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_newline\");\n        char *message = test_newline();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_control_characters\");\n        char *message = test_control_characters();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_ignored_controls\");\n        char *message = test_ignored_controls();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_statusreport\");\n        char *message = test_statusreport();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_DECALN\");\n        char *message = test_DECALN();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_scrollregion\");\n        char *message = test_scrollregion();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_wraparound\");\n        char *message = test_wraparound();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_editing\");\n        char *message = test_editing();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_repeat\");\n        char *message = test_repeat();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_col_modes\");\n        char *message = test_col_modes();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_style\");\n        char *message = test_style();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_tabstops\");\n        char *message = test_tabstops();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_cursor\");\n        char *message = test_cursor();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"char *run_tests_name_conflict() {\n  printf(\"--> %s\\n\", \"test_reset\");\n  term_write(\"\\x1b[H\");\n  term_resize(80, 24);\n  for (size_t i = 0; i < sizeof(response.text) / sizeof(response.text[0]); i++)\n    response.text[i] = '\\0';\n  term_write(\"abcde\");\n  term_flush();\n  do {\n    tests_checks++;\n    if (!(wcscmp(output.text, L\"abcde\") == 0))\n      return \"C_COMPILE/halhen_terma/test/unit/test_terminal.c\"\n             \"(\"\n             \"154\"\n             \"): \"\n             \"wcscmp(output.text, L\\\"abcde\\\") == 0\"\n             \" \" failed \"; } while (0);\n          term_write(\"\\x1b[H\");\n    term_flush();\n    do {\n      tests_checks++;\n      if (!(oisempty()))\n        return \"C_COMPILE/halhen_terma/test/unit/test_terminal.c\"\n               \"(\"\n               \"157\"\n               \"): \"\n               \"oisempty()\"\n               \" \" failed \"; } while (0);\n            tests_run++;\n      printf(\"--> %s\\n\", \"test_movement\");\n      if (test_movement())\n        return \"test_movement failed\";\n      tests_run++;\n      printf(\"--> %s\\n\", \"test_crlf\");\n      if (test_crlf())\n        return \"test_crlf failed\";\n      tests_run++;\n      printf(\"--> %s\\n\", \"test_erase_line\");\n      if (test_erase_line())\n        return \"test_erase_line failed\";\n      tests_run++;\n      printf(\"--> %s\\n\", \"test_erase_display\");\n      if (test_erase_display())\n        return \"test_erase_display failed\";\n      tests_run++;\n      printf(\"--> %s\\n\", \"test_newline\");\n      if (test_newline())\n        return \"test_newline failed\";\n    tests_run","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_terminal.c"}
{"compilable":0,"function":"static bool esc_state_csi(char c) {\n    if (between(c, 64, 126)) {\n        esc_csi_dispatch(c);\n        esc_clear();\n        return 1;\n    }\n    if (c == 127) {\n        return 1;\n    }\n    if (c >= 32) {\n        esc_collect(c);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int esc_state_csi_name_conflict(char c) {\n  int i, j, k, p[16];\n  char m, n;\n  int err = 0;\n\n  if (c >= 0x40 && c <= 0x7e) {\n    m = n = 0;\n    for (i = 0, j = 0, k = 0; k < 16; k++)\n      p[k] = -1;\n    if (esc_seq.len == 0) {\n      i = 0;\n      p[0] = 0;\n    }\n    for (k = 0; k < esc_seq.len; k++) {\n      if (isdigit(esc_seq.buf[k])) {\n        i = i * 10 + esc_seq.buf[k] - '0';\n      } else if (esc_seq.buf[k] == ';') {\n        if (j < 16) {\n          p[j++] = i;\n          i = 0;\n        } else {\n          fprintf(stderr, \"%-10s (%s:%d): \", \"esc_csi_dispatch\",\n                  \"C_COMPILE/halhen_terma/src/escparse.c\", 62);\n          fprintf(stderr, \"Too many parameters: %s\", esc_seq.buf);\n          fputc('\\n', stderr);\n          err = 1;\n          break;\n        }\n      } else if (esc_seq.buf[k] == '<' || esc_seq.buf[k] == '=' ||\n                 esc_seq.buf[k] == '>' || esc_seq.buf[k] == '?') {\n        if (m == 0) {\n          m = esc_seq.buf[k];\n        } else {\n          fprintf(stderr, \"%-10s (%s:%d): \", \"esc_csi_dispatch\",\n                  \"C_COMPILE/halhen_terma/src/escparse.c\", 71);\n          fprintf(stderr, \"Private marker already set %s\", esc_seq.buf);\n                    fputc('\\n',","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_osc(char c) {\n    if (c == BEL) {\n        esc_clear();\n        return 1;\n    }\n    if (between(c, 0, 31)) {\n        return 1;\n    } else {\n        esc_collect(c);\n        return 1;\n    }\n}\n","function_prediction":"int esc_state_osc_name_conflict(unsigned char c) {\n  if (c == 7) {\n    if (esc_seq.osc_callback)\n      esc_seq.osc_callback();\n    esc_seq.osc_params = 0;\n    esc_seq.osc_param_count = 0;\n    esc_seq.osc_callback = NULL;\n    esc_seq.osc_param_count = 0;\n    for (int i = 0; i < 128; i++)\n      esc_seq.osc_params[i] = 0;\n    esc_seq.osc_param_count = 0;\n  } else if (c >= 32) {\n    if (esc_seq.osc_param_count < 1024)\n      esc_seq.osc_params[esc_seq.osc_param_count++] = c;\n    else {\n      do {\n        fprintf(stderr, \"%-10s (%s:%d): \", \"esc_collect\",\n                \"C_COMPILE/halhen_terma/src/escparse.c\", 25);\n        fputs(\"Buffer full\", stderr);\n        fputc('\\n', stderr);\n      } while (0);\n    }\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"static bool esc_state_wait_for_ST(__attribute__((unused)) char c) {\n    return 1;\n}\n","function_prediction":"bool esc_state_wait_for_ST_name_conflict(esc_state_t *state, uint8_t c) { return true; }","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"bool esc_handle(char c) {\n    if (c == ESC || c == SUB || c == CAN) {\n        esc_clear();\n        if (c == ESC) {\n            esc_seq.state = esc_state_escape;\n        }\n        return 1;\n    }\n    if (esc_seq.state == ((void *)0)) {\n        return 0;\n    }\n    return (*esc_seq.state)(c);\n}\n","function_prediction":"void esc_handle_name_conflict(int c) {\n  if (c == '[' || c == 'O' || c == '[' || c == ']') {\n    if (esc_seq.exit)\n      esc_seq.exit();\n    esc_seq.state = NULL;\n    esc_seq.param = 0;\n    esc_seq.param2 = 0;\n    esc_seq.param3 = 0;\n    esc_seq.param4 = 0;\n    esc_seq.param5 = 0;\n    esc_seq.param6 = 0;\n    esc_seq.param7 = 0;\n    esc_seq.param8 = 0;\n    esc_seq.param9 = 0;\n    esc_seq.param10 = 0;\n    esc_seq.param11 = 0;\n    esc_seq.param12 = 0;\n    esc_seq.param13 = 0;\n    esc_seq.param14 = 0;\n    esc_seq.param15 = 0;\n    esc_seq.param16 = 0;\n    esc_seq.param17 = 0;\n    esc_seq.param18 = 0;\n    esc_seq.param19 = 0;\n    esc_seq.param20 = 0;\n    esc_seq.param21 = 0;\n    esc_seq.param22 = 0;\n    esc_seq.param23 = 0;\n    esc_seq.param24 = 0;\n    esc_seq.param25 = 0;\n    esc_seq.param26 = 0;\n    esc_seq.param27 = 0;\n    esc_seq.param28 = 0;\n    esc_seq.param29 = 0;\n    esc_seq.param30 = 0;\n    esc_seq.param31 = 0;\n    esc_seq.param32 = 0;\n    esc_seq.param33 = 0;\n    esc_seq.param34 = 0;\n    esc_seq.param35 = 0;\n    esc_seq.param36 = 0;\n    esc_seq.param37 = 0;\n    esc_seq.param38 = 0;\n","pass":0,"source_file":"C_COMPILE/halhen_terma/src/escparse.c"}
{"compilable":0,"function":"char *test_dcs() {\n    escbatch(\"\\033P123456789\\033\\\\\");\n    return ((void *)0);\n}\n","function_prediction":"int test_dcs_name_conflict() {\n  char *str = \"\\x1b[?1049h\\x1b[?1000h\\x1b[?1003h\\x1b[?1006h\\x1b[?1015h\\x1b[?\"\n              \"1049l\\x1b[?1000l\\x1b[?1003l\\x1b[?1006l\\x1b[?1015l\";\n  int i = 0;\n  while (str[i] != '\\0') {\n    esc_handle(str[i]);\n    i++;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_escparse.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_anywhere\");\n        char *message = test_anywhere();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi\");\n        char *message = test_csi();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_bad\");\n        char *message = test_csi_bad();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_too_many_params\");\n        char *message = test_csi_too_many_params();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_too_long_param\");\n        char *message = test_csi_too_long_param();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_csi_C0\");\n        char *message = test_csi_C0();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_osc\");\n        char *message = test_osc();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_dcs\");\n        char *message = test_dcs();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"char *run_tests_name_conflict() {\n  printf(\"--> %s\\n\", \"test_anywhere\");\n  esc_handle('\\x14');\n  csi_privflag = '\\0';\n  csi_function = '\\0';\n  esc_intermediate = false;\n  esc_function = '\\0';\n  csi_param[0] = 0;\n  csi_param[1] = 0;\n  csi_param[2] = 0;\n  csi_param[3] = 0;\n  csi_param[4] = 0;\n  csi_param[5] = 0;\n  csi_param[6] = 0;\n  csi_param[7] = 0;\n  csi_param[8] = 0;\n  csi_param[9] = 0;\n  csi_param[10] = 0;\n  csi_param[11] = 0;\n  csi_param[12] = 0;\n  csi_param[13] = 0;\n  csi_param[14] = 0;\n  csi_param[15] = 0;\n  for (char *s = \"A\"; *s; s++) {\n    esc_handle(*s);\n  }\n  tests_run++;\n  do {\n    if (!(csi_function == 'A'))\n      return \"C_COMPILE/halhen_terma/test/unit/test_escparse.c\"\n             \"(\"\n             \"156\"\n             \"): \"\n             \"csi_function == 'A' failed\";\n    tests_checks++;\n  } while (0);\n  do {\n    if (!(csi_param[0] == 0))\n      return \"C_COMPILE/halhen_terma/test/unit/test_escparse.c\"\n             \"(\"\n             \"158\"\n             \"): \"\n             \"csi_param[0] == 0 failed\";\n    tests_checks++;\n  } while (0);\n  do {\n    if (!(csi_privflag == '?'))\n  return \"C_COMPILE/halhen_terma/test/unit/test_escparse.c\"\n         \"(\"\n         \"157\"\n         \"): \"\n         \"csi_privflag","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_escparse.c"}
{"compilable":0,"function":"char *run_tests() {\n    do {\n        printf(\"--> %s\\n\", \"test_utf8toucs2\");\n        char *message = test_utf8toucs2();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    do {\n        printf(\"--> %s\\n\", \"test_helpers\");\n        char *message = test_helpers();\n        tests_run++;\n        if (message)\n            return message;\n    } while (0);\n    return (char *)((void *)0);\n}\n","function_prediction":"char *run_tests_name_conflict() {\n  do {\n    printf(\"--> %s\\n\", \"test_utf8toucs2\");\n    char *message = test_utf8toucs2();\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  do {\n    printf(\"--> %s\\n\", \"test_helpers\");\n    char *message = test_helpers();\n    tests_checks += 11;\n    tests_run++;\n    if (message)\n      return message;\n  } while (0);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/halhen_terma/test/unit/test_util.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"ASTEmpty *ASTEmpty_create_name_conflict() {\n  ASTEmpty *empty = calloc(1, sizeof(ASTEmpty));\n  empty->type = 3;\n  return empty;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"ASTLiteral *ASTLiteral_create_name_conflict(char value) {\n  ASTLiteral *literal = calloc(1, sizeof(ASTLiteral));\n  literal->type = 'L';\n  literal->value = value;\n  return literal;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"ASTEmpty *ASTEmpty_create_name_conflict() {\n  ASTEmpty *empty = calloc(1, sizeof(ASTEmpty));\n  empty->type = 3;\n  return empty;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"ASTLiteral *ASTLiteral_create_name_conflict(char value) {\n  ASTLiteral *literal = calloc(1, sizeof(ASTLiteral));\n  literal->type = 'L';\n  literal->value = value;\n  return literal;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTNode *parse(char *string) {\n    if (strlen(string) == 0)\n        return (ASTNode *)ASTEmpty_create();\n    yycontext yy;\n    memset(&yy, 0, sizeof (yy));\n    yy.ptr = string;\n    while (yyparse(&yy))\n        ;\n    ASTNode *result = yy.root;\n    yyrelease(&yy);\n    return result;\n}\n","function_prediction":"ASTNode *parse_name_conflict(char *input) {\n  int yy_size_of_input;\n  int yy_start;\n  int yy_end;\n  int yy_more_text;\n  int yy_more_start;\n  int yy_more_end;\n  int yy_more_size;\n  int yy_done_more;\n  int yy_accept;\n  int yy_more_status;\n  int yy_c_buf_p;\n  int yy_act;\n  int yy_top_of_stack;\n  int yy_end_of_buffer;\n  int yy_amount_of_matched_text;\n  int yy_old_matched_size;\n  int yy_new_state;\n  int yy_done_saving;\n  int yy_done_saving_1;\n  int yy_done_saving_2;\n  int yy_done_saving_3;\n  int yy_done_saving_4;\n  int yy_done_saving_5;\n  int yy_done_saving_6;\n  int yy_done_saving_7;\n  int yy_done_saving_8;\n  int yy_done_saving_9;\n  int yy_done_saving_10;\n  int yy_done_saving_11;\n  int yy_done_saving_12;\n  int yy_done_saving_13;\n  int yy_done_saving_14;\n  int yy_done_saving_15;\n  int yy_done_saving_16;\n  int yy_done_saving_17;\n  int yy_done_saving_18;\n  int yy_done_saving_19;\n  int yy_done_saving_20;\n  int yy_done_saving_21;\n  int yy_done_saving_22;\n  int yy_done_saving_23","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/parser.c"}
{"compilable":0,"function":"ASTEmpty *ASTEmpty_create() {\n    ASTEmpty *node = calloc(1, sizeof(ASTEmpty));\n    node->node.type = AST_EMPTY;\n    node->node.precedence = 3;\n    return node;\n}\n","function_prediction":"ASTEmpty *ASTEmpty_create_name_conflict() {\n  ASTEmpty *empty = calloc(1, sizeof(ASTEmpty));\n  empty->type = 3;\n  return empty;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTLiteral *ASTLiteral_create(char character) {\n    ASTLiteral *node = calloc(1, sizeof(ASTLiteral));\n    node->node.type = AST_LITERAL;\n    node->node.precedence = 3;\n    node->character = character;\n    return node;\n}\n","function_prediction":"ASTLiteral *ASTLiteral_create_name_conflict(char value) {\n  ASTLiteral *literal = calloc(1, sizeof(ASTLiteral));\n  literal->type = 'L';\n  literal->value = value;\n  return literal;\n}","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/syntax.c"}
{"compilable":0,"function":"ASTNode *parse(char *string) {\n    if (strlen(string) == 0)\n        return (ASTNode *)ASTEmpty_create();\n    yycontext yy;\n    memset(&yy, 0, sizeof (yy));\n    yy.ptr = string;\n    while (yyparse(&yy))\n        ;\n    ASTNode *result = yy.root;\n    yyrelease(&yy);\n    return result;\n}\n","function_prediction":"ASTNode *parse_name_conflict(char *input) {\n  ASTNode *result = NULL;\n  ASTNode *node = NULL;\n  ASTNode *node1 = NULL;\n  ASTNode *node2 = NULL;\n  ASTNode *node3 = NULL;\n  ASTNode *node4 = NULL;\n  ASTNode *node5 = NULL;\n  ASTNode *node6 = NULL;\n  ASTNode *node7 = NULL;\n  ASTNode *node8 = NULL;\n  ASTNode *node9 = NULL;\n  ASTNode *node10 = NULL;\n  ASTNode *node11 = NULL;\n  ASTNode *node12 = NULL;\n  ASTNode *node13 = NULL;\n  ASTNode *node14 = NULL;\n  ASTNode *node15 = NULL;\n  ASTNode *node16 = NULL;\n  ASTNode *node17 = NULL;\n  ASTNode *node18 = NULL;\n  ASTNode *node19 = NULL;\n  ASTNode *node20 = NULL;\n  ASTNode *node21 = NULL;\n  ASTNode *node22 = NULL;\n  ASTNode *node23 = NULL;\n  ASTNode *node24 = NULL;\n  ASTNode *node25 = NULL;\n  ASTNode *node26 = NULL;\n  ASTNode *node27 = NULL;\n  ASTNode *node28 = NULL;\n  ASTNode *node29 = NULL;\n  ASTNode *node30 = NULL;\n  ASTNode *node31 = NULL;\n  ASTNode *node32 = NULL;\n  ASTNode *node33 = NULL;\n  ASTNode *node34 = NULL;\n  ASTNode *node35 = NULL;\n  ASTNode *node36 = NULL;\n  ASTNode *node37 = NULL;\n  ASTNode *node38 = NULL;\n  ASTNode *node39 = NULL;\n  ASTNode *node40 = NULL;\n  ASTNode *node41 =","pass":0,"source_file":"C_COMPILE/txus_libreg/src/reg/parser.c"}
{"compilable":0,"function":"struct dump978_reader *dump978_reader_new(int fd, int nonblock) {\n    struct dump978_reader *reader = calloc(1, sizeof (*reader));\n    if (!reader)\n        return ((void *)0);\n    if (nonblock) {\n        int flags = fcntl(fd, 3);\n        if (flags < 0 || fcntl(fd, 4, flags | 2048) < 0) {\n            int save_errno = (*__errno_location());\n            free(reader);\n            (*__errno_location()) = save_errno;\n            return ((void *)0);\n        }\n    }\n    reader->fd = fd;\n    reader->used = 0;\n    return reader;\n}\n","function_prediction":"dump978_reader_t *dump978_reader_new_name_conflict(int fd, int nonblock) {\n  dump978_reader_t *reader = calloc(1, sizeof(dump978_reader_t));\n  if (!reader)\n    return NULL;\n\n  if (nonblock) {\n    int flags = fcntl(fd, 3);\n    if (flags < 0 || fcntl(fd, 4, flags | 0x800) < 0) {\n      free(reader);\n      return NULL;\n    }\n  }\n\n  reader->fd = fd;\n  reader->state = 0;\n  return reader;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static int hexbyte(char *buf) {\n    int i;\n    char c;\n    c = buf[0];\n    if (c >= '0' && c <= '9')\n        i = (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        i = (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        i = (c - 'A' + 10);\n    else\n        return -1;\n    i <<= 4;\n    c = buf[1];\n    if (c >= '0' && c <= '9')\n        return i | (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        return i | (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        return i | (c - 'A' + 10);\n    else\n        return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static const char *get_fisb_product_name(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 20:\n        return \"METAR and SPECI\";\n      case 1:\n      case 21:\n        return \"TAF and Amended TAF\";\n      case 2:\n      case 22:\n        return \"SIGMET\";\n      case 3:\n      case 23:\n        return \"Convective SIGMET\";\n      case 4:\n      case 24:\n        return \"AIRMET\";\n      case 5:\n      case 25:\n        return \"PIREP\";\n      case 6:\n      case 26:\n        return \"AWW\";\n      case 7:\n      case 27:\n        return \"Winds and Temperatures Aloft\";\n      case 8:\n        return \"NOTAM (Including TFRs) and Service Status\";\n      case 9:\n        return \"Aerodrome and Airspace \\342\\200\\223 D-ATIS\";\n      case 10:\n        return \"Aerodrome and Airspace - TWIP\";\n      case 11:\n        return \"Aerodrome and Airspace - AIRMET\";\n      case 12:\n        return \"Aerodrome and Airspace - SIGMET/Convective SIGMET\";\n      case 13:\n        return \"Aerodrome and Airspace - SUA Status\";\n      case 51:\n        return \"National NEXRAD, Type 0 - 4 level\";\n      case 52:\n        return \"National NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 53:\n        return \"National NEXRAD, Type 2 - 8 level\";\n      case 54:\n        return \"National NEXRAD, Type 3 - 16 level\";\n      case 55:\n        return \"Regional NEXRAD, Type 0 - low dynamic range\";\n      case 56:\n        return \"Regional NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 57:\n        return \"Regional NEXRAD, Type 2 - 8 level\";\n      case 58:\n        return \"Regional NEXRAD, Type 3 - 16 level\";\n      case 59:\n        return \"Individual NEXRAD, Type 0 - low dynamic range\";\n      case 60:\n        return \"Individual NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 61:\n        return \"Individual NEXRAD, Type 2 - 8 level\";\n      case 62:\n        return \"Individual NEXRAD, Type 3 - 16 level\";\n      case 63:\n        return \"Global Block Representation - Regional NEXRAD, Type 4 \\342\\200\\223 8 level\";\n      case 64:\n        return \"Global Block Representation - CONUS NEXRAD, Type 4 - 8 level\";\n      case 81:\n        return \"Radar echo tops graphic, scheme 1: 16-level\";\n      case 82:\n        return \"Radar echo tops graphic, scheme 2: 8-level\";\n      case 83:\n        return \"Storm tops and velocity\";\n      case 101:\n        return \"Lightning strike type 1 (pixel level)\";\n      case 102:\n        return \"Lightning strike type 2 (grid element level)\";\n      case 151:\n        return \"Point phenomena, vector format\";\n      case 201:\n        return \"Surface conditions/winter precipitation graphic\";\n      case 202:\n        return \"Surface weather systems\";\n      case 254:\n        return \"AIRMET, SIGMET: Bitmap encoding\";\n      case 351:\n        return \"System Time\";\n      case 352:\n        return \"Operational Status\";\n      case 353:\n        return \"Ground Station Status\";\n      case 401:\n        return \"Generic Raster Scan Data Product APDU Payload Format Type 1\";\n      case 402:\n      case 411:\n        return \"Generic Textual Data Product APDU Payload Format Type 1\";\n      case 403:\n        return \"Generic Vector Data Product APDU Payload Format Type 1\";\n      case 404:\n      case 412:\n        return \"Generic Symbolic Product APDU Payload Format Type 1\";\n      case 405:\n      case 413:\n        return \"Generic Textual Data Product APDU Payload Format Type 2\";\n      case 600:\n        return \"FISDL Products \\342\\200\\223 Proprietary Encoding\";\n      case 2000:\n        return \"FAA/FIS-B Product 1 \\342\\200\\223 Developmental\";\n      case 2001:\n        return \"FAA/FIS-B Product 2 \\342\\200\\223 Developmental\";\n      case 2002:\n        return \"FAA/FIS-B Product 3 \\342\\200\\223 Developmental\";\n      case 2003:\n        return \"FAA/FIS-B Product 4 \\342\\200\\223 Developmental\";\n      case 2004:\n        return \"WSI Products - Proprietary Encoding\";\n      case 2005:\n        return \"WSI Developmental Products\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":0,"function":"static const char *get_fisb_product_format(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 351:\n      case 352:\n      case 353:\n      case 402:\n      case 405:\n        return \"Text\";\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n        return \"Text/Graphic\";\n      case 20:\n      case 21:\n      case 22:\n      case 23:\n      case 24:\n      case 25:\n      case 26:\n      case 27:\n      case 411:\n      case 413:\n        return \"Text (DLAC)\";\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n      case 58:\n      case 59:\n      case 60:\n      case 61:\n      case 62:\n      case 63:\n      case 64:\n      case 81:\n      case 82:\n      case 83:\n      case 101:\n      case 102:\n      case 151:\n      case 201:\n      case 202:\n      case 254:\n      case 401:\n      case 403:\n      case 404:\n        return \"Graphic\";\n      case 412:\n        return \"Graphic (DLAC)\";\n      case 600:\n      case 2004:\n        return \"Proprietary\";\n      case 2000:\n      case 2001:\n      case 2002:\n      case 2003:\n      case 2005:\n        return \"Developmental\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":0,"function":"static int encode_altitude(int ft) {\n    int i;\n    i = (ft + 1000) / 25;\n    if (i < 0)\n        i = 0;\n    if (i > 2047)\n        i = 2047;\n    return (i & 15) | 16 | ((i & 2032) << 1);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static int encode_ground_speed(int kt) {\n    if (kt > 175)\n        return 124;\n    if (kt > 100)\n        return (kt - 100) / 5 + 108;\n    if (kt > 70)\n        return (kt - 70) / 2 + 93;\n    if (kt > 15)\n        return (kt - 15) + 38;\n    if (kt > 2)\n        return (kt - 2) * 2 + 11;\n    if (kt == 2)\n        return 12;\n    if (kt == 1)\n        return 8;\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static int encode_air_speed(int kt, int supersonic) {\n    int sign;\n    if (kt < 0) {\n        sign = 1024;\n        kt = -kt;\n    } else {\n        sign = 0;\n    }\n    if (supersonic)\n        kt = kt / 4;\n    ++kt;\n    if (kt > 1023)\n        kt = 1023;\n    return kt | sign;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static int encode_vert_rate(int rate) {\n    int sign;\n    if (rate < 0) {\n        sign = 512;\n        rate = -rate;\n    } else {\n        sign = 0;\n    }\n    rate = (rate / 64) + 1;\n    if (rate > 511)\n        rate = 511;\n    return rate | sign;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static uint8_t char_to_ais(int ch) {\n    char *match;\n    if (!ch)\n        return 32;\n    match = strchr(ais_charset, ch);\n    if (match)\n        return (uint8_t)(match - ais_charset);\n    else\n        return 32;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":1,"function":"static unsigned int encodeSquawk(char *squawkStr) {\n    unsigned int squawk = strtoul(squawkStr, ((void *)0), 16);\n    unsigned int encoded = 0;\n    if (squawk & 4096)\n        encoded |= 2048;\n    if (squawk & 8192)\n        encoded |= 512;\n    if (squawk & 16384)\n        encoded |= 128;\n    if (squawk & 256)\n        encoded |= 32;\n    if (squawk & 512)\n        encoded |= 8;\n    if (squawk & 1024)\n        encoded |= 2;\n    if (squawk & 16)\n        encoded |= 4096;\n    if (squawk & 32)\n        encoded |= 1024;\n    if (squawk & 64)\n        encoded |= 256;\n    if (squawk & 1)\n        encoded |= 16;\n    if (squawk & 2)\n        encoded |= 4;\n    if (squawk & 4)\n        encoded |= 1;\n    return encoded;\n}\n","function_prediction":"uint16_t encodeSquawk_name_conflict(const char *squawk) {\n  uint16_t squawk_code = 0;\n  uint16_t squawk_bits = strtoul(squawk, NULL, 16);\n\n  if (squawk_bits & 0x2000) {\n    squawk_code |= 0x200;\n  }\n  if (squawk_bits & 0x4000) {\n    squawk_code |= 0x80;\n  }\n  squawk_code |= (squawk_bits >> 1) & 0x800;\n\n  if (squawk_bits & 0x100) {\n    squawk_code |= 0x20;\n  }\n  if (squawk_bits & 0x200) {\n    squawk_code |= 0x8;\n  }\n  if (squawk_bits & 0x400) {\n    squawk_code |= 0x2;\n  }\n  if (squawk_bits & 0x10) {\n    squawk_code |= 0x1000;\n  }\n  if (squawk_bits & 0x20) {\n    squawk_code |= 0x400;\n  }\n  if (squawk_bits & 0x40) {\n    squawk_code |= 0x100;\n  }\n  if (squawk_bits & 0x1) {\n    squawk_code |= 0x10;\n  }\n  if (squawk_bits & 0x2) {\n    squawk_code |= 0x4;\n  }\n  if (squawk_bits & 0x4) {\n    squawk_code |= 0x1;\n  }\n\n  return squawk_code;\n}","pass":1,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"static uint32_t checksum(uint8_t *message, int n) {\n    uint32_t rem = 0;\n    int i;\n    for (i = 0; i < n; ++i) {\n        rem = (rem << 8) ^ crc_table[message[i] ^ ((rem & 16711680) >> 16)];\n        rem = rem & 16777215;\n    }\n    return rem;\n}\n","function_prediction":"void checksum_and_send_constprop_1(unsigned char *buf) {\n  unsigned int crc;\n  int i;\n\n  crc = crc_table[buf[0]];\n  crc = crc_table[(crc >> 16) ^ buf[1]] ^ (crc << 16);\n  crc = crc_table[(crc >> 16) ^ buf[2]] ^ (crc << 16);\n  crc = crc_table[(crc >> 16) ^ buf[3]] ^ (crc << 16);\n  crc = crc_table[(crc >> 16) ^ buf[4]] ^ (crc << 16);\n  crc = crc_table[(crc >> 16) ^ buf[5]] ^ (crc << 16);\n  crc = crc_table[(crc >> 16) ^ buf[6]] ^ (crc << 16);\n  crc = crc_table[(crc >> 16) ^ buf[7]] ^ (crc << 16);\n  crc = crc_table[(crc >> 16) ^ buf[8]] ^ (crc << 16);\n  crc = crc_table[(crc >> 16) ^ buf[9]] ^ (crc << 16);\n  crc = crc_table[(crc >> 16) ^ buf[10]] ^ (crc << 16);\n  buf[11] = (crc >> 8) & 0xff;\n  buf[12] = (crc >> 0) & 0xff;\n\n  fputc('*', stdout);\n  for (i = 0; i < 14; i++)\n    fprintf(stdout, \"%02X\", buf[i]);\n  fwrite(\"\\r\\n\", 1, 2, stdout);\n  fflush(stdout);\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat2esnt.c"}
{"compilable":0,"function":"struct dump978_reader *dump978_reader_new(int fd, int nonblock) {\n    struct dump978_reader *reader = calloc(1, sizeof (*reader));\n    if (!reader)\n        return ((void *)0);\n    if (nonblock) {\n        int flags = fcntl(fd, 3);\n        if (flags < 0 || fcntl(fd, 4, flags | 2048) < 0) {\n            int save_errno = (*__errno_location());\n            free(reader);\n            (*__errno_location()) = save_errno;\n            return ((void *)0);\n        }\n    }\n    reader->fd = fd;\n    reader->used = 0;\n    return reader;\n}\n","function_prediction":"dump978_reader_t *dump978_reader_new_name_conflict(int fd, int nonblock) {\n  dump978_reader_t *reader = calloc(1, sizeof(dump978_reader_t));\n  if (!reader)\n    return NULL;\n\n  if (nonblock) {\n    int flags = fcntl(fd, 3);\n    if (flags < 0 || fcntl(fd, 4, flags | 0x800) < 0) {\n      free(reader);\n      return NULL;\n    }\n  }\n\n  reader->fd = fd;\n  reader->state = 0;\n  return reader;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static int hexbyte(char *buf) {\n    int i;\n    char c;\n    c = buf[0];\n    if (c >= '0' && c <= '9')\n        i = (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        i = (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        i = (c - 'A' + 10);\n    else\n        return -1;\n    i <<= 4;\n    c = buf[1];\n    if (c >= '0' && c <= '9')\n        return i | (c - '0');\n    else if (c >= 'a' && c <= 'f')\n        return i | (c - 'a' + 10);\n    else if (c >= 'A' && c <= 'F')\n        return i | (c - 'A' + 10);\n    else\n        return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/reader.c"}
{"compilable":0,"function":"static const char *get_fisb_product_name(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 20:\n        return \"METAR and SPECI\";\n      case 1:\n      case 21:\n        return \"TAF and Amended TAF\";\n      case 2:\n      case 22:\n        return \"SIGMET\";\n      case 3:\n      case 23:\n        return \"Convective SIGMET\";\n      case 4:\n      case 24:\n        return \"AIRMET\";\n      case 5:\n      case 25:\n        return \"PIREP\";\n      case 6:\n      case 26:\n        return \"AWW\";\n      case 7:\n      case 27:\n        return \"Winds and Temperatures Aloft\";\n      case 8:\n        return \"NOTAM (Including TFRs) and Service Status\";\n      case 9:\n        return \"Aerodrome and Airspace \\342\\200\\223 D-ATIS\";\n      case 10:\n        return \"Aerodrome and Airspace - TWIP\";\n      case 11:\n        return \"Aerodrome and Airspace - AIRMET\";\n      case 12:\n        return \"Aerodrome and Airspace - SIGMET/Convective SIGMET\";\n      case 13:\n        return \"Aerodrome and Airspace - SUA Status\";\n      case 51:\n        return \"National NEXRAD, Type 0 - 4 level\";\n      case 52:\n        return \"National NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 53:\n        return \"National NEXRAD, Type 2 - 8 level\";\n      case 54:\n        return \"National NEXRAD, Type 3 - 16 level\";\n      case 55:\n        return \"Regional NEXRAD, Type 0 - low dynamic range\";\n      case 56:\n        return \"Regional NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 57:\n        return \"Regional NEXRAD, Type 2 - 8 level\";\n      case 58:\n        return \"Regional NEXRAD, Type 3 - 16 level\";\n      case 59:\n        return \"Individual NEXRAD, Type 0 - low dynamic range\";\n      case 60:\n        return \"Individual NEXRAD, Type 1 - 8 level (quasi 6-level VIP)\";\n      case 61:\n        return \"Individual NEXRAD, Type 2 - 8 level\";\n      case 62:\n        return \"Individual NEXRAD, Type 3 - 16 level\";\n      case 63:\n        return \"Global Block Representation - Regional NEXRAD, Type 4 \\342\\200\\223 8 level\";\n      case 64:\n        return \"Global Block Representation - CONUS NEXRAD, Type 4 - 8 level\";\n      case 81:\n        return \"Radar echo tops graphic, scheme 1: 16-level\";\n      case 82:\n        return \"Radar echo tops graphic, scheme 2: 8-level\";\n      case 83:\n        return \"Storm tops and velocity\";\n      case 101:\n        return \"Lightning strike type 1 (pixel level)\";\n      case 102:\n        return \"Lightning strike type 2 (grid element level)\";\n      case 151:\n        return \"Point phenomena, vector format\";\n      case 201:\n        return \"Surface conditions/winter precipitation graphic\";\n      case 202:\n        return \"Surface weather systems\";\n      case 254:\n        return \"AIRMET, SIGMET: Bitmap encoding\";\n      case 351:\n        return \"System Time\";\n      case 352:\n        return \"Operational Status\";\n      case 353:\n        return \"Ground Station Status\";\n      case 401:\n        return \"Generic Raster Scan Data Product APDU Payload Format Type 1\";\n      case 402:\n      case 411:\n        return \"Generic Textual Data Product APDU Payload Format Type 1\";\n      case 403:\n        return \"Generic Vector Data Product APDU Payload Format Type 1\";\n      case 404:\n      case 412:\n        return \"Generic Symbolic Product APDU Payload Format Type 1\";\n      case 405:\n      case 413:\n        return \"Generic Textual Data Product APDU Payload Format Type 2\";\n      case 600:\n        return \"FISDL Products \\342\\200\\223 Proprietary Encoding\";\n      case 2000:\n        return \"FAA/FIS-B Product 1 \\342\\200\\223 Developmental\";\n      case 2001:\n        return \"FAA/FIS-B Product 2 \\342\\200\\223 Developmental\";\n      case 2002:\n        return \"FAA/FIS-B Product 3 \\342\\200\\223 Developmental\";\n      case 2003:\n        return \"FAA/FIS-B Product 4 \\342\\200\\223 Developmental\";\n      case 2004:\n        return \"WSI Products - Proprietary Encoding\";\n      case 2005:\n        return \"WSI Developmental Products\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":0,"function":"static const char *get_fisb_product_format(uint16_t product_id) {\n    switch (product_id) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 351:\n      case 352:\n      case 353:\n      case 402:\n      case 405:\n        return \"Text\";\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n        return \"Text/Graphic\";\n      case 20:\n      case 21:\n      case 22:\n      case 23:\n      case 24:\n      case 25:\n      case 26:\n      case 27:\n      case 411:\n      case 413:\n        return \"Text (DLAC)\";\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n      case 58:\n      case 59:\n      case 60:\n      case 61:\n      case 62:\n      case 63:\n      case 64:\n      case 81:\n      case 82:\n      case 83:\n      case 101:\n      case 102:\n      case 151:\n      case 201:\n      case 202:\n      case 254:\n      case 401:\n      case 403:\n      case 404:\n        return \"Graphic\";\n      case 412:\n        return \"Graphic (DLAC)\";\n      case 600:\n      case 2004:\n        return \"Proprietary\";\n      case 2000:\n      case 2001:\n      case 2002:\n      case 2003:\n      case 2005:\n        return \"Developmental\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/ssokol_stratux/dump978/uat_decode.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len;\n  unsigned long hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = hash * 257 + word[i];\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 1 + (unsigned int)length;\n  for (hash = 0; length > 0; length--)\n    hash = hash * a + (unsigned int)word[length - 1];\n  hash = hash % 500000000;\n  a = vocab_hash[hash];\n  while (a != -1) {\n    if (!strcmp(word, vocab[a].word))\n      return a;\n    else\n      hash = (hash + 1) % 500000000;\n    a = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  long long len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 500000000;\n  while (vocab_hash[hash] != -1) {\n    hash = (hash + 1) % 500000000;\n  }\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len, hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = (hash << 8) + word[i];\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 0;\n  hash = 0;\n  for (int i = 0; i < length; i++) {\n    hash = hash * 257 + word[i];\n    a = a * 257 + word[i];\n  }\n  hash = hash % 30000000;\n  a = a % 30000000;\n  int hentry = vocab_hash[hash];\n  while (hentry != -1) {\n    if (!strcmp(word, vocab[hentry].word)) {\n      return hentry;\n    }\n    hash = (hash + 1) % 30000000;\n    a = (a + 1) % 30000000;\n    hentry = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  int length = strlen(word) + 1;\n  if (length > 100)\n    length = 100;\n  vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 30000000;\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 30000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/a60814billy_word2vec/word2vec.c"}
{"compilable":0,"function":"int setup() {\n    int i;\n    FILE *test_input = fopen(\"test_input.log\", \"w\");\n    if (!test_input)\n        return 1;\n    for (i = 1; i <= 10; i++)\n        fprintf(test_input, \"this is line %d\\n\", i);\n    fclose(test_input);\n    return 0;\n}\n","function_prediction":"int setup_name_conflict() {\n  FILE *fp = fopen(\"test_input.log\", \"w\");\n  if (!fp)\n    return 1;\n\n  for (int i = 1; i <= 10; i++)\n    fprintf(fp, \"this is line %d\\n\", i);\n\n  fclose(fp);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/test/dbfr_test.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  p = strdup(s);\n  if (p == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"size_t fields_in_line_name_conflict(char *line, char *delim) {\n  size_t count = 0;\n  char *p;\n  size_t delim_len;\n\n  if (line == NULL || delim == NULL)\n    return 0;\n\n  delim_len = strlen(delim);\n  p = line;\n  while ((p = strstr(p, delim)) != NULL) {\n    count++;\n    p += delim_len;\n  }\n\n  return count;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"int get_line_field(char *field, char *line, int field_size, int field_num,\n                   char *delim) {\n  char *p, *q;\n  int i, len;\n\n  if (delim == NULL || *delim == '\\0') {\n    strncpy(field, line, field_size);\n    field[field_size] = '\\0';\n    return strlen(field);\n  }\n\n  len = strlen(delim);\n  p = line;\n  for (i = 0; i < field_num; i++) {\n    p = strstr(p, delim);\n    if (p == NULL) {\n      field[0] = '\\0';\n      return -1;\n    }\n    p += len;\n  }\n\n  q = strstr(p, delim);\n  if (q == NULL) {\n    q = line + strlen(line) - 1;\n    while (*q == '\\n' || *q == '\\r')\n      q--;\n    q++;\n  }\n\n  len = q - p;\n  if (len > field_size - 1)\n    len = field_size - 1;\n  strncpy(field, p, len);\n  field[len] = '\\0';\n  return len;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"int copy_field(char *line, char **field, size_t *field_len, size_t n,\n               const char *delim) {\n  size_t delim_len = strlen(delim);\n  char *end;\n  int i;\n\n  for (i = 0; i < n; i++) {\n    line = strstr(line, delim);\n    if (line == NULL)\n      return -1;\n    line += delim_len;\n  }\n\n  end = strstr(line, delim);\n  if (end == NULL) {\n    end = line + strlen(line);\n    while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n      end--;\n  }\n\n  size_t len = end - line;\n  if (*field == NULL || *field_len < len + 1) {\n    *field = xmalloc(len + 1);\n    *field_len = len + 1;\n  }\n  (*field)[len] = '\\0';\n  strncpy(*field, line, len);\n\n  return end - line;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"char *field_start_name_conflict(char *line, size_t n, const char *delim) {\n  size_t i, delim_len = strlen(delim);\n\n  for (i = 0; i < n - 1; i++) {\n    line = strstr(line, delim);\n    if (line == NULL)\n      return NULL;\n    line += delim_len;\n  }\n\n  return line;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"int mdyhms_datecmp_name_conflict(const char *s1, const char *s2) {\n  if (s1[6] == s2[6] && s1[7] == s2[7] && s1[8] == s2[8] && s1[9] == s2[9])\n    return strcmp(s1, s2);\n  else\n    return strncmp(s1 + 6, s2 + 6, 4);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"int dmyhms_datecmp_name_conflict(const char *s1, const char *s2) {\n  int rc;\n\n  rc = strncmp(s1 + 6, s2 + 6, 4);\n  if (rc)\n    return rc;\n  rc = strncmp(s1 + 3, s2 + 3, 2);\n  if (rc)\n    return rc;\n  return strcmp(s1, s2);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"int expand_nums_name_conflict(const char *nums, int **nums_p, size_t *nums_size) {\n  int i, j, n, n1, n2;\n  char *p, *s;\n\n  if (!nums || !*nums)\n    return 0;\n\n  for (p = (char *)nums; *p; p++)\n    if (!((*(const unsigned short *)(__ctype_b_loc()) +\n           1)[(unsigned char)(*p)] &\n          (1 << 3)) &&\n        *p != ',' && *p != '-')\n      return -2;\n\n  if (!*nums_p && !*nums_size) {\n    *nums_p = xmalloc(16 * sizeof(int));\n    *nums_size = 16;\n  }\n\n  if (strchr(nums, ',') || strchr(nums, '-')) {\n    s = strtok((char *)nums, \",\");\n    for (i = 0; s; s = strtok(NULL, \",\")) {\n      if (i >= *nums_size) {\n        *nums_p = xrealloc(*nums_p, (*nums_size += 16) * sizeof(int));\n        if (!*nums_p)\n          return -1;\n      }\n      if (strchr(s, '-')) {\n        __isoc99_sscanf(s, \"%d-%d\", &n1, &n2);\n        if (i + (n2 - n1) > *nums_size) {\n          *nums_p = xrealloc(*nums_p, (*nums_size += n2 - n1) * sizeof(int));\n          if (!*nums_p)\n            return -1;\n        }\n        for (n = n1; n <= n2; n++)\n          (*nums_p)[i++] = n;\n      } else\n        __isoc99_sscanf(s, \"%d\", &(*nums_p)[i++]);\n    }\n  } else {\n    __is","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"int expand_label_list(const char *label_list, const char *field_list,\n                      const char *field_sep, int **label_array,\n                      size_t *label_array_size) {\n  size_t label_list_len, label_array_len;\n  char *label_list_copy, *label_list_copy_ptr;\n  size_t label_list_copy_len, label_list_copy_pos;\n  int label_array_pos;\n  int error_count;\n\n  label_list_len = strlen(label_list);\n  label_list_copy = xmalloc(label_list_len + 1);\n  label_list_copy_len = 0;\n  label_list_copy_pos = 0;\n  label_list_copy_ptr = label_list_copy;\n  label_array_len = 0;\n\n  for (label_list_pos = 0; label_list_pos < label_list_len + 1;\n       label_list_pos++) {\n    switch (label_list[label_list_pos]) {\n    case ',':\n      *label_list_copy_ptr++ = '\\0';\n      label_list_copy_len++;\n      break;\n    case '\\\\':\n      if (label_list[label_list_pos + 1] == '\\\\' ||\n          label_list[label_list_pos + 1] == ',') {\n        *label_list_copy_ptr++ = label_list[label_list_pos + 1];\n        label_list_pos++;\n      } else {\n        *label_list_copy_ptr++ = '\\\\';\n        *label_list_copy_ptr++ = label_list[label_list_pos + 1];\n        label_list_pos++;\n      }\n      break;\n    default:\n      *label_list_copy_ptr++ = label_list[label_list_pos];\n      break;\n    }\n  }\n\n  if (*label_array == NULL) {\n    *label_array = xmalloc(label_list_copy_len * sizeof(int));\n","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"int get_line_pos_name_conflict(char *buf, int line, char *delim, int *start, int *end) {\n  int i, j, k, len, len_delim;\n  char *p, *q;\n\n  len_delim = strlen(delim);\n\n  p = buf;\n  for (i = 0; i < line + 1; i++) {\n    p = strstr(p, delim);\n    if (p == NULL)\n      goto err;\n    p += len_delim;\n  }\n\n  *start = p - buf;\n\n  q = strstr(p, delim);\n  if (q == NULL) {\n    len = strlen(buf);\n    *end = len - 1;\n    for (i = len - 1; i >= 0; i--) {\n      if (buf[i] != '\\n' && buf[i] != '\\r')\n        break;\n      *end = i;\n    }\n  } else if (q == p) {\n    *end = *start;\n  } else {\n    *end = q - buf - 1;\n  }\n\n  if (*end < *start)\n    return *end - *start + 1;\n\n  if (buf[*start] == '\\n' || buf[*start] == '\\r')\n    return 0;\n\n  if (!strncmp(buf + *start, delim, len_delim))\n    return 0;\n\n  return 1;\n\nerr:\n  *start = -1;\n  *end = -1;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"int field_str_name_conflict(const char *str, const char *field, const char *delim) {\n  char *p, *q, *r;\n  int i, len, delim_len, field_len, str_len;\n\n  if (!str || !field || !*field)\n    return -1;\n\n  if (!delim || !*delim)\n    return !strcmp(str, field) ? 0 : -1;\n\n  len = strlen(str);\n  p = xmalloc(len + 4);\n  field_len = len + 3;\n\n  for (i = 0; *delim; i++) {\n    delim_len = strlen(delim);\n    q = (char *)field;\n    for (r = q; i; i--, r = q) {\n      q = strstr(r, delim);\n      if (!q)\n        goto not_found;\n      q += delim_len;\n    }\n    q = strstr(q, delim);\n    if (!q) {\n      q = (char *)field;\n      str_len = strlen(field);\n      while (q[str_len - 1] == '\\n' || q[str_len - 1] == '\\r')\n        str_len--;\n      q += str_len;\n    }\n    if (q - r > field_len - 1)\n      q = r + field_len - 1;\n    strncpy(p, r, q - r);\n    p[q - r] = '\\0';\n    for (;;) {\n      if (strcmp(p, str) == 0) {\n        free(p);\n        return i;\n      }\n      if (!*delim) {\n        strncpy(p, field, field_len);\n        p[field_len] = '\\0';\n        i++;\n      }\n    }\n  }\n\n  strncpy(p, field, field_len);\n  p[field_len] = '\\0';\n  return strcmp(p, str) == 0 ? 0 : -1;\n\n  not_","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  p = strdup(s);\n  if (p == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"size_t fields_in_line_name_conflict(char *line, char *delim) {\n  size_t count = 0;\n  char *p;\n  size_t delim_len;\n\n  if (line == NULL || delim == NULL)\n    return 0;\n\n  delim_len = strlen(delim);\n  p = line;\n  while ((p = strstr(p, delim)) != NULL) {\n    count++;\n    p += delim_len;\n  }\n\n  return count;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"int get_line_field(char *field, char *line, int field_size, int field_num,\n                   char *delim) {\n  char *p, *q;\n  int i, len;\n\n  if (delim == NULL || *delim == '\\0') {\n    strncpy(field, line, field_size);\n    field[field_size] = '\\0';\n    return strlen(field);\n  }\n\n  len = strlen(delim);\n  p = line;\n  for (i = 0; i < field_num; i++) {\n    p = strstr(p, delim);\n    if (p == NULL) {\n      field[0] = '\\0';\n      return -1;\n    }\n    p += len;\n  }\n\n  q = strstr(p, delim);\n  if (q == NULL) {\n    q = line + strlen(line) - 1;\n    while (*q == '\\n' || *q == '\\r')\n      q--;\n    q++;\n  }\n\n  len = q - p;\n  if (len > field_size - 1)\n    len = field_size - 1;\n  strncpy(field, p, len);\n  field[len] = '\\0';\n  return len;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"int copy_field(char *line, char **field, size_t *field_len, size_t n,\n               const char *delim) {\n  size_t delim_len = strlen(delim);\n  char *p, *q;\n  int i;\n\n  for (i = 0; i < n; i++) {\n    p = strstr(line, delim);\n    if (p == NULL)\n      return -1;\n    line = p + delim_len;\n  }\n\n  p = strstr(line, delim);\n  if (p == NULL) {\n    p = line + strlen(line);\n    while (*--p == '\\n' || *p == '\\r')\n      ;\n    p++;\n  }\n\n  q = *field;\n  i = p - line;\n  if (q == NULL || *field_len == 0 || i + 1 > *field_len) {\n    *field = xmalloc(i + 1);\n    *field_len = i + 1;\n  }\n  (*field)[i] = '\\0';\n  strncpy(*field, line, i);\n\n  return i;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"char *field_start_name_conflict(char *line, size_t n, const char *delim) {\n  size_t i, delim_len = strlen(delim);\n\n  for (i = 0; i < n - 1; i++) {\n    line = strstr(line, delim);\n    if (line == NULL)\n      return NULL;\n    line += delim_len;\n  }\n\n  return line;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"int mdyhms_datecmp_name_conflict(const char *s1, const char *s2) {\n  if (s1[6] == s2[6] && s1[7] == s2[7] && s1[8] == s2[8] && s1[9] == s2[9])\n    return strcmp(s1, s2);\n  else\n    return strncmp(s1 + 6, s2 + 6, 4);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"int dmyhms_datecmp_name_conflict(const char *s1, const char *s2) {\n  int rc;\n\n  rc = strncmp(s1 + 6, s2 + 6, 4);\n  if (rc)\n    return rc;\n  rc = strncmp(s1 + 3, s2 + 3, 2);\n  if (rc)\n    return rc;\n  return strcmp(s1, s2);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"int expand_nums_name_conflict(const char *nums, int **nums_p, size_t *nums_size) {\n  int i, j, n, n1, n2;\n  char *p, *s;\n\n  if (!nums || !*nums)\n    return 0;\n\n  for (p = (char *)nums; *p; p++)\n    if (!((*(const unsigned short *)(__ctype_b_loc()) +\n           1)[(unsigned char)(*p)] &\n          (1 << 3)) &&\n        *p != ',' && *p != '-')\n      return -2;\n\n  if (!*nums_p && !*nums_size) {\n    *nums_p = xmalloc(16 * sizeof(int));\n    *nums_size = 16;\n  }\n\n  if (strchr(nums, ',') || strchr(nums, '-')) {\n    s = strtok((char *)nums, \",\");\n    for (i = 0; s; s = strtok(NULL, \",\")) {\n      if (i >= *nums_size) {\n        *nums_p = xrealloc(*nums_p, (*nums_size += 16) * sizeof(int));\n        if (!*nums_p)\n          return -1;\n      }\n      if (strchr(s, '-')) {\n        __isoc99_sscanf(s, \"%d-%d\", &n1, &n2);\n        if (i + (n2 - n1) > *nums_size) {\n          *nums_p = xrealloc(*nums_p, (*nums_size += n2 - n1) * sizeof(int));\n          if (!*nums_p)\n            return -1;\n        }\n        for (n = n1; n <= n2; n++)\n          (*nums_p)[i++] = n;\n      } else\n        __isoc99_sscanf(s, \"%d\", &(*nums_p)[i++]);\n    }\n  } else {\n    __is","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"int expand_label_list(const char *label_list, const char *field_list,\n                      const char *field_sep, int **label_array,\n                      size_t *label_array_size) {\n  size_t label_list_len = strlen(label_list);\n  char *label_list_copy = xmalloc(label_list_len + 1);\n  size_t label_list_copy_len = 0;\n  size_t label_list_copy_pos = 0;\n  size_t label_list_pos = 0;\n  int error = 0;\n\n  for (label_list_pos = 0; label_list_pos < label_list_len + 1;\n       label_list_pos++) {\n    switch (label_list[label_list_pos]) {\n    case ',':\n      label_list_copy[label_list_copy_pos++] = '\\0';\n      label_list_copy_len++;\n      break;\n    case '\\\\':\n      if (label_list[label_list_pos + 1] == '\\\\' ||\n          label_list[label_list_pos + 1] == ',') {\n        label_list_copy[label_list_copy_pos++] = label_list[label_list_pos + 1];\n        label_list_pos++;\n      } else {\n        label_list_copy[label_list_copy_pos++] = '\\\\';\n        label_list_copy[label_list_copy_pos++] = label_list[label_list_pos + 1];\n        label_list_pos++;\n      }\n      break;\n    case '\\n':\n    case '\\r':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\0':\n    case ' ':\n      label_list_copy[label_list_copy_pos++] = '\\0';\n      label_list_copy_len++;\n      break;\n    default:\n      label_list_copy[label_list_copy_pos++] = label_","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"int get_line_pos_name_conflict(char *buf, int line, char *delim, int *start, int *end) {\n  char *p, *q;\n  int i, len, delim_len;\n\n  delim_len = strlen(delim);\n\n  for (i = 0, p = buf; i < line; i++) {\n    p = strstr(p, delim);\n    if (!p)\n      goto err;\n    p += delim_len;\n  }\n\n  *start = p - buf;\n\n  q = strstr(p, delim);\n  if (q && q != p)\n    *end = q - buf - 1;\n  else {\n    len = strlen(buf);\n    *end = len - 1;\n    while (buf[*end] == '\\n' || buf[*end] == '\\r')\n      (*end)--;\n  }\n\n  if (*start > *end)\n    return 1;\n\n  if (buf[*start] == '\\n' || buf[*start] == '\\r' || buf[*start] == '\\0')\n    return 0;\n\n  if (!strncmp(buf + *start, delim, strlen(delim)))\n    return 0;\n\n  return 1;\n\nerr:\n  *start = *end = -1;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"int field_str_name_conflict(const char *str, const char *field, const char *delim) {\n  char *p, *q, *r;\n  int i, len, delim_len, field_len, str_len;\n\n  if (!str || !field || !*field)\n    return -1;\n\n  if (!delim || !*delim)\n    return !strcmp(str, field) ? 0 : -1;\n\n  len = strlen(str);\n  p = xmalloc(len + 4);\n  field_len = len + 3;\n\n  for (i = 0; *delim; i++) {\n    delim_len = strlen(delim);\n    q = (char *)field;\n    for (r = q; i; i--, r = q) {\n      q = strstr(r, delim);\n      if (!q)\n        goto not_found;\n      q += delim_len;\n    }\n    q = strstr(q, delim);\n    if (!q) {\n      str_len = strlen(field);\n      for (q = field + str_len - 1; *q == '\\n' || *q == '\\r'; q--)\n        ;\n      q++;\n    }\n    str_len = q - r;\n    if (str_len > field_len - 1)\n      str_len = field_len - 1;\n    strncpy(p, r, str_len);\n    p[str_len] = '\\0';\n    if (!strcmp(p, str)) {\n      free(p);\n      return i;\n    }\n  }\n\n  strncpy(p, field, field_len);\n  p[field_len] = '\\0';\n  if (!strcmp(p, str)) {\n    free(p);\n    return i;\n  }\n\nnot_found:\n  free(p);\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  p = strdup(s);\n  if (p == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"size_t fields_in_line(const char *l, const char *d) {\n    char *p = (char *)l;\n    size_t f = 1;\n    size_t dl;\n    if (l == ((void *)0) || d == ((void *)0))\n        return 0;\n    dl = strlen(d);\n    while ((p = strstr(p, d)) != ((void *)0))\n        {\n            f++;\n            p += dl;\n        }\n    return f;\n}\n","function_prediction":"size_t fields_in_line_name_conflict(char *line, char *delim) {\n  size_t count = 0;\n  char *p;\n  size_t delim_len;\n\n  if (line == NULL || delim == NULL)\n    return 0;\n\n  delim_len = strlen(delim);\n  p = line;\n  while ((p = strstr(p, delim)) != NULL) {\n    count++;\n    p += delim_len;\n  }\n\n  return count;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_field(char *dest, const char *line, size_t n, int i, const char *delim) {\n    int field_len;\n    char *fstart, *fend;\n    if (!(delim && delim[0])) {\n        strncpy(dest, line, n);\n        dest[n] = 0;\n        return (strlen(dest));\n    }\n    fstart = field_start(line, i + 1, delim);\n    if (fstart == ((void *)0)) {\n        dest[0] = 0;\n        return -1;\n    }\n    fend = strstr(fstart, delim);\n    if (fend == ((void *)0)) {\n        fend = (char *)line + strlen(line) - 1;\n        while (*fend == '\\n' || *fend == '\\r')\n            fend--;\n        fend++;\n    }\n    field_len = (fend - fstart > n - 1 ? n - 1 : fend - fstart);\n    strncpy(dest, fstart, field_len);\n    dest[field_len] = '\\x00';\n    return field_len;\n}\n","function_prediction":"int get_line_field(char *field, char *line, int field_size, int field_num,\n                   char *delim) {\n  char *p, *q;\n  int i, len;\n\n  if (delim == NULL || *delim == '\\0') {\n    strncpy(field, line, field_size);\n    field[field_size] = '\\0';\n    return strlen(field);\n  }\n\n  len = strlen(delim);\n  p = line;\n  for (i = 0; i < field_num; i++) {\n    p = strstr(p, delim);\n    if (p == NULL) {\n      field[0] = '\\0';\n      return -1;\n    }\n    p += len;\n  }\n\n  q = strstr(p, delim);\n  if (q == NULL) {\n    q = line + strlen(line) - 1;\n    while (*q == '\\n' || *q == '\\r')\n      q--;\n    q++;\n  }\n\n  len = q - p;\n  if (len > field_size - 1)\n    len = field_size - 1;\n  strncpy(field, p, len);\n  field[len] = '\\0';\n  return len;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int copy_field(const char *line, char **dest, size_t *dest_sz, size_t field_no, const char *delim) {\n    int len;\n    char *start, *end;\n    start = field_start(line, field_no + 1, delim);\n    if (!start)\n        return -1;\n    end = strstr(start, delim);\n    if (!end) {\n        end = start + strlen(start);\n        while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n            end--;\n    }\n    len = end - start;\n    if (*dest == ((void *)0) || dest_sz == 0) {\n        *dest = xmalloc(len + 1);\n        *dest_sz = len + 1;\n    } else if (len + 1 > *dest_sz) {\n        *dest = xrealloc(*dest, len + 1);\n        *dest_sz = len + 1;\n    }\n    (*dest)[len] = '\\x00';\n    strncpy(*dest, start, len);\n    return len;\n}\n","function_prediction":"int copy_field(char *line, char **field, size_t *field_len, size_t n,\n               const char *delim) {\n  size_t delim_len = strlen(delim);\n  char *end;\n  int i;\n\n  for (i = 0; i < n; i++) {\n    line = strstr(line, delim);\n    if (line == NULL)\n      return -1;\n    line += delim_len;\n  }\n\n  end = strstr(line, delim);\n  if (end == NULL) {\n    end = line + strlen(line);\n    while (*(end - 1) == '\\n' || *(end - 1) == '\\r')\n      end--;\n  }\n\n  if (*field == NULL || *field_len == 0) {\n    *field = xmalloc(end - line + 1);\n    *field_len = end - line + 1;\n  } else if (*field_len < end - line + 1) {\n    *field = xrealloc(*field, end - line + 1);\n    *field_len = end - line + 1;\n  }\n\n  (*field)[end - line] = '\\0';\n  strncpy(*field, line, end - line);\n\n  return end - line;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *field_start(const char *const line, size_t fn, const char *delim) {\n    int i;\n    char *p = (char *)line;\n    size_t dl = strlen(delim);\n    for (i = 1; i < fn; i++) {\n        p = strstr(p, delim);\n        if (!p)\n            return ((void *)0);\n        p += dl;\n    }\n    return p;\n}\n","function_prediction":"char *field_start_name_conflict(char *line, size_t n, const char *delim) {\n  size_t i, delim_len = strlen(delim);\n\n  for (i = 0; i < n - 1; i++) {\n    line = strstr(line, delim);\n    if (line == NULL)\n      return NULL;\n    line += delim_len;\n  }\n\n  return line;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int mdyhms_datecmp(const char *a, const char *b) {\n    if (!(a[6] - b[6] || a[7] - b[7] || a[8] - b[8] || a[9] - b[9]))\n        return strcmp(a, b);\n    return strncmp(a + 6, b + 6, 4);\n}\n","function_prediction":"int mdyhms_datecmp_name_conflict(const char *s1, const char *s2) {\n  if (s1[6] == s2[6] && s1[7] == s2[7] && s1[8] == s2[8] && s1[9] == s2[9])\n    return strcmp(s1, s2);\n  else\n    return strncmp(s1 + 6, s2 + 6, 4);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int dmyhms_datecmp(const char *a, const char *b) {\n    int cmp;\n    cmp = strncmp(a + 6, b + 6, 4);\n    if (cmp)\n        return cmp;\n    cmp = strncmp(a + 3, b + 3, 2);\n    if (cmp)\n        return cmp;\n    return strcmp(a, b);\n}\n","function_prediction":"int dmyhms_datecmp_name_conflict(const char *s1, const char *s2) {\n  int rc;\n\n  rc = strncmp(s1 + 6, s2 + 6, 4);\n  if (rc)\n    return rc;\n  rc = strncmp(s1 + 3, s2 + 3, 2);\n  if (rc)\n    return rc;\n  return strcmp(s1, s2);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_nums(char *arg, int **array, size_t *array_size) {\n    int i;\n    char *token;\n    if (arg == ((void *)0) || strlen(arg) == 0) {\n        return 0;\n    }\n    for (i = 0; arg[i] != '\\x00'; i++) {\n        if ((!((*__ctype_b_loc())[(int)((arg[i]))] & (unsigned short)_ISdigit)) && arg[i] != ',' && arg[i] != '-') {\n            return -2;\n        }\n    }\n    i = 0;\n    if (*array == ((void *)0) && *array_size == 0) {\n        *array = xmalloc(sizeof(int) * 16);\n        *array_size = 16;\n    }\n    if (strchr(arg, ',') == ((void *)0) && strchr(arg, '-') == ((void *)0)) {\n        sscanf(arg, \"%u\", &((*array)[0]));\n        return 1;\n    }\n    token = strtok(arg, \",\");\n    while (token != ((void *)0))\n        {\n            if (i >= *array_size) {\n                if ((*array_size = arr_resize((void **)array, sizeof(int), *array_size, 16)) == 0) {\n                    return -1;\n                }\n            }\n            if (strchr(token, '-') == ((void *)0)) {\n                sscanf(token, \"%u\", &((*array)[i]));\n                i++;\n            } else {\n                unsigned int i0, i1, ii;\n                sscanf(token, \"%u-%u\", &i0, &i1);\n                if (*array_size < (i + i1 - i0)) {\n                    *array_size = arr_resize((void **)array, sizeof(int), *array_size, i1 - i0);\n                    if (*array_size == 0) {\n                        return -1;\n                    }\n                }\n                for (ii = i0; ii <= i1; ii++) {\n                    (*array)[i++] = ii;\n                }\n            }\n            token = strtok(((void *)0), \",\");\n        }\n    return i;\n}\n","function_prediction":"int expand_nums_name_conflict(const char *nums, int **nums_p, size_t *nums_size) {\n  int i, j, n, n1, n2;\n  char *p, *s;\n\n  if (!nums || !*nums)\n    return 0;\n\n  for (p = (char *)nums; *p; p++)\n    if (!((*(const unsigned short *)(__ctype_b_loc()) +\n           1)[(unsigned char)(*p)] &\n          (1 << 3)) &&\n        *p != ',' && *p != '-')\n      return -2;\n\n  if (!*nums_p && !*nums_size) {\n    *nums_p = xmalloc(16 * sizeof(int));\n    *nums_size = 16;\n  }\n\n  if (strchr(nums, ',') || strchr(nums, '-')) {\n    s = strtok((char *)nums, \",\");\n    for (i = 0; s; s = strtok(NULL, \",\")) {\n      if (i >= *nums_size) {\n        *nums_p = xrealloc(*nums_p, (*nums_size += 16) * sizeof(int));\n        if (!*nums_p)\n          return -1;\n      }\n      if (strchr(s, '-')) {\n        __isoc99_sscanf(s, \"%d-%d\", &n1, &n2);\n        if (i + (n2 - n1) > *nums_size) {\n          *nums_p = xrealloc(*nums_p, (*nums_size += n2 - n1) * sizeof(int));\n          if (!*nums_p)\n            return -1;\n        }\n        for (n = n1; n <= n2; n++)\n          (*nums_p)[i++] = n;\n      } else\n        __isoc99_sscanf(s, \"%d\", &(*nums_p)[i++]);\n    }\n  } else {\n    __is","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t expand_label_list(const char *labels, const char *line, const char *delim, int **array, size_t *array_sz) {\n    int i = 0, j = 0;\n    size_t labels_len = strlen(labels);\n    char *labels_copy = xmalloc(labels_len + 1);\n    size_t tokens = 0;\n    char *pos, *labels_end;\n    while (i < labels_len + 1)\n        {\n            if (labels[i] == '\\x00' || labels[i] == '\\n' || labels[i] == '\\r') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                break;\n            } else if (labels[i] == '\\\\') {\n                if (labels[i + 1] == '\\\\') {\n                    labels_copy[j] = '\\\\';\n                } else if (labels[i + 1] == ',') {\n                    labels_copy[j] = ',';\n                } else {\n                    labels_copy[j++] = labels[i];\n                    labels_copy[j] = labels[i + 1];\n                }\n                i += 2;\n            } else if (labels[i] == ',') {\n                labels_copy[j] = '\\x00';\n                tokens++;\n                i++;\n            } else {\n                labels_copy[j] = labels[i];\n                i++;\n            }\n            j++;\n        }\n    labels_end = labels_copy + j;\n    if (*array == ((void *)0)) {\n        *array = xmalloc(sizeof(int) * tokens);\n        *array_sz = tokens;\n    } else {\n        if (*array_sz < tokens) {\n            *array_sz = arr_resize((void **)array, sizeof(int), *array_sz, tokens - *array_sz);\n            if (*array_sz == 0)\n                return -2;\n        }\n    }\n    {\n        int unfound_labels = 0;\n        j = 0;\n        for (pos = labels_copy; pos != labels_end + 1; pos += strlen(pos) + 1) {\n            i = field_str(pos, line, delim);\n            if (i < 0) {\n                warnx(\"Failed to find field label: %s\", pos);\n                unfound_labels++;\n            }\n            (*array)[j++] = i + 1;\n        }\n        if (unfound_labels)\n            return -1;\n    }\n    free(labels_copy);\n    return j;\n}\n","function_prediction":"int expand_label_list(const char *label_list, const char *field_list,\n                      const char *field_sep, int **label_array,\n                      size_t *label_array_size) {\n  size_t label_list_len, i, j, k, n;\n  char *label_list_copy, *p;\n  int error;\n\n  label_list_len = strlen(label_list);\n  label_list_copy = xmalloc(label_list_len + 1);\n\n  i = j = k = 0;\n  while (i < label_list_len + 1) {\n    if (label_list[i] == '\\\\' && label_list[i + 1] == '\\\\') {\n      label_list_copy[j++] = label_list[i++];\n      label_list_copy[j++] = label_list[i++];\n    } else if (label_list[i] == '\\\\' && label_list[i + 1] == ',') {\n      label_list_copy[j++] = label_list[i++];\n      label_list_copy[j++] = label_list[i++];\n    } else if (label_list[i] == ',') {\n      label_list_copy[j++] = '\\0';\n      k++;\n    } else {\n      label_list_copy[j++] = label_list[i++];\n    }\n  }\n\n  if (*label_array == NULL) {\n    *label_array = xmalloc(k * sizeof(int));\n    *label_array_size = k;\n  } else if (*label_array_size < k) {\n    *label_array = xrealloc(*label_array, k * sizeof(int));\n    *label_array_size = k;\n  }\n\n  error = 0;\n  n = 0;\n  p = label_list_copy;\n  while (p < label_list_copy + j) {\n    i = field_str(p, field_list, field_sep);\n    if (i < 0) {\n                        warnx(\"Failed to","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"int get_line_pos(const char *line, int field_no, const char *d, int *start, int *end) {\n    char *field, *field_end;\n    field = field_start(line, field_no + 1, d);\n    if (field == ((void *)0)) {\n        *start = -1;\n        *end = -1;\n        return -1;\n    }\n    *start = field - line;\n    field_end = strstr(field, d);\n    if (field_end == ((void *)0)) {\n        *end = strlen(line) - 1;\n        while (line[*end] == '\\n' || line[*end] == '\\r')\n            (*end)--;\n        if (*end < *start)\n            *end = *start;\n    } else if (field_end == field) {\n        *end = field_end - line;\n    } else {\n        *end = field_end - line - 1;\n    }\n    if (*start == *end) {\n        if (line[*start] == '\\x00' || line[*start] == '\\n' || line[*start] == '\\r' || strncmp(line + *start, d, strlen(d)) == 0) {\n            return 0;\n        }\n        return 1;\n    } else {\n        return *end - *start + 1;\n    }\n}\n","function_prediction":"int get_line_pos_name_conflict(char *buf, int line, char *delim, int *start, int *end) {\n  int i, j, k, len, len_delim;\n  char *p, *q;\n\n  len_delim = strlen(delim);\n\n  p = buf;\n  for (i = 0; i < line + 1; i++) {\n    p = strstr(p, delim);\n    if (p == NULL)\n      goto err;\n    p += len_delim;\n  }\n\n  *start = p - buf;\n\n  q = strstr(p, delim);\n  if (q == NULL) {\n    len = strlen(buf);\n    *end = len - 1;\n    for (i = len - 1; i >= 0; i--) {\n      if (buf[i] != '\\n' && buf[i] != '\\r')\n        break;\n      *end = i;\n    }\n  } else if (q == p) {\n    *end = *start;\n  } else {\n    *end = q - buf - 1;\n  }\n\n  if (*end < *start)\n    return *end - *start + 1;\n\n  if (buf[*start] == '\\n' || buf[*start] == '\\r')\n    return 0;\n\n  if (!strncmp(buf + *start, delim, len_delim))\n    return 0;\n\n  return 1;\n\nerr:\n  *start = -1;\n  *end = -1;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"ssize_t field_str(const char *value, const char *line, const char *delim) {\n    char *curfield;\n    int max_field_chars;\n    int curfield_len;\n    int i;\n    int found;\n    if (value == ((void *)0))\n        return -2;\n    if (line == ((void *)0) || line[0] == '\\x00')\n        return -1;\n    if (delim == ((void *)0) || delim[0] == '\\x00') {\n        if ((strcmp(value, line) == 0))\n            return 0;\n        return -1;\n    }\n    max_field_chars = strlen(value) + 3;\n    curfield = xmalloc(max_field_chars + 1);\n    i = 0;\n    curfield_len = 0;\n    found = 0;\n    while ((curfield_len = get_line_field(curfield, line, max_field_chars, i, delim)) > -1)\n        {\n            if ((strcmp(curfield, value) == 0)) {\n                found = 1;\n                break;\n            }\n            i++;\n        }\n    free(curfield);\n    if (found)\n        return i;\n    return -1;\n}\n","function_prediction":"int field_str_name_conflict(const char *str, const char *field, const char *delim) {\n  char *p, *q, *r;\n  int i, len, delim_len, field_len, str_len;\n\n  if (!str || !field || !*field)\n    return -1;\n\n  if (!delim || !*delim)\n    return !strcmp(str, field) ? 0 : -1;\n\n  len = strlen(str);\n  p = xmalloc(len + 4);\n  field_len = len + 3;\n\n  for (i = 0; *delim; i++) {\n    delim_len = strlen(delim);\n    q = (char *)field;\n    for (r = q; i; i--, r = q) {\n      q = strstr(r, delim);\n      if (!q)\n        goto not_found;\n      q += delim_len;\n    }\n    q = strstr(q, delim);\n    if (!q) {\n      str_len = strlen(field);\n      for (r = field + str_len - 1; *r == '\\n' || *r == '\\r'; r--)\n        ;\n      q = r + 1;\n    }\n    if ((str_len = q - r) > field_len - 1)\n      str_len = field_len - 1;\n    strncpy(p, r, str_len);\n    p[str_len] = '\\0';\n    for (;;) {\n      if (str_len < 0)\n        goto not_found;\n      if (!strcmp(p, str)) {\n        free(p);\n        return i;\n      }\n      if (!*delim) {\n        strncpy(p, field, field_len);\n        p[field_len] = '\\0';\n        str_len = strlen(p);\n        continue;\n      }\n      break;\n    }\n  }\n  strncpy(p, field, field_len);\n  p[field_len] = '\\0';\n  str_","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/ffutils.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  p = strdup(s);\n  if (p == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  p = strdup(s);\n  if (p == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"char *xstrdup(const char *str) {\n    char *tmp = strdup(str);\n    if (!tmp) {\n        warn(\"xstrdup failed to dup string of length %lu\", strlen(str));\n        exit(1);\n    }\n    return tmp;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p;\n\n  p = strdup(s);\n  if (p == NULL) {\n    warn(\"xstrdup_name_conflict failed to dup string of length %lu\",\n         (unsigned long)strlen(s));\n    exit(1);\n  }\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/general.c"}
{"compilable":0,"function":"int qsort_strcmp(const char **a, const char **b) {\n    return strcmp(*a, *b);\n}\n","function_prediction":"int qsort_strcmp_name_conflict(const void *a, const void *b) {\n  return strcmp(*(const char **)a, *(const char **)b);\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":0,"function":"int qsort_intcmp(const int *a, const int *b) {\n    return *a - *b;\n}\n","function_prediction":"int qsort_intcmp_name_conflict(const void *a, const void *b) { return *(int *)a - *(int *)b; }","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":0,"function":"int qsort_uintcmp(const unsigned int *a, const unsigned int *b) {\n    return *a - *b;\n}\n","function_prediction":"int qsort_uintcmp_name_conflict(const void *a, const void *b) {\n  return *(const uint32_t *)a - *(const uint32_t *)b;\n}","pass":0,"source_file":"C_COMPILE/google_crush-tools/src/libcrush/qsort_helper.c"}
{"compilable":0,"function":"static char *striplower(char *s) {\n    char *p = ((void *)0);\n    for (p = s; p && *p; p++) {\n        if (*p == '/')\n            *p = ',';\n        *p = tolower(*p);\n    }\n    return s;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int get_filepath(char *filepath, size_t len, char *channel, char *file) {\n    if (channel) {\n        if (!snprintf(filepath, len, \"%s/%s\", path, channel))\n            return 0;\n        create_dirtree(filepath);\n        return snprintf(filepath, len, \"%s/%s/%s\", path, channel, file);\n    }\n    return snprintf(filepath, len, \"%s/%s\", path, file);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int open_channel(char *name) {\n    static char infile[256];\n    create_filepath(infile, sizeof (infile), name, \"in\");\n    if (access(infile, 0) == -1)\n        mkfifo(infile, (256 | 128 | 64));\n    return open(infile, 0 | 2048, 0);\n}\n","function_prediction":"int open_channel_name_conflict(char *channel) {\n  char *p;\n  char *q;\n  char *r;\n  char *s;\n  char *t;\n  char *u;\n  char *v;\n  char *w;\n  char *x;\n  char *y;\n  char *z;\n  char *aa;\n  char *ab;\n  char *ac;\n  char *ad;\n  char *ae;\n  char *af;\n  char *ag;\n  char *ah;\n  char *ai;\n  char *aj;\n  char *ak;\n  char *al;\n  char *am;\n  char *an;\n  char *ao;\n  char *ap;\n  char *aq;\n  char *ar;\n  char *as;\n  char *at;\n  char *au;\n  char *av;\n  char *aw;\n  char *ax;\n  char *ay;\n  char *az;\n  char *ba;\n  char *bb;\n  char *bc;\n  char *bd;\n  char *be;\n  char *bf;\n  char *bg;\n  char *bh;\n  char *bi;\n  char *bj;\n  char *bk;\n  char *bl;\n  char *bm;\n  char *bn;\n  char *bo;\n  char *bp;\n  char *bq;\n  char *br;\n  char *bs;\n  char *bt;\n  char *bu;\n  char *bv;\n  char *bw;\n  char *bx;\n  char *by;\n  char *bz;\n  char *ca;\n  char *cb;\n  char *cc;\n  char *cd;\n  char *ce;\n  char *cf;\n  char *cg;\n  char *ch;\n  char *ci;\n  char *cj;\n  char *ck;\n  char *cl;\n  char *cm;\n  char *cn;\n  char *co;\n  char *cp;\n  char *cq;\n  char *cr;\n  char *","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int tcpopen(unsigned short port) {\n    int fd;\n    struct sockaddr_in sin;\n    memset(&sin, 0, sizeof(struct sockaddr_in));\n    struct hostent *hp = gethostbyname(host);\n    if (!hp) {\n        perror(\"plom-ii: cannot retrieve host information\");\n        exit(1);\n    }\n    memcpy(&sin.sin_addr, hp->h_addr_list[0], hp->h_length);\n    sin.sin_family = 2;\n    sin.sin_port = htons(port);\n    if ((fd = socket(2, SOCK_STREAM, 0)) < 0) {\n        perror(\"plom-ii: cannot create socket\");\n        exit(1);\n    }\n    if (connect(fd, (const struct sockaddr *)&sin, sizeof (sin)) < 0) {\n        perror(\"plom-ii: cannot connect to host\");\n        exit(1);\n    }\n    return fd;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static size_t tokenize(char **result, size_t reslen, char *str, char delim) {\n    char *p = ((void *)0), *n = ((void *)0);\n    size_t i;\n    if (!str)\n        return 0;\n    for (n = str; *n == ' '; n++)\n        ;\n    p = n;\n    for (i = 0; *n != 0;) {\n        if (i == reslen)\n            return 0;\n        if (*n == delim) {\n            *n = 0;\n            result[i++] = p;\n            p = ++n;\n        } else\n            n++;\n    }\n    if (i < reslen && p < n && strlen(p))\n        result[i++] = p;\n    return i;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"static int read_line(int fd, size_t res_len, char *buf) {\n    size_t i = 0;\n    char c = 0;\n    do {\n        if (read(fd, &c, sizeof(char)) != sizeof(char))\n            return -1;\n        buf[i++] = c;\n    } while (c != '\\n' && i < res_len);\n    buf[i - 1] = 0;\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/plomlompom_plom-ii/plom-ii.c"}
{"compilable":0,"function":"int Needs_Quote(char *str) {\n    while (*str)\n        {\n            if (!((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISalnum) && strchr(\"-_./\", *str) == ((void *)0))\n                return 1;\n            str++;\n        }\n    return 0;\n}\n","function_prediction":"int Needs_Quote_name_conflict(char *s) {\n  int i;\n  for (i = 0; s[i]; i++)\n    if (!((__ctype_b_loc())->__b[((unsigned char)(s[i]))] & (0x08)))\n      if (strchr(\"-_./\", s[i]) == NULL)\n        return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":0,"function":"char *Get_Label(char *str) {\n    if (((*__ctype_b_loc())[(int)((*buff))] & (unsigned short)_ISspace))\n        return ((void *)0);\n    while (((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISalnum) || strchr(\".$_\", *str))\n        str++;\n    if (*str != ':' || str[1] != '\\x00')\n        return ((void *)0);\n    *str = '\\x00';\n    return buff;\n}\n","function_prediction":"char *Get_Label_name_conflict(char *s) {\n  char *p;\n\n  if (__ctype_b_loc()[(unsigned char)buff[0] & 0377] & 020)\n    return NULL;\n\n  for (;;) {\n    if (__ctype_b_loc()[(unsigned char)*s & 0377] & 010)\n      break;\n    if (strchr(\".$_\", *s) == NULL)\n      break;\n    s++;\n  }\n\n  if (*s == ':' && s[1] == '\\0') {\n    *s = '\\0';\n    return buff;\n  }\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":0,"function":"int Detect_End_Of_Fct(char *buff) {\n    if (strncmp(buff, \"END\", 3) == 0)\n        return 1;\n    {\n        static int i = 0;\n        if (i == 0) {\n            fprintf(stderr, \"warning, Detect_End_Of_Fct() not customizedfor this architecture\\n)\");\n            i++;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int Detect_End_Of_Fct_name_conflict(char *s) {\n  if (s[0] == 'E' && s[1] == 'N' && s[2] == 'D')\n    return 1;\n  if (!i_0) {\n    fputs(\"warning, Detect_End_Of_Fct_name_conflict() not customized\"\n          \"for this architecture\\n)\",\n          stderr);\n    i_0++;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/Ma2Asm/extract_asm.c"}
{"compilable":0,"function":"static int Common_Prefix_Length(char *str1, int l1, char *str2, int l2) {\n    if (l1 < l2)\n        l2 = l1;\n    l1 = 0;\n    while (l1 < l2 && *str1 == *str2)\n        {\n            str1++;\n            str2++;\n            l1++;\n        }\n    return l1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/cpt_string.c"}
{"compilable":1,"function":"int Display_Completion(char *str, int length, int no) {\n    printf(\"match %6d  :<%s> len=%d\\n\", no, str, length);\n    return 1;\n}\n","function_prediction":"int Display_Completion_name_conflict(char *text, int len, int match_no) {\n  printf(\"match %6d  :<%s> len=%d\\n\", match_no, text, len);\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/cpt_string.c"}
{"compilable":0,"function":"static int init_mparams(void) {\n    ;\n    if (mparams.magic == 0) {\n        size_t magic;\n        size_t psize;\n        size_t gsize;\n        psize = sysconf(_SC_PAGESIZE);\n        gsize = (((0) != 0) ? (0) : psize);\n        if ((sizeof(size_t) != sizeof(char *)) || ((~(size_t)0) < (((sizeof(mchunk)) + (((size_t)8U) - ((size_t)1))) & ~(((size_t)8U) - ((size_t)1)))) || (sizeof(int) < 4) || (((size_t)8U) < (size_t)8U) || ((((size_t)8U) & (((size_t)8U) - ((size_t)1))) != 0) || (((sizeof(mchunk)) & ((sizeof(mchunk)) - ((size_t)1))) != 0) || ((gsize & (gsize - ((size_t)1))) != 0) || ((psize & (psize - ((size_t)1))) != 0))\n            abort();\n        mparams.granularity = gsize;\n        mparams.page_size = psize;\n        mparams.mmap_threshold = ((size_t)256U * (size_t)1024U);\n        mparams.trim_threshold = ((size_t)2U * (size_t)1024U * (size_t)1024U);\n        mparams.default_mflags = (0U) | (((size_t)1));\n        (&_gm_)->mflags = mparams.default_mflags;\n        (void)(0);\n        {\n            magic = (size_t)(time(0) ^ (size_t)1431655765U);\n            magic |= (size_t)8U;\n            magic &= ~(size_t)7U;\n            (*(volatile size_t *)(&(mparams.magic))) = magic;\n        }\n    }\n    ;\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"static int change_mparam(int param_number, int value) {\n    size_t val;\n    (void)(mparams.magic != 0 || init_mparams());\n    val = (value == -1) ? (~(size_t)0) : (size_t)value;\n    switch (param_number) {\n      case (-1):\n        mparams.trim_threshold = val;\n        return 1;\n      case (-2):\n        if (val >= mparams.page_size && ((val & (val - 1)) == 0)) {\n            mparams.granularity = val;\n            return 1;\n        } else\n            return 0;\n      case (-3):\n        mparams.mmap_threshold = val;\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"int malloc_trim(size_t pad) {\n    int result = 0;\n    (void)(mparams.magic != 0 || init_mparams());\n    if (!(0)) {\n        result = sys_trim((&_gm_), pad);\n        ;\n    }\n    return result;\n}\n","function_prediction":"void malloc_trim_cold(void) { abort(); }","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_footprint(void) {\n    return (&_gm_)->footprint;\n}\n","function_prediction":"size_t malloc_footprint_name_conflict(void) { return 1024; }","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_max_footprint(void) {\n    return (&_gm_)->max_footprint;\n}\n","function_prediction":"size_t malloc_max_footprint_name_conflict(void) { return 1024 * 1024 * 1024; }","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"size_t malloc_footprint_limit(void) {\n    size_t maf = (&_gm_)->footprint_limit;\n    return maf == 0 ? (~(size_t)0) : maf;\n}\n","function_prediction":"size_t malloc_footprint_limit_name_conflict(void) {\n  return (size_t)1024 * 1024 * 1024 * 1024;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"size_t malloc_set_footprint_limit(size_t bytes) {\n    size_t result;\n    if (bytes == 0)\n        result = (((1) + (mparams.granularity - ((size_t)1))) & ~(mparams.granularity - ((size_t)1)));\n    if (bytes == (~(size_t)0))\n        result = 0;\n    else\n        result = (((bytes) + (mparams.granularity - ((size_t)1))) & ~(mparams.granularity - ((size_t)1)));\n    return (&_gm_)->footprint_limit = result;\n}\n","function_prediction":"void malloc_set_footprint_limit_name_conflict(size_t limit) {\n  static size_t page_size = 0;\n  if (page_size == 0) {\n    page_size = sysconf(_SC_PAGESIZE);\n  }\n\n  if (limit == (size_t)-1) {\n    limit = (size_t)-1;\n  } else {\n    limit = (limit + page_size - 1) & ~(page_size - 1);\n  }\n\n  malloc_state_t *state = &global_state;\n  state->footprint_limit = limit;\n}","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"struct mallinfo mallinfo(void) {\n    return internal_mallinfo((&_gm_));\n}\n","function_prediction":"void mallinfo_cold(void) { abort(); }","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":0,"function":"int mallopt(int param_number, int value) {\n    return change_mparam(param_number, value);\n}\n","function_prediction":"void mallopt_cold(void) { abort(); }","pass":0,"source_file":"C_COMPILE/maandree_gprolog/src/EnginePl/dl_malloc.c"}
{"compilable":1,"function":"char *format_date_r(char *buf) {\n    struct tm *l;\n    time_t t = time(((void *)0));\n    l = localtime(&t);\n    sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", l->tm_mon + 1, l->tm_mday, l->tm_year + 1900, l->tm_hour, l->tm_min, l->tm_sec);\n    return buf;\n}\n","function_prediction":"char *format_date_r_name_conflict(char *buf) {\n  time_t t = time(NULL);\n  struct tm *tm = localtime(&t);\n  sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", tm->tm_mon + 1, tm->tm_mday,\n          tm->tm_year + 1900, tm->tm_hour, tm->tm_min, tm->tm_sec);\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/aleksey200505_dspam/src/error.c"}
{"compilable":0,"function":"char *format_date_r(char *buf) {\n    struct tm *l;\n    time_t t = time(((void *)0));\n    l = localtime(&t);\n    sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", l->tm_mon + 1, l->tm_mday, l->tm_year + 1900, l->tm_hour, l->tm_min, l->tm_sec);\n    return buf;\n}\n","function_prediction":"char *format_date_r_name_conflict(char *buf) {\n  time_t t = time(NULL);\n  struct tm *tm = localtime(&t);\n  sprintf(buf, \"%02d/%02d/%04d %02d:%02d:%02d\", tm->tm_mon + 1, tm->tm_mday,\n          tm->tm_year + 1900, tm->tm_hour, tm->tm_min, tm->tm_sec);\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/error.c"}
{"compilable":0,"function":"char *strtok_r(char *s1, const char *s2, char **lasts) {\n    char *ret;\n    if (s1 == ((void *)0))\n        s1 = *lasts;\n    while (*s1 && strchr(s2, *s1))\n        ++s1;\n    if (*s1 == '\\x00')\n        return ((void *)0);\n    ret = s1;\n    while (*s1 && !strchr(s2, *s1))\n        ++s1;\n    if (*s1)\n        *s1++ = '\\x00';\n    *lasts = s1;\n    return ret;\n}\n","function_prediction":"char *strtok_r_name_conflict(char *s, const char *delim, char **lasts) {\n  char *token;\n\n  if (s == NULL)\n    s = *lasts;\n\n  s += strspn(s, delim);\n  if (*s == '\\0')\n    return NULL;\n\n  token = s;\n  s = strpbrk(token, delim);\n  if (s == NULL)\n    *lasts = s + strlen(token);\n  else {\n    *s = '\\0';\n    *lasts = s + 1;\n  }\n\n  return token;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *strsep(char **stringp, const char *delim) {\n    char *ret = *stringp;\n    if (ret == ((void *)0))\n        return (((void *)0));\n    if ((*stringp = strpbrk(*stringp, delim)) != ((void *)0))\n        *((*stringp)++) = '\\x00';\n    return (ret);\n}\n","function_prediction":"char *strsep_name_conflict(char **stringp, const char *delim) {\n  char *s;\n  char *spanp;\n  int c, sc;\n  char *tok;\n\n  if ((s = *stringp) == NULL)\n    return (NULL);\n  for (tok = s;;) {\n    c = *s++;\n    spanp = (char *)delim;\n    if (c == '\\0') {\n      s = NULL;\n      break;\n    }\n    do {\n      if ((sc = *spanp++) == c) {\n        s = NULL;\n        break;\n      }\n    } while (sc != '\\0');\n    if (s == NULL)\n      break;\n  }\n  *stringp = s;\n  if (tok == s)\n    return (NULL);\n  else\n    return (tok);\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *ltrim(char *str) {\n    char *p;\n    if (!str || !str[0])\n        return str;\n    for (p = str; ((*__ctype_b_loc())[(int)(((int)*p))] & (unsigned short)_ISspace); ++p) {\n    }\n    if (p > str)\n        strcpy(str, p);\n    return str;\n}\n","function_prediction":"char *ltrim_name_conflict(char *str) {\n  char *p = str;\n  if (p == NULL || *p == '\\0')\n    return str;\n\n  const unsigned short *ctype_b = __ctype_b_loc();\n  while (ctype_b[((unsigned char)(*p)) + 1] & (0x0020))\n    p++;\n\n  if (p > str)\n    strcpy(str, p);\n\n  return str;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *rtrim(char *str) {\n    size_t offset;\n    char *p;\n    if (!str || !str[0])\n        return str;\n    offset = strlen(str);\n    p = str + offset - 1;\n    for (; p >= str && ((*__ctype_b_loc())[(int)(((int)*p))] & (unsigned short)_ISspace); --p) {\n        *p = 0;\n    }\n    return str;\n}\n","function_prediction":"char *rtrim_name_conflict(char *str) {\n  char *end;\n\n  if (str == NULL || *str == '\\0')\n    return str;\n\n  end = str + strlen(str) - 1;\n  while (end >= str && isspace((unsigned char)*end))\n    *end-- = '\\0';\n\n  return str;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long strlcat(dst, src, siz)\n    char *dst;\n    const char *src;\n    size_t siz;\n {\n    register char *d = dst;\n    register const char *s = src;\n    register size_t n = siz;\n    size_t dlen;\n    while (n-- != 0 && *d != '\\x00')\n        d++;\n    dlen = d - dst;\n    n = siz - dlen;\n    if (n == 0)\n        return (dlen + strlen(s));\n    while (*s != '\\x00')\n        {\n            if (n != 1) {\n                *d++ = *s;\n                n--;\n            }\n            s++;\n        }\n    *d = '\\x00';\n    return (dlen + (s - src));\n}\n","function_prediction":"size_t strlcat_name_conflict(char *dst, const char *src, size_t size) {\n  char *d = dst;\n  const char *s = src;\n  size_t n = size;\n  size_t dlen;\n\n  while (n-- != 0 && *d != '\\0')\n    d++;\n  dlen = d - dst;\n  n = size - dlen;\n\n  if (n == 0)\n    return (dlen + strlen(s));\n  while (*s != '\\0') {\n    if (n != 1) {\n      *d++ = *s;\n      n--;\n    }\n    s++;\n  }\n  *d = '\\0';\n\n  return (dlen + (s - src));\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long strlcpy(dst, src, siz)\n    char *dst;\n    const char *src;\n    size_t siz;\n {\n    register char *d = dst;\n    register const char *s = src;\n    register size_t n = siz;\n    if (n != 0 && --n != 0) {\n        do {\n            if ((*d++ = *s++) == 0)\n                break;\n        } while (--n != 0);\n    }\n    if (n == 0) {\n        if (siz != 0)\n            *d = '\\x00';\n        while (*s++)\n            ;\n    }\n    return (s - src - 1);\n}\n","function_prediction":"size_t strlcpy_name_conflict(char *dst, const char *src, size_t siz) {\n  char *d = dst;\n  const char *s = src;\n  size_t n = siz;\n\n  if (n != 0) {\n    while (--n != 0) {\n      if ((*d++ = *s++) == '\\0')\n        break;\n    }\n  }\n\n  if (n == 0) {\n    if (siz != 0)\n      *d = '\\0';\n    while (*s++)\n      ;\n  }\n\n  return (s - src - 1);\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"const char *_ds_userdir_path(char *path, const char *home, const char *filename, const char *extension) {\n    char username[4096];\n    char userpath[4096];\n    if (filename == ((void *)0) || filename[0] == 0) {\n        path[0] = 0;\n        return path;\n    }\n    strlcpy(username, filename, 4096);\n    strcpy(userpath, username);\n    if (extension != ((void *)0) && (!strcmp(extension, \"nodspam\") || !strcmp(extension, \"dspam\"))) {\n        snprintf(path, 4096, \"%s/opt-%s/%s.%s\", home, (!strcmp(extension, \"nodspam\")) ? \"out\" : \"in\", userpath, extension);\n        return path;\n    }\n    if (extension == ((void *)0)) {\n        snprintf(path, 4096, \"%s/data/%s\", home, userpath);\n    } else {\n        snprintf(path, 4096, \"%s/data/%s/%s.%s\", home, userpath, username, extension);\n    }\n    return path;\n}\n","function_prediction":"char *_ds_userdir_path(char *buf, const char *prefix, const char *user,\n                       const char *type) {\n  char userbuf[4096];\n  char *p;\n\n  if (!user || !*user) {\n    *buf = '\\0';\n    return buf;\n  }\n\n  for (p = userbuf; *user && p < &userbuf[sizeof(userbuf) - 1]; user++, p++)\n    *p = *user;\n  *p = '\\0';\n\n  while (*user)\n    user++;\n\n  strcpy(userbuf, userbuf);\n\n  if (type) {\n    if (!strcmp(type, \"nodspam\"))\n      snprintf(buf, 4096, \"%s/data/%s\", prefix, userbuf);\n    else if (!strcmp(type, \"dspam\"))\n      snprintf(buf, 4096, \"%s/opt-%s/%s.%s\", prefix, userbuf, userbuf, type);\n    else\n      snprintf(buf, 4096, \"%s/data/%s/%s.%s\", prefix, userbuf, userbuf, type);\n  } else\n    snprintf(buf, 4096, \"%s/data/%s\", prefix, userbuf);\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_prepare_path_for(const char *filename) {\n    char path[4096];\n    char *dir, *file;\n    char *file_buffer_start;\n    struct stat s;\n    if (!filename)\n        return 22;\n    file = strdup(filename);\n    if (!file) {\n        LOG(3, \"Memory allocation failed\");\n        return -5;\n    }\n    file_buffer_start = file;\n    path[0] = 0;\n    dir = strsep(&file, \"/\");\n    while (dir != ((void *)0))\n        {\n            strlcat(path, dir, sizeof (path));\n            dir = strsep(&file, \"/\");\n            {\n                if (dir != ((void *)0) && stat(path, &s) && path[0] != 0) {\n                    int x;\n                    ;\n                    ;\n                    x = mkdir(path, 504);\n                    if (x) {\n                        LOG(3, \"Unable to create directory: %s: %s\", path, strerror((*__errno_location())));\n                        free(file_buffer_start);\n                        return -3;\n                    }\n                }\n            }\n            strlcat(path, \"/\", sizeof (path));\n        }\n    free(file_buffer_start);\n    return 0;\n}\n","function_prediction":"int _ds_prepare_path_for_name_conflict(const char *path) {\n  char *path_copy, *path_copy_ptr, *path_ptr, *path_dir, *path_file;\n  char path_buf[4096];\n  struct stat st;\n\n  if (!path)\n    return 22;\n\n  path_copy = strdup(path);\n  if (!path_copy) {\n    LOG(3, \"Memory allocation failed\");\n    return -5;\n  }\n\n  path_buf[0] = '\\0';\n  path_ptr = path_copy;\n  path_dir = NULL;\n  path_file = NULL;\n\n  path_ptr = strchr(path_ptr, '/');\n  if (path_ptr) {\n    *path_ptr = '\\0';\n    path_dir = path_ptr + 1;\n  }\n\n  path_copy_ptr = path_buf;\n  while (1) {\n    while (*path_copy_ptr && path_copy_ptr < path_buf + 4096)\n      path_copy_ptr++;\n\n    if (path_copy_ptr == path_buf + 4096)\n      break;\n\n    while (*path_ptr && path_copy_ptr < path_buf + 4096 - 1)\n      *path_copy_ptr++ = *path_ptr++;\n\n    if (!*path_ptr)\n      break;\n\n    *path_copy_ptr = '\\0';\n  }\n\n  *path_copy_ptr = '\\0';\n\n  if (path_dir) {\n    path_ptr = path_dir;\n    path_dir = NULL;\n    path_file = NULL;\n\n    path_ptr = strchr(path_ptr, '/');\n    if (path_ptr) {\n      *path_ptr = '\\0';\n      path_file = path_ptr + 1;\n    }\n\n    if (stat(path_buf, &st)) {\n      if (path_buf[0]) {\n        if (mkdir(path_buf, 0770)) {\n                    LOG(3,","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int lc(char *buff, const char *string) {\n    char *buffer;\n    int i, j = 0;\n    int len = strlen(string);\n    buffer = malloc(len + 1);\n    if (len == 0) {\n        buff[0] = 0;\n        free(buffer);\n        return 0;\n    }\n    for (i = 0; i < len; i++) {\n        if (((*__ctype_b_loc())[(int)(((int)string[i]))] & (unsigned short)_ISupper)) {\n            buffer[i] = tolower(string[i]);\n            j++;\n        } else {\n            buffer[i] = string[i];\n        }\n    }\n    buffer[len] = 0;\n    strcpy(buff, buffer);\n    free(buffer);\n    return j;\n}\n","function_prediction":"int lc_name_conflict(char *dest, char *src) {\n  int i, len, count;\n  char *temp;\n\n  len = strlen(src);\n  temp = (char *)malloc(sizeof(char) * (len + 1));\n\n  count = 0;\n  for (i = 0; i < len; i++) {\n    if (isupper(src[i])) {\n      temp[i] = tolower(src[i]);\n      count++;\n    } else {\n      temp[i] = src[i];\n    }\n  }\n  temp[len] = '\\0';\n  strcpy(dest, temp);\n  free(temp);\n\n  return count;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"unsigned long long _ds_getcrc64(const char *s) {\n    static unsigned long long CRCTable[256];\n    unsigned long long crc = 0;\n    static int init = 0;\n    if (!init) {\n        int i;\n        init = 1;\n        for (i = 0; i <= 255; i++) {\n            int j;\n            unsigned long long part = i;\n            for (j = 0; j < 8; j++) {\n                if (part & 1)\n                    part = (part >> 1) ^ 15564440312192434176ULL;\n                else\n                    part >>= 1;\n            }\n            CRCTable[i] = part;\n        }\n    }\n    for (; *s; s++) {\n        unsigned long long temp1 = crc >> 8;\n        unsigned long long temp2 = CRCTable[(crc ^ (unsigned long long)*s) & 255];\n        crc = temp1 ^ temp2;\n    }\n    return crc;\n}\n","function_prediction":"uint64_t _ds_getcrc64_name_conflict(const char *s) {\n  static uint64_t CRCTable[256];\n  static int init = 0;\n  uint64_t crc = 0;\n  int i;\n\n  if (!init) {\n    for (i = 0; i < 256; i++) {\n      uint64_t c = i;\n      int j;\n      for (j = 0; j < 8; j++) {\n        if (c & 1) {\n          c = 0xd800000000000000ULL ^ (c >> 1);\n        } else {\n          c = c >> 1;\n        }\n      }\n      CRCTable[i] = c;\n    }\n    init = 1;\n  }\n\n  while (*s) {\n    crc = CRCTable[(crc >> 56) & 0xff] ^ (crc << 8) ^ *s++;\n  }\n\n  return crc;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_weight(const char *token) {\n    int complexity = _ds_compute_complexity(token);\n    int sparse = _ds_compute_sparse(token);\n    if (complexity == 5) {\n        if (sparse == 1)\n            return 64;\n        if (sparse == 2)\n            return 16;\n        if (sparse == 3)\n            return 4;\n        if (sparse == 0)\n            return 256;\n    }\n    if (complexity == 4) {\n        if (sparse == 1)\n            return 16;\n        if (sparse == 2)\n            return 4;\n        if (sparse == 0)\n            return 64;\n    }\n    if (complexity == 3) {\n        if (sparse == 1)\n            return 4;\n        if (sparse == 0)\n            return 16;\n    }\n    if (complexity == 2) {\n        if (sparse == 0)\n            return 4;\n    }\n    if (complexity == 1) {\n        if (sparse == 0)\n            return 1;\n    }\n    LOG(4, \"_ds_compute_weight: no rule to compute markovian weight for '%s'; complexity: %d; sparse: %d\", token, complexity, sparse);\n    return 1;\n}\n","function_prediction":"int _ds_compute_weight_name_conflict(const char *complexity) {\n  int sparse = 0;\n  int markov = 1;\n  int i = 0;\n\n  if (complexity == NULL)\n    return _ds_compute_sparse(NULL);\n\n  while (complexity[i] != '\\0') {\n    if (complexity[i] == '+')\n      markov++;\n    i++;\n  }\n\n  sparse = _ds_compute_sparse(complexity);\n\n  if (markov == 5) {\n    if (sparse == 1)\n      return 64;\n    if (sparse == 2)\n      return 16;\n    if (sparse == 3)\n      return 4;\n    if (sparse == 0)\n      return 256;\n  }\n\n  if (markov == 4) {\n    if (sparse == 1)\n      return 16;\n    if (sparse == 2)\n      return 4;\n    if (sparse == 0)\n      return 64;\n  }\n\n  if (markov == 3) {\n    if (sparse == 1)\n      return 4;\n    if (sparse == 0)\n      return 16;\n  }\n\n  if (markov == 2) {\n    if (sparse == 0)\n      return 4;\n  }\n\n  if (markov == 1) {\n    if (sparse == 0)\n      return 1;\n  }\n\n  LOG(4,\n      \"_ds_compute_weight_name_conflict: no rule to compute markovian weight for '%s'; \"\n      \"complexity: %d; sparse: %d\",\n      complexity, markov, sparse);\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_sparse(const char *token) {\n    int sparse = 0, i;\n    if (!strncmp(token, \"#+\", 2))\n        sparse++;\n    if (strlen(token) >= 2 && !strncmp((token + strlen(token)) - 2, \"+#\", 2))\n        sparse++;\n    for (i = 0; token[i]; i++) {\n        if (!strncmp(token + i, \"+#+\", 3)) {\n            sparse++;\n            i++;\n        }\n    }\n    return sparse;\n}\n","function_prediction":"int _ds_compute_sparse_name_conflict(char *s) {\n  int sparse = 0;\n  size_t len;\n\n  if (s[0] == '#' && s[1] == '+')\n    sparse++;\n  len = strlen(s);\n  if (len > 1 && s[len - 2] == '+' && s[len - 1] == '#')\n    sparse++;\n  for (int i = 0; s[i] != '\\0'; i++)\n    if (s[i] == '+' && s[i + 1] == '#' && s[i + 2] == '+') {\n      sparse++;\n      i++;\n    }\n  return sparse;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_compute_complexity(const char *token) {\n    int i, complexity = 1;\n    if (token == ((void *)0))\n        return 1;\n    for (i = 0; token[i]; i++) {\n        if (token[i] == '+') {\n            complexity++;\n            i++;\n        }\n    }\n    return complexity;\n}\n","function_prediction":"int _ds_compute_complexity_name_conflict(const char *str) {\n  int i = 0;\n  int complexity = 1;\n\n  if (str == NULL)\n    return 1;\n\n  while (str[i] != '\\0') {\n    if (str[i] == '+')\n      complexity += 2;\n    i++;\n  }\n\n  return complexity;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_extract_address(char *buf, const char *address, size_t len) {\n    char *str = strdup(address);\n    char *x, *y;\n    if (str == ((void *)0))\n        return -2;\n    x = strchr(str, '<');\n    if (!x) {\n        free(str);\n        return -5;\n    }\n    y = strchr(x, '>');\n    if (y)\n        y[0] = 0;\n    strlcpy(buf, x + 1, len);\n    free(str);\n    return 0;\n}\n","function_prediction":"int _ds_extract_address_name_conflict(char *address, const char *line, size_t max_len) {\n  char *copy = strdup(line);\n  if (copy == NULL)\n    return -2;\n\n  char *start = strchr(copy, '<');\n  if (start == NULL) {\n    free(copy);\n    return -5;\n  }\n\n  char *end = strchr(start, '>');\n  if (end != NULL)\n    *end = '\\0';\n\n  start++;\n\n  while (*start != '\\0') {\n    if (max_len == 0) {\n      address++;\n    } else {\n      max_len--;\n      if (max_len == 0) {\n        *address = '\\0';\n        break;\n      }\n      *address = *start;\n      address++;\n    }\n    start++;\n  }\n\n  free(copy);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_get_fcntl_lock(int fd) {\n    struct flock f;\n    int r;\n    f.l_type = 1;\n    f.l_whence = 0;\n    f.l_start = 0;\n    f.l_len = 0;\n    signal(14, timeout);\n    alarm(300);\n    r = fcntl(fd, 7, &f);\n    alarm(0);\n    signal(14, ((__sighandler_t)0));\n    return r;\n}\n","function_prediction":"int _ds_get_fcntl_lock_name_conflict(int fd) {\n  int ret;\n  struct flock lock;\n\n  lock.l_type = F_RDLCK;\n  lock.l_whence = 0;\n  lock.l_start = 0;\n  lock.l_len = 0;\n\n  signal(14, timeout);\n  alarm(300);\n  ret = fcntl(fd, 7, &lock);\n  alarm(0);\n  signal(14, SIG_DFL);\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_free_fcntl_lock(int fd) {\n    struct flock f;\n    f.l_type = 2;\n    f.l_whence = 0;\n    f.l_start = 0;\n    f.l_len = 0;\n    return fcntl(fd, 7, &f);\n}\n","function_prediction":"int _ds_free_fcntl_lock_name_conflict(int fd) {\n  struct flock fl;\n  fl.l_type = F_UNLCK;\n  fl.l_whence = 0;\n  fl.l_start = 0;\n  fl.l_len = 0;\n  return fcntl(fd, 7, &fl);\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_pow(int base, unsigned int exp) {\n    int result = 1;\n    while (exp > 0)\n        {\n            if (exp & 1)\n                result *= base;\n            base *= base;\n            exp /= 2;\n        }\n    return result;\n}\n","function_prediction":"int _ds_pow2(uint32_t n) {\n  int r = 1;\n  int b = 2;\n  while (n) {\n    if (n & 1) {\n      r *= b;\n    }\n    b *= b;\n    n >>= 1;\n  }\n  return r;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"int _ds_pow2(int exp) {\n    return _ds_pow(2, exp);\n}\n","function_prediction":"int _ds_pow2_name_conflict(int n) {\n  int i, p;\n\n  p = 1;\n  for (i = 0; i < n; i++) {\n    if (n & (1 << i))\n      p *= 2;\n  }\n  return p;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *strcasestr(s, find)\n    const char *s;\n    const char *find;\n {\n    char c, sc;\n    size_t len;\n    if ((c = *find++) != 0) {\n        c = tolower((unsigned char)c);\n        len = strlen(find);\n        do {\n            do {\n                if ((sc = *s++) == 0)\n                    return (((void *)0));\n            } while ((char)tolower((unsigned char)sc) != c);\n        } while (strncasecmp(s, find, len) != 0);\n        s--;\n    }\n    return ((char *)s);\n}\n","function_prediction":"char *strcasestr_name_conflict(const char *haystack, const char *needle) {\n  const char *p, *q;\n  const char *h, *n;\n  size_t len;\n  struct _ctype_t *ct;\n\n  if (!*needle)\n    return (char *)haystack;\n\n  ct = __ctype_tolower_loc();\n  h = haystack;\n  n = needle;\n  len = strlen(n + 1);\n  while (*h) {\n    p = h;\n    q = n;\n    if (ct->table[(unsigned char)*p] == ct->table[(unsigned char)*q]) {\n      if (!strncasecmp(p + 1, q + 1, len))\n        return (char *)(p);\n    }\n    h++;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":0,"function":"char *inet_ntoa_r(struct in_addr in, char *buf, int len) {\n    char b[18];\n    register char *p;\n    p = (char *)&in;\n    snprintf(b, sizeof (b), \"%d.%d.%d.%d\", (((int)p[0]) & 255), (((int)p[1]) & 255), (((int)p[2]) & 255), (((int)p[3]) & 255));\n    if (len <= strlen(b)) {\n        (*__errno_location()) = 34;\n        return (((void *)0));\n    }\n    return strcpy(buf, b);\n}\n","function_prediction":"char *inet_ntoa_r_name_conflict(uint32_t ip, char *buf, int buflen) {\n  char tmp[18];\n  int len;\n\n  snprintf(tmp, sizeof(tmp), \"%d.%d.%d.%d\", (ip >> 24) & 0xff,\n           (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);\n  len = strlen(tmp);\n  if (len >= buflen) {\n    do {\n      if (__builtin_expect(!!(0), 0))\n        __builtin_unreachable();\n      __errno_location()->__val = 34;\n    } while (0);\n    return NULL;\n  }\n  if (len + 1 < sizeof(tmp)) {\n    if (len & 4) {\n      *(uint32_t *)buf = *(uint32_t *)tmp;\n      *(uint32_t *)(buf + len - 4) = *(uint32_t *)(tmp + len + 1);\n    } else if (len) {\n      *buf = *tmp;\n      if (len & 2)\n        *(uint16_t *)(buf + len - 2) = *(uint16_t *)(tmp + len + 1);\n    }\n  } else {\n    *(uint64_t *)buf = *(uint64_t *)tmp;\n    *(uint64_t *)(buf + len - 8) = *(uint64_t *)(tmp + len + 1);\n    for (int i = len - 8; i < buflen; i += 8)\n      *(uint64_t *)(buf + i) = *(uint64_t *)(tmp + i + 8);\n  }\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/aleksey200505_dspam/src/util.c"}
{"compilable":1,"function":"char *strcpy(char *s, char *t) {\n    char *os;\n    os = s;\n    while ((*s++ = *t++) != 0)\n        ;\n    return os;\n}\n","function_prediction":"char *strcpy_name_conflict(char *dest, const char *src) {\n  char *s = dest;\n  while ((*dest++ = *src++))\n    ;\n  return s;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int strcmp(const char *p, const char *q) {\n    while (*p && *p == *q)\n        p++ , q++;\n    return (uchar)*p - (uchar)*q;\n}\n","function_prediction":"int strcmp_name_conflict(const char *s1, const char *s2) {\n  while (*s1 && *s1 == *s2) {\n    s1++;\n    s2++;\n  }\n  return *s1 - *s2;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"uint strlen(char *s) {\n    int n;\n    for (n = 0; s[n]; n++)\n        ;\n    return n;\n}\n","function_prediction":"size_t strlen_name_conflict(const char *s) {\n  if (*s == '\\0')\n    return 0;\n  return 1 + strlen_name_conflict(s + 1);\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"char *strchr(const char *s, char c) {\n    for (; *s; s++)\n        if (*s == c)\n            return (char *)s;\n    return 0;\n}\n","function_prediction":"char *strchr_name_conflict(const char *s, int c) {\n  while (*s) {\n    if (*s == c)\n      return (char *)s;\n    s++;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"char *gets(char *buf, int max) {\n    int i, cc;\n    char c;\n    for (i = 0; i + 1 < max;) {\n        cc = read(0, &c, 1);\n        if (cc < 1)\n            break;\n        buf[i++] = c;\n        if (c == '\\n' || c == '\\r')\n            break;\n    }\n    buf[i] = '\\x00';\n    return buf;\n}\n","function_prediction":"char *gets_name_conflict(char *s) {\n  int i, c;\n  char buf[9];\n\n  for (i = 0; i < sizeof(s) - 1; i++) {\n    c = read(0, buf, 1);\n    if (c <= 0)\n      break;\n    s[i] = buf[0];\n    if (buf[0] == '\\n' || buf[0] == '\\r')\n      break;\n  }\n  s[i] = '\\0';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int stat(char *n, struct stat *st) {\n    int fd;\n    int r;\n    fd = open(n, 0);\n    if (fd < 0)\n        return -1;\n    r = fstat(fd, st);\n    close(fd);\n    return r;\n}\n","function_prediction":"int stat_name_conflict(const char *path, struct stat_name_conflict *st) {\n  int fd;\n  int ret;\n\n  fd = open(path, 0);\n  if (fd < 0)\n    return -1;\n\n  ret = fstat_name_conflict(fd, st);\n  close(fd);\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int atoi(const char *s) {\n    int n;\n    n = 0;\n    while ('0' <= *s && *s <= '9')\n        n = n * 10 + *s++ - '0';\n    return n;\n}\n","function_prediction":"int atoi_name_conflict(char *str) {\n  int i = 0;\n  while (*str >= '0' && *str <= '9') {\n    i = i * 10 + (*str - '0');\n    str++;\n  }\n  return i;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"char *strcpy(char *s, char *t) {\n    char *os;\n    os = s;\n    while ((*s++ = *t++) != 0)\n        ;\n    return os;\n}\n","function_prediction":"char *strcpy_name_conflict(char *dest, const char *src) {\n  char *s = dest;\n  while ((*dest++ = *src++))\n    ;\n  return s;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int strcmp(const char *p, const char *q) {\n    while (*p && *p == *q)\n        p++ , q++;\n    return (uchar)*p - (uchar)*q;\n}\n","function_prediction":"int strcmp_name_conflict(const char *s1, const char *s2) {\n  while (*s1 && *s1 == *s2) {\n    s1++;\n    s2++;\n  }\n  return *s1 - *s2;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"uint strlen(char *s) {\n    int n;\n    for (n = 0; s[n]; n++)\n        ;\n    return n;\n}\n","function_prediction":"size_t strlen_name_conflict(const char *s) {\n  if (*s == '\\0')\n    return 0;\n  return 1 + strlen_name_conflict(s + 1);\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":0,"function":"char *strchr(const char *s, char c) {\n    for (; *s; s++)\n        if (*s == c)\n            return (char *)s;\n    return 0;\n}\n","function_prediction":"char *strchr_name_conflict(const char *s, int c) {\n  while (*s) {\n    if (*s == c)\n      return (char *)s;\n    s++;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"char *gets(char *buf, int max) {\n    int i, cc;\n    char c;\n    for (i = 0; i + 1 < max;) {\n        cc = read(0, &c, 1);\n        if (cc < 1)\n            break;\n        buf[i++] = c;\n        if (c == '\\n' || c == '\\r')\n            break;\n    }\n    buf[i] = '\\x00';\n    return buf;\n}\n","function_prediction":"char *gets_name_conflict(char *s) {\n  int i, c;\n  char buf[9];\n\n  for (i = 0; i < sizeof(s) - 1; i++) {\n    c = read(0, buf, 1);\n    if (c <= 0)\n      break;\n    s[i] = buf[0];\n    if (buf[0] == '\\n' || buf[0] == '\\r')\n      break;\n  }\n  s[i] = '\\0';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int stat(char *n, struct stat *st) {\n    int fd;\n    int r;\n    fd = open(n, 0);\n    if (fd < 0)\n        return -1;\n    r = fstat(fd, st);\n    close(fd);\n    return r;\n}\n","function_prediction":"int stat_name_conflict(const char *path, struct stat_name_conflict *st) {\n  int fd;\n  int ret;\n\n  fd = open(path, 0);\n  if (fd < 0)\n    return -1;\n\n  ret = fstat_name_conflict(fd, st);\n  close(fd);\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"int atoi(const char *s) {\n    int n;\n    n = 0;\n    while ('0' <= *s && *s <= '9')\n        n = n * 10 + *s++ - '0';\n    return n;\n}\n","function_prediction":"int atoi_name_conflict(char *str) {\n  int i = 0;\n  while (*str >= '0' && *str <= '9') {\n    i = i * 10 + (*str - '0');\n    str++;\n  }\n  return i;\n}","pass":0,"source_file":"C_COMPILE/s-rah_xv6-permissions/ulib.c"}
{"compilable":1,"function":"bool check(const char *word) {\n    return 0;\n}\n","function_prediction":"int check_name_conflict(int a, int b) {\n  int c;\n  if (a > b)\n    c = a;\n  else\n    c = b;\n  return c;\n}","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"bool load(const char *dictionary) {\n    return 0;\n}\n","function_prediction":"int load_name_conflict(const char *filename) { return 0; }","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":0,"function":"unsigned int size(void) {\n    return 0;\n}\n","function_prediction":"int size_name_conflict(struct node *head) {\n  int count = 0;\n  struct node *temp = head;\n  while (temp != NULL) {\n    count++;\n    temp = temp->next;\n  }\n  return count;\n}","pass":0,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"bool unload(void) {\n    return 0;\n}\n","function_prediction":"int unload_name_conflict(void) { return 0; }","pass":1,"source_file":"C_COMPILE/allangarcia_gchq-xmas2015/step3/third-party/pset5/dictionary.c"}
{"compilable":1,"function":"int open_serial(int k) {\n    if (k == 0) {\n        fd = open(\"/dev/ttyUSB0\", 2 | 256);\n        perror(\"open /dev/ttyUSB0\");\n    } else {\n        fd = open(\"/dev/ttyUSB1\", 2 | 256);\n        perror(\"open /dev/ttyUSB1\");\n    }\n    if (fd == -1)\n        return -1;\n    else\n        return 0;\n}\n","function_prediction":"int open_serial_name_conflict(int port) {\n  if (port == 0) {\n    fd = open(\"/dev/ttyUSB0\", 0x00000200 | 0x00000002);\n    perror(\"open /dev/ttyUSB0\");\n  } else {\n    fd = open(\"/dev/ttyUSB1\", 0x00000200 | 0x00000002);\n    perror(\"open /dev/ttyUSB1\");\n  }\n\n  if (fd == -1)\n    return -1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/recessburton_UartHumidSensor/src/c_conf/configure.c"}
{"compilable":0,"function":"unsigned int calc_crc16(unsigned char *snd, unsigned char num) {\n    unsigned char i, j;\n    unsigned int c, crc = 65535;\n    for (i = 0; i < num; i++) {\n        c = snd[i] & 255;\n        crc ^= c;\n        for (j = 0; j < 8; j++) {\n            if (crc & 1) {\n                crc >>= 1;\n                crc ^= 40961;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n    return (crc);\n}\n","function_prediction":"uint16_t calc_crc16_name_conflict(uint8_t *data, uint8_t len) {\n  uint16_t crc = 0xFFFF;\n  uint8_t i;\n\n  while (len--) {\n    crc ^= *data++;\n    for (i = 0; i < 8; i++) {\n      if (crc & 0x01) {\n        crc = (crc >> 1) ^ 0xA001;\n      } else {\n        crc >>= 1;\n      }\n    }\n  }\n  return crc;\n}","pass":0,"source_file":"C_COMPILE/recessburton_UartHumidSensor/src/c_conf/configure.c"}
{"compilable":1,"function":"int read(char *name, char *permission) {\n    int buf;\n    FILE *file;\n    file = fopen(name, permission);\n    fread(&buf, sizeof (buf), 1, file);\n    fclose(file);\n    return buf;\n}\n","function_prediction":"int read_name_conflict(char *filename) {\n  FILE *fp = fopen(filename, \"r\");\n  int i;\n  fread_name_conflict(&i, sizeof(int), 1, fp);\n  fclose(fp);\n  return i;\n}","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":1,"function":"int average(int *data, int size) {\n    if (data == ((void *)0) || size == 0) {\n        return 0;\n    }\n    printf(\"size=%d\\n\", sizeof data / sizeof(int));\n    int i, average = 0;\n    for (i = 0; i < size; i++) {\n        average += data[i];\n    }\n    return average / size;\n}\n","function_prediction":"int average_name_conflict(int *a, int size) {\n  int i, sum = 0;\n  if (a == NULL)\n    return 0;\n  if (size == 0)\n    return 0;\n  printf(\"size=%d\\n\", sizeof(a));\n  for (i = 0; i < size; i++)\n    sum += a[i];\n  return sum / size;\n}","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":1,"function":"int average2(int data[], int size) {\n    int i, average = 0;\n    for (i = 0; i < size; i++) {\n        average += data[i];\n    }\n    return average / size;\n}\n","function_prediction":"int average2_name_conflict(int *a, int n) {\n  int i, sum = 0;\n  for (i = 0; i < n; i++)\n    sum += a[i];\n  return sum / n;\n}","pass":0,"source_file":"C_COMPILE/pollseed_linux_setup/src/c/lib/util.c"}
{"compilable":1,"function":"char readchar() {\n    while (uartadr[8] & 1)\n        ;\n    return uartadr[4];\n}\n","function_prediction":"char readchar_name_conflict(void) {\n  while (!(*(volatile unsigned char *)(uartadr + 8) & 0x01))\n    ;\n  return *(volatile unsigned char *)(uartadr + 4);\n}","pass":1,"source_file":"C_COMPILE/bonfireprocessor_bonfire-soc/riscv/software/cpptest/uart.c"}
{"compilable":1,"function":"_Bool show_cmd_help(int argc, char **argv) {\n    return (argc > 0 && (0 == strcmp(argv[0], \"-h\") || 0 == strcmp(argv[0], \"--help\")));\n}\n","function_prediction":"int show_cmd_help_name_conflict(int argc, char **argv) {\n  if (argc > 0) {\n    if (!strcmp(argv[0], \"-h\") || !strcmp(argv[0], \"--help\"))\n      return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/wfleming_c-timecard/src/punch.c"}
{"compilable":0,"function":"int in_cmd(int argc, char **argv) {\n    if (0 == argc) {\n        char *cmd = \"in\";\n        help_cmd(1, &cmd);\n        return 64;\n    }\n    int did_punch_in = with_open_log_file(argv[0], in_cmd_with_fh);\n    return (0 != did_punch_in);\n}\n","function_prediction":"int in_cmd_name_conflict(int argc, char **argv) {\n  if (argc == 0) {\n    char *help_argv[] = {\"in\", NULL};\n    help_cmd(1, help_argv);\n    return 64;\n  }\n\n  if (!with_open_log_file(argv[0], in_cmd_name_conflict_with_fh))\n    return 0;\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/in_cmd.c"}
{"compilable":0,"function":"bool ensure_data_dir_exists(void) {\n    char path[4096];\n    get_data_dir(path);\n    struct stat finfo;\n    int success = stat(path, &finfo);\n    if (-1 == success) {\n        if (2 == (*__errno_location())) {\n            success = mkdir(path, 16384 | (256 | 128 | 64) | (256 >> 3));\n            if (-1 == success) {\n                goto fail;\n            }\n        } else {\n            goto fail;\n        }\n    }\n    return 1;\n  fail:\n    fprintf(stderr, \"Error %d (%s) trying to create %s\\n\", (*__errno_location()), edesc((*__errno_location())), path);\n    return 0;\n}\n","function_prediction":"int ensure_data_dir_exists_name_conflict(void) {\n  char *punch_home = getenv(\"PUNCH_HOME\");\n  char data_dir[4096];\n  if (punch_home) {\n    strncpy(data_dir, punch_home, 4096);\n  } else {\n    char *xdg_config_home = getenv(\"XDG_CONFIG_HOME\");\n    if (xdg_config_home) {\n      strncpy(data_dir, xdg_config_home, 4096);\n    } else {\n      char *home = getenv(\"HOME\");\n      snprintf(data_dir, 4096 - 3, \"%s/.config\", home);\n    }\n    size_t len = strlen(data_dir);\n    data_dir[len] = 'n';\n    data_dir[len + 1] = 'u';\n    data_dir[len + 2] = 'p';\n    data_dir[len + 3] = '/';\n  }\n\n  struct stat st;\n  if (stat(data_dir, &st) != -1) {\n    return 1;\n  }\n\n  int err = *__errno_location();\n  if (err == 2) {\n    if (mkdir(data_dir, 07550) != -1) {\n      return 1;\n    }\n    err = *__errno_location();\n  }\n\n  const char *err_str;\n  switch (err) {\n  case 0:\n    err_str = \"no error\";\n    break;\n  case 2:\n    err_str = \"file does not exist\";\n    break;\n  case 9:\n    err_str = \"bad file descriptor\";\n    break;\n  case 13:\n    err_str = \"access denied\";\n    break;\n  case 17:\n    err_str = \"the file exists\";\n    break;\n  case 20:\n    err_str = \"is not a directory\";\n    break;\n  case 22:\n    err_str","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/cmd_util.c"}
{"compilable":1,"function":"char *edesc(int err) {\n    switch (err) {\n      case 2:\n        return \"file does not exist\";\n      case 20:\n        return \"is not a directory\";\n      case 13:\n        return \"access denied\";\n      case 9:\n        return \"bad file descriptor\";\n      case 17:\n        return \"the file exists\";\n      case 36:\n        return \"filename too long\";\n      case 30:\n        return \"write access requested on a read-only filesystem\";\n      case 22:\n        return \"flag is invalid\";\n      default:\n        return \"unknown error\";\n    }\n}\n","function_prediction":"const char *edesc_name_conflict(int e) {\n  switch (e) {\n  case 0x02:\n    return \"file does not exist\";\n  case 0x09:\n    return \"bad file descriptor\";\n  case 0x0D:\n    return \"access denied\";\n  case 0x11:\n    return \"the file exists\";\n  case 0x14:\n    return \"is not a directory\";\n  case 0x16:\n    return \"flag is invalid\";\n  case 0x1E:\n    return \"write access requested on a read-only filesystem\";\n  case 0x24:\n    return \"filename too long\";\n  default:\n    return \"unknown error\";\n  }\n}","pass":1,"source_file":"C_COMPILE/wfleming_c-timecard/src/cmd_util.c"}
{"compilable":0,"function":"int out_cmd(int argc) {\n    if (argc > 0) {\n        char *cmd = \"out\";\n        help_cmd(1, &cmd);\n        return 64;\n    }\n    int did_punch_out = with_open_log_file(((void *)0), out_cmd_with_fh);\n    return (0 != did_punch_out);\n}\n","function_prediction":"bool out_cmd_name_conflict(int argc, char **argv) {\n  if (argc > 0) {\n    char *args[2];\n    args[0] = \"out\";\n    help_cmd(1, args);\n    return 0x40;\n  }\n\n  if (!with_open_log_file(NULL, out_cmd_name_conflict_with_fh))\n    return true;\n\n  return false;\n}","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/out_cmd.c"}
{"compilable":0,"function":"size_t strfentry_time(char *buf, time_t *t) {\n    struct tm tt;\n    localtime_r(t, &tt);\n    size_t foo = strfiso8601(buf, 26, &tt);\n    return foo;\n}\n","function_prediction":"void strfentry_time_name_conflict(char *buf, time_t *t) {\n  struct tm tm;\n\n  localtime_r(t, &tm);\n  strfiso8601(buf, 26, &tm);\n}","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/entry.c"}
{"compilable":0,"function":"int summary_cmd(int argc, char **argv) {\n    t_formatter_fn formatter = print_summary_human;\n    if (argc > 0 && 0 == strncmp(\"--csv\", argv[0], 5)) {\n        formatter = print_summary_csv;\n    }\n    int exit_code = 0;\n    if (isatty(fileno(stdin))) {\n        exit_code = with_open_log_file((void *)formatter, summary_cmd_with_fh);\n    } else {\n        exit_code = summary_cmd_with_fh(stdin, (void *)formatter);\n    }\n    return exit_code;\n}\n","function_prediction":"int summary_cmd_with_fh(FILE *fh, void (*summary_func)(struct summary *)) {\n  return with_parsed_log(fh, summary_func, summary_cmd_with_log);\n}","pass":0,"source_file":"C_COMPILE/wfleming_c-timecard/src/summary_cmd.c"}
{"compilable":0,"function":"static int choose_pivot(int *p, int n) {\n    int *pl, *pm, *pn;\n    int s;\n    pm = p + (n >> 1);\n    if (n > 7) {\n        pl = p;\n        pn = p + n - 1;\n        if (n > 40) {\n            s = n >> 3;\n            pl = ((V[*(pl) + (h)]) < (V[*(pl + s) + (h)]) ? ((V[*(pl + s) + (h)]) < (V[*(pl + s + s) + (h)]) ? (pl + s) : (V[*(pl) + (h)]) < (V[*(pl + s + s) + (h)]) ? (pl + s + s) : (pl)) : ((V[*(pl + s) + (h)]) > (V[*(pl + s + s) + (h)]) ? (pl + s) : (V[*(pl) + (h)]) > (V[*(pl + s + s) + (h)]) ? (pl + s + s) : (pl)));\n            pm = ((V[*(pm - s) + (h)]) < (V[*(pm) + (h)]) ? ((V[*(pm) + (h)]) < (V[*(pm + s) + (h)]) ? (pm) : (V[*(pm - s) + (h)]) < (V[*(pm + s) + (h)]) ? (pm + s) : (pm - s)) : ((V[*(pm) + (h)]) > (V[*(pm + s) + (h)]) ? (pm) : (V[*(pm - s) + (h)]) > (V[*(pm + s) + (h)]) ? (pm + s) : (pm - s)));\n            pn = ((V[*(pn - s - s) + (h)]) < (V[*(pn - s) + (h)]) ? ((V[*(pn - s) + (h)]) < (V[*(pn) + (h)]) ? (pn - s) : (V[*(pn - s - s) + (h)]) < (V[*(pn) + (h)]) ? (pn) : (pn - s - s)) : ((V[*(pn - s) + (h)]) > (V[*(pn) + (h)]) ? (pn - s) : (V[*(pn - s - s) + (h)]) > (V[*(pn) + (h)]) ? (pn) : (pn - s - s)));\n        }\n        pm = ((V[*(pl) + (h)]) < (V[*(pm) + (h)]) ? ((V[*(pm) + (h)]) < (V[*(pn) + (h)]) ? (pm) : (V[*(pl) + (h)]) < (V[*(pn) + (h)]) ? (pn) : (pl)) : ((V[*(pm) + (h)]) > (V[*(pn) + (h)]) ? (pm) : (V[*(pl) + (h)]) > (V[*(pn) + (h)]) ? (pn) : (pl)));\n    }\n    return (V[*(pm) + (h)]);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":0,"function":"static int transform(int *x, int *p, int n, int k, int l, int q) {\n    int b, c, d, e, i, j, m, s;\n    int *pi, *pj;\n    for (s = 0 , i = k - l; i; i >>= 1)\n        ++s;\n    e = 2147483647 >> s;\n    for (b = d = r = 0; r < n && d <= e && (c = d << s | (k - l)) <= q; ++r) {\n        b = b << s | (x[r] - l + 1);\n        d = c;\n    }\n    m = (1 << (r - 1) * s) - 1;\n    x[n] = l - 1;\n    if (d <= n) {\n        for (pi = p; pi <= p + d; ++pi)\n            *pi = 0;\n        for (pi = x + r , c = b; pi <= x + n; ++pi) {\n            p[c] = 1;\n            c = (c & m) << s | (*pi - l + 1);\n        }\n        for (i = 1; i < r; ++i) {\n            p[c] = 1;\n            c = (c & m) << s;\n        }\n        for (pi = p , j = 1; pi <= p + d; ++pi)\n            if (*pi)\n                *pi = j++;\n        for (pi = x , pj = x + r , c = b; pj <= x + n; ++pi , ++pj) {\n            *pi = p[c];\n            c = (c & m) << s | (*pj - l + 1);\n        }\n        while (pi < x + n)\n            {\n                *pi++ = p[c];\n                c = (c & m) << s;\n            }\n    } else {\n        for (pi = x , pj = x + r , c = b; pj <= x + n; ++pi , ++pj) {\n            *pi = c;\n            c = (c & m) << s | (*pj - l + 1);\n        }\n        while (pi < x + n)\n            {\n                *pi++ = c;\n                c = (c & m) << s;\n            }\n        j = d + 1;\n    }\n    x[n] = 0;\n    return j;\n}\n","function_prediction":"int transform_name_conflict(int *a, int *b, int n, int m, int k, int l) {\n  int i, j, p, q, r, s, t, u, v, w, x, y, z;\n\n  r = 0;\n  for (i = 1; i <= n; i++) {\n    if (a[i] > l) {\n      a[i] = k - 1;\n      break;\n    }\n    r++;\n  }\n  for (j = i; j <= n; j++) {\n    a[j] = k - 1;\n  }\n  for (i = 1; i <= n; i++) {\n    if (a[i] > l) {\n      break;\n    }\n    r++;\n  }\n  for (j = i; j <= n; j++) {\n    a[j] = k - 1;\n  }\n  for (i = 1; i <= n; i++) {\n    if (a[i] > l) {\n      break;\n    }\n    r++;\n  }\n  for (j = i; j <= n; j++) {\n    a[j] = k - 1;\n  }\n  for (i = 1; i <= n; i++) {\n    if (a[i] > l) {\n      break;\n    }\n    r++;\n  }\n  for (j = i; j <= n; j++) {\n    a[j] = k - 1;\n  }\n  for (i = 1; i <= n; i++) {\n    if (a[i] > l) {\n      break;\n    }\n    r++;\n  }\n  for (j = i; j <= n; j++) {\n    a[j] = k - 1;\n  }\n  for (i = 1; i <= n; i++) {\n    if (a[i] > l) {\n      break;\n    }\n    r++;\n  }\n  for (j = i; j <= n; j++) {\n    a[j] = k -","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":0,"function":"int vcblocksortCompress(int level, const unsigned char *data, size_t avail_in, unsigned char *odata, size_t *avail_out) {\n    double result;\n    struct BlockSortCompressionInstance *bsci;\n    bsci = calloc(sizeof (*bsci), 1);\n    resetStatistics(bsci);\n    result = bs_compress(bsci, (unsigned char *)data, avail_in);\n    freeBSCI(bsci);\n    *avail_out = (int)result;\n    return 0;\n}\n","function_prediction":"int vcblocksortCompress(int *universe, unsigned char *in, int insize,\n                        unsigned char *out, long *outsize) {\n  int i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z;\n  int *state;\n  double a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x,\n      y, z;\n  double aa, bb, cc, dd, ee, ff, gg, hh, ii, jj, kk, ll, mm, nn, oo, pp, qq, rr,\n      ss, tt, uu, vv, ww, xx, yy, zz;\n  double aaa, bbb, ccc, ddd, eee, fff, ggg, hhh, iii, jjj, kkk, lll, mmm, nnn,\n      ooo, ppp, qqq, rrr, sss, ttt, uuu, vvv, www, xxx, yyy, zzz;\n  double aaaa, bbbb, cccc, dddd, eeee, ffff, gggg, hhhh, iii, jjjj, kkkk, llll,\n      mmmm, nnnn, oooo, pppp, qqqq, rrrr, ssss, tttt, uuuu, vvvv, wwww, xxxx,\n      yyyy, zzzz;\n  double aaaaa, bbbbb, ccccc, ddddd, eeeee, fffff, ggggg, hhhhh, iiiii, jjjjj,\n      kkkkk, lllll, mmmmm, nnnnn, ooooo, ppppp, qqqqq, rrrrr, sssss, ttttt,\n      uuuuu, vvvvv, wwww, xxxxx, yyyyy, zzzzz;\n  double aaaaaa, bbbbbb, cccccc, dddddd, e","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/vcblocksort/vcblocksort.c"}
{"compilable":0,"function":"int smaz_compress(const unsigned char *in, size_t inlen, unsigned char *out, size_t outlen) {\n    unsigned int h1, h2, h3 = 0;\n    int verblen = 0, _outlen = outlen;\n    unsigned char verb[256], *_out = out;\n    while (inlen)\n        {\n            int j = 7, needed;\n            unsigned char *flush = ((void *)0);\n            char *slot;\n            h1 = h2 = in[0] << 3;\n            if (inlen > 1)\n                h2 += in[1];\n            if (inlen > 2)\n                h3 = h2 ^ in[2];\n            if (j > inlen)\n                j = inlen;\n            for (; j > 0; j--) {\n                switch (j) {\n                  case 1:\n                    slot = Smaz_cb[h1 % 241];\n                    break;\n                  case 2:\n                    slot = Smaz_cb[h2 % 241];\n                    break;\n                  default:\n                    slot = Smaz_cb[h3 % 241];\n                    break;\n                }\n                while (slot[0])\n                    {\n                        if (slot[0] == j && memcmp(slot + 1, in, j) == 0) {\n                            if (verblen) {\n                                needed = (verblen == 1) ? 2 : 2 + verblen;\n                                flush = out;\n                                out += needed;\n                                outlen -= needed;\n                            }\n                            if (outlen <= 0)\n                                return _outlen + 1;\n                            out[0] = slot[slot[0] + 1];\n                            out++;\n                            outlen--;\n                            inlen -= j;\n                            in += j;\n                            goto out;\n                        } else {\n                            slot += slot[0] + 2;\n                        }\n                    }\n            }\n            verb[verblen] = in[0];\n            verblen++;\n            inlen--;\n            in++;\n          out:\n            if (!flush && (verblen == 256 || (verblen > 0 && inlen == 0))) {\n                needed = (verblen == 1) ? 2 : 2 + verblen;\n                flush = out;\n                out += needed;\n                outlen -= needed;\n                if (outlen < 0)\n                    return _outlen + 1;\n            }\n            if (flush) {\n                if (verblen == 1) {\n                    flush[0] = (signed char)254;\n                    flush[1] = verb[0];\n                } else {\n                    flush[0] = (signed char)255;\n                    flush[1] = (signed char)(verblen - 1);\n                    memcpy(flush + 2, verb, verblen);\n                }\n                flush = ((void *)0);\n                verblen = 0;\n            }\n        }\n    return out - _out;\n}\n","function_prediction":"size_t smaz_compress_name_conflict(const char *in, size_t inlen, char *out, size_t outlen) {\n  const char *inptr = in;\n  char *outptr = out;\n  size_t outleft = outlen;\n  unsigned char hash[3] = {0, 0, 0};\n  unsigned char buf[256];\n  size_t buflen = 0;\n  size_t i, j, k, l;\n\n  while (inlen > 0) {\n    i = inptr[0];\n    j = inlen > 1 ? inptr[1] : 0;\n    k = inlen > 2 ? inptr[2] : 0;\n    l = inlen > 3 ? inptr[3] : 0;\n    hash[0] = (hash[0] * 47 + i) % 241;\n    hash[1] = (hash[1] * 47 + j) % 241;\n    hash[2] = (hash[2] * 47 + k) % 241;\n\n    for (k = inlen; k > 0; k--) {\n      for (l = k; l > 0; l--) {\n        const char *str = Smaz_cb[((hash[0] * 47 + hash[1]) % 241)];\n        for (; str[0] != 0; str += str[0] + 1) {\n          if (str[0] == l && !memcmp(str + 1, inptr, k)) {\n            if (buflen == 0) {\n              if (outleft > 0) {\n                *outptr++ = str[l];\n                inptr += k;\n                inlen -= k;\n                outleft--;\n              }\n            } else {\n              if (buflen == 1) {\n                l = 2;\n              }\n              if (outleft > l) {\n                *outptr++ = str[l];\n                inptr += k;\n                inlen -= k;\n                outleft -= l;\n              } else {\n                return out","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":0,"function":"int sCompress(int level, const unsigned char *in, size_t inlen, unsigned char *out, size_t *outlen) {\n    int res = smaz_compress(in, inlen, out, *outlen);\n    *outlen = res;\n    return 0;\n}\n","function_prediction":"int sCompress(lw6sys_context_t *sys_context, const char *input,\n              size_t input_len, char *output, size_t *output_len) {\n  int rc;\n\n  rc = smaz_compress(input, input_len, output, *output_len);\n  *output_len = rc;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":1,"function":"int smaz_decompress(char *in, int inlen, char *out, int outlen) {\n    unsigned char *c = (unsigned char *)in;\n    char *_out = out;\n    int _outlen = outlen;\n    while (inlen)\n        {\n            if (*c == 254) {\n                if (outlen < 1)\n                    return _outlen + 1;\n                *out = *(c + 1);\n                out++;\n                outlen--;\n                c += 2;\n                inlen -= 2;\n            } else if (*c == 255) {\n                int len = (*(c + 1)) + 1;\n                if (outlen < len)\n                    return _outlen + 1;\n                memcpy(out, c + 2, len);\n                out += len;\n                outlen -= len;\n                c += 2 + len;\n                inlen -= 2 + len;\n            } else {\n                char *s = Smaz_rcb[*c];\n                int len = strlen(s);\n                if (outlen < len)\n                    return _outlen + 1;\n                memcpy(out, s, len);\n                out += len;\n                outlen -= len;\n                c++;\n                inlen--;\n            }\n        }\n    return out - _out;\n}\n","function_prediction":"int smaz_decompress_name_conflict(const char *source, int slen, char *dest, int dlen) {\n  const char *src = source;\n  char *dst = dest;\n  int dstlen = dlen;\n\n  while (slen) {\n    if (*src == (char)0xFE) {\n      if (dstlen < 1)\n        return dlen + 1;\n      *dst++ = *++src;\n      slen -= 2;\n      dstlen--;\n    } else if (*src == (char)0xFF) {\n      int len = *(src + 1) + 1;\n      if (dstlen < len)\n        return dlen + 1;\n      if (len > 7) {\n        *(long long *)dst = *(long long *)(src + 2);\n        *(long long *)(dst + len - 8) = *(long long *)(src + len - 6);\n        dst += len;\n      } else if (len & 4) {\n        *(int *)dst = *(int *)(src + 2);\n        *(int *)(dst + len - 4) = *(int *)(src + len - 2);\n        dst += len;\n      } else if (len) {\n        *dst++ = *(src + 2);\n        if (len & 2)\n          *(short *)(dst + len - 2) = *(short *)(src + len);\n        dst += len - 1;\n      }\n      slen -= len + 2;\n      src += 2 + len;\n    } else {\n      int len = strlen(Smaz_rcb[*src]);\n      if (dstlen < len)\n        return dlen + 1;\n      memcpy(dst, Smaz_rcb[*src], len);\n      slen--;\n      src++;\n      dst += len;\n      dstlen -= len;\n    }\n  }\n\n  return dst - dest;\n}","pass":0,"source_file":"C_COMPILE/Ever-Never_androguard/elsim/elsim/similarity/libsimilarity/smaz/smaz.c"}
{"compilable":1,"function":"long rand() {\n    _lastRand = _lastRand * 71762886081639153L;\n    return _lastRand;\n}\n","function_prediction":"int rand_name_conflict() {\n  _lastRand = _lastRand * 0xfef3f6f4f3f2f1;\n  return (int)_lastRand;\n}","pass":1,"source_file":"C_COMPILE/zma_cc0/src/toolchain/test/srad.c"}
{"compilable":1,"function":"long rand_long() {\n    int lower_32bit, upper_32bit;\n    long rand_long;\n    lower_32bit = rand();\n    upper_32bit = rand();\n    return (((long)upper_32bit << 32) + lower_32bit);\n}\n","function_prediction":"long rand_long_name_conflict() {\n  long r = rand();\n  r = (r << 32) + rand();\n  return r;\n}","pass":0,"source_file":"C_COMPILE/zma_cc0/apps/kmeans/input-generator/gen-input.c"}
{"compilable":1,"function":"static int isAlphanum(int c) {\n    return ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$' || c == '\\\\' || c > 126);\n}\n","function_prediction":"int isAlphanum_name_conflict(int c) {\n  return (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') ||\n         (c >= '$' && c <= ';') || (c == '\\\\') || (c >= '~');\n}","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":0,"function":"static int get() {\n    int c = theLookahead;\n    theLookahead = (-1);\n    if (c == (-1)) {\n        c = getc(stdin);\n    }\n    if (c >= ' ' || c == '\\n' || c == (-1)) {\n        return c;\n    }\n    if (c == '\\r') {\n        return '\\n';\n    }\n    return ' ';\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":0,"function":"static int peek() {\n    theLookahead = get();\n    return theLookahead;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":0,"function":"static int next() {\n    int c = get();\n    if (c == '/') {\n        switch (peek()) {\n          case '/':\n            for (;;) {\n                c = get();\n                if (c <= '\\n') {\n                    return c;\n                }\n            }\n          case '*':\n            get();\n            for (;;) {\n                switch (get()) {\n                  case '*':\n                    if (peek() == '/') {\n                        get();\n                        return ' ';\n                    }\n                    break;\n                  case (-1):\n                    fprintf(stderr, \"Error: JSMIN Unterminated comment.\\n\");\n                    exit(1);\n                }\n            }\n          default:\n            return c;\n        }\n    }\n    return c;\n}\n","function_prediction":"int next_name_conflict() {\n  int c;\n  if (theLookahead != -1) {\n    c = theLookahead;\n    theLookahead = -1;\n    if (c == ' ' || c == '\\n' || c == '\\r' || c == -1) {\n      return c;\n    }\n    if (c == '/') {\n      theLookahead = -1;\n      return c;\n    }\n    theLookahead = -1;\n    return ' ';\n  }\n  c = getc(stdin);\n  if (c == ' ' || c == '\\n' || c == '\\r' || c == -1) {\n    return c;\n  }\n  if (c == '/') {\n    theLookahead = getc(stdin);\n    if (theLookahead == -1 || theLookahead == '\\n' || theLookahead == '\\r' ||\n        theLookahead == ' ') {\n      theLookahead = -1;\n      return '/';\n    }\n    if (theLookahead == '*') {\n      theLookahead = -1;\n      while (1) {\n        while (1) {\n          if (theLookahead != -1) {\n            break;\n          }\n          theLookahead = getc(stdin);\n          if (theLookahead == -1 || theLookahead == '\\n' ||\n              theLookahead == '\\r' || theLookahead == ' ') {\n            break;\n          }\n        }\n        if (theLookahead == -1) {\n          continue;\n        }\n        theLookahead = -1;\n        while (theLookahead == -1 && (theLookahead = getc(stdin)) != -1 &&\n               theLookahead != '\\n' && theLookahead != '\\r' &&\n               theLookahead != ' ') {\n        }\n        if (theLookahead == '*') {\n          theLookahead = -1;\n          break;\n        }\n        theLookahead = -1;\n      }\n      if (theLookahead == -","pass":0,"source_file":"C_COMPILE/glind_NullRecords/~/openlayers/tools/jsmin.c"}
{"compilable":1,"function":"unsigned short CheckSum(unsigned short *ptr, int nbytes) {\n    register long sum;\n    unsigned short oddbyte;\n    register short answer;\n    sum = 0;\n    while (nbytes > 1)\n        {\n            sum += *ptr++;\n            nbytes -= 2;\n        }\n    if (nbytes == 1) {\n        oddbyte = 0;\n        *((u_char *)&oddbyte) = *(u_char *)ptr;\n        sum += oddbyte;\n    }\n    sum = (sum >> 16) + (sum & 65535);\n    sum = sum + (sum >> 16);\n    answer = (short)~sum;\n    return (answer);\n}\n","function_prediction":"unsigned short CheckSum_name_conflict(unsigned char *pData, unsigned int len) {\n  unsigned int sum = 0;\n  unsigned int i;\n\n  for (i = 0; i < len - 1; i += 2) {\n    sum += (pData[i] << 8) + pData[i + 1];\n  }\n\n  if (i < len) {\n    sum += pData[i];\n  }\n\n  sum = (sum >> 16) + (sum & 0xffff);\n  sum += (sum >> 16);\n\n  return (unsigned short)(~sum);\n}","pass":0,"source_file":"C_COMPILE/2dango_Custom-UDP-packet/udp.c"}
{"compilable":1,"function":"size_t encode_string(char *dest, const char *src) {\n    char *start = dest, c;\n    while ((c = *(src++)))\n        {\n            switch (c) {\n              case '\\n':\n                *(dest++) = '\\\\';\n                *(dest++) = 'n';\n                break;\n              case '\\\\':\n                *(dest++) = '\\\\';\n                *(dest++) = '\\\\';\n                break;\n              case ':':\n                *(dest++) = '\\\\';\n              default:\n                *(dest++) = c;\n            }\n        }\n    *dest = '\\x00';\n    return dest - start;\n}\n","function_prediction":"int encode_string_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n\n  while (*src) {\n    switch (*src) {\n    case '\\n':\n      *d++ = '\\\\';\n      *d++ = 'n';\n      break;\n    case ':':\n      *d++ = '\\\\';\n      *d++ = ':';\n      break;\n    case '\\\\':\n      *d++ = '\\\\';\n      *d++ = '\\\\';\n      break;\n    default:\n      *d++ = *src;\n      break;\n    }\n    src++;\n  }\n  *d = '\\0';\n  return d - dest;\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/DSV.c"}
{"compilable":0,"function":"static inline unsigned int digits(unsigned int n) {\n    return n ? 1 + digits(n / 10) : n;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/redo.c"}
{"compilable":0,"function":"static char **parse_shebang(char *target, char *doscript, char *temp_output) {\n    FILE *fp = fopen(doscript, \"rb\");\n    if (!fp)\n        die_(\"(build.c:137): redo: failed to open %s: %s\\n\", doscript, strerror((*__errno_location())));\n    char *buf = xmalloc(1024);\n    buf[fread(buf, 1, 1023, fp)] = '\\x00';\n    if (ferror(fp))\n        die_(\"(build.c:141): redo: failed to read from %s: %s\\n\", doscript, strerror((*__errno_location())));\n    fclose(fp);\n    char **argv;\n    size_t i = 0;\n    if (buf[0] == '#' && buf[1] == '!') {\n        argv = parsecmd(&buf[2], &i, 5);\n    } else {\n        argv = xmalloc(7 * sizeof(char *));\n        argv[i++] = \"/bin/sh\";\n        argv[i++] = \"-e\";\n    }\n    argv[i++] = doscript;\n    argv[i++] = target;\n    char *__xpg_basename = remove_ext(target);\n    argv[i++] = __xpg_basename;\n    argv[i++] = temp_output;\n    argv[i] = ((void *)0);\n    return argv;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char **parsecmd(char *cmd, size_t *i, size_t keep_free) {\n    size_t argv_len = 16;\n    char **argv = xmalloc(argv_len * sizeof(char *));\n    size_t j = 0;\n    bool prev_space = 1;\n    for (;; ++j) {\n        switch (cmd[j]) {\n          case ' ':\n            cmd[j] = '\\x00';\n            prev_space = 1;\n            break;\n          case '\\n':\n          case '\\r':\n            cmd[j] = '\\x00';\n          case '\\x00':\n            return argv;\n          default:\n            if (!prev_space)\n                break;\n            while (*i + keep_free >= argv_len)\n                {\n                    argv_len *= 2;\n                    argv = xrealloc(argv, argv_len * sizeof(char *));\n                }\n            prev_space = 0;\n            argv[*i] = &cmd[j];\n            ++*i;\n        }\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char *xrealpath(const char *path) {\n    char *dirc = xstrdup(path);\n    char *dname = dirname(dirc);\n    char *absdir = realpath(dname, ((void *)0));\n    char *abstarget = ((void *)0);\n    if (absdir)\n        abstarget = concat(3, absdir, \"/\", xbasename(path));\n    free(dirc);\n    free(absdir);\n    return abstarget;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":1,"function":"static char *get_relpath(const char *target) {\n    char *root = getenv(\"REDO_ROOT\");\n    char *abstarget = xrealpath(target);\n    if (!abstarget)\n        return ((void *)0);\n    char *path = xstrdup(relpath(abstarget, root));\n    free(abstarget);\n    return path;\n}\n","function_prediction":"char *get_relpath_name_conflict(const char *path) {\n  char *root = getenv(\"REDO_ROOT\");\n  char *dir, *base, *rel, *tmp;\n\n  dir = xstrdup(path);\n  tmp = dirname(dir);\n  dir = realpath(tmp, NULL);\n  if (!dir) {\n    free(dir);\n    return NULL;\n  }\n  base = xbasename(path);\n  tmp = concat(3, dir, \"/\", base);\n  free(dir);\n  free(tmp);\n  if (!tmp)\n    return NULL;\n  rel = relpath(tmp, root);\n  rel = xstrdup(rel);\n  free(tmp);\n  return rel;\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"static char *get_dep_path(const char *target) {\n    char *root = getenv(\"REDO_ROOT\");\n    char *dep_path;\n    char *reltarget = get_relpath(target);\n    if (!reltarget)\n        return ((void *)0);\n    char *redodir = is_absolute(reltarget) ? \"/.redo/abs/\" : \"/.redo/rel/\";\n    dep_path = concat(3, root, redodir, reltarget);\n    mkpath(dep_path, 493);\n    free(reltarget);\n    return dep_path;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":0,"function":"int update_target(const char *target, int ident) {\n    dep_info dep = {.target = target, .path = get_dep_path(target)};\n    if (!dep.path)\n        return 1;\n    int retval = handle_ident(&dep, ident);\n    free(dep.path);\n    free(dep.hash);\n    return retval;\n}\n","function_prediction":"int update_target_name_conflict(char *target, char id) {\n  char *redo_root = getenv(\"REDO_ROOT\");\n  char *relpath = get_relpath(target);\n  char *dep_path =\n      concat(3, redo_root, is_absolute(relpath) ? \"/.redo/abs/\" : \"/.redo/rel/\",\n             relpath);\n  int ret = 0;\n  FILE *dep_file;\n  FILE *target_file;\n  struct stat statbuf;\n  struct dsv_parser dsv;\n  struct dsv_record record;\n  char *prereq_path;\n  FILE *prereq_file;\n  struct dsv_parser prereq_dsv;\n  struct dsv_record prereq_record;\n  struct sha1 *target_sha1;\n  struct sha1 *prereq_sha1;\n  int i;\n\n  mkpath(dep_path, 0755);\n  free(relpath);\n\n  if (!dep_path)\n    return 1;\n\n  switch (id) {\n  case 'a':\n    if (!fexists(target))\n      ret = 1;\n    break;\n  case 'e':\n    if (fexists(target))\n      ret = 1;\n    break;\n  case 'c':\n    dep_file = fopen(dep_path, \"rb\");\n    if (!dep_file) {\n      if (*__errno_location() != 2)\n        die_(\"(build.c:329): redo: failed to open %s: %s\\n\", dep_path,\n             strerror(*__errno_location()));\n      if (DBG_LVL >= 3)\n        fprintf(stderr,\n                \"(build.c:326): %s ood: dependency record doesn't exist\\n\",\n                target);\n      break;\n    }\n\n    dsv_init(&dsv, 4);\n    if (!dsv_parse_file(&dsv, dep_file)) {\n      if (DBG_LVL >= 3)\n                fprintf(stderr, \"(build.","pass":0,"source_file":"C_COMPILE/Tharre_redo/src/build.c"}
{"compilable":1,"function":"bool is_absolute(const char *path) {\n    return path[0] == '/';\n}\n","function_prediction":"int is_absolute_name_conflict(char *path) { return path[0] == '/'; }","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":1,"function":"char *relpath(char *path, char *start) {\n    int i;\n    for (i = 0; path[i] && start[i]; ++i) {\n        if (path[i] != start[i])\n            return path;\n    }\n    if (!path[i] && start[i])\n        return start;\n    if (!path[i] && !start[i])\n        return \".\";\n    if (path[i] == '/')\n        ++i;\n    return &path[i];\n}\n","function_prediction":"const char *relpath_name_conflict(const char *path, const char *base) {\n  int i;\n\n  for (i = 0; path[i] && base[i] && path[i] == base[i]; i++)\n    ;\n\n  if (path[i] == '/' && base[i] == '/')\n    i++;\n\n  if (path[i] == '\\0' && base[i] == '\\0')\n    return \".\";\n\n  if (base[i] == '\\0')\n    return path + i;\n\n  return path;\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":1,"function":"off_t fsize(const char *fn) {\n    struct stat st;\n    if (stat(fn, &st)) {\n        if ((*__errno_location()) != 2)\n            die_(\"(build.c:66): redo: failed to aquire stat() information about %s: %s\\n\", fn, strerror((*__errno_location())));\n        return -1;\n    }\n    return st.st_size;\n}\n","function_prediction":"long fsize_name_conflict(const char *filename) {\n  struct stat st;\n\n  if (!stat(filename, &st))\n    return st.st_size;\n\n  if (*__errno_location() == 2)\n    return -1;\n\n  die_(\"(build.c:65): redo: failed to aquire stat() information about %s: %s\\n\",\n       filename, strerror(*__errno_location()));\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":1,"function":"char *make_abs(char *root, char *path) {\n    if (!is_absolute(path))\n        return concat(3, root, \"/\", path);\n    else\n        return xstrdup(path);\n}\n","function_prediction":"char *make_abs_name_conflict(const char *dir, const char *file) {\n  if (file[0] == '/')\n    return xstrdup(file);\n  else\n    return concat(3, dir, \"/\", file);\n}","pass":1,"source_file":"C_COMPILE/Tharre_redo/src/filepath.c"}
{"compilable":0,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/c2h2_luna-buildroot-2013.08.1/package/x11r7/mcookie/mcookie.c"}
{"compilable":1,"function":"int bb_make_directory(char *path, long mode, int flags) {\n    mode_t mask;\n    const char *fail_msg;\n    char *s = path;\n    char c;\n    struct stat st;\n    mask = umask(0);\n    if (mode == -1) {\n        umask(mask);\n        mode = (64 | (64 >> 3) | ((64 >> 3) >> 3) | 128 | (128 >> 3) | ((128 >> 3) >> 3) | 256 | (256 >> 3) | ((256 >> 3) >> 3)) & ~mask;\n    } else {\n        umask(mask & ~192);\n    }\n    do {\n        c = 0;\n        if (flags & FILEUTILS_RECUR) {\n            while (*s)\n                {\n                    if (*s == '/') {\n                        do {\n                            ++s;\n                        } while (*s == '/');\n                        c = *s;\n                        *s = 0;\n                        break;\n                    }\n                    ++s;\n                }\n        }\n        if (mkdir(path, 511) < 0) {\n            if (((*__errno_location()) != 17 && (*__errno_location()) != 21) || !(flags & FILEUTILS_RECUR) || (stat(path, &st) < 0 || !((((st.st_mode)) & 61440) == (16384)))) {\n                fail_msg = \"create\";\n                umask(mask);\n                break;\n            }\n            if (!c) {\n                umask(mask);\n                return 0;\n            }\n        }\n        if (!c) {\n            umask(mask);\n            if ((mode != -1) && (chmod(path, mode) < 0)) {\n                fail_msg = \"set permissions of\";\n                break;\n            }\n            return 0;\n        }\n        *s = c;\n    } while (1);\n    bb_perror_msg(\"Cannot %s directory `%s'\", fail_msg, path);\n    return -1;\n}\n","function_prediction":"int bb_make_directory_name_conflict(const char *path, mode_t mode, int flags) {\n  int ret;\n  mode_t old_umask;\n  struct stat st;\n\n  old_umask = umask(0);\n  if (mode == (mode_t)-1)\n    mode = (mode_t)0777 & ~old_umask;\n  else\n    umask((mode_t)0777 & ~(old_umask & (mode_t)0777));\n\n  if (flags & 0x0004) {\n    const char *p = path;\n    char *q = (char *)path;\n    char c = *p;\n\n    while (c != '\\0') {\n      if (c == '/') {\n        *q = '\\0';\n        if (mkdir(path, (mode_t)0777) < 0)\n          goto error;\n        while (*p == '/')\n          p++;\n        *q = '/';\n      }\n      q++;\n      c = *p++;\n    }\n    if (mkdir(path, (mode_t)0777) < 0)\n      goto error;\n  } else {\n    if (mkdir(path, (mode_t)0777) < 0)\n      goto error;\n  }\n\n  umask(old_umask);\n  ret = chmod(path, mode);\n  if (ret < 0)\n    goto error;\n\n  return 0;\n\nerror:\n  bb_perror_msg(\"Cannot %s directory `%s'\",\n                (flags & 0x0004) ? \"create\" : \"set permissions of\", path);\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/c2h2_luna-buildroot-2013.08.1/package/makedevs/makedevs.c"}
{"compilable":1,"function":"long my_getpwnam(const char *name) {\n    struct passwd *myuser;\n    myuser = getpwnam(name);\n    if (myuser == ((void *)0))\n        bb_error_msg_and_die(\"unknown user name: %s\", name);\n    return myuser->pw_uid;\n}\n","function_prediction":"uid_t my_getpwnam_name_conflict(const char *name) {\n  struct passwd *pw;\n\n  pw = getpwnam(name);\n  if (!pw)\n    bb_error_msg_and_die(\"unknown user name: %s\", name);\n\n  return pw->pw_uid;\n}","pass":1,"source_file":"C_COMPILE/c2h2_luna-buildroot-2013.08.1/package/makedevs/makedevs.c"}
{"compilable":1,"function":"long my_getgrnam(const char *name) {\n    struct group *mygroup;\n    mygroup = getgrnam(name);\n    if (mygroup == ((void *)0))\n        bb_error_msg_and_die(\"unknown group name: %s\", name);\n    return (mygroup->gr_gid);\n}\n","function_prediction":"gid_t my_getgrnam_name_conflict(const char *name) {\n  struct group *grp;\n\n  grp = getgrnam(name);\n  if (!grp)\n    bb_error_msg_and_die(\"unknown group name: %s\", name);\n\n  return grp->gr_gid;\n}","pass":1,"source_file":"C_COMPILE/c2h2_luna-buildroot-2013.08.1/package/makedevs/makedevs.c"}
{"compilable":1,"function":"char *last_char_is(const char *s, int c) {\n    char *sret = (char *)s;\n    if (sret) {\n        sret = strrchr(sret, c);\n        if (sret != ((void *)0) && *(sret + 1) != 0)\n            sret = ((void *)0);\n    }\n    return sret;\n}\n","function_prediction":"char *last_char_is_name_conflict(char *str, int c) {\n  char *p;\n\n  if (!str)\n    return NULL;\n\n  p = strrchr(str, c);\n  if (p && !p[1])\n    return p;\n\n  return NULL;\n}","pass":1,"source_file":"C_COMPILE/c2h2_luna-buildroot-2013.08.1/package/makedevs/makedevs.c"}
{"compilable":1,"function":"char *concat_path_file(const char *path, const char *filename) {\n    char *outbuf;\n    char *lc;\n    if (!path)\n        path = \"\";\n    lc = last_char_is(path, '/');\n    while (*filename == '/')\n        filename++;\n    bb_xasprintf(&outbuf, \"%s%s%s\", path, (lc == ((void *)0) ? \"/\" : \"\"), filename);\n    return outbuf;\n}\n","function_prediction":"char *concat_path_file_name_conflict(const char *path, const char *file) {\n  char *ret;\n  const char *sep = \"\";\n\n  if (path && strrchr(path, '/') && !strrchr(path, '/')[1])\n    sep = \"\";\n  else if (*file == '/') {\n    sep = \"/\";\n    while (*file == '/')\n      file++;\n  }\n\n  bb_xasprintf(&ret, \"%s%s%s\", path, sep, file);\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/c2h2_luna-buildroot-2013.08.1/package/makedevs/makedevs.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int file_open_name_conflict(const char *path, int flags) {\n  int fd;\n\n  fd = open(path, flags);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return fd;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"int file_write_name_conflict(int fd, const char *buf, int len) {\n  int ret;\n\n  ret = write(fd, buf, len);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_valid_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int file_close_name_conflict(int fd) {\n  if (close(fd) < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"int file_read_int_fd_name_conflict(int fd, int *value) {\n  char buf[20];\n\n  lseek(fd, 0, 0);\n  if (read(fd, buf, 20) < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  *value = strtol(buf, NULL, 10);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_int_path_name_conflict(char *path, int *value) {\n  int fd, rc;\n  char buf[20];\n\n  fd = open(path, O_RDONLY);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  lseek(fd, 0, 0);\n  rc = read(fd, buf, 20);\n  if (rc < 0) {\n    perror(\"libsoc-file-debug\");\n    rc = close(fd);\n    if (rc < 0)\n      return 1;\n    return 1;\n  }\n\n  *value = strtol(buf, NULL, 10);\n\n  rc = close(fd);\n  if (rc < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_fd_name_conflict(int fd, int value) {\n  char buf[20];\n\n  sprintf(buf, \"%d\", value);\n\n  if (write(fd, buf, 20) < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_path_name_conflict(char *path, int value) {\n  int fd, ret;\n  char buf[20];\n\n  fd = open(path, 0666 | O_WRONLY);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  sprintf(buf, \"%d\", value);\n  ret = write(fd, buf, 20);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    ret = close(fd);\n    if (ret < 0)\n      return 1;\n    return 0;\n  }\n\n  ret = close(fd);\n  if (ret < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_str_name_conflict(const char *filename, char *buf, int len) {\n  int fd, ret;\n\n  fd = open(filename, O_RDONLY);\n  if (fd < 0)\n    goto err;\n\n  lseek(fd, 0, 0);\n  ret = read(fd, buf, len);\n  if (ret < 0)\n    goto err;\n\n  ret = close(fd);\n  if (ret < 0)\n    goto err;\n\n  return 0;\n\nerr:\n  perror(\"libsoc-file-debug\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_str_name_conflict(const char *filename, const char *data, int len) {\n  int fd, ret;\n\n  fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC);\n  if (fd < 0)\n    goto error;\n\n  ret = write(fd, data, len);\n  if (ret < 0)\n    goto error;\n\n  ret = close(fd);\n  if (ret < 0)\n    goto error;\n\n  return 0;\n\nerror:\n  perror(\"libsoc-file-debug\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"char *file_read_contents_name_conflict(const char *filename) {\n  struct stat st;\n  int fd;\n  char *buf;\n  int r;\n\n  if (stat(filename, &st)) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  fd = open(filename, 0);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  buf = malloc(st.st_size);\n  if (!buf)\n    return NULL;\n\n  lseek(fd, 0, 0);\n  r = read(fd, buf, st.st_size);\n  if (r < 0) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  if (r != st.st_size) {\n    free(buf);\n    return NULL;\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"spi *libsoc_spi_init(uint8_t spidev_device, uint8_t chip_select) {\n    spi *spi_dev;\n    libsoc_spi_debug(__func__, ((void *)0), \"initialising spidev device %d.%d\", spidev_device, chip_select);\n    spi_dev = malloc(sizeof(spi));\n    if (spi_dev == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"failed to allocate memory\");\n        return ((void *)0);\n    }\n    char path[40];\n    spi_dev->spi_dev = spidev_device;\n    spi_dev->chip_select = chip_select;\n    sprintf(path, \"/dev/spidev%d.%d\", spi_dev->spi_dev, spi_dev->chip_select);\n    if (!file_valid(path)) {\n        libsoc_spi_debug(__func__, spi_dev, \"%s not a vaild device\", path);\n        goto error;\n    }\n    spi_dev->fd = file_open(path, 1052672 | 2);\n    if (spi_dev->fd < 0) {\n        libsoc_spi_debug(__func__, spi_dev, \"%s could not be opened\", path);\n        goto error;\n    }\n    return spi_dev;\n  error:\n    free(spi_dev);\n    return ((void *)0);\n}\n","function_prediction":"libsoc_spi_t *libsoc_spi_init_name_conflict(unsigned int bus, unsigned int device) {\n\n  char filename[40];\n  libsoc_spi_t *spi;\n\n  spi = malloc(sizeof(libsoc_spi_t));\n  if (spi == NULL)\n    return NULL;\n\n  spi->bus = bus;\n  spi->device = device;\n\n  sprintf(filename, \"/dev/spidev%d.%d\", bus, device);\n\n  if (!file_valid(filename))\n    goto err_file_valid;\n\n  spi->file_descriptor = file_open(filename, 0664);\n  if (spi->file_descriptor < 0)\n    goto err_file_open;\n\n  return spi;\n\nerr_file_open:\n  free(spi);\n  return NULL;\n\nerr_file_valid:\n  free(spi);\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_bits_per_word(spi *spi, spi_bpw bpw) {\n    if (bpw != BITS_8 && bpw != BITS_16) {\n        libsoc_spi_debug(__func__, spi, \"bits per word was not BITS_8 or BITS_16\", bpw);\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"setting bits per word to %d\", bpw);\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &bpw);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting bits per word\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_set_bits_per_word_name_conflict(libsoc_spi *spi, uint8_t bits) {\n\n  if (bits != 8 && bits != 16 && bits != 32)\n    return 1;\n\n int ret = ioctl(spi->fd, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"spi_bpw libsoc_spi_get_bits_per_word(spi *spi) {\n    uint8_t bpw;\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &bpw);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading bits per word\");\n        return BPW_ERROR;\n    }\n    switch (bpw) {\n      case 8:\n        libsoc_spi_debug(__func__, spi, \"read bits per word as 8\");\n        return BITS_8;\n      case 16:\n        libsoc_spi_debug(__func__, spi, \"read bits per word as 16\");\n        return BITS_16;\n      default:\n        libsoc_spi_debug(__func__, spi, \"bits per word not recognised\");\n        return BPW_ERROR;\n    }\n}\n","function_prediction":"int libsoc_spi_get_bits_per_word_name_conflict(libsoc_spi *spi) {\n  int bits_per_word;\n  int ret;\n\n ret = ioctl(spi->fd, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_speed(spi *spi, uint32_t speed) {\n    libsoc_spi_debug(__func__, spi, \"setting speed to %dHz\", speed);\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(__u32)))) << ((0 + 8) + 8))), &speed);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting speed\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_set_speed_name_conflict(libsoc_spi_t *spi, uint32_t speed) {\n if (ioctl(spi->fd, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"uint32_t libsoc_spi_get_speed(spi *spi) {\n    uint32_t speed;\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(__u32)))) << ((0 + 8) + 8))), &speed);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading speed\");\n        return -1;\n    }\n    libsoc_spi_debug(__func__, spi, \"read speed as %dHz\", speed);\n    return speed;\n}\n","function_prediction":"int libsoc_spi_get_speed_name_conflict(libsoc_spi_t *spi) {\n  int speed;\n\n if (ioctl(spi->fd, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_set_mode(spi *spi, spi_mode mode) {\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"setting mode to %d\", mode);\n    uint8_t new_mode;\n    switch (mode) {\n      case MODE_0:\n        new_mode = (0 | 0);\n        break;\n      case MODE_1:\n        new_mode = (0 | (((1UL)) << (0)));\n        break;\n      case MODE_2:\n        new_mode = ((((1UL)) << (1)) | 0);\n        break;\n      case MODE_3:\n        new_mode = ((((1UL)) << (1)) | (((1UL)) << (0)));\n        break;\n      default:\n        return 1;\n    }\n    int ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((1)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &new_mode);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed setting mode\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_set_mode_name_conflict(libsoc_spi_t *spi, uint32_t mode) {\n  int ret;\n  uint32_t mode_val;\n\n  if (spi == NULL) {\n    return 1;\n  }\n\n  switch (mode) {\n  case 0:\n    mode_val = 0;\n    break;\n  case 1:\n    mode_val = 1;\n    break;\n  case 2:\n    mode_val = 2;\n    break;\n  case 3:\n    mode_val = 3;\n    break;\n  default:\n    return 1;\n  }\n\n ret = ioctl(spi->fd, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"spi_mode libsoc_spi_get_mode(spi *spi) {\n    uint8_t mode;\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return MODE_ERROR;\n    }\n    int ret = ioctl(spi->fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((1)) << 0) | ((((sizeof(__u8)))) << ((0 + 8) + 8))), &mode);\n    if (ret == -1) {\n        libsoc_spi_debug(__func__, spi, \"failed reading mode\");\n        return MODE_ERROR;\n    }\n    switch (mode) {\n      case (0 | 0):\n        libsoc_spi_debug(__func__, spi, \"read mode as 0\");\n        return MODE_0;\n      case (0 | (((1UL)) << (0))):\n        libsoc_spi_debug(__func__, spi, \"read mode as 1\");\n        return MODE_1;\n      case ((((1UL)) << (1)) | 0):\n        libsoc_spi_debug(__func__, spi, \"read mode as 2\");\n        return MODE_2;\n      case ((((1UL)) << (1)) | (((1UL)) << (0))):\n        libsoc_spi_debug(__func__, spi, \"read mode as 3\");\n        return MODE_3;\n      default:\n        libsoc_spi_debug(__func__, spi, \"mode not recognised\");\n        return MODE_ERROR;\n    }\n}\n","function_prediction":"uint8_t libsoc_spi_get_mode_name_conflict(libsoc_spi_t *spi) {\n  uint8_t mode;\n\n  if (spi == NULL) {\n    return 4;\n  }\n\n if (ioctl(spi->fd, (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_write(spi *spi, uint8_t *tx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing write transfer of %d bytes\", len);\n    if (spi == ((void *)0) || tx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi or tx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.tx_buf = (unsigned long)tx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed sending message\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_write_name_conflict(libsoc_spi_t *spi, uint8_t *data, uint32_t len) {\n\n  if (spi == NULL || data == NULL || len == 0)\n    return 1;\n\n  struct spi_ioc_transfer spi_transfer;\n  spi_transfer.tx_buf = (unsigned long)data;\n  spi_transfer.rx_buf = 0;\n  spi_transfer.len = len;\n  spi_transfer.delay_usecs = 0;\n  spi_transfer.speed_hz = 0;\n  spi_transfer.bits_per_word = 0;\n\n  int ret = ioctl(spi->fd, 0x40206b00, &spi_transfer);\n\n  if (ret < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_read(spi *spi, uint8_t *rx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing read transfer of %d bytes\", len);\n    if (spi == ((void *)0) || rx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi or rx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.rx_buf = (unsigned long)rx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed recieving message\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_read_name_conflict(libsoc_spi_t *spi, uint8_t *data, uint32_t len) {\n\n  if (spi == NULL || data == NULL || len == 0) {\n    return 1;\n  }\n\n  struct spi_ioc_transfer spi_transfer;\n  spi_transfer.tx_buf = 0;\n  spi_transfer.rx_buf = (unsigned long)data;\n  spi_transfer.len = len;\n  spi_transfer.delay_usecs = 0;\n  spi_transfer.speed_hz = 0;\n  spi_transfer.bits_per_word = 0;\n\n  int ret = ioctl(spi->fd, 0x40206b00, &spi_transfer);\n\n  if (ret < 0) {\n    return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_rw(spi *spi, uint8_t *tx, uint8_t *rx, uint32_t len) {\n    libsoc_spi_debug(__func__, spi, \"performing duplex rw transfer of %d bytes\", len);\n    if (spi == ((void *)0) || rx == ((void *)0) || tx == ((void *)0)) {\n        libsoc_spi_debug(__func__, spi, \"spi | rx | tx was NULL\");\n        return 1;\n    }\n    if (len <= 0) {\n        libsoc_spi_debug(__func__, spi, \"length was less than zero\");\n        return 1;\n    }\n    int ret;\n    struct spi_ioc_transfer tr = {.rx_buf = (unsigned long)rx, .tx_buf = (unsigned long)tx, .len = len};\n    ret = ioctl(spi->fd, (((1U) << (((0 + 8) + 8) + 14)) | ((('k')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(char[32])))) << ((0 + 8) + 8))), &tr);\n    if (ret < 1) {\n        libsoc_spi_debug(__func__, spi, \"failed duplex transfer\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int libsoc_spi_rw_name_conflict(libsoc_spi *spi, uint8_t *tx, uint8_t *rx, int len) {\n  if (spi == NULL || tx == NULL || rx == NULL || len == 0) {\n    return 1;\n  }\n\n  struct spi_ioc_transfer spi_transfer = {.tx_buf = (unsigned long)tx,\n                                          .rx_buf = (unsigned long)rx,\n                                          .len = len,\n                                          .delay_usecs = 0,\n                                          .speed_hz = 0,\n                                          .bits_per_word = 0,\n                                          .cs_change = 0};\n\n  int ret = ioctl(spi->fd, 0x40206b00, &spi_transfer);\n\n  if (ret > 0) {\n    return 0;\n  }\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_spi_free(spi *spi) {\n    if (spi == ((void *)0)) {\n        libsoc_spi_debug(__func__, ((void *)0), \"spi was not valid\");\n        return 1;\n    }\n    libsoc_spi_debug(__func__, spi, \"freeing spi device\");\n    if (file_close(spi->fd) < 0)\n        return 1;\n    free(spi);\n    return 0;\n}\n","function_prediction":"int libsoc_spi_free_name_conflict(libsoc_spi_t *spi) {\n  int result;\n\n  if (spi == NULL) {\n    return 1;\n  }\n\n  result = file_close(spi->fd);\n  if (result < 0) {\n    return 1;\n  }\n\n  free(spi);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/spi.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"void libsoc_get_debug_name_conflict(void) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmckaskill/libsoc/refs/heads/master/src/libsoc-debug.c\"\n  puts(\"libsoc-debug: warning debug support missing!\");\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"uint8_t read_status_register(spi *spi_dev) {\n    printf(\"Reading STATUS register\\n\");\n    tx[0] = 5;\n    tx[1] = 0;\n    rx[0] = 0;\n    rx[1] = 0;\n    libsoc_spi_rw(spi_dev, tx, rx, 2);\n    printf(\"STATUS is 0x%02x\\n\", rx[1]);\n    return rx[1];\n}\n","function_prediction":"uint8_t read_status_register_name_conflict(libsoc_spi_t *spi) {\n  puts(\"Reading STATUS register\");\n  tx[0] = 0x00;\n  tx[1] = 0x00;\n  libsoc_spi_rw(spi, tx, rx, 2);\n  printf(\"STATUS is 0x%02x\\n\", rx[1]);\n  return rx[1];\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int write_page(spi *spi_dev, uint16_t page_address, uint8_t *data, int len) {\n    printf(\"Writing to page %d\\n\", page_address);\n    page_address = page_address * 32;\n    tx[0] = 2;\n    tx[1] = (page_address >> 8);\n    tx[2] = page_address;\n    if (len > 32) {\n        printf(\"Page size is 32 bytes\\n\");\n        return 1;\n    }\n    int i;\n    for (i = 0; i < len; i++) {\n        tx[(i + 3)] = data[i];\n    }\n    libsoc_spi_write(spi_dev, tx, (len + 3));\n    int status;\n    do {\n        status = read_status_register(spi_dev);\n        if (status & 1) {\n            printf(\"Write in progress...\\n\");\n        } else {\n            printf(\"Write finished...\\n\");\n        }\n    } while (status & 1);\n    return 0;\n}\n","function_prediction":"int write_page_name_conflict(struct libsoc_spi *spi, int page, char *data, int len) {\n  int i;\n  unsigned short page_addr = page << 5;\n\n  printf(\"Writing to page %d\\n\", page_addr);\n\n  _tx[0] = (page_addr >> 8) & 0xff;\n  _tx[1] = page_addr & 0xff;\n  _tx[2] = 0x02;\n\n  if (len > 32) {\n    printf(\"Page size is 32 bytes\\n\");\n    return 1;\n  }\n\n  for (i = 0; i < len; i++) {\n    _tx[i + 3] = data[i];\n  }\n\n  libsoc_spi_write(spi, _tx, len + 3);\n\n  while (1) {\n    printf(\"Reading STATUS register\\n\");\n    _tx[0] = 0x00;\n    _tx[1] = 0x03;\n    rx[0] = 0;\n    libsoc_spi_rw(spi, _tx, rx, 2);\n    printf(\"STATUS is 0x%02x\\n\", rx[1]);\n    if (!(rx[0] & 0x0100)) {\n      printf(\"Write finished...\\n\");\n      break;\n    }\n    printf(\"Write in progress...\\n\");\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int read_page(spi *spi_dev, uint16_t page_address, uint8_t *data, int len) {\n    printf(\"Reading page address %d\\n\", page_address);\n    tx[0] = 3;\n    page_address = page_address * 32;\n    tx[1] = (page_address >> 8);\n    tx[2] = page_address;\n    libsoc_spi_rw(spi_dev, tx, rx, (len + 3));\n    int i;\n    for (i = 0; i < len; i++) {\n        data[i] = rx[(i + 3)];\n    }\n    return 0;\n}\n","function_prediction":"int read_page(libsoc_spi_t *spi, unsigned short page, unsigned char *data,\n              unsigned int len) {\n  unsigned short addr = page << 5;\n  unsigned int i;\n\n  printf(\"Reading page address %d\\n\", addr);\n\n  tx[0] = 0x03;\n  tx[1] = (addr >> 8) & 0xFF;\n  tx[2] = addr & 0xFF;\n\n  libsoc_spi_rw(spi, tx, rx, len + 3);\n\n  for (i = 0; i < len; i++)\n    data[i] = rx[i + 3];\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int set_write_enable(spi *spi_dev) {\n    tx[0] = 6;\n    printf(\"Setting write enable bit\\n\");\n    libsoc_spi_write(spi_dev, tx, 1);\n    return 0;\n}\n","function_prediction":"int set_write_enable_name_conflict(libsoc_spi *spi) {\n\n  tx.data[0] = 0x06;\n  puts(\"Setting write enable bit\");\n  libsoc_spi_write(spi, &tx, 1);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/test/spi_test.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int file_open_name_conflict(const char *path, int flags) {\n  int fd;\n\n  fd = open(path, flags);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return fd;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"int file_write_name_conflict(int fd, const char *buf, int len) {\n  int ret;\n\n  ret = write(fd, buf, len);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_valid_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int file_close_name_conflict(int fd) {\n  if (close(fd) < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"int file_read_int_fd_name_conflict(int fd, int *value) {\n  char buf[20];\n\n  lseek(fd, 0, 0);\n  if (read(fd, buf, 20) < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  *value = strtol(buf, NULL, 10);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_int_path_name_conflict(char *path, int *value) {\n  int fd, rc;\n  char buf[20];\n\n  fd = open(path, O_RDONLY);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  lseek(fd, 0, 0);\n  rc = read(fd, buf, 20);\n  if (rc < 0) {\n    perror(\"libsoc-file-debug\");\n    rc = close(fd);\n    if (rc < 0)\n      return 1;\n    return 1;\n  }\n\n  *value = strtol(buf, NULL, 10);\n\n  rc = close(fd);\n  if (rc < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_fd_name_conflict(int fd, int value) {\n  char buf[20];\n\n  sprintf(buf, \"%d\", value);\n\n  if (write(fd, buf, 20) < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_path_name_conflict(char *path, int value) {\n  int fd, ret;\n  char buf[20];\n\n  fd = open(path, 0666 | O_WRONLY);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  sprintf(buf, \"%d\", value);\n  ret = write(fd, buf, 20);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    ret = close(fd);\n    if (ret < 0)\n      return 1;\n    return 0;\n  }\n\n  ret = close(fd);\n  if (ret < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_str_name_conflict(const char *filename, char *buf, int len) {\n  int fd, ret;\n\n  fd = open(filename, O_RDONLY);\n  if (fd < 0)\n    goto err;\n\n  lseek(fd, 0, 0);\n  ret = read(fd, buf, len);\n  if (ret < 0)\n    goto err;\n\n  ret = close(fd);\n  if (ret < 0)\n    goto err;\n\n  return 0;\n\nerr:\n  perror(\"libsoc-file-debug\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_str_name_conflict(const char *filename, const char *data, int len) {\n  int fd, ret;\n\n  fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC);\n  if (fd < 0)\n    goto error;\n\n  ret = write(fd, data, len);\n  if (ret < 0)\n    goto error;\n\n  ret = close(fd);\n  if (ret < 0)\n    goto error;\n\n  return 0;\n\nerror:\n  perror(\"libsoc-file-debug\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"char *file_read_contents_name_conflict(const char *filename) {\n  struct stat st;\n  int fd;\n  char *buf;\n  int r;\n\n  if (stat(filename, &st)) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  fd = open(filename, 0);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  buf = malloc(st.st_size);\n  if (!buf)\n    return NULL;\n\n  lseek(fd, 0, 0);\n  r = read(fd, buf, st.st_size);\n  if (r < 0) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  if (r != st.st_size) {\n    free(buf);\n    return NULL;\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"void libsoc_get_debug_name_conflict(void) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmckaskill/libsoc/refs/heads/master/src/libsoc-debug.c\"\n  puts(\"libsoc-debug: warning debug support missing!\");\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int file_open_name_conflict(const char *path, int flags) {\n  int fd;\n\n  fd = open(path, flags);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return fd;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"int file_write_name_conflict(int fd, const char *buf, int len) {\n  int ret;\n\n  ret = write(fd, buf, len);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_valid_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int file_close_name_conflict(int fd) {\n  if (close(fd) < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"int file_read_int_fd_name_conflict(int fd, int *value) {\n  char buf[20];\n\n  lseek(fd, 0, 0);\n  if (read(fd, buf, 20) < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  *value = strtol(buf, NULL, 10);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_int_path_name_conflict(char *path, int *value) {\n  int fd, rc;\n  char buf[20];\n\n  fd = open(path, O_RDONLY);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  lseek(fd, 0, 0);\n  rc = read(fd, buf, 20);\n  if (rc < 0) {\n    perror(\"libsoc-file-debug\");\n    rc = close(fd);\n    if (rc < 0)\n      return 1;\n    return 1;\n  }\n\n  *value = strtol(buf, NULL, 10);\n\n  rc = close(fd);\n  if (rc < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_fd_name_conflict(int fd, int value) {\n  char buf[20];\n\n  sprintf(buf, \"%d\", value);\n\n  if (write(fd, buf, 20) < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_path_name_conflict(char *path, int value) {\n  int fd, ret;\n  char buf[20];\n\n  fd = open(path, 0666 | O_WRONLY);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  sprintf(buf, \"%d\", value);\n  ret = write(fd, buf, 20);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    ret = close(fd);\n    if (ret < 0)\n      return 1;\n    return 0;\n  }\n\n  ret = close(fd);\n  if (ret < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_str_name_conflict(const char *filename, char *buf, int len) {\n  int fd, ret;\n\n  fd = open(filename, O_RDONLY);\n  if (fd < 0)\n    goto err;\n\n  lseek(fd, 0, 0);\n  ret = read(fd, buf, len);\n  if (ret < 0)\n    goto err;\n\n  ret = close(fd);\n  if (ret < 0)\n    goto err;\n\n  return 0;\n\nerr:\n  perror(\"libsoc-file-debug\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_str_name_conflict(const char *filename, const char *data, int len) {\n  int fd, ret;\n\n  fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC);\n  if (fd < 0)\n    goto error;\n\n  ret = write(fd, data, len);\n  if (ret < 0)\n    goto error;\n\n  ret = close(fd);\n  if (ret < 0)\n    goto error;\n\n  return 0;\n\nerror:\n  perror(\"libsoc-file-debug\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"char *file_read_contents_name_conflict(const char *filename) {\n  struct stat st;\n  int fd;\n  char *buf;\n  int r;\n\n  if (stat(filename, &st)) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  fd = open(filename, 0);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  buf = malloc(st.st_size);\n  if (!buf)\n    return NULL;\n\n  lseek(fd, 0, 0);\n  r = read(fd, buf, st.st_size);\n  if (r < 0) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  if (r != st.st_size) {\n    free(buf);\n    return NULL;\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"void libsoc_get_debug_name_conflict(void) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmckaskill/libsoc/refs/heads/master/src/libsoc-debug.c\"\n  puts(\"libsoc-debug: warning debug support missing!\");\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int file_open_name_conflict(const char *path, int flags) {\n  int fd;\n\n  fd = open(path, flags);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return fd;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"int file_write_name_conflict(int fd, const char *buf, int len) {\n  int ret;\n\n  ret = write(fd, buf, len);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_valid_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int file_close_name_conflict(int fd) {\n  if (close(fd) < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"int file_read_int_fd_name_conflict(int fd, int *value) {\n  char buf[20];\n\n  lseek(fd, 0, 0);\n  if (read(fd, buf, 20) < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  *value = strtol(buf, NULL, 10);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_int_path_name_conflict(char *path, int *value) {\n  int fd, rc;\n  char buf[20];\n\n  fd = open(path, O_RDONLY);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  lseek(fd, 0, 0);\n  rc = read(fd, buf, 20);\n  if (rc < 0) {\n    perror(\"libsoc-file-debug\");\n    rc = close(fd);\n    if (rc < 0)\n      return 1;\n    return 1;\n  }\n\n  *value = strtol(buf, NULL, 10);\n\n  rc = close(fd);\n  if (rc < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_fd_name_conflict(int fd, int value) {\n  char buf[20];\n\n  sprintf(buf, \"%d\", value);\n\n  if (write(fd, buf, 20) < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_path_name_conflict(char *path, int value) {\n  int fd, ret;\n  char buf[20];\n\n  fd = open(path, 0666 | O_WRONLY);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  sprintf(buf, \"%d\", value);\n  ret = write(fd, buf, 20);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    ret = close(fd);\n    if (ret < 0)\n      return 1;\n    return 0;\n  }\n\n  ret = close(fd);\n  if (ret < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_str_name_conflict(const char *filename, char *buf, int len) {\n  int fd, ret;\n\n  fd = open(filename, O_RDONLY);\n  if (fd < 0)\n    goto err;\n\n  lseek(fd, 0, 0);\n  ret = read(fd, buf, len);\n  if (ret < 0)\n    goto err;\n\n  ret = close(fd);\n  if (ret < 0)\n    goto err;\n\n  return 0;\n\nerr:\n  perror(\"libsoc-file-debug\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_str_name_conflict(const char *filename, const char *data, int len) {\n  int fd, ret;\n\n  fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC);\n  if (fd < 0)\n    goto error;\n\n  ret = write(fd, data, len);\n  if (ret < 0)\n    goto error;\n\n  ret = close(fd);\n  if (ret < 0)\n    goto error;\n\n  return 0;\n\nerror:\n  perror(\"libsoc-file-debug\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"char *file_read_contents_name_conflict(const char *filename) {\n  struct stat st;\n  int fd;\n  char *buf;\n  int r;\n\n  if (stat(filename, &st)) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  fd = open(filename, 0);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  buf = malloc(st.st_size);\n  if (!buf)\n    return NULL;\n\n  lseek(fd, 0, 0);\n  r = read(fd, buf, st.st_size);\n  if (r < 0) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  if (r != st.st_size) {\n    free(buf);\n    return NULL;\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"pwm *libsoc_pwm_request(unsigned int chip, unsigned int pwm_num, shared_mode mode) {\n    pwm *new_pwm;\n    char tmp_str[256];\n    int shared = 0;\n    if (mode != LS_PWM_SHARED && mode != LS_PWM_GREEDY && mode != LS_PWM_WEAK) {\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"mode was not set, or invalid, setting mode to LS_PWM_SHARED\");\n        mode = LS_PWM_SHARED;\n    }\n    libsoc_pwm_debug(__func__, chip, pwm_num, \"requested PWM\");\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n    if (file_valid(tmp_str)) {\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"PWM already exported\");\n        switch (mode) {\n          case LS_PWM_WEAK:\n            {\n                return ((void *)0);\n            }\n          case LS_PWM_SHARED:\n            {\n                shared = 1;\n                break;\n            }\n          default:\n            {\n                break;\n            }\n        }\n    } else {\n        sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/export\", chip);\n        if (file_write_int_path(tmp_str, pwm_num) == 1) {\n            libsoc_pwm_debug(__func__, chip, pwm_num, \"write failed\");\n            return ((void *)0);\n        }\n        sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n        if (!file_valid(tmp_str)) {\n            libsoc_pwm_debug(__func__, chip, pwm_num, \"failed to export PWM\");\n            perror(\"libsoc-pwm-debug\");\n            return ((void *)0);\n        }\n    }\n    new_pwm = malloc(sizeof(pwm));\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm_num);\n    new_pwm->enable_fd = file_open(tmp_str, 1052672 | 2);\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/period\", chip, pwm_num);\n    new_pwm->period_fd = file_open(tmp_str, 1052672 | 2);\n    sprintf(tmp_str, \"/sys/class/pwm/pwmchip%d/pwm%d/duty_cycle\", chip, pwm_num);\n    new_pwm->duty_fd = file_open(tmp_str, 1052672 | 2);\n    if (new_pwm->enable_fd < 0 || new_pwm->period_fd < 0 || new_pwm->duty_fd < 0) {\n        free(new_pwm);\n        libsoc_pwm_debug(__func__, chip, pwm_num, \"Failed to open pwm sysfs file: %d\", new_pwm->enable_fd);\n        return ((void *)0);\n    }\n    new_pwm->chip = chip;\n    new_pwm->pwm = pwm_num;\n    new_pwm->shared = shared;\n    return new_pwm;\n}\n","function_prediction":"pwm_t *libsoc_pwm_request_name_conflict(int chip, int pwm, int flags) {\n  char path[256];\n  pwm_t *pwm_handle;\n  int period_fd, duty_fd, enable_fd;\n  int period_valid, duty_valid, enable_valid;\n  int enable_val;\n\n  if (flags > 2)\n    flags = 0;\n\n  sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm);\n  enable_valid = file_valid(path);\n\n  if (!enable_valid) {\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/export\", chip);\n    if (file_write_int_path(path, pwm) != 1) {\n      sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm);\n      if (!file_valid(path)) {\n        perror(\"libsoc-pwm-debug\");\n        return NULL;\n      }\n    }\n  }\n\n  if (flags == 0)\n    enable_val = 1;\n  else if (flags == 2)\n    enable_val = 0;\n  else\n    enable_val = 0;\n\n  pwm_handle = malloc(sizeof(pwm_t));\n\n  sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", chip, pwm);\n  pwm_handle->enable_fd = file_open(path, 0666);\n\n  sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/period\", chip, pwm);\n  pwm_handle->period_fd = file_open(path, 0666);\n\n  sprintf","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_free(pwm *pwm) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"freeing pwm\");\n    if (file_close(pwm->enable_fd) < 0) {\n        return 1;\n    }\n    if (file_close(pwm->period_fd) < 0) {\n        return 1;\n    }\n    if (file_close(pwm->duty_fd) < 0) {\n        return 1;\n    }\n    if (pwm->shared == 1) {\n        free(pwm);\n        return 0;\n    }\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/unexport\", pwm->chip);\n    file_write_int_path(path, pwm->pwm);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d\", pwm->chip, pwm->pwm);\n    if (file_valid(path)) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"freeing failed\");\n        return 1;\n    }\n    free(pwm);\n    return 0;\n}\n","function_prediction":"int libsoc_pwm_free_name_conflict(pwm_t *pwm) {\n  int ret;\n  char path[256];\n\n  if (pwm == NULL) {\n    return 1;\n  }\n\n  ret = file_close(pwm->period_fd);\n  if (ret < 0) {\n    return 1;\n  }\n\n  ret = file_close(pwm->duty_fd);\n  if (ret < 0) {\n    return 1;\n  }\n\n  ret = file_close(pwm->polarity_fd);\n  if (ret < 0) {\n    return 1;\n  }\n\n  if (pwm->chip_num != 1) {\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/unexport\", pwm->chip_num);\n    file_write_int_path(path, pwm->channel_num);\n\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d\", pwm->chip_num,\n            pwm->channel_num);\n    if (!file_valid(path)) {\n      return 1;\n    }\n  }\n\n  free(pwm);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_enabled(pwm *pwm, pwm_enabled enabled) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    if (enabled != ENABLED && enabled != DISABLED) {\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting enabled to %s\", pwm_enabled_strings[enabled]);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", pwm->chip, pwm->pwm);\n    return file_write_str(path, pwm_enabled_strings[enabled], 1);\n}\n","function_prediction":"int libsoc_pwm_set_enabled_name_conflict(pwm *PWM, int enabled) {\n  char path[256];\n\n  if (PWM == NULL)\n    return 1;\n\n  if (enabled != 0 && enabled != 1)\n    return 1;\n\n  sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/enable\", PWM->chip,\n          PWM->channel);\n\n  return file_write_str(path, &pwm_enabled_strings[enabled], 1);\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"pwm_enabled libsoc_pwm_get_enabled(pwm *pwm) {\n    int val;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return ENABLED_ERROR;\n    }\n    if (file_read_int_fd(pwm->enable_fd, &val) == 1) {\n        return ENABLED_ERROR;\n    }\n    if (val == 1) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"read as enabled\");\n        return ENABLED;\n    } else if (val == 0) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"read as disabled\");\n        return DISABLED;\n    } else {\n        return ENABLED_ERROR;\n    }\n}\n","function_prediction":"int libsoc_pwm_get_enabled_name_conflict(pwm *p) {\n  if (p == NULL) {\n    return -1;\n  }\n\n  int value;\n  if (file_read_int_fd(p->enable_file, &value) == 1) {\n    return -1;\n  }\n\n  if (value == 1) {\n    return 1;\n  } else if (value == 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_period(pwm *pwm, unsigned int period) {\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting period to %d\", period);\n    return file_write_int_fd(pwm->period_fd, period);\n}\n","function_prediction":"int libsoc_pwm_set_period_name_conflict(pwm *PWM, int period) {\n  if (PWM == NULL)\n    return 1;\n\n  return file_write_int_fd(PWM->period_fd, period);\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_duty_cycle(pwm *pwm, unsigned int duty) {\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting duty to %d\", duty);\n    return file_write_int_fd(pwm->duty_fd, duty);\n}\n","function_prediction":"int libsoc_pwm_set_duty_cycle_name_conflict(pwm *p, double duty_cycle) {\n  if (p == NULL)\n    return 1;\n\n  return file_write_int_fd(p->duty_cycle_fd, duty_cycle);\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_period(pwm *pwm) {\n    int period = -1;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return -1;\n    }\n    file_read_int_fd(pwm->period_fd, &period);\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got period as %d\", period);\n    return period;\n}\n","function_prediction":"int libsoc_pwm_get_period_name_conflict(pwm *p) {\n  int period = -1;\n  if (p == NULL)\n    return -1;\n  file_read_int_fd(p->period_fd, &period);\n  return period;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_duty_cycle(pwm *pwm) {\n    int duty = -1;\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return -1;\n    }\n    file_read_int_fd(pwm->duty_fd, &duty);\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got duty as %d\", duty);\n    return duty;\n}\n","function_prediction":"int libsoc_pwm_get_duty_cycle_name_conflict(libsoc_pwm *PWM) {\n  int duty_cycle = -1;\n  if (PWM == NULL) {\n    return -1;\n  }\n  file_read_int_fd(PWM->duty_cycle_fd, &duty_cycle);\n  return duty_cycle;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_set_polarity(pwm *pwm, pwm_polarity polarity) {\n    char path[256];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    if (polarity != NORMAL && polarity != INVERSED) {\n        return 1;\n    }\n    libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"setting polarity to %s\", pwm_polarity_strings[polarity]);\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", pwm->chip, pwm->pwm);\n    return file_write_str(path, pwm_polarity_strings[polarity], 256);\n}\n","function_prediction":"int libsoc_pwm_set_polarity_name_conflict(pwm_t *pwm, libsoc_pwm_polarity_t polarity) {\n  char path[256];\n\n  if (pwm == NULL)\n    return 1;\n\n  if (polarity != LIBSOC_PWM_POLARITY_NORMAL &&\n      polarity != LIBSOC_PWM_POLARITY_INVERSED)\n    return 1;\n\n  sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", pwm->chip_id,\n          pwm->pwm_id);\n\n  return file_write_str(path, &pwm_polarity_strings[polarity], 256);\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_pwm_get_polarity(pwm *pwm) {\n    int polarity;\n    char path[256];\n    char tmp_str[1];\n    if (pwm == ((void *)0)) {\n        libsoc_pwm_debug(__func__, -1, -1, \"invalid pwm pointer\");\n        return 1;\n    }\n    sprintf(path, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", pwm->chip, pwm->pwm);\n    if (file_read_str(path, tmp_str, 1) == 1) {\n        return POLARITY_ERROR;\n    }\n    if (strncmp(tmp_str, \"i\", 1) == 0) {\n        polarity = INVERSED;\n    } else if (strncmp(tmp_str, \"n\", 1) == 0) {\n        polarity = NORMAL;\n    } else {\n        polarity = POLARITY_ERROR;\n    }\n    if (polarity > 0) {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"got polarity as %s\", pwm_polarity_strings[polarity]);\n    } else {\n        libsoc_pwm_debug(__func__, pwm->chip, pwm->pwm, \"getting polarity failed\");\n    }\n    return polarity;\n}\n","function_prediction":"int libsoc_pwm_get_polarity_name_conflict(pwm_t *pwm) {\n  char buf[256];\n  char polarity;\n  int ret;\n\n  if (pwm == NULL) {\n    return 1;\n  }\n\n  sprintf(buf, \"/sys/class/pwm/pwmchip%d/pwm%d/polarity\", pwm->chip_num,\n          pwm->pwm_num);\n\n  ret = file_read_str(buf, &polarity, 1);\n  if (ret != 1) {\n    return -1;\n  }\n\n  if (polarity == 'i') {\n    return 1;\n  } else if (polarity == 'n') {\n    return 0;\n  }\n\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/pwm.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"void libsoc_get_debug_name_conflict(void) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmckaskill/libsoc/refs/heads/master/src/libsoc-debug.c\"\n  puts(\"libsoc-debug: warning debug support missing!\");\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"int file_open(const char *path, int flags) {\n    int fd = open(path, flags);\n    if (fd < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int file_open_name_conflict(const char *path, int flags) {\n  int fd;\n\n  fd = open(path, flags);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return fd;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write(int fd, const char *str, int len) {\n    int ret_len = write(fd, str, len);\n    if (ret_len < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return ret_len;\n}\n","function_prediction":"int file_write_name_conflict(int fd, const char *buf, int len) {\n  int ret;\n\n  ret = write(fd, buf, len);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_valid(char *path) {\n    if (access(path, 0) == 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_valid_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_close(int fd) {\n    if (close(fd) < 0) {\n        perror(\"libsoc-file-debug\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int file_close_name_conflict(int fd) {\n  if (close(fd) < 0) {\n    perror(\"libsoc-file-debug\");\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_fd(int fd, int *tmp) {\n    char buf[20];\n    if (file_read(fd, buf, 20) < 0) {\n        return 1;\n    }\n    *tmp = atoi(buf);\n    return 0;\n}\n","function_prediction":"int file_read_int_fd_name_conflict(int fd, int *value) {\n  char buf[20];\n\n  lseek(fd, 0, 0);\n  if (read(fd, buf, 20) < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  *value = strtol(buf, NULL, 10);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_int_path(char *path, int *tmp) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_read_int_fd(fd, tmp);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_int_path_name_conflict(char *path, int *value) {\n  int fd, rc;\n  char buf[20];\n\n  fd = open(path, O_RDONLY);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  lseek(fd, 0, 0);\n  rc = read(fd, buf, 20);\n  if (rc < 0) {\n    perror(\"libsoc-file-debug\");\n    rc = close(fd);\n    if (rc < 0)\n      return 1;\n    return 1;\n  }\n\n  *value = strtol(buf, NULL, 10);\n\n  rc = close(fd);\n  if (rc < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_fd(int fd, int val) {\n    char buf[20];\n    sprintf(buf, \"%d\", val);\n    if (file_write(fd, buf, 20) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_fd_name_conflict(int fd, int value) {\n  char buf[20];\n\n  sprintf(buf, \"%d\", value);\n\n  if (write(fd, buf, 20) < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_int_path(char *path, int val) {\n    int fd, ret;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    ret = file_write_int_fd(fd, val);\n    if (file_close(fd) < 0 || ret == 1) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_int_path_name_conflict(char *path, int value) {\n  int fd, ret;\n  char buf[20];\n\n  fd = open(path, 0666 | O_WRONLY);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return 1;\n  }\n\n  sprintf(buf, \"%d\", value);\n  ret = write(fd, buf, 20);\n  if (ret < 0) {\n    perror(\"libsoc-file-debug\");\n    ret = close(fd);\n    if (ret < 0)\n      return 1;\n    return 0;\n  }\n\n  ret = close(fd);\n  if (ret < 0)\n    return 1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_read_str(char *path, char *tmp, int buf_len) {\n    int fd;\n    fd = file_open(path, 1052672 | 0);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_read(fd, tmp, buf_len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_read_str_name_conflict(const char *filename, char *buf, int len) {\n  int fd, ret;\n\n  fd = open(filename, O_RDONLY);\n  if (fd < 0)\n    goto err;\n\n  lseek(fd, 0, 0);\n  ret = read(fd, buf, len);\n  if (ret < 0)\n    goto err;\n\n  ret = close(fd);\n  if (ret < 0)\n    goto err;\n\n  return 0;\n\nerr:\n  perror(\"libsoc-file-debug\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int file_write_str(char *path, char *buf, int len) {\n    int fd;\n    fd = file_open(path, 1052672 | 1);\n    if (fd < 0) {\n        return 1;\n    }\n    if (file_write(fd, buf, len) < 0) {\n        return 1;\n    }\n    if (file_close(fd) < 0) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int file_write_str_name_conflict(const char *filename, const char *data, int len) {\n  int fd, ret;\n\n  fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC);\n  if (fd < 0)\n    goto error;\n\n  ret = write(fd, data, len);\n  if (ret < 0)\n    goto error;\n\n  ret = close(fd);\n  if (ret < 0)\n    goto error;\n\n  return 0;\n\nerror:\n  perror(\"libsoc-file-debug\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"char *file_read_contents(const char *path) {\n    int fd;\n    struct stat st;\n    char *buf;\n    if (stat(path, &st)) {\n        perror(\"libsoc-file-debug\");\n        return ((void *)0);\n    }\n    fd = file_open(path, 0);\n    if (fd < 0)\n        return ((void *)0);\n    buf = malloc(st.st_size);\n    if (buf) {\n        if (file_read(fd, buf, st.st_size) != st.st_size) {\n            free(buf);\n            return ((void *)0);\n        }\n    }\n    return buf;\n}\n","function_prediction":"char *file_read_contents_name_conflict(const char *filename) {\n  struct stat st;\n  int fd;\n  char *buf;\n  int r;\n\n  if (stat(filename, &st)) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  fd = open(filename, 0);\n  if (fd < 0) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  buf = malloc(st.st_size);\n  if (!buf)\n    return NULL;\n\n  lseek(fd, 0, 0);\n  r = read(fd, buf, st.st_size);\n  if (r < 0) {\n    perror(\"libsoc-file-debug\");\n    return NULL;\n  }\n\n  if (r != st.st_size) {\n    free(buf);\n    return NULL;\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/file.c"}
{"compilable":0,"function":"int libsoc_get_debug() {\n    printf(\"libsoc-debug: warning debug support missing!\\n\");\n}\n","function_prediction":"void libsoc_get_debug_name_conflict(void) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jmckaskill/libsoc/refs/heads/master/src/libsoc-debug.c\"\n  puts(\"libsoc-debug: warning debug support missing!\");\n}","pass":0,"source_file":"C_COMPILE/hlummis_libsoc/lib/debug.c"}
{"compilable":0,"function":"static int wait_for_process(pid_t pid) {\n    int rv = 70;\n    int stats = 0;\n    int i = 0;\n    struct sigaction sig_handler;\n    sig_handler.__sigaction_handler.sa_handler = caught_signal;\n    sig_handler.sa_flags = 0;\n    sigaction(14, &sig_handler, ((void *)0));\n    sigaction(1, &sig_handler, ((void *)0));\n    sigaction(2, &sig_handler, ((void *)0));\n    sigaction(15, &sig_handler, ((void *)0));\n    sigaction(13, &sig_handler, ((void *)0));\n    for (i = 0; ; i++) {\n        pid_t p = waitpid(pid, &stats, 0);\n        if (p == pid) {\n            rv = (((stats) & 127) == 0) ? (((stats) & 65280) >> 8) : (128 | ((stats) & 127));\n            break;\n        } else {\n            int sig = 0;\n            switch (i) {\n              case 0:\n                sig = caught > 0 ? caught : 15;\n                if (caught == 14) {\n                    fprintf(stderr, \"Timeout.. killing the process\\n\");\n                }\n                break;\n              case 1:\n                sig = 15;\n                break;\n              default:\n                sig = 9;\n                break;\n            }\n            if (kill(pid, sig) < 0) {\n                perror(\"lost child when trying to kill\");\n            }\n            alarm(5);\n        }\n    }\n    return rv;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/shelsonjava_memcached/timedrun.c"}
{"compilable":0,"function":"unsigned int hamdist(unsigned int x, unsigned int y) {\n    unsigned int dist = 0, val = x ^ y;\n    while (val)\n        {\n            ++dist;\n            val &= val - 1;\n        }\n    return dist;\n}\n","function_prediction":"int hamdist_name_conflict(uint32_t a, uint32_t b) {\n  int dist = 0;\n  uint32_t val = a ^ b;\n\n  while (val) {\n    dist++;\n    val &= val - 1;\n  }\n\n  return dist;\n}","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Hamming_Distance/C/Arpan-Patel/HammingDistance.c"}
{"compilable":1,"function":"int partition(int a[], int lo, int hi) {\n    int i = lo, j = hi + 1, temp;\n    while (1)\n        {\n            while (a[++i] < a[lo])\n                {\n                    if (i == hi)\n                        break;\n                }\n            ;\n            while (a[lo] < a[--j])\n                {\n                    if (j == lo)\n                        break;\n                }\n            if (i >= j)\n                break;\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n        }\n    temp = a[lo];\n    a[lo] = a[j];\n    a[j] = temp;\n    return j;\n}\n","function_prediction":"int partition_name_conflict(int *a, int p, int r) {\n  int x = a[p];\n  int i = p + 1;\n  int j = r + 1;\n  int tmp;\n\n  while (1) {\n    while (a[i] < x && i < r)\n      i++;\n    while (a[j] > x && j > p)\n      j--;\n    if (i >= j)\n      break;\n    tmp = a[i];\n    a[i] = a[j];\n    a[j] = tmp;\n  }\n  tmp = a[p];\n  a[p] = a[j];\n  a[j] = tmp;\n  return j;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Quick_Sort/C/jonathanlebron/quick_sort.c"}
{"compilable":1,"function":"int parent(int i) {\n    return (int)((i + 1) / 2) - 1;\n}\n","function_prediction":"int parent_name_conflict(int i) { return (i + 1) / 2 - 1; }","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":1,"function":"int left(int i) {\n    return i * 2 + 1;\n}\n","function_prediction":"int left_name_conflict(int i) { return 2 * i + 1; }","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":1,"function":"int right(int i) {\n    return 2 * i + 2;\n}\n","function_prediction":"int right_name_conflict(int i) { return 2 * i + 2; }","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":1,"function":"int test_sorted_array(int *array, int size) {\n    int i;\n    for (i = 0; i < size - 2; i++) {\n        if (array[i] > array[i + 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"int test_sorted_array_name_conflict(int *array, int size) {\n  int i;\n\n  for (i = 1; i < size; i++) {\n    if (array[i] < array[i - 1])\n      return 0;\n  }\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Heap_Sort/C/Sweet-kid/heap_sort.c"}
{"compilable":0,"function":"int BinarySearch(TypeArray a[], TypeArray key, int first, int last) {\n    if (first > last)\n        return -1;\n    ;\n    int length = last - first + 1;\n    int midIndex = (first + last) / 2;\n    TypeArray midValue = a[midIndex];\n    if (key > midValue) {\n        return BinarySearch(a, key, midIndex + 1, last);\n    } else if (key < midValue) {\n        return BinarySearch(a, key, first, midIndex - 1);\n    } else\n        return midIndex;\n}\n","function_prediction":"void BinarySearchTest() {\n  int a[] = {1, 2, 3, 4, 5, 6, 7, 8};\n  int b[] = {1, 2, 3, 4, 5, 6, 7, 8};\n  int c[] = {1, 2, 3, 4, 5, 6, 7, 8};\n  int d[] = {1, 2, 3, 4, 5, 6, 7, 8};\n  int e[] = {1, 2, 3, 4, 5, 6, 7, 8};\n  int f[] = {1, 2, 3, 4, 5, 6, 7, 8};\n  int g[] = {1, 2, 3, 4, 5, 6, 7, 8};\n  int h[] = {1, 2, 3, 4, 5, 6, 7, 8};\n\n  printf(\"should be 0: %d\\n\", BinarySearch(a, 5, 0, 7));\n  printf(\"should be 5: %d\\n\", BinarySearch(b, 5, 0, 7));\n  printf(\"should be 4: %d\\n\", BinarySearch(c, 5, 0, 7));\n  printf(\"should be 0: %d\\n\", BinarySearch(d, 5, 0, 7));\n  printf(\"should be -1: %d\\n\", BinarySearch(e, 5, 0, 7));\n  printf(\"should be -1: %d\\n\", BinarySearch(f, 5, 0, 7));\n  printf(\"should be -1: %d\\n\", BinarySearch(g, 5, 0, 7));\n  printf(\"should be -1: %d\\n\", BinarySearch(h, 5, 0, 7));\n}","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Binary_Search/C/mariolamacchia/binarysearch.c"}
{"compilable":1,"function":"int gcd_division(int a, int b) {\n    while (b != 0)\n        {\n            int tmp = a;\n            a = b;\n            b = tmp % b;\n        }\n    return a;\n}\n","function_prediction":"int gcd_division_name_conflict(int a, int b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd_division_name_conflict(b, a % b);\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":1,"function":"int gcd_substraction(int a, int b) {\n    while (a != b)\n        {\n            if (a > b) {\n                a = a - b;\n            } else {\n                b = b - a;\n            }\n        }\n    return a;\n}\n","function_prediction":"int gcd_substraction_name_conflict(int a, int b) {\n  if (a == b)\n    return a;\n  else if (a > b)\n    return gcd_substraction_name_conflict(a - b, b);\n  else\n    return gcd_substraction_name_conflict(a, b - a);\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":1,"function":"int gcd_recursive(int a, int b) {\n    return (b == 0) ? a : gcd_recursive(b, a % b);\n}\n","function_prediction":"int gcd_recursive_name_conflict(int a, int b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd_recursive_name_conflict(b, a % b);\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Euclidean_algorithm/C/mitogh/euclidean.c"}
{"compilable":1,"function":"bool test_doors(int doors[]) {\n    for (int i = 0; i <= 99; ++i) {\n        if (doors[i] && (int)sqrt(doors[i]) % 1 != 0)\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"int test_doors_name_conflict(int *doors) {\n  int i;\n  for (i = 0; i < 100; i++) {\n    if (doors[i] != 0) {\n      double x = sqrt(doors[i]);\n    }\n  }\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/100_Doors_Problem/C/kennyledet/100-Doors.c"}
{"compilable":1,"function":"int length(char *string) {\n    int count = 0;\n    while (string[count++] != '\\x00')\n        ;\n    return --count;\n}\n","function_prediction":"int length_name_conflict(char *s) { return strlen(s); }","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":1,"function":"int exponentiation(int base, int exp) {\n    if (!exp) {\n        return 1;\n    }\n    int total = base;\n    int i = 1;\n    while (i++ < exp)\n        {\n            total *= base;\n        }\n    return total;\n}\n","function_prediction":"int exponentiation_name_conflict(int base, int exponent) {\n  int result = 1;\n  int i;\n\n  for (i = 1; i <= exponent; i++) {\n    result *= base;\n  }\n\n  return result;\n}","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":1,"function":"int parse(char *number) {\n    int size = length(number);\n    int exp = size - 1;\n    int total = 0;\n    int i;\n    for (i = 0; i < size; i++) {\n        if (number[i] >= '0' && number[i] <= '9') {\n            total += (number[i] - 48) * exponentiation(10, exp--);\n        }\n    }\n    return total;\n}\n","function_prediction":"int parse_name_conflict(char *str) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  int len = strlen(str);\n  int sum = 0;\n  for (i = 0; i < len; i++) {\n    if (str[i] >= '0' && str[i] <= '9') {\n      sum += (str[i] - '0');\n      for (j = len - 1; j > i; j--) {\n        sum *= 10;\n      }\n    }\n  }\n  return sum;\n}","pass":0,"source_file":"C_COMPILE/movb_Algorithm-Implementations/String_to_int/C/mitogh/string_to_int.c"}
{"compilable":1,"function":"int linear_search(int arr[], int size, int element) {\n    for (int i = 0; i < size; i++) {\n        if (arr[i] == element) {\n            return i;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int linear_search_name_conflict(int *array, int size, int value) {\n  int i;\n  for (i = 0; i < size; i++) {\n    if (array[i] == value) {\n      return i;\n    }\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Linear_Search/C/jay754/linear_search.c"}
{"compilable":1,"function":"unsigned long long factorial(int number) {\n    if (0 == number)\n        return 1;\n    else\n        return number * factorial(number - 1);\n}\n","function_prediction":"long factorial_name_conflict(int n) {\n  long result = 1;\n  for (int i = n; i > 0; i--) {\n    result *= i;\n  }\n  return result;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Factorial/C/harshasrisri/factorial.c"}
{"compilable":1,"function":"int fibo_r() {\n    static int a = 0, b = 1, count = 0;\n    if (0 == count) {\n        count++;\n        return a;\n    }\n    if (1 == count) {\n        count++;\n        return b;\n    }\n    return (b > a) ? (a += b) : (b += a);\n}\n","function_prediction":"int fibo_r_name_conflict(void) {\n  static int a = 0;\n  static int b = 1;\n  static int count = 0;\n\n  if (count == 0) {\n    count++;\n    return a;\n  }\n  if (count == 1) {\n    count++;\n    return b;\n  }\n  int c = a + b;\n  if (a < b) {\n    a = c;\n  } else {\n    b = c;\n  }\n  return c;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Fibonacci_series/C/harshasrisri/fibo_r.c"}
{"compilable":1,"function":"bool isSorted(int a[], int size) {\n    for (int i = 1; i < size; i++) {\n        if (a[i] < a[i - 1])\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"int isSorted_name_conflict(int *a, int n) {\n  int i;\n  for (i = 1; i < n; i++)\n    if (a[i] < a[i - 1])\n      return 0;\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Bogosort/C/jonathanlebron/bogo_sort.c"}
{"compilable":1,"function":"bool test_insertion_sort(int *sequence, int sequence_length) {\n    for (int i = 1; i < sequence_length; i++) {\n        if (sequence[i] < sequence[i - 1])\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"int test_insertion_sort_name_conflict(int *array, int size) {\n  int i;\n  for (i = 1; i < size; i++)\n    if (array[i] < array[i - 1])\n      return 0;\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/movb_Algorithm-Implementations/Insertion_Sort/C/kennyledet/insertion_sort.c"}
{"compilable":1,"function":"in_port_t get_port(struct sockaddr *sa) {\n    switch (sa->sa_family) {\n      case 2:\n        return ntohs(((struct sockaddr_in *)sa)->sin_port);\n      case 10:\n        return ntohs(((struct sockaddr_in6 *)sa)->sin6_port);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"unsigned short get_port_name_conflict(unsigned char *buf) {\n  unsigned short port;\n\n  if (buf[0] == 2 || buf[0] == 10) {\n    port = (buf[2] << 8) | buf[3];\n  } else {\n    port = 0;\n  }\n\n  return port;\n}","pass":0,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":0,"function":"int is_addr_any(struct sockaddr *sa) {\n    switch (sa->sa_family) {\n      case 2:\n        return (((struct sockaddr_in *)sa)->sin_addr.s_addr == htonl(((in_addr_t)0)));\n      case 10:\n        return !memcmp(&((struct sockaddr_in6 *)sa)->sin6_addr, &in6addr_any, sizeof (in6addr_any));\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int is_addr_any_name_conflict(struct sockaddr *sa) {\n  switch (sa->sa_family) {\n  case 2:\n    return ((struct sockaddr_in *)sa)->sin_addr.s_addr == 0;\n  case 10:\n  return (((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[0] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[1] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[2] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[3] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[4] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[5] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[6] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[7] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[8] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[9] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[10] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[11] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[12] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[13] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[14] |\n   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[15] |\n   ((struct sockaddr_in6","pass":0,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":0,"function":"int sed_the_buffer(int size, int *live) {\n    int i;\n    memmove(b2, buf, size);\n    for (i = 0; i < rules;) {\n        if (rule_live[i] == 0) {\n            i++;\n            break;\n        }\n        if (replace(b2, size, &rule[i].expression, rule[i].torig)) {\n            printf(\"\\033[32m[+] Replacing %s with %s\\n\\033[0m\", rule[i].forig, rule[i].torig);\n            rule_live[i]--;\n        }\n        i++;\n    }\n    return size;\n}\n","function_prediction":"int sed_the_buffer_name_conflict(int size) {\n  memcpy(b2, buf, size);\n  for (int i = 0; i < rules; i++) {\n    if (!rule_live[i])\n      return size;\n    if (replace(b2, size, &rule[i].find, rule[i].replace)) {\n      printf(\"\\x1b[32m\"\n             \"[+] Replacing %s with %s\\n\"\n             \"\\x1b[0m\",\n             rule[i].find, rule[i].replace);\n      rule_live[i]--;\n    }\n  }\n  return size;\n}","pass":0,"source_file":"C_COMPILE/Chaemelion_netsed/netsed.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int xpmem_init_name_conflict(void) {\n  struct stat st;\n\n  if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000)\n    return -1;\n\n  xpmem_fd = open(\"/dev/xpmem\", 2);\n  if (xpmem_fd == -1)\n    return -1;\n\n  if (fcntl(xpmem_fd, 2, 1) == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_remove_name_conflict(void *addr) {\n  struct xpmem_addr xpmem_addr;\n  struct stat st;\n\n  if (xpmem_fd == -1) {\n    if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000 ||\n        (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1)\n      return -1;\n  }\n\n  xpmem_addr.xpmem_addr = addr;\n  if (ioctl(xpmem_fd, 0x7802, &xpmem_addr) == -1) {\n    if (*__errno_location() == 2004 &&\n            (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 ||\n        ioctl(xpmem_fd, 0x7802, &xpmem_addr) == -1)\n      return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_release_name_conflict(void *addr) {\n  struct xpmem_handle handle;\n  struct stat st;\n\n  if (xpmem_fd == -1) {\n    if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000 ||\n        (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1)\n      return -1;\n  }\n\n  handle.addr = addr;\n  if (ioctl(xpmem_fd, 0x7804, &handle) == -1) {\n    if (*__errno_location() == 2004 &&\n        (xpmem_fd = open(\"/dev/xpmem\", 2)) != -1 &&\n        ioctl(xpmem_fd, 0x7804, &handle) == -1)\n      return -1;\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"int xpmem_version_name_conflict(void) {\n  int version;\n  struct stat st;\n\n  if (xpmem_fd != -1)\n    return ioctl(xpmem_fd, 0x7800, 0);\n\n  if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000)\n    return -1;\n\n  if ((xpmem_fd = open(\"/dev/xpmem\", 0x0002)) == -1)\n    return -1;\n\n  if (fcntl(xpmem_fd, 0x0002, 0x0001) == -1)\n    return -1;\n\n  if ((version = ioctl(xpmem_fd, 0x7800, 0)) == -1) {\n    if (*__errno_location() == 2004) {\n      if ((xpmem_fd = open(\"/dev/xpmem\", 0x0002)) == -1)\n        return -1;\n\n      return ioctl(xpmem_fd, 0x7800, 0);\n    }\n  }\n\n  return version;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int xpmem_init_name_conflict(void) {\n  struct stat st;\n\n  if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000)\n    return -1;\n\n  xpmem_fd = open(\"/dev/xpmem\", 2);\n  if (xpmem_fd == -1)\n    return -1;\n\n  if (fcntl(xpmem_fd, 2, 1) == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_remove_name_conflict(void *addr) {\n  struct xpmem_addr xpmem_addr;\n  struct stat st;\n\n  if (xpmem_fd == -1) {\n    if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000 ||\n        (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1)\n      return -1;\n  }\n\n  xpmem_addr.xpmem_addr = addr;\n  if (ioctl(xpmem_fd, 0x7802, &xpmem_addr) == -1) {\n    if (*__errno_location() == 2004 &&\n            (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 ||\n        ioctl(xpmem_fd, 0x7802, &xpmem_addr) == -1)\n      return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_release_name_conflict(void *addr) {\n  struct xpmem_handle handle;\n  struct stat st;\n\n  if (xpmem_fd == -1) {\n    if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000 ||\n        (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1)\n      return -1;\n  }\n\n  handle.addr = addr;\n  if (ioctl(xpmem_fd, 0x7804, &handle) == -1) {\n    if (*__errno_location() == 2004 &&\n        (xpmem_fd = open(\"/dev/xpmem\", 2)) != -1 &&\n        ioctl(xpmem_fd, 0x7804, &handle) == -1)\n      return -1;\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"int xpmem_version_name_conflict(void) {\n  int version;\n  struct stat st;\n\n  if (xpmem_fd != -1)\n    return ioctl(xpmem_fd, 0x7800, 0);\n\n  if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000)\n    return -1;\n\n  if ((xpmem_fd = open(\"/dev/xpmem\", 0x0002)) == -1)\n    return -1;\n\n  if (fcntl(xpmem_fd, 0x0002, 0x0001) == -1)\n    return -1;\n\n  if ((version = ioctl(xpmem_fd, 0x7800, 0)) == -1) {\n    if (*__errno_location() == 2004) {\n      if ((xpmem_fd = open(\"/dev/xpmem\", 0x0002)) == -1)\n        return -1;\n\n      return ioctl(xpmem_fd, 0x7800, 0);\n    }\n  }\n\n  return version;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_init(void) {\n    struct stat stb;\n    if (stat(\"/dev/xpmem\", &stb) != 0 || !((((stb.st_mode)) & 61440) == (8192)) || (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int xpmem_init_name_conflict(void) {\n  struct stat st;\n\n  if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000)\n    return -1;\n\n  xpmem_fd = open(\"/dev/xpmem\", 2);\n  if (xpmem_fd == -1)\n    return -1;\n\n  if (fcntl(xpmem_fd, 2, 1) == -1)\n    return -1;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_remove(xpmem_segid_t segid) {\n    struct xpmem_cmd_remove remove_info;\n    remove_info.segid = segid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((2)) << 0) | ((0) << ((0 + 8) + 8))), &remove_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_remove_name_conflict(void *addr) {\n  struct xpmem_addr xpmem_addr;\n  struct stat st;\n\n  if (xpmem_fd == -1) {\n    if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000 ||\n        (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1)\n      return -1;\n  }\n\n  xpmem_addr.xpmem_addr = addr;\n  if (ioctl(xpmem_fd, 0x7802, &xpmem_addr) == -1) {\n    if (*__errno_location() == 2004 &&\n            (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 ||\n        ioctl(xpmem_fd, 0x7802, &xpmem_addr) == -1)\n      return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_release(xpmem_apid_t apid) {\n    struct xpmem_cmd_release release_info;\n    release_info.apid = apid;\n    if (xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((4)) << 0) | ((0) << ((0 + 8) + 8))), &release_info) == -1)\n        return -1;\n    return 0;\n}\n","function_prediction":"int xpmem_release_name_conflict(void *addr) {\n  struct xpmem_handle handle;\n  struct stat st;\n\n  if (xpmem_fd == -1) {\n    if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000 ||\n        (xpmem_fd = open(\"/dev/xpmem\", 2)) == -1 || fcntl(xpmem_fd, 2, 1) == -1)\n      return -1;\n  }\n\n  handle.addr = addr;\n  if (ioctl(xpmem_fd, 0x7804, &handle) == -1) {\n    if (*__errno_location() == 2004 &&\n        (xpmem_fd = open(\"/dev/xpmem\", 2)) != -1 &&\n        ioctl(xpmem_fd, 0x7804, &handle) == -1)\n      return -1;\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":0,"function":"int xpmem_version(void) {\n    return xpmem_ioctl((((0U) << (((0 + 8) + 8) + 14)) | ((('x')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), ((void *)0));\n}\n","function_prediction":"int xpmem_version_name_conflict(void) {\n  int version;\n  struct stat st;\n\n  if (xpmem_fd != -1)\n    return ioctl(xpmem_fd, 0x7800, 0);\n\n  if (stat(\"/dev/xpmem\", &st) || (st.st_mode & 0170000) != 0020000)\n    return -1;\n\n  if ((xpmem_fd = open(\"/dev/xpmem\", 0x0002)) == -1)\n    return -1;\n\n  if (fcntl(xpmem_fd, 0x0002, 0x0001) == -1)\n    return -1;\n\n  if ((version = ioctl(xpmem_fd, 0x7800, 0)) == -1) {\n    if (*__errno_location() == 2004) {\n      if ((xpmem_fd = open(\"/dev/xpmem\", 0x0002)) == -1)\n        return -1;\n\n      return ioctl(xpmem_fd, 0x7800, 0);\n    }\n  }\n\n  return version;\n}","pass":0,"source_file":"C_COMPILE/hjelmn_xpmem/lib/libxpmem.c"}
{"compilable":1,"function":"int RateStatement(char *question, int *score) {\n    int response = 0;\n    printf(\"1. Agree\\n2. Nuetral\\n3. Disagree\\n\");\n    printf(\"%s: \", question);\n    scanf(\"%d\", &response);\n    switch (response) {\n      case 1:\n        *score += agree;\n        return 1;\n      case 2:\n        *score += neutral;\n        return 1;\n      case 3:\n        *score += disagree;\n      default:\n        return 0;\n    }\n    printf(\"\\n\\n\");\n}\n","function_prediction":"int RateStatement_name_conflict(char *statement, int *score) {\n  int rate = 0;\n\n  printf(\"1. Agree\\n2. Nuetral\\n3. Disagree\\n\");\n  printf(\"%s: \", statement);\n  __isoc99_scanf(\"%d\", &rate);\n\n  switch (rate) {\n  case 1:\n    *score += 10;\n    break;\n  case 2:\n    *score += 5;\n    break;\n  case 3:\n    *score -= 5;\n    break;\n  default:\n    return 0;\n  }\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/UnrealDesign_HW1/main.c"}
{"compilable":1,"function":"int AskQuestion(char *question, int *score) {\n    int response = 0;\n    printf(\"1. Yes\\n2. No\\n\");\n    printf(\"%s: \", question);\n    scanf(\"%d\", &response);\n    switch (response) {\n      case 1:\n        *score += yes;\n        printf(\"\\n\\n\");\n        return 1;\n      case 2:\n        *score += no;\n        printf(\"\\n\\n\");\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int AskQuestion_name_conflict(char *question, int *score) {\n  int answer = 0;\n  printf(\"1. Yes\\n2. No\\n\");\n  printf(\"%s: \", question);\n  __isoc99_scanf(\"%d\", &answer);\n  if (answer == 1) {\n    *score += 15;\n    printf(\"\\n\\n\");\n    return 1;\n  } else if (answer == 2) {\n    *score -= 5;\n    printf(\"\\n\\n\");\n    return 0;\n  } else {\n    return 0;\n  }\n}","pass":1,"source_file":"C_COMPILE/UnrealDesign_HW1/main.c"}
{"compilable":0,"function":"static int beenhere(int syms, int len, int left, int mem, int rem) {\n    size_t index;\n    size_t offset;\n    int bit;\n    size_t length;\n    char *vector;\n    index = (((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) + (left >> 1) - 1) * (max - 1) + len - 1);\n    mem -= 1 << root;\n    offset = (mem >> 3) + rem;\n    offset = ((offset * (offset + 1)) >> 1) + rem;\n    bit = 1 << (mem & 7);\n    length = done[index].len;\n    if (offset < length && (done[index].vec[offset] & bit) != 0)\n        return 1;\n    if (length <= offset) {\n        if (length) {\n            do {\n                length <<= 1;\n            } while (length <= offset);\n            vector = realloc(done[index].vec, length);\n            if (vector != ((void *)0))\n                memset(vector + done[index].len, 0, length - done[index].len);\n        } else {\n            length = 1 << (len - root);\n            while (length <= offset)\n                length <<= 1;\n            vector = calloc(length, sizeof(char));\n        }\n        if (vector == ((void *)0)) {\n            fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n            cleanup();\n            exit(1);\n        }\n        done[index].len = length;\n        done[index].vec = vector;\n    }\n    done[index].vec[offset] |= bit;\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Sigil-Ebook_Sigil/3rdparty/zlib/examples/enough.c"}
{"compilable":1,"function":"int generateRandom(int min, int max) {\n    return rand() % (max - min + 1) + min;\n}\n","function_prediction":"int generateRandom_name_conflict(int min, int max) {\n  return (rand() % (max - min + 1)) + min;\n}","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int getEmptyCells(struct Pos empty[], struct Square m[][4]) {\n    int i, j;\n    int n = 0;\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 4; j++)\n            if (!m[i][j].value) {\n                struct Pos temp;\n                temp.x = i;\n                temp.y = j;\n                empty[n++] = temp;\n            }\n    return n;\n}\n","function_prediction":"int getEmptyCells_name_conflict(int *emptyCells, int *board) {\n  int i = 0;\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;\n    i++;\n  }\n  if (board[i] == 0) {\n    emptyCells[i] = i;","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int playerWon(struct Square m[][4]) {\n    int i, j;\n    for (i = 0; i < 4; i++) {\n        for (j = 0; j < 4; j++) {\n            if (m[i][j].value == 2048)\n                return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int playerWon_name_conflict(int *board) {\n  int i;\n  for (i = 0; i < 9; i++) {\n    if (board[i] != 2048) {\n      return 0;\n    }\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":0,"function":"int readMove() {\n    int move, validMove = 0;\n    while (!validMove)\n        {\n            printf(\"Make a move: moves right %d, down %d, left %d, up %d \\n\", RIGHT, DOWN, LEFT, UP);\n            scanf(\"%d\", &move);\n            if (move >= 0 && move < 3)\n                validMove = 1;\n        }\n    return move;\n}\n","function_prediction":"int readMove_name_conflict(int *move) {\n  int i;\n  do {\n    printf(\"Make a move: moves right %d, down %d, left %d, up %d \\n\", 0, 1, 2,\n           3);\n    i = __isoc99_scanf(\"%d\", move);\n  } while (i < 0 || i > 3);\n}","pass":0,"source_file":"C_COMPILE/juancjara_2048-terminal/game.c"}
{"compilable":1,"function":"int gpio_export(unsigned int gpio) {\n    int fd, len;\n    char buf[64];\n    fd = open(\"/sys/class/gpio/export\", 1);\n    if (fd < 0) {\n        perror(\"gpio/export\");\n        return fd;\n    }\n    len = snprintf(buf, sizeof (buf), \"%d\", gpio);\n    write(fd, buf, len);\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_export_name_conflict(int gpio) {\n  int fd, len;\n  char buf[64];\n\n  fd = open(\"/sys/class/gpio/export\", 1);\n  if (fd < 0) {\n    perror(\"gpio/export\");\n    return fd;\n  }\n\n  len = snprintf(buf, sizeof(buf), \"%d\", gpio);\n  write(fd, buf, len);\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_unexport(unsigned int gpio) {\n    int fd, len;\n    char buf[64];\n    fd = open(\"/sys/class/gpio/unexport\", 1);\n    if (fd < 0) {\n        perror(\"gpio/export\");\n        return fd;\n    }\n    len = snprintf(buf, sizeof (buf), \"%d\", gpio);\n    write(fd, buf, len);\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_unexport_name_conflict(unsigned int gpio) {\n  char buffer[64];\n  ssize_t bytes_written;\n  int fd;\n\n  fd = open(\"/sys/class/gpio/unexport\", 1);\n  if (fd < 0) {\n    perror(\"gpio/export\");\n    return fd;\n  }\n\n  bytes_written = snprintf(buffer, 64, \"%d\", gpio);\n  write(fd, buffer, bytes_written);\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_set_dir(unsigned int gpio, char *ident, unsigned int out_flag) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/direction\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/direction\");\n        return fd;\n    }\n    if (out_flag)\n        write(fd, \"out\", 4);\n    else\n        write(fd, \"in\", 3);\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_set_dir_name_conflict(unsigned int gpio, const char *bank, int out_flag) {\n  int fd;\n  char filename[64];\n\n  snprintf(filename, sizeof(filename), \"/sys/class/gpio/gpio%d_%s/direction\",\n           gpio, bank);\n\n  fd = open(filename, 1);\n  if (fd < 0) {\n    perror(\"gpio/direction\");\n    return fd;\n  }\n\n  if (out_flag)\n    write(fd, \"out\", 4);\n  else\n    write(fd, \"in\", 3);\n\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_set_value(unsigned int gpio, char *ident, unsigned int value) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/set-value\");\n        return fd;\n    }\n    if (value)\n        write(fd, \"1\", 2);\n    else\n        write(fd, \"0\", 2);\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_set_value_name_conflict(unsigned int gpio, const char *dir, int value) {\n  int fd;\n  char buf[64];\n\n  snprintf(buf, sizeof(buf),\n           \"/sys/class/gpio\"\n           \"/gpio%d_%s/value\",\n           gpio, dir);\n\n  fd = open(buf, 1);\n  if (fd < 0) {\n    perror(\"gpio/set-value\");\n    return fd;\n  }\n\n  if (value)\n    write(fd, \"1\", 2);\n  else\n    write(fd, \"0\", 2);\n\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_get_value(unsigned int gpio, char *ident, unsigned int *value) {\n    int fd, len;\n    char buf[64];\n    char ch;\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 0);\n    if (fd < 0) {\n        perror(\"gpio/get-value\");\n        return fd;\n    }\n    read(fd, &ch, 1);\n    if (ch != '0') {\n        *value = 1;\n    } else {\n        *value = 0;\n    }\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_get_value_name_conflict(unsigned int gpio, const char *edge, int *value) {\n  char buf[64];\n  char ch;\n  int fd;\n\n  snprintf(buf, sizeof(buf),\n           \"/sys/class/gpio\"\n           \"/gpio%d_%s\"\n           \"/value\",\n           gpio, edge);\n\n  fd = open(buf, 0);\n  if (fd < 0) {\n    perror(\"gpio/get-value\");\n    return fd;\n  }\n\n  read(fd, &ch, 1);\n  *value = (ch != '0');\n\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_set_edge(unsigned int gpio, char *ident, char *edge) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/edge\", gpio, ident);\n    fd = open(buf, 1);\n    if (fd < 0) {\n        perror(\"gpio/set-edge\");\n        return fd;\n    }\n    write(fd, edge, strlen(edge) + 1);\n    close(fd);\n    return 0;\n}\n","function_prediction":"int gpio_set_edge_name_conflict(unsigned int gpio, const char *edge, const char *value) {\n  char filename[64];\n  int fd;\n\n  snprintf(filename, sizeof(filename),\n           \"/sys/class/gpio\"\n           \"/gpio%d_%s/edge\",\n           gpio, edge);\n  fd = open(filename, 1);\n  if (fd < 0) {\n    perror(\"gpio/set-edge\");\n    return fd;\n  }\n\n  write(fd, value, strlen(value) + 1);\n  close(fd);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_fd_open(unsigned int gpio, char *ident) {\n    int fd, len;\n    char buf[64];\n    len = snprintf(buf, sizeof (buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, ident);\n    fd = open(buf, 0 | 2048);\n    if (fd < 0) {\n        perror(\"gpio/fd_open\");\n    }\n    return fd;\n}\n","function_prediction":"int gpio_fd_open_name_conflict(unsigned int gpio, const char *dir) {\n  int fd;\n  char buf[64];\n\n  snprintf(buf, sizeof(buf), \"/sys/class/gpio/gpio%d_%s/value\", gpio, dir);\n  fd = open(buf, 02000);\n  if (fd < 0)\n    perror(\"gpio/fd_open\");\n  return fd;\n}","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":1,"function":"int gpio_fd_close(int fd) {\n    return close(fd);\n}\n","function_prediction":"int gpio_fd_close_name_conflict(int fd) { return PTR_close_00104028(fd); }","pass":1,"source_file":"C_COMPILE/nicowollenzin_cubieGPIO/nummernschalter.c"}
{"compilable":0,"function":"int hello(void) {\n    return 1;\n}\n","function_prediction":"int hello_name_conflict(void) { return 1; }","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/src/hello.c"}
{"compilable":0,"function":"int UnityEnd(void) {\n    {\n        putchar('\\n');\n    }\n    ;\n    UnityPrint(UnityStrBreaker);\n    {\n        putchar('\\n');\n    }\n    ;\n    UnityPrintNumber((_U_SINT)(Unity.NumberOfTests));\n    UnityPrint(UnityStrResultsTests);\n    UnityPrintNumber((_U_SINT)(Unity.TestFailures));\n    UnityPrint(UnityStrResultsFailures);\n    UnityPrintNumber((_U_SINT)(Unity.TestIgnores));\n    UnityPrint(UnityStrResultsIgnored);\n    {\n        putchar('\\n');\n    }\n    ;\n    if (Unity.TestFailures == 0U) {\n        UnityPrintOk();\n    } else {\n        UnityPrintFail();\n    }\n    {\n        putchar('\\n');\n    }\n    ;\n    ;\n    return (int)(Unity.TestFailures);\n}\n","function_prediction":"int UnityEnd_name_conflict(void) {\n  int i;\n  int n;\n  int m;\n  int d;\n\n  putc('\\n', stdout);\n  UnityPrint_part_0(\"-----------------------\");\n  putc('\\n', stdout);\n  UnityPrint_part_0(\"Tests \");\n  n = (int)Unity.TestCount;\n  if (n < 0) {\n    putc('-', stdout);\n    n = -n;\n  } else if (n == 0) {\n    putc('0', stdout);\n  }\n  m = 1;\n  for (i = 0; i < 19; i++) {\n    d = n / m;\n    if (d < 10)\n      break;\n    m *= 10;\n  }\n  while (1) {\n    d = n / m;\n    putc('0' + d, stdout);\n    if (m <= 9)\n      break;\n    n -= d * m;\n    m /= 10;\n  }\n  UnityPrint_part_0(\" Failures \");\n  n = (int)Unity.FailureCount;\n  if (n < 0) {\n    putc('-', stdout);\n    n = -n;\n  } else if (n == 0) {\n    putc('0', stdout);\n  }\n  m = 1;\n  for (i = 0; i < 19; i++) {\n    d = n / m;\n    if (d < 10)\n      break;\n    m *= 10;\n  }\n  while (1) {\n    d = n / m;\n    putc('0' + d, stdout);\n    if (m <= 9)\n      break;\n    n -= d * m;\n    m /= 10;\n  }\n  UnityPrint_part_0(\" Ignored \");\n  n = (int)Unity.IgnoreCount;\n  if (n < 0) {\n    putc('-', stdout);\n    n = -n;\n  }\n","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity.c"}
{"compilable":0,"function":"static int selected(const char *filter, const char *name) {\n    if (filter == 0)\n        return 1;\n    return strstr(name, filter) ? 1 : 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"static int testSelected(const char *test) {\n    return selected(UnityFixture.NameFilter, test);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"static int groupSelected(const char *group) {\n    return selected(UnityFixture.GroupFilter, group);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int UnityFailureCount(void) {\n    return Unity.TestFailures;\n}\n","function_prediction":"int UnityFailureCount_name_conflict(void) { return 0; }","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int UnityGetCommandLineOptions(int argc, const char *argv[]) {\n    int i;\n    UnityFixture.Verbose = 0;\n    UnityFixture.GroupFilter = 0;\n    UnityFixture.NameFilter = 0;\n    UnityFixture.RepeatCount = 1;\n    if (argc == 1)\n        return 0;\n    for (i = 1; i < argc;) {\n        if (strcmp(argv[i], \"-v\") == 0) {\n            UnityFixture.Verbose = 1;\n            i++;\n        } else if (strcmp(argv[i], \"-g\") == 0) {\n            i++;\n            if (i >= argc)\n                return 1;\n            UnityFixture.GroupFilter = argv[i];\n            i++;\n        } else if (strcmp(argv[i], \"-n\") == 0) {\n            i++;\n            if (i >= argc)\n                return 1;\n            UnityFixture.NameFilter = argv[i];\n            i++;\n        } else if (strcmp(argv[i], \"-r\") == 0) {\n            UnityFixture.RepeatCount = 2;\n            i++;\n            if (i < argc) {\n                if (*(argv[i]) >= '0' && *(argv[i]) <= '9') {\n                    UnityFixture.RepeatCount = atoi(argv[i]);\n                    i++;\n                }\n            }\n        } else {\n            i++;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int UnityGetCommandLineOptions_name_conflict(int argc, const char *argv[]) {\n  int i;\n  UnityFixture.m_Verbosity = 1;\n  UnityFixture.m_Name = NULL;\n  UnityFixture.m_Group = NULL;\n  UnityFixture.m_UnityFixture = 0;\n  for (i = 1; i < argc; ++i) {\n    const char *arg = argv[i];\n    if (arg[0] == '-' && arg[1] == 'v' && arg[2] == 0) {\n      if (i + 1 < argc) {\n        UnityFixture.m_Verbosity = (int)strtol(argv[i + 1], NULL, 10);\n        ++i;\n      }\n    } else if (arg[0] == '-' && arg[1] == 'g' && arg[2] == 0) {\n      if (i + 1 < argc) {\n        UnityFixture.m_Group = argv[i + 1];\n        ++i;\n      }\n    } else if (arg[0] == '-' && arg[1] == 'n' && arg[2] == 0) {\n      if (i + 1 < argc) {\n        UnityFixture.m_Name = argv[i + 1];\n        ++i;\n      }\n    } else if (arg[0] == '-' && arg[1] == 'r' && arg[2] == 0) {\n      UnityFixture.m_Verbosity = 2;\n    } else if (arg[0] == '-' && arg[1] == 0) {\n      UnityFixture.m_UnityFixture = 1;\n    } else {\n      return 0;\n    }\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/sunwxg_unity_fixture_test/test/src/unity_fixture.c"}
{"compilable":0,"function":"int print_jpeg_metadata(char *filename) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n        return (*__errno_location());\n    }\n    int c;\n    int lsb = 0;\n    int err = 1;\n    int offset = 0;\n    long metadata_size = 0;\n    while ((c = fgetc(f)) != (-1))\n        {\n            buf[offset++] = c;\n            if (offset >= bufsize)\n                buf_resize(0);\n            if (lsb) {\n                int pos = ftell(f) - 2;\n                int length;\n                int d;\n                if (c != 216) {\n                    if ((c & 240) != 224) {\n                        metadata_size = offset - 2;\n                        if (metadata_size != ftell(f) - 2 || metadata_size < 0) {\n                            fprintf(stderr, \"unexpected error while processing %s\\n\", filename);\n                            exit(1);\n                        }\n                        err = 0;\n                        fprintf(stderr, \"%li %s\\n\", metadata_size, filename);\n                        break;\n                    }\n                    length = 0;\n                    if ((d = fgetc(f)) == (-1)) {\n                        fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n                        exit(1);\n                    }\n                    buf[offset++] = d;\n                    if (offset >= bufsize)\n                        buf_resize(0);\n                    length += d << 8;\n                    if ((d = fgetc(f)) == (-1)) {\n                        fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n                        exit(1);\n                    }\n                    buf[offset++] = d;\n                    if (offset >= bufsize)\n                        buf_resize(0);\n                    length += d;\n                    if (length < 2) {\n                        fprintf(stderr, \"error: invalid segment length in %s\\n\", filename);\n                        exit(1);\n                    }\n                    length -= 2;\n                    if (offset + length > bufsize) {\n                        buf_resize(length);\n                    }\n                    uint16_t segment = *((uint16_t *)(buf + offset - 4));\n                    fprintf(stderr, \"segment: %02X%02X, length: %d\\n\", segment & 255, segment >> 8, length);\n                    if (length) {\n                        if (fread(buf + offset, 1, length, f) != length) {\n                            fprintf(stderr, \"error: read error while processing %s\\n\", filename);\n                            exit(1);\n                        }\n                        offset += length;\n                    }\n                }\n                lsb = 0;\n            } else if (c == 255) {\n                lsb = 1;\n            }\n        }\n    fclose(f);\n    long file_offset = ftell(output_file);\n    if (file_offset < 0) {\n        fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n        exit(1);\n    }\n    uint32_t file_offset32 = (uint32_t)file_offset;\n    if (fwrite(&file_offset32, 1, sizeof (file_offset32), index_file) != sizeof (file_offset32)) {\n        fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n        exit(1);\n    }\n    if (metadata_size) {\n        if (fwrite(buf, 1, metadata_size, output_file) != metadata_size) {\n            fprintf(stderr, \"error: write error while processing %s\\n\", filename);\n            exit(1);\n        }\n    }\n    fflush(output_file);\n    return err;\n}\n","function_prediction":"int print_jpeg_metadata_name_conflict(char *filename) {\n  FILE *file;\n  int c, i, j, k, length, segment_length, segment_type;\n  unsigned int offset;\n\n  file = fopen(filename, \"r\");\n  if (file == NULL) {\n    fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n    return *__errno_location();\n  }\n\n  i = 0;\n  j = 0;\n  while (1) {\n    c = fgetc(file);\n    if (c == -1) {\n      j = 1;\n      break;\n    }\n    buf[i++] = c;\n    if (i >= bufsize) {\n      buf = realloc(buf, bufsize + 128 * 1024);\n      if (buf == NULL) {\n        fprintf(stderr, \"error: out of memory !\\n\");\n        exit(1);\n      }\n    }\n    if (j == 0) {\n      if (c == 0xff) {\n        j = 1;\n      }\n    } else {\n      if (c == 0xd8) {\n        j = 0;\n      } else if ((c & 0xf0) == 0xe0) {\n        segment_type = c;\n        c = fgetc(file);\n        if (c == -1) {\n          fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n          exit(1);\n        }\n        buf[i++] = c;\n        if (i >= bufsize) {\n          buf = realloc(buf, bufsize + 128 * 1024);\n          if (buf == NULL) {\n            fprintf(stderr, \"error: out of memory !\\n\");\n            exit(1);\n          }\n        }\n        c = fgetc(file);\n        if (c == -1) {\n          fprintf(stderr, \"error: unexpected end of file %s\\n\", filename);\n          exit(1);\n        }\n        buf[i++] = c;\n        if","pass":0,"source_file":"C_COMPILE/bugdanov_jpeg_metadata_size/jpeg_metadata.c"}
{"compilable":1,"function":"int print_jpeg_metadata_size(char *filename) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n        return (*__errno_location());\n    }\n    int c;\n    int lsb = 0;\n    int err = 0;\n    while ((c = fgetc(f)) != (-1))\n        {\n            if (lsb) {\n                int pos = ftell(f) - 2;\n                int length;\n                int d;\n                if (c != 216) {\n                    if ((c & 240) != 224) {\n                        printf(\"%d %s\\n\", ftell(f) - 2, filename);\n                        break;\n                    }\n                    length = 0;\n                    if ((d = fgetc(f)) == (-1))\n                        break;\n                    length += d << 8;\n                    if ((d = fgetc(f)) == (-1))\n                        break;\n                    length += d;\n                    if (length < 2) {\n                        fprintf(stderr, \"error: invalid segment length in %s\\n\", filename);\n                        err = 1;\n                        break;\n                    }\n                    if (length && fseek(f, length - 2, 1) < 0) {\n                        fprintf(stderr, \"error: i/o error with %s\\n\", filename);\n                        err = (*__errno_location());\n                        break;\n                    }\n                }\n                lsb = 0;\n            } else if (c == 255) {\n                lsb = 1;\n            }\n        }\n    fclose(f);\n    return err;\n}\n","function_prediction":"int print_jpeg_metadata_size_name_conflict(char *filename) {\n  FILE *fp;\n  int c, s, m, l, e, i;\n  int in_soi = 0;\n\n  fp = fopen(filename, \"r\");\n  if (fp == NULL) {\n    fprintf(stderr, \"error: cannot open file %s\\n\", filename);\n    return errno;\n  }\n\n  while ((c = fgetc(fp)) != -1) {\n    if (in_soi) {\n      if (c == 0xD8) {\n        in_soi = 0;\n        continue;\n      }\n      if ((c & 0xF0) == 0xE0) {\n        if ((s = fgetc(fp)) == -1)\n          break;\n        if ((m = fgetc(fp)) == -1)\n          break;\n        l = s * 256 + m;\n        if (l < 2) {\n          fprintf(stderr, \"error: invalid segment length in %s\\n\", filename);\n          break;\n        }\n        if (fseek(fp, l - 2, 1) < 0) {\n          fprintf(stderr, \"error: i/o error with %s\\n\", filename);\n          return errno;\n        }\n        continue;\n      }\n      printf(\"%d %s\\n\", ftell(fp) - 2, filename);\n      break;\n    }\n    if (c == 0xFF)\n      in_soi = 1;\n  }\n  fclose(fp);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/bugdanov_jpeg_metadata_size/jpeg_metadata_size.c"}
{"compilable":0,"function":"int mread(int s, char *bufp, unsigned int n) {\n    register unsigned int count = 0;\n    register int nread;\n    do {\n        nread = read(s, bufp, n - count);\n        numCalls++;\n        if (nread < 0) {\n            perror(\"ttcp_mread\");\n            return (-1);\n        }\n        if (nread == 0)\n            return ((int)count);\n        count += (unsigned int)nread;\n        bufp += nread;\n    } while (count < n);\n    return ((int)count);\n}\n","function_prediction":"int mread_name_conflict(int fd, char *buf, int len) {\n  int nread = 0;\n  int n;\n\n  while (nread < len) {\n    n = read(fd, buf, len - nread);\n    numCalls++;\n    if (n < 0) {\n      perror(\"ttcp_mread_name_conflict\");\n      return -1;\n    }\n    if (n == 0)\n      break;\n    nread += n;\n    buf += n;\n  }\n  return nread;\n}","pass":0,"source_file":"C_COMPILE/hynnet_openwrt-mt7620/feeds/packages/net/ttcp/ttcp.c"}
{"compilable":0,"function":"int testfunction(int arg1, int *arg2) {\n    return arg2[arg1];\n}\n","function_prediction":"int testfunction_name_conflict(int i, int *a) { return a[i]; }","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int test2function(void) {\n    return 0;\n}\n","function_prediction":"int test2function_name_conflict(int a) {\n  int b = 0;\n  int c = 0;\n  int d = 0;\n  int e = 0;\n  int f = 0;\n  int g = 0;\n  int h = 0;\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u = 0;\n  int v = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n  int aa = 0;\n  int ab = 0;\n  int ac = 0;\n  int ad = 0;\n  int ae = 0;\n  int af = 0;\n  int ag = 0;\n  int ah = 0;\n  int ai = 0;\n  int aj = 0;\n  int ak = 0;\n  int al = 0;\n  int am = 0;\n  int an = 0;\n  int ao = 0;\n  int ap = 0;\n  int aq = 0;\n  int ar = 0;\n  int as = 0;\n  int at = 0;\n  int au = 0;\n  int av = 0;\n  int aw = 0;\n  int ax = 0;\n  int ay = 0;\n  int az = 0;\n  int ba = 0;\n  int bb = 0;\n  int bc = 0;\n  int bd = 0;\n  int be = 0;\n  int bf = 0;\n  int bg = 0;\n  int bh = 0;\n  int bi = 0;\n  int bj = 0;\n  int bk = 0;\n  int bl = 0;\n  int bm = 0;\n  int bn = 0;\n  int bo = 0;\n  int bp = 0;\n  int bq = 0;\n  int br = 0;\n","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int test4function(const int arg1) {\n    return carray[arg1];\n}\n","function_prediction":"int test4function_name_conflict(int i) { return carray[i]; }","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int possibly_duplicate_function() {\n    return 0;\n}\n","function_prediction":"int possibly_duplicate_function_name_conflict(void) { return 0; }","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int possibly_dupli_function() {\n    return 1;\n}\n","function_prediction":"int possibly_dupli_function_name_conflict(void) { return 1; }","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int is_char_signed(int arg) {\n    if (arg == 189) {\n        return 0;\n    } else if (arg != -67) {\n        printf(\"Hmm, it seems 'char' is not eight bits wide on your machine.\\n\");\n        printf(\"I fear the JPEG software will not work at all.\\n\\n\");\n    }\n    return 1;\n}\n","function_prediction":"int is_char_signed_name_conflict(void) {\n  if (sizeof(char) == 127)\n    return 0;\n  if (sizeof(char) == -67)\n    return 1;\n  puts(\"Hmm, it seems 'char' is not eight bits wide on your machine.\");\n  puts(\"I fear the JPEG software will not work at all.\\n\");\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"int is_shifting_signed(long arg) {\n    long res = arg >> 4;\n    if (res == -133687308L) {\n        return 1;\n    }\n    res |= (~0L) << (32 - 4);\n    if (res == -133687308L) {\n        return 0;\n    }\n    printf(\"Right shift isn't acting as I expect it to.\\n\");\n    printf(\"I fear the JPEG software will not work at all.\\n\\n\");\n    return 0;\n}\n","function_prediction":"int is_shifting_signed_name_conflict(void) {\n  if ((((int)0x80000000L) >> (4)) != -1)\n    return 1;\n  if ((((int)0x80000000L) >> (4) | 0xF0000000) != -1)\n    return 0;\n  puts(\"Right shift isn't acting as I expect it to.\");\n  puts(\"I fear the JPEG software will not work at all.\\n\");\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/davidfof13_fypMedicalImagingProject/annotationTools/libjpeg/ckconfig.c"}
{"compilable":0,"function":"static int pmu_can_sleep(const int fd) {\n    unsigned long arg = 0;\n    if (ioctl(fd, (((2U) << (((0 + 8) + 8) + 14)) | ((('B')) << (0 + 8)) | (((5)) << 0) | ((((sizeof(size_t)))) << ((0 + 8) + 8))), &arg) < 0 || arg != 1)\n        return 1;\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-pmu.c"}
{"compilable":0,"function":"static int pmu_sleep(const int fd) {\n    unsigned long arg = 0;\n    if (ioctl(fd, (((0U) << (((0 + 8) + 8) + 14)) | ((('B')) << (0 + 8)) | (((0)) << 0) | ((0) << ((0 + 8) + 8))), arg) < 0)\n        return 1;\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-pmu.c"}
{"compilable":1,"function":"off_t get_sig_offset(int orig) {\n    int pagesize = sysconf(_SC_PAGESIZE);\n    return (off_t)((sizeof(char) * pagesize) - (orig ? 20 : 10));\n}\n","function_prediction":"size_t get_sig_offset_name_conflict(int is_32bit) {\n  return (size_t)sysconf(_SC_PAGESIZE) - (is_32bit ? 20 : 16);\n}","pass":0,"source_file":"C_COMPILE/openSUSE_pm-utils/src/pm-reset-swap.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len;\n  unsigned long hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = hash * 257 + word[i];\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 1 + (unsigned int)length;\n  for (hash = 0; length > 0; length--)\n    hash = hash * a + (unsigned int)word[length - 1];\n  hash = hash % 500000000;\n  a = vocab_hash[hash];\n  while (a != -1) {\n    if (!strcmp(word, vocab[a].word))\n      return a;\n    else\n      hash = (hash + 1) % 500000000;\n    a = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  long long len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 500000000;\n  while (vocab_hash[hash] != -1) {\n    hash = (hash + 1) % 500000000;\n  }\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len, hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = (hash << 8) + word[i];\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 0;\n  hash = 0;\n  for (int i = 0; i < length; i++) {\n    hash = hash * 257 + word[i];\n    a = a * 257 + word[i];\n  }\n  hash = hash % 30000000;\n  a = a % 30000000;\n  int hentry = vocab_hash[hash];\n  while (hentry != -1) {\n    if (!strcmp(word, vocab[hentry].word)) {\n      return hentry;\n    }\n    hash = (hash + 1) % 30000000;\n    a = (a + 1) % 30000000;\n    hentry = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  int length = strlen(word) + 1;\n  if (length > 100)\n    length = 100;\n  vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 30000000;\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 30000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/Cherishzhang_word2vec/word2vec.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro_ArvoreB(char *arquivo, uint32_t id) {\n    FILE *arq_arv;\n    uint16_t raiz;\n    uint16_t offset;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0)\n        return 0;\n    Busca_Recursiva_ArvoreB(arq_arv, raiz, id, &offset);\n    return offset;\n}\n","function_prediction":"short Buscar_Registro_ArvoreB_name_conflict(char *nome_arquivo, int chave) {\n  FILE *arquivo;\n  short raiz, retorno[5];\n\n  arquivo = fopen(nome_arquivo, \"r+\");\n\n  fseek(arquivo, 2, 0);\n  fread(&raiz, sizeof(short), 1, arquivo);\n\n  if (raiz != 0) {\n    Busca_Recursiva_ArvoreB(arquivo, raiz, chave, retorno);\n    raiz = retorno[0];\n  }\n\n  return raiz;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Inserir_No_ArvoreB(char *arquivo, uint32_t id, uint16_t offset) {\n    uint16_t raiz;\n    uint16_t raiz_pos;\n    uint16_t nova_rrn;\n    uint16_t promo_r_child;\n    uint32_t promo_key_id;\n    uint16_t promo_key_offset;\n    uint8_t flag;\n    FILE *arq_arv;\n    no_arvore_b_t nova;\n    no_arvore_b_t raiz_a;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0) {\n        nova.n = 1;\n        nova.id[0] = id;\n        nova.offset[0] = offset;\n        nova.filhas[0] = 0;\n        nova.filhas[1] = 0;\n        nova_rrn = (Criar_Pagina(arq_arv, nova));\n        fseek(arq_arv, 2, 0);\n        fwrite(&nova_rrn, sizeof(uint16_t), 1, arq_arv);\n    } else {\n        flag = Recursive_Insertion(arq_arv, raiz, id, offset, &promo_r_child, &promo_key_id, &promo_key_offset);\n        switch (flag) {\n          case 2:\n            raiz_a.filhas[0] = raiz;\n            raiz_a.id[0] = promo_key_id;\n            raiz_a.offset[0] = promo_key_offset;\n            raiz_a.filhas[1] = promo_r_child;\n            raiz_a.n = 1;\n            raiz = Criar_Pagina(arq_arv, raiz_a);\n            fseek(arq_arv, 2, 0);\n            fwrite(&raiz, sizeof(uint16_t), 1, arq_arv);\n            break;\n          case 1:\n            break;\n          case 0:\n            break;\n        }\n    }\n    fclose(arq_arv);\n    return nova_rrn;\n}\n","function_prediction":"short Inserir_No_ArvoreB_name_conflict(char *nome_arquivo, int chave, short valor) {\n  FILE *arquivo;\n  short raiz, novo_no, novo_no_pai, novo_no_pai_pai, novo_no_pai_pai_pai;\n  short resultado;\n  short pagina_atual;\n  short pagina_pai;\n  short pagina_pai_pai;\n  short pagina_pai_pai_pai;\n\n  arquivo = fopen(nome_arquivo, \"r+\");\n\n  fseek(arquivo, 2, 0);\n  fread(&pagina_atual, sizeof(short), 1, arquivo);\n\n  if (pagina_atual == 0) {\n    novo_no = Criar_Pagina(arquivo);\n    raiz = novo_no;\n\n    fseek(arquivo, 2, 0);\n    fwrite(&raiz, sizeof(short), 1, arquivo);\n\n    fclose(arquivo);\n\n    return novo_no;\n  }\n\n  resultado =\n      Recursive_Insertion(arquivo, pagina_atual, chave, valor, &novo_no_pai,\n                          &novo_no_pai_pai, &novo_no_pai_pai_pai);\n\n  if (resultado == 2) {\n    novo_no = Criar_Pagina(arquivo);\n    raiz = novo_no;\n\n    fseek(arquivo, 2, 0);\n    fwrite(&raiz, sizeof(short), 1, arquivo);\n\n    fclose(arquivo);\n\n    return novo_no;\n  }\n\n  fclose(arquivo);\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint8_t Inicializar_ArvoreB(char *arquivo) {\n    FILE *nova;\n    uint16_t ped = 0;\n    uint16_t raiz = 0;\n    nova = fopen(arquivo, \"r\");\n    if (nova == ((void *)0)) {\n        nova = fopen(arquivo, \"w\");\n        if (nova == ((void *)0))\n            return 0;\n        fwrite(&ped, sizeof(uint16_t), 1, nova);\n        fwrite(&raiz, sizeof(uint16_t), 1, nova);\n        fclose(nova);\n        return 2;\n    }\n    fclose(nova);\n    return 1;\n}\n","function_prediction":"int Inicializar_ArvoreB_name_conflict(char *nome_arquivo) {\n  FILE *arquivo;\n  unsigned short raiz = 0;\n  unsigned short folhas = 0;\n\n  if ((arquivo = fopen(nome_arquivo, \"r\")) != NULL) {\n    fclose(arquivo);\n    return 1;\n  }\n\n  if ((arquivo = fopen(nome_arquivo, \"w\")) == NULL)\n    return 0;\n\n  fwrite(&raiz, sizeof(unsigned short), 1, arquivo);\n  fwrite(&folhas, sizeof(unsigned short), 1, arquivo);\n\n  fclose(arquivo);\n\n  return 2;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t POS_to_RRN(uint16_t POS) {\n    POS -= 4;\n    POS /= sizeof(no_arvore_b_t);\n    POS += 1;\n    return POS;\n}\n","function_prediction":"int POS_to_RRN_name_conflict(int pos) { return (pos - 4) / 40 + 1; }","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t RRN_to_POS(uint16_t RRN) {\n    --RRN;\n    RRN *= sizeof(no_arvore_b_t);\n    RRN += 4;\n    return RRN;\n}\n","function_prediction":"int RRN_to_POS_name_conflict(int RRN) { return (RRN * 5 - 5) * 8 + 4; }","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Remocao_Arvore_B(char *arquivo, uint32_t id) {\n    FILE *arq_arv;\n    uint16_t raiz;\n    uint16_t offset;\n    uint16_t rrn;\n    no_arvore_b_t pagina;\n    int i;\n    arq_arv = fopen(arquivo, \"r+\");\n    fseek(arq_arv, 2, 0);\n    fread(&raiz, sizeof(uint16_t), 1, arq_arv);\n    if (raiz == 0)\n        return 0;\n    rrn = Busca_Recursiva_ArvoreB(arq_arv, raiz, id, &offset);\n    if (rrn == 0)\n        return 0;\n    fseek(arq_arv, RRN_to_POS(rrn), 0);\n    Carregar_Pagina(arq_arv, &pagina);\n    i = 0;\n    while (pagina.id[i] != id)\n        ++i;\n    pagina.offset[i] = 0;\n    fseek(arq_arv, RRN_to_POS(rrn), 0);\n    Escrever_Pagina(arq_arv, pagina);\n    fclose(arq_arv);\n    return rrn;\n}\n","function_prediction":"int Remocao_Arvore_B_name_conflict(char *nome_arquivo, int chave) {\n  FILE *arquivo;\n  arquivo = fopen(nome_arquivo, \"r+\");\n\n  short raiz;\n  fseek(arquivo, 2, 0);\n  fread(&raiz, sizeof(short), 1, arquivo);\n\n  if (raiz == 0)\n    return 0;\n\n  int posicao;\n  posicao = Busca_Recursiva_ArvoreB(arquivo, raiz, chave);\n\n  if (posicao == 0)\n    return 0;\n\n  int posicao_no;\n  posicao_no = (posicao - 1) * 5 + 4;\n  fseek(arquivo, posicao_no, 0);\n\n  int posicao_atual;\n  posicao_atual = ftell(arquivo);\n\n  No_ArvoreB no;\n  fread(&no, sizeof(No_ArvoreB), 1, arquivo);\n\n  int i;\n  for (i = 0; i < 3; i++) {\n    if (no.chaves[i] == chave) {\n      no.chaves[i] = 0;\n      break;\n    }\n  }\n\n  fseek(arquivo, posicao_no, 0);\n  fwrite(&no, sizeof(No_ArvoreB), 1, arquivo);\n\n  fclose(arquivo);\n\n  return posicao;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arvore_b.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro_Com_Indice(char *caminho_registro, uint32_t id, registro_t *registro) {\n    FILE *arq_reg;\n    char caminho_indice[128];\n    uint16_t pos;\n    int i;\n    char c;\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    pos = Buscar_Registro_ArvoreB(caminho_indice, id);\n    if (pos != 0 && registro != ((void *)0)) {\n        arq_reg = fopen(caminho_registro, \"r\");\n        fseek(arq_reg, pos + 2, 0);\n        fread(&(registro->id), sizeof(uint32_t), 1, arq_reg);\n        fgetc(arq_reg);\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->autor[i] = c;\n                ++i;\n            }\n        registro->autor[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->titulo[i] = c;\n                ++i;\n            }\n        registro->titulo[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->curso[i] = c;\n                ++i;\n            }\n        registro->curso[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->tipo[i] = c;\n                ++i;\n            }\n        registro->tipo[i] = '\\x00';\n        fclose(arq_reg);\n    }\n    return pos;\n}\n","function_prediction":"int Buscar_Registro_Com_Indice_name_conflict(char *nome_arquivo, int chave, Registro *reg) {\n  char nome_arquivo_indice[128];\n  int i, j, posicao;\n  FILE *arquivo;\n\n  i = 0;\n  j = 0;\n  if (nome_arquivo[0] == '.') {\n    nome_arquivo_indice[i++] = '.';\n    j++;\n  }\n  while (nome_arquivo[j] != '\\0' && nome_arquivo[j] != '.') {\n    nome_arquivo_indice[i++] = nome_arquivo[j++];\n  }\n  nome_arquivo_indice[i] = '\\0';\n  i = strlen(nome_arquivo_indice);\n  nome_arquivo_indice[i++] = '.';\n  nome_arquivo_indice[i++] = 'i';\n  nome_arquivo_indice[i++] = 'd';\n  nome_arquivo_indice[i++] = 'i';\n  nome_arquivo_indice[i++] = 'e';\n  nome_arquivo_indice[i] = '\\0';\n\n  posicao = Buscar_Registro_ArvoreB(nome_arquivo_indice, chave);\n\n  if (posicao != 0 && reg != NULL) {\n    arquivo = fopen(nome_arquivo, \"r\");\n    fseek(arquivo, posicao + 2, 0);\n    fread(reg, sizeof(Registro), 1, arquivo);\n    fgetc(arquivo);\n    i = 0;\n    while ((reg->nome[i] = fgetc(arquivo)) != '|') {\n      i++;\n    }\n    reg->nome[i] = '\\0';\n    i = 0;\n    while","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Buscar_Registro(char *caminho_registro, uint32_t id, registro_t *registro) {\n    FILE *arq_reg;\n    uint32_t id_c;\n    uint16_t tamanho_c;\n    int tamanho_arq;\n    uint16_t retorno = 2;\n    char is_vazio;\n    int i;\n    char c;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r\");\n    fseek(arq_reg, 0, 2);\n    tamanho_arq = ftell(arq_reg);\n    fseek(arq_reg, 2, 0);\n    fread(&tamanho_c, sizeof(uint16_t), 1, arq_reg);\n    fread(&id_c, sizeof(uint32_t), 1, arq_reg);\n    fseek(arq_reg, tamanho_c - 4, 1);\n    while (id_c != id && ftell(arq_reg) < tamanho_arq)\n        {\n            retorno = ftell(arq_reg);\n            fread(&tamanho_c, sizeof(uint16_t), 1, arq_reg);\n            is_vazio = fgetc(arq_reg);\n            if (is_vazio == '*') {\n                id_c = id + 1;\n                fseek(arq_reg, tamanho_c - 1, 1);\n            } else {\n                fseek(arq_reg, -1, 1);\n                fread(&id_c, sizeof(uint32_t), 1, arq_reg);\n                fseek(arq_reg, tamanho_c - 4, 1);\n            }\n        }\n    if (id_c != id)\n        retorno = 0;\n    else if (registro != ((void *)0)) {\n        fseek(arq_reg, retorno + 7, 0);\n        registro->id = id_c;\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->autor[i] = c;\n                ++i;\n            }\n        registro->autor[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->titulo[i] = c;\n                ++i;\n            }\n        registro->titulo[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->curso[i] = c;\n                ++i;\n            }\n        registro->curso[i] = '\\x00';\n        i = 0;\n        while ((c = fgetc(arq_reg)) != '|')\n            {\n                registro->tipo[i] = c;\n                ++i;\n            }\n        registro->tipo[i] = '\\x00';\n    }\n    fclose(arq_reg);\n    return retorno;\n}\n","function_prediction":"short Buscar_Registro_ArvoreB(char *nome_arquivo, int chave) {\n  FILE *arquivo;\n  short raiz, retorno[5];\n\n  arquivo = fopen(nome_arquivo, \"r+\");\n\n  fseek(arquivo, 2, 0);\n  fread(&raiz, sizeof(short), 1, arquivo);\n\n  if (raiz != 0) {\n    Busca_Recursiva_ArvoreB(arquivo, raiz, chave, retorno);\n    raiz = retorno[0];\n  }\n\n  return raiz;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Calcular_Tamanho(registro_t registro) {\n    uint16_t retorno = 0;\n    retorno += 5;\n    retorno += sizeof(uint32_t);\n    retorno += strlen(registro.autor);\n    retorno += strlen(registro.titulo);\n    retorno += strlen(registro.curso);\n    retorno += strlen(registro.tipo);\n    return retorno;\n}\n","function_prediction":"int Calcular_Tamanho_name_conflict() {\n  int tamanho = 0;\n\n  tamanho += strlen(\"int\");\n  tamanho += strlen(\" \");\n  tamanho += strlen(\"main\");\n  tamanho += strlen(\"(\");\n  tamanho += strlen(\")\");\n  tamanho += strlen(\"{\\n\");\n  tamanho += strlen(\"int\");\n  tamanho += strlen(\" \");\n  tamanho += strlen(\"a\");\n  tamanho += strlen(\";\");\n  tamanho += strlen(\"\\n\");\n  tamanho += strlen(\"int\");\n  tamanho += strlen(\" \");\n  tamanho += strlen(\"b\");\n  tamanho += strlen(\";\");\n  tamanho += strlen(\"\\n\");\n  tamanho += strlen(\"int\");\n  tamanho += strlen(\" \");\n  tamanho += strlen(\"c\");\n  tamanho += strlen(\";\");\n  tamanho += strlen(\"\\n\");\n  tamanho += strlen(\"a\");\n  tamanho += strlen(\" = \");\n  tamanho += strlen(\"10\");\n  tamanho += strlen(\";\");\n  tamanho += strlen(\"\\n\");\n  tamanho += strlen(\"b\");\n  tamanho += strlen(\" = \");\n  tamanho += strlen(\"20\");\n  tamanho += strlen(\";\");\n  tamanho += strlen(\"\\n\");\n  tamanho += strlen(\"c\");\n  tamanho += strlen(\" = \");\n  tamanho += strlen(\"30\");\n  tamanho += strlen(\";\");\n  tamanho += strlen(\"\\n\");\n  tamanho += strlen(\"int\");\n  tamanho += strlen(\" \");\n  tamanho += strlen(\"d\");\n  tamanho += strlen(\";\");\n  tamanho += strlen(\"\\n\");\n  tamanho += strlen(\"d\");\n  tamanho += strlen(\" = \");\n  tamanho += strlen(\"a\");\n    tamanho += strlen(\"","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"int Inserir_Registro(char *caminho_registro, registro_t registro) {\n    FILE *arq_reg;\n    uint16_t first_led;\n    uint16_t nova_first_led;\n    uint16_t tamanho, tamanho_first_led, tamanho_novo_branco;\n    int retorno;\n    char caminho_indice[128];\n    tamanho = Calcular_Tamanho(registro);\n    tamanho_first_led = 0;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r+\");\n    fseek(arq_reg, 0, 0);\n    fread(&first_led, sizeof(uint16_t), 1, arq_reg);\n    if (first_led != 0) {\n        fseek(arq_reg, first_led, 0);\n        fread(&tamanho_first_led, sizeof(uint16_t), 1, arq_reg);\n    }\n    if (first_led == 0 || tamanho_first_led < tamanho)\n        retorno = Inserir_Registro_Final(arq_reg, registro);\n    else {\n        fgetc(arq_reg);\n        fread(&nova_first_led, sizeof(uint16_t), 1, arq_reg);\n        fseek(arq_reg, 0, 0);\n        fwrite(&nova_first_led, sizeof(uint16_t), 1, arq_reg);\n        fseek(arq_reg, first_led, 0);\n        tamanho_novo_branco = tamanho_first_led - tamanho - 2;\n        if (tamanho_novo_branco > 8) {\n            fwrite(&tamanho_novo_branco, sizeof(uint16_t), 1, arq_reg);\n            Inserir_ED(arq_reg, first_led);\n            fseek(arq_reg, first_led + 2 + tamanho_novo_branco, 0);\n        } else\n            tamanho = tamanho_first_led;\n        retorno = ftell(arq_reg);\n        fwrite(&tamanho, sizeof(uint16_t), 1, arq_reg);\n        fwrite(&(registro.id), sizeof(uint32_t), 1, arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.autor, sizeof(char), strlen(registro.autor), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.titulo, sizeof(char), strlen(registro.titulo), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.curso, sizeof(char), strlen(registro.curso), arq_reg);\n        fputc('|', arq_reg);\n        fwrite(registro.tipo, sizeof(char), strlen(registro.tipo), arq_reg);\n        fputc('|', arq_reg);\n    }\n    fclose(arq_reg);\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    Inserir_No_ArvoreB(caminho_indice, registro.id, (uint16_t)(retorno));\n    return retorno;\n}\n","function_prediction":"int Inserir_Registro_Final(FILE *arquivo) {\n  Registro_Final registro;\n  registro.tamanho = sizeof(registro.tamanho) + sizeof(registro.id) +\n                     strlen(registro.nome) + strlen(registro.sobrenome) +\n                     strlen(registro.email) + strlen(registro.telefone);\n  fseek(arquivo, 0, 2);\n  int posicao = ftell(arquivo);\n  fwrite(&registro.tamanho, sizeof(registro.tamanho), 1, arquivo);\n  fwrite(&registro.id, sizeof(registro.id), 1, arquivo);\n  fputc('|', arquivo);\n  fwrite(registro.nome, sizeof(registro.nome), 1, arquivo);\n  fputc('|', arquivo);\n  fwrite(registro.sobrenome, sizeof(registro.sobrenome), 1, arquivo);\n  fputc('|', arquivo);\n  fwrite(registro.email, sizeof(registro.email), 1, arquivo);\n  fputc('|', arquivo);\n  fwrite(registro.telefone, sizeof(registro.telefone), 1, arquivo);\n  fputc('|', arquivo);\n  return posicao;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"uint16_t Remover_Registro(char *caminho_registro, uint32_t id) {\n    FILE *arq_reg;\n    uint16_t posicao;\n    char asteristico = '*';\n    char caminho_indice[128];\n    posicao = Buscar_Registro_Com_Indice(caminho_registro, id, ((void *)0));\n    if (posicao == 0)\n        return 0;\n    arq_reg = Abrir_arquivo(caminho_registro, \"r+\");\n    fseek(arq_reg, posicao + 2, 0);\n    fwrite(&asteristico, sizeof(char), 1, arq_reg);\n    Inserir_ED(arq_reg, posicao);\n    fclose(arq_reg);\n    Get_Caminho_Indice(caminho_registro, caminho_indice);\n    Remocao_Arvore_B(caminho_indice, id);\n    return posicao;\n}\n","function_prediction":"short Remover_Registro_name_conflict(char *nome_arquivo, int chave) {\n  FILE *arquivo;\n  short indice;\n  char *nome_arquivo_indice;\n  char nome_arquivo_indice_aux[120];\n  char marcador = '*';\n  int i, j;\n\n  indice = Buscar_Registro_Com_Indice(nome_arquivo, chave, 0);\n\n  if (indice != 0) {\n    arquivo = Abrir_arquivo(nome_arquivo, \"r+b\");\n\n    fseek(arquivo, (indice + 2), 0);\n    fwrite(&marcador, sizeof(char), 1, arquivo);\n\n    Inserir_ED(arquivo, indice);\n\n    fclose(arquivo);\n\n    i = 0;\n    j = 0;\n\n    if (nome_arquivo[0] == '.') {\n      nome_arquivo_indice_aux[i] = '.';\n      i++;\n      j++;\n    }\n\n    while (nome_arquivo[j] != '.' && nome_arquivo[j] != '\\0') {\n      nome_arquivo_indice_aux[i] = nome_arquivo[j];\n      i++;\n      j++;\n    }\n\n    nome_arquivo_indice_aux[i] = '\\0';\n\n    i = strlen(nome_arquivo_indice_aux);\n    nome_arquivo_indice_aux[i] = 'i';\n    nome_arquivo_indice_aux[i + 1] = 'd';\n    nome_arquivo_indice_aux[i + 2] = 'x';\n    nome_arquivo_indice_aux[i + 3] = '.';\n    nome_arquivo_indice_aux[i + 4] = '\\0';\n\n  nome_arquivo_ind","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"registro_t String_to_reg(char *cadeia) {\n    registro_t retorno;\n    char *campo;\n    if (cadeia == ((void *)0)) {\n        printf(\"Erro ao converter arquivo de catalogo: linha vazia!\\n\");\n        retorno.id = 0;\n        return retorno;\n    }\n    campo = strtok(cadeia, \";\");\n    retorno.id = (uint32_t)(atoi(campo));\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.autor, campo + 1);\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.titulo, campo + 1);\n    campo = strtok(((void *)0), \";\");\n    strcpy(retorno.curso, campo + 1);\n    campo = strtok(((void *)0), \"\\r\");\n    strcpy(retorno.tipo, campo + 1);\n    return retorno;\n}\n","function_prediction":"registro String_to_reg_name_conflict(char *linha) {\n  registro reg;\n  char *token;\n\n  if (linha == NULL) {\n    printf(\"Erro ao converter arquivo de catalogo: linha vazia!\\n\");\n    reg.chave = 0;\n  } else {\n    token = strtok(linha, \";\");\n    reg.chave = strtol(token, NULL, 10);\n\n    token = strtok(NULL, \";\");\n    strcpy(reg.nome, token + 1);\n\n    token = strtok(NULL, \";\");\n    strcpy(reg.autor, token + 1);\n\n    token = strtok(NULL, \";\");\n    strcpy(reg.editora, token + 1);\n\n    token = strtok(NULL, \"\\r\");\n    strcpy(reg.ano, token + 1);\n  }\n\n  return reg;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"int Importar_arquivo_catalogo(char *caminho_catalogo, char *caminho_registro) {\n    char leitura[1024];\n    char c;\n    int i;\n    int n_reg = 0;\n    registro_t lido;\n    FILE *catalogo;\n    catalogo = Abrir_arquivo(caminho_catalogo, \"r\");\n    while (1)\n        {\n            i = 0;\n            while ((c = fgetc(catalogo)) != '\\n' && c != (-1))\n                {\n                    leitura[i] = c;\n                    ++i;\n                }\n            leitura[i] = '\\x00';\n            if (strlen(leitura) < 4)\n                break;\n            lido = String_to_reg(leitura);\n            i = Inserir_Registro(caminho_registro, lido);\n            printf(\"Inserido registro na posicao %d do arquivo.\\n\", i);\n            ++n_reg;\n        }\n    fclose(catalogo);\n    return n_reg;\n}\n","function_prediction":"int Importar_arquivo_catalogo_name_conflict(char *nome_arquivo, Catalogo *catalogo) {\n  FILE *arquivo;\n  int i, j, k, cont = 0;\n  char linha[1024], *p;\n  Registro reg;\n  char *reg_str[60];\n\n  arquivo = Abrir_arquivo(nome_arquivo, \"r\");\n\n  while (1) {\n    i = 0;\n    while ((linha[i] = fgetc(arquivo)) != '\\n' && linha[i] != EOF)\n      i++;\n    linha[i] = '\\0';\n\n    if (strlen(linha) < 4)\n      break;\n\n    cont++;\n\n    String_to_reg(reg_str, linha);\n\n    for (i = 0, j = 0; i < 60; i++) {\n      reg.campos[i] = reg_str[i];\n    }\n\n    printf(\"Inserido registro na posicao %d do arquivo.\\n\",\n           Inserir_Registro(catalogo, reg));\n  }\n\n  fclose(arquivo);\n\n  return cont;\n}","pass":0,"source_file":"C_COMPILE/rafaiska_6897_Arq_Reg_LED/arq_reg.c"}
{"compilable":0,"function":"static unsigned char *option_find1(unsigned char *p, unsigned char *end, int opt, int minsize) {\n    while (*p != 255)\n        {\n            if (p >= end)\n                return ((void *)0);\n            else if (*p == 0)\n                p++;\n            else {\n                int opt_len;\n                if (p >= end - 2)\n                    return ((void *)0);\n                opt_len = ((int)(((unsigned char *)(p))[1]));\n                if (p >= end - (2 + opt_len))\n                    return ((void *)0);\n                if (*p == opt && opt_len >= minsize)\n                    return p;\n                p += opt_len + 2;\n            }\n        }\n    return opt == 255 ? p : ((void *)0);\n}\n","function_prediction":"const unsigned char *option_find1(const unsigned char *p,\n                                  const unsigned char *end, unsigned char type,\n                                  unsigned int min_len) {\n  while (p < end && *p != 0xff) {\n    if (*p == 0) {\n      p++;\n      continue;\n    }\n    if (p + 2 >= end)\n      return NULL;\n    unsigned int len = p[1];\n    if (p + 2 + len >= end)\n      return NULL;\n    if (p[0] == type && len >= min_len)\n      return p;\n    p += 2 + len;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":0,"function":"static unsigned char *option_find(struct dhcp_packet *mess, size_t size, int opt_type, int minsize) {\n    unsigned char *ret, *overload;\n    if ((ret = option_find1(&mess->options[0], ((unsigned char *)mess) + size, opt_type, minsize)))\n        return ret;\n    if (!(overload = option_find1(&mess->options[0], ((unsigned char *)mess) + size, 52, 1)))\n        return ((void *)0);\n    if ((overload[2] & 1) && (ret = option_find1(&mess->file[0], &mess->file[128], opt_type, minsize)))\n        return ret;\n    if ((overload[2] & 2) && (ret = option_find1(&mess->sname[0], &mess->sname[64], opt_type, minsize)))\n        return ret;\n    return ((void *)0);\n}\n","function_prediction":"const unsigned char *option_find1(const unsigned char *p,\n                                  const unsigned char *end, unsigned char type,\n                                  unsigned int min_len) {\n  while (p < end && *p != 0xff) {\n    if (*p == 0) {\n      p++;\n      continue;\n    }\n    if (p + 2 >= end)\n      return NULL;\n    unsigned int len = p[1];\n    if (p + 2 + len >= end)\n      return NULL;\n    if (p[0] == type && len >= min_len)\n      return p;\n    p += 2 + len;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":0,"function":"static unsigned int option_uint(unsigned char *opt, int size) {\n    unsigned int ret = 0;\n    int i;\n    unsigned char *p = ((void *)&(((unsigned char *)(opt))[2]));\n    for (i = 0; i < size; i++)\n        ret = (ret << 8) | *p++;\n    return ret;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_lease_time.c"}
{"compilable":0,"function":"static ssize_t netlink_recv(int fd) {\n    struct msghdr msg;\n    ssize_t rc;\n    msg.msg_control = ((void *)0);\n    msg.msg_controllen = 0;\n    msg.msg_name = ((void *)0);\n    msg.msg_namelen = 0;\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    while (1)\n        {\n            msg.msg_flags = 0;\n            while ((rc = recvmsg(fd, &msg, MSG_PEEK)) == -1 && (*__errno_location()) == 4)\n                ;\n            if (rc == -1 && (*__errno_location()) == 95) {\n                if (!expand_buf(&iov, 2000))\n                    return -1;\n                break;\n            }\n            if (rc == -1 || !(msg.msg_flags & MSG_TRUNC))\n                break;\n            if (!expand_buf(&iov, iov.iov_len + 100))\n                return -1;\n        }\n    while ((rc = recvmsg(fd, &msg, 0)) == -1 && (*__errno_location()) == 4)\n        ;\n    return rc;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":1,"function":"static int parse_hex(char *in, unsigned char *out, int maxlen, int *mac_type) {\n    int i = 0;\n    char *r;\n    if (mac_type)\n        *mac_type = 0;\n    while (maxlen == -1 || i < maxlen)\n        {\n            for (r = in; *r != 0 && *r != ':' && *r != '-'; r++)\n                ;\n            if (*r == 0)\n                maxlen = i;\n            if (r != in) {\n                if (*r == '-' && i == 0 && mac_type) {\n                    *r = 0;\n                    *mac_type = strtol(in, ((void *)0), 16);\n                    mac_type = ((void *)0);\n                } else {\n                    *r = 0;\n                    out[i] = strtol(in, ((void *)0), 16);\n                    i++;\n                }\n            }\n            in = r + 1;\n        }\n    return i;\n}\n","function_prediction":"int parse_hex_name_conflict(char *str, char *buf, int max, int *len) {\n  int i = 0;\n\n  if (len)\n    *len = 0;\n\n  while (1) {\n    while (*str == ':' || *str == '-')\n      str++;\n\n    if (!*str)\n      break;\n\n    if (i == 0 && len) {\n      *str = 0;\n      *len = strtol(str, NULL, 16);\n      str++;\n      continue;\n    }\n\n    *str = 0;\n    buf[i++] = strtol(str, NULL, 16);\n    str++;\n\n    if (i >= max)\n      break;\n  }\n\n  if (str == str + 1)\n    return 0;\n\n  return i;\n}","pass":1,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"static int is_same_net(struct in_addr a, struct in_addr b, struct in_addr mask) {\n    return (a.s_addr & mask.s_addr) == (b.s_addr & mask.s_addr);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":0,"function":"static struct in_addr find_interface(struct in_addr client, int fd, unsigned int index) {\n    struct sockaddr_nl addr;\n    struct nlmsghdr *h;\n    ssize_t len;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg g;\n    } req;\n    addr.nl_family = 16;\n    addr.nl_pad = 0;\n    addr.nl_groups = 0;\n    addr.nl_pid = 0;\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETADDR;\n    req.nlh.nlmsg_flags = 256 | 512 | 1 | 4;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = 1;\n    req.g.rtgen_family = 2;\n    if (sendto(fd, (void *)&req, sizeof (req), 0, (struct sockaddr *)&addr, sizeof (addr)) == -1) {\n        perror(\"sendto failed\");\n        exit(1);\n    }\n    while (1)\n        {\n            if ((len = netlink_recv(fd)) == -1) {\n                perror(\"netlink\");\n                exit(1);\n            }\n            for (h = (struct nlmsghdr *)iov.iov_base; (((size_t)len) >= (int)sizeof(struct nlmsghdr) && (h)->nlmsg_len >= sizeof(struct nlmsghdr) && (h)->nlmsg_len <= ((size_t)len)); h = ((len) -= ((((h)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(h)) + ((((h)->nlmsg_len) + 4U - 1) & ~(4U - 1)))))\n                if (h->nlmsg_type == 3)\n                    exit(0);\n                else if (h->nlmsg_type == RTM_NEWADDR) {\n                    struct ifaddrmsg *ifa = ((void *)(((char *)h) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    struct rtattr *rta;\n                    unsigned int len1 = h->nlmsg_len - ((sizeof (*ifa)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))));\n                    if (ifa->ifa_index == index && ifa->ifa_family == 2) {\n                        struct in_addr netmask, addr;\n                        netmask.s_addr = htonl(4294967295U << (32 - ifa->ifa_prefixlen));\n                        addr.s_addr = 0;\n                        for (rta = ((struct rtattr *)(((char *)(ifa)) + (((sizeof(struct ifaddrmsg)) + 4U - 1) & ~(4U - 1)))); ((len1) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len1)); rta = ((len1) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n                            if (rta->rta_type == IFA_LOCAL)\n                                addr = *((struct in_addr *)(rta + 1));\n                        if (addr.s_addr && is_same_net(addr, client, netmask))\n                            return addr;\n                    }\n                }\n        }\n    exit(0);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Android-Apps_dnsmasq/contrib/wrt/dhcp_release.c"}
{"compilable":1,"function":"int output(char *filename) {\n    FILE *fp;\n    char str[64];\n    if ((fp = fopen(filename, \"r\")) == ((void *)0)) {\n        printf(\"Cannot open file %s.\\n\", filename);\n        return 1;\n    }\n    while (!feof(fp))\n        {\n            if (fgets(str, 128, fp)) {\n                printf(\"%s\", str);\n            }\n        }\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int output_name_conflict(char *filename) {\n  FILE *fp;\n  char line[128];\n\n  if ((fp = fopen(filename, \"r\")) == NULL) {\n    printf(\"Cannot open file %s.\\n\", filename);\n    return 1;\n  }\n\n  while (!feof(fp)) {\n    if (fgets(line, 128, fp) != NULL)\n      printf(\"%s\", line);\n  }\n\n  fclose(fp);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/lazyparser_honggfuzz/examples/targets/badcode1.c"}
{"compilable":0,"function":"int askCharQuestion(char *question) {\n    char answer = 0;\n    printf(\"%s\\n> \", question);\n    scanf(\" %c\", &answer);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"char askCharQuestion_name_conflict(char *question) {\n  char answer[9];\n  answer[0] = '\\0';\n\n  printf(\"%s\\n> \", question);\n  __isoc99_scanf(\"%s\", answer);\n  fflush(stdin);\n\n  return answer[0];\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int askIntQuestion(char *question) {\n    int answer = 0;\n    printf(\"%s\\n> \", question);\n    scanf(\" %i\", &answer);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"int askIntQuestion_name_conflict(char *question) {\n  int answer = 0;\n  printf(\"%s\\n> \", question);\n  __isoc99_scanf(\"%d\", &answer);\n  fflush(stdin);\n  return answer;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"short askBoolQuestion(char *question) {\n    int response = -1;\n    do {\n        printf(\"%s\\n> \", question);\n        scanf(\" %i\", &response);\n        fflush(stdin);\n        if (response < 0 || response > 1) {\n            printf(\"\\t\\tERROR: Input must be either a 0 (false) or 1 (true)!\\n\");\n        }\n    } while (response < 0 || response > 1);\n    return response;\n}\n","function_prediction":"int askBoolQuestion_name_conflict(char *question) {\n  int answer = -1;\n  do {\n    printf(\"%s\\n> \", question);\n    __isoc99_scanf(\"%d\", &answer);\n    fflush(stdin);\n    if (answer != 0 && answer != 1) {\n      printf(\"\\t\\tERROR: Input must be either a 0 (false) or 1 (true)!\\n\");\n    }\n  } while (answer != 0 && answer != 1);\n  return answer;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"char *askStringQuestion(char *question, int maxLength) {\n    char *answer = calloc(maxLength + 1, sizeof(char));\n    printf(\"%s\\n> \", question);\n    fgets(answer, maxLength, stdin);\n    fflush(stdin);\n    return answer;\n}\n","function_prediction":"char *askStringQuestion_name_conflict(char *question, int maxLength) {\n  char *answer = calloc(maxLength + 1, sizeof(char));\n  printf(\"%s\\n> \", question);\n  fgets(answer, maxLength, stdin);\n  fflush(stdin);\n  return answer;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int multiprobabilisticRand(int probabilities[], int arraySize) {\n    int i, winner = -1, total = 0, choice = 0, currentTick = 0;\n    for (i = 0; i < arraySize; i++) {\n        total += probabilities[i];\n    }\n    choice = rand() % total;\n    for (i = 0; i < arraySize; i++) {\n        currentTick += probabilities[i];\n        if (choice < currentTick) {\n            winner = i;\n            break;\n        }\n    }\n    return winner;\n}\n","function_prediction":"int multiprobabilisticRand_name_conflict(int *probabilities, int size) {\n  int i, sum = 0;\n  for (i = 0; i < size; i++) {\n    sum += probabilities[i];\n  }\n  int r = rand() % sum;\n  int sum2 = 0;\n  for (i = 0; i < size; i++) {\n    sum2 += probabilities[i];\n    if (r < sum2) {\n      return i;\n    }\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"int randMinMax(int minimum, int maximum) {\n    return (rand() % (maximum - minimum)) + minimum;\n}\n","function_prediction":"int randMinMax_name_conflict(int min, int max) { return rand() % (max - min) + min; }","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/frankCommonLibrary.c"}
{"compilable":0,"function":"char cycleChar(char original, int ticks) {\n    char alphabet[26] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int min = alphabet[0];\n    int max = alphabet[25];\n    if (isMutable(original))\n        return min + ((original + ticks - min) % 26);\n    return original;\n}\n","function_prediction":"char cycleChar_name_conflict(char c, int n) {\n  char alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  int i;\n  for (i = 0; i < 26; i++) {\n    if (c == alphabet[i]) {\n      return alphabet[(i + n - 65) % 26];\n    }\n  }\n  return c;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"bool isMutable(char c) {\n    int i;\n    char mutables[26] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for (i = 0; i < 26; i++) {\n        if (mutables[i] == c)\n            return 1;\n    }\n    return 0;\n}\n","function_prediction":"int isMutable_name_conflict(char c) {\n  char mutable[] = {'a', 'e', 'i', 'o', 'u', 'y'};\n  int i;\n  for (i = 0; i < 6; i++) {\n    if (c == mutable[i]) {\n      return 1;\n    }\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"char *loadFileToDecode(char *fileName) {\n    int length = 0;\n    FILE *file = fopen(fileName, \"rb\");\n    char *buffer = ((void *)0);\n    if (file) {\n        fseek(file, 0, 2);\n        length = ftell(file);\n        fseek(file, 0, 0);\n        buffer = calloc(length + 1, sizeof(char));\n        fread(buffer, 1, length, file);\n        fclose(file);\n        return buffer;\n    } else {\n        error(\"Couldn't read input file\");\n    }\n    return ((void *)0);\n}\n","function_prediction":"char *loadFileToDecode_name_conflict(char *filename) {\n  FILE *file;\n  char *buffer;\n  long fileLen;\n\n  file = fopen(filename, \"rb\");\n  if (!file) {\n    error(\"Couldn't read input file\");\n    return NULL;\n  }\n\n  fseek(file, 0, 2);\n  fileLen = ftell(file);\n  fseek(file, 0, 0);\n\n  buffer = calloc(fileLen + 1, 1);\n  fread(buffer, 1, fileLen, file);\n  fclose(file);\n\n  return buffer;\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/src/Decode.c"}
{"compilable":0,"function":"long timediff(clock_t t1, clock_t t2) {\n    long elapsed;\n    elapsed = ((double)t2 - t1) / ((__clock_t)1000000) * 1000;\n    return elapsed;\n}\n","function_prediction":"long timediff_name_conflict(struct timeval start, struct timeval end) {\n  return (long)((end.tv_sec - start.tv_sec) * 1000.0 +\n                (end.tv_usec - start.tv_usec) / 1000.0);\n}","pass":0,"source_file":"C_COMPILE/Far117_caesar-decryptor/main.c"}
{"compilable":0,"function":"inline Limit init_limit(unsigned int h, struct Limit lim) {\n    double WSd = (double)sizeof(WORD) * 8;\n    unsigned int WSi = (unsigned int)sizeof(WORD) * 8;\n    lim.h = h;\n    WORD yWord = (9223372036854775807L * 2UL + 1UL);\n    unsigned int shift_places = (WSi - (h % WSi)) % WSi;\n    yWord = yWord >> shift_places;\n    lim.yWord = yWord;\n    lim.words = (unsigned int)ceil((double)lim.h / WSd);\n    lim.yIndex = 0;\n    return lim;\n}\n","function_prediction":"void init_limit_name_conflict(struct limit *l, int n) {\n  l->n = n;\n  l->m = (int)(n * 1.5);\n  l->mask = (1ULL << n) - 1;\n  l->size = 0;\n}","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int popcount_words(WORD *words, int length) {\n    unsigned int count = 0;\n    unsigned int i;\n    for (i = 0; i < length; i++) {\n        count += __builtin_popcountl(words[i]);\n    }\n    return count;\n}\n","function_prediction":"int popcount_words_name_conflict(uint64_t *words, int n) {\n  int i, count = 0;\n\n  for (i = 0; i < n; i++)\n    count += __builtin_popcountll(words[i]);\n\n  return count;\n}","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD *shift_words(WORD *words, int length) {\n    WORD mask = (WORD)1 << ((int)sizeof(WORD) * 8 - 1);\n    WORD carried_bit = 0;\n    WORD temp;\n    int i;\n    for (i = length - 1; i > -1; i--) {\n        temp = words[i];\n        words[i] = (WORD)((words[i] << 1) | carried_bit);\n        carried_bit = (WORD)((temp & mask) != 0);\n    }\n    return words;\n}\n","function_prediction":"void shift_words_name_conflict(uint64_t *words, int n) {\n  uint64_t carry = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    uint64_t word = words[i];\n    words[i] = (word << 1) | carry;\n    carry = word >> 63;\n  }\n}","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD *shiftc_words(WORD *words, struct Limit lim) {\n    words = shift_words(words, lim.words);\n    words[lim.yIndex] = words[lim.yIndex] & lim.yWord;\n    return words;\n}\n","function_prediction":"void shiftc_words_name_conflict(uint64_t *words, int nwords, int shift, uint64_t mask) {\n  int i;\n  uint64_t carry = 0;\n\n  for (i = nwords - 1; i >= 0; i--) {\n    uint64_t word = words[i];\n    words[i] = (word << shift) | carry;\n    carry = word >> (64 - shift);\n  }\n\n  words[i] &= mask;\n}","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline WORD delta(char a, char b) {\n    return (WORD)(a != b);\n}\n","function_prediction":"int delta_name_conflict(char a, char b) { return a != b; }","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int maxshiftm_hd(unsigned char *p, unsigned int m, unsigned char *t, unsigned int n, unsigned int h, unsigned int *ii, unsigned int *jj, unsigned int *dd) {\n    unsigned int i, j, k, err, min_err;\n    min_err = (2147483647 * 2U + 1U);\n    Limit lim;\n    lim = init_limit(h, lim);\n    WORD *ones;\n    if ((ones = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n        fprintf(stderr, \" Error: ow could not be allocated!\\n\");\n        return (0);\n    }\n    WORD ***M;\n    if ((M = (WORD ***)calloc((m + 1), sizeof(WORD **))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M1 could not be allocated!\\n\");\n        return (0);\n    }\n    for (i = 0; i < m + 1; i++) {\n        if ((M[i] = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M2 could not be allocated!\\n\");\n            return (0);\n        }\n    }\n    for (i = 0; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if ((M[i][j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n                fprintf(stderr, \" Error: M3 could not be allocated!\\n\");\n                return (0);\n            }\n        }\n    }\n    for (i = 1; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if (j == 0) {\n                if (i <= lim.h) {\n                    ones = shift_words(ones, lim.words);\n                    ones[lim.words - 1] = ones[lim.words - 1] + 1;\n                }\n                memcpy(M[i][j], ones, lim.words * sizeof(WORD));\n            } else {\n                for (k = 0; k < lim.words; k++) {\n                    M[i][j][k] = M[i - 1][j - 1][k];\n                }\n                M[i][j] = shiftc_words(M[i][j], lim);\n                M[i][j][lim.words - 1] = M[i][j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n            }\n            if (j >= lim.h && i >= lim.h) {\n                err = popcount_words(M[i][j], lim.words);\n                if (err < min_err) {\n                    min_err = err;\n                    (*dd) = min_err;\n                    (*ii) = i - 1;\n                    (*jj) = j - 1;\n                }\n            }\n        }\n    }\n    for (i = 0; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            free(M[i][j]);\n        }\n        free(M[i]);\n    }\n    free(M);\n    free(ones);\n    return 1;\n}\n","function_prediction":"int maxshiftm_hd_ls(char *s1, uint32_t l1, char *s2, uint32_t l2,\n                    uint32_t max_shift, uint32_t *max_shift_i,\n                    uint32_t *max_shift_j, uint32_t *max_shift_score) {\n  uint32_t i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a, b, c, d, e,\n      f, g, h, i1, j1, k1, l11, m1, n1, o1, p1, q1, r1, s11, t1, u1, v1, w1, x1,\n      y1, z1, a1, b1, c1, d1, e1, f1, g1, h1, i2, j2, k2, l22, m2, n2, o2, p2,\n      q2, r2, s22, t2, u2, v2, w2, x2, y2, z2, a2, b2, c2, d2, e2, f2, g2, h2,\n      i3, j3, k3, l3, m3, n3, o3, p3, q3, r3, s3, t3, u3, v3, w3, x3, y3, z3,\n      a3, b3, c3, d3, e3, f3, g3, h3, i4, j4, k4, l4, m4, n4, o4, p4, q4, r4,\n      s4, t4, u4, v4, w4, x4, y4, z4, a4, b4, c4, d4, e4, f4, g4, h4, i5, j5,\n      k5, l5, m5, n5, o5, p5, q5, r5, s5, t5, u5, v5, w5, x5, y5, z5, a5","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"inline unsigned int maxshiftm_hd_ls(unsigned char *p, unsigned int m, unsigned char *t, unsigned int n, unsigned int h, unsigned int *ii, unsigned int *jj, unsigned int *dd) {\n    unsigned int i, j, k, err, min_err;\n    min_err = (2147483647 * 2U + 1U);\n    Limit lim;\n    lim = init_limit(h, lim);\n    WORD *ones;\n    if ((ones = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n        fprintf(stderr, \" Error: ow could not be allocated!\\n\");\n        return (0);\n    }\n    WORD **M0;\n    WORD **M1;\n    if ((M0 = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M0 could not be allocated!\\n\");\n        return (0);\n    }\n    if ((M1 = (WORD **)calloc((n + 1), sizeof(WORD *))) == ((void *)0)) {\n        fprintf(stderr, \" Error: M1 could not be allocated!\\n\");\n        return (0);\n    }\n    for (j = 0; j < n + 1; j++) {\n        if ((M0[j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M0J could not be allocated!\\n\");\n            return (0);\n        }\n        if ((M1[j] = (WORD *)calloc(lim.words, sizeof(WORD))) == ((void *)0)) {\n            fprintf(stderr, \" Error: M1J could not be allocated!\\n\");\n            return (0);\n        }\n    }\n    for (i = 1; i < m + 1; i++) {\n        for (j = 0; j < n + 1; j++) {\n            if (j == 0 && i <= lim.h) {\n                ones = shift_words(ones, lim.words);\n                ones[lim.words - 1] = ones[lim.words - 1] + 1;\n            }\n            switch (i % 2) {\n              case 0:\n                if (j == 0) {\n                    memcpy(M1[j], ones, lim.words * sizeof(WORD));\n                } else {\n                    for (k = 0; k < lim.words; k++) {\n                        M1[j][k] = M0[j - 1][k];\n                    }\n                    M1[j] = shiftc_words(M1[j], lim);\n                    M1[j][lim.words - 1] = M1[j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n                }\n                if (j >= lim.h && i >= lim.h) {\n                    err = popcount_words(M1[j], lim.words);\n                    if (err < min_err) {\n                        min_err = err;\n                        (*dd) = min_err;\n                        (*ii) = i - 1;\n                        (*jj) = j - 1;\n                    }\n                }\n                break;\n              case 1:\n                if (j == 0) {\n                    memcpy(M0[j], ones, lim.words * sizeof(WORD));\n                } else {\n                    for (k = 0; k < lim.words; k++) {\n                        M0[j][k] = M1[j - 1][k];\n                    }\n                    M0[j] = shiftc_words(M0[j], lim);\n                    M0[j][lim.words - 1] = M0[j][lim.words - 1] | delta(p[i - 1], t[j - 1]);\n                }\n                if (j >= lim.h && i >= lim.h) {\n                    err = popcount_words(M0[j], lim.words);\n                    if (err < min_err) {\n                        min_err = err;\n                        (*dd) = min_err;\n                        (*ii) = i - 1;\n                        (*jj) = j - 1;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    for (j = 0; j < n + 1; j++) {\n        free(M0[j]);\n        free(M1[j]);\n    }\n    free(M0);\n    free(M1);\n    free(ones);\n    return 1;\n}\n","function_prediction":"int maxshiftm_hd_ls(char *T, unsigned int n, char *P, unsigned int m,\n                    unsigned int k, unsigned int *max_i, unsigned int *max_j,\n                    unsigned int *max_d) {\n  unsigned int i, j, l, d, max_d_tmp, max_d_tmp_tmp, max_d_tmp_tmp_tmp;\n  unsigned int *ow, *M0, *M1, *M0J, *M1J;\n  unsigned int M0_size, M1_size, M0J_size, M1J_size;\n  unsigned int mask;\n\n  M0_size = (unsigned int)(k * 0.5 + 0.5);\n  M1_size = (unsigned int)(k * 0.5 + 0.5);\n  M0J_size = (unsigned int)(k * 0.5 + 0.5);\n  M1J_size = (unsigned int)(k * 0.5 + 0.5);\n\n  mask = (unsigned int)(0xFFFFFFFF >> (32 - k));\n\n  ow = (unsigned int *)calloc(M0J_size, sizeof(unsigned int));\n  if (ow == NULL) {\n    fprintf(stderr, \" Error: ow could not be allocated!\\n\");\n    return 0;\n  }\n\n  M0 = (unsigned int *)calloc(m + 1, sizeof(unsigned int));\n  if (M0 == NULL) {\n    fprintf(stderr, \" Error: M0 could not be allocated!\\n\");\n    return 0;\n  }\n\n  M1 = (unsigned int *)calloc(m + 1, sizeof(unsigned int));\n  if (M1 == NULL) {\n    fprintf(stderr, \" Error: M1 could not be allocated!\\n\");\n    return 0;\n  }\n\n  for (i = 0; i < m + 1; i++) {\n    M0J = (unsigned int *)calloc(M0J_size, sizeof(unsigned int));\n    if (M0J == NULL) {\n            fprintf(","pass":0,"source_file":"C_COMPILE/webmasterar_maxshiftm/maxshiftm.c"}
{"compilable":0,"function":"static int buf_prepare(size_t require) {\n    if (buf->size >= require) {\n        return 0;\n    }\n    buf->size = require * 2;\n    if (buf->size < 4096) {\n        buf->size = 4096;\n    }\n    if (buf->data == ((void *)0)) {\n        buf->data = malloc(buf->size);\n    } else {\n        buf->data = realloc(buf->data, buf->size);\n    }\n    if (buf->data == ((void *)0)) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_connect(const char *addrstr) {\n    int fd;\n    struct sockaddr_un addr;\n    fd = socket(1, SOCK_STREAM, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    memset(&addr, 0, sizeof(struct sockaddr_un));\n    addr.sun_family = 1;\n    strncpy(addr.sun_path, addrstr, sizeof (addr.sun_path) - 1);\n    if (connect(fd, (struct sockaddr *)&addr, sizeof (addr)) == -1) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int pt_comm_connect_name_conflict(const char *host) {\n  int sock;\n  struct sockaddr_un addr;\n\n  sock = socket(1, 1, 0);\n  if (sock == -1)\n    return -1;\n\n  addr.sun_family = 1;\n  strncpy(addr.sun_path, host, 107);\n  addr.sun_path[107] = '\\0';\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1)\n    return -1;\n\n  return sock;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_listen(const char *addrstr) {\n    int fd;\n    struct sockaddr_un addr;\n    fd = socket(1, SOCK_STREAM, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    memset(&addr, 0, sizeof(struct sockaddr_un));\n    addr.sun_family = 1;\n    strncpy(addr.sun_path, addrstr, sizeof (addr.sun_path) - 1);\n    if (unlink(addr.sun_path) == -1 && (*__errno_location()) != 2) {\n        return -1;\n    }\n    if (bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) == -1) {\n        return -1;\n    }\n    if (chmod(addr.sun_path, (2048 | 1024 | 512 | (256 | 128 | 64) | ((256 | 128 | 64) >> 3) | (((256 | 128 | 64) >> 3) >> 3))) == 0) {\n        (*__errno_location()) = 0;\n    }\n    if (listen(fd, 128) == -1) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int pt_comm_listen_name_conflict(const char *path) {\n  int sock;\n  struct sockaddr_un addr;\n\n  sock = socket(1, 1, 0);\n  if (sock == -1)\n    return -1;\n\n  addr.sun_family = 1;\n  addr.sun_path[0] = '\\0';\n  strncpy(addr.sun_path + 1, path, 107);\n\n  if (unlink(addr.sun_path) == -1 && *__errno_location() != 2)\n    return -1;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1)\n    return -1;\n\n  if (!chmod(addr.sun_path, 07777))\n    *__errno_location() = 0;\n\n  if (listen(sock, 128) == -1)\n    return -1;\n\n  return sock;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_accept(int fd) {\n    struct sockaddr_un addr;\n    socklen_t addrlen = sizeof (addr);\n    return accept(fd, (struct sockaddr *)&addr, &addrlen);\n}\n","function_prediction":"int pt_comm_accept_name_conflict(int sock) {\n  struct sockaddr_un addr;\n  socklen_t addrlen = sizeof(addr);\n  return accept(sock, (struct sockaddr *)&addr, &addrlen);\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_recv_msg(int fd, pt_comm_message_t **msg_ptr) {\n    int i;\n    ssize_t retval, recvlen;\n    pt_comm_message_t *msg;\n    if (buf_prepare(sizeof(pt_comm_message_t)) == -1) {\n        return PT_MSG_ERR_BUF;\n    }\n    msg = *msg_ptr = buf->data;\n    retval = recv(fd, msg, sizeof(pt_comm_message_t), MSG_DONTWAIT);\n    if (retval == -1) {\n        if ((*__errno_location()) == 11 || (*__errno_location()) == 11) {\n            return PT_MSG_EMPTY;\n        } else {\n            return PT_MSG_ERR_SOCK;\n        }\n    } else if (retval == 0) {\n        return PT_MSG_PEERDOWN;\n    } else if (retval != sizeof(pt_comm_message_t)) {\n        return PT_MSG_INVALID;\n    } else if (msg->len > 1024 * 1024 || msg->len < 0) {\n        return PT_MSG_INVALID;\n    }\n    if (msg->len == 0) {\n        return msg->type;\n    }\n    if (buf_prepare(sizeof(pt_comm_message_t) + msg->len) == -1) {\n        return PT_MSG_ERR_BUF;\n    }\n    msg = *msg_ptr = buf->data;\n    for (i = 0 , recvlen = 0; i < 10; i++) {\n        retval = recv(fd, msg->data + recvlen, msg->len - recvlen, 0);\n        if (retval == -1) {\n            return PT_MSG_ERR_SOCK;\n        } else if (retval == 0) {\n            return PT_MSG_PEERDOWN;\n        }\n        recvlen += retval;\n        if (recvlen == msg->len) {\n            break;\n        }\n    }\n    if (recvlen != msg->len) {\n        return PT_MSG_INVALID;\n    }\n    return msg->type;\n}\n","function_prediction":"int pt_comm_recv_msg_name_conflict(int sock, char **buf) {\n  static size_t buf_size = 4096;\n  size_t recv_size;\n  int i;\n\n  if (buf_size < 12) {\n    buf_size = 4096;\n    if (bufst)\n      bufst = realloc(bufst, buf_size);\n    else\n      bufst = malloc(buf_size);\n    if (!bufst)\n      return 3;\n  }\n\n  *buf = bufst;\n\n  recv_size = recv(sock, bufst, 12, 0x40);\n  if (recv_size == -1) {\n    if (*__errno_location() == 11)\n      return 0;\n    else\n      return 2;\n  }\n  if (recv_size == 0)\n    return 1;\n  if (recv_size != 12)\n    return 4;\n\n  if ((((struct pt_comm_msg *)bufst)->size) > (1024 * 1024))\n    return 4;\n\n  if ((((struct pt_comm_msg *)bufst)->size) == 0)\n    return (((struct pt_comm_msg *)bufst)->code);\n\n  if (buf_size < (((struct pt_comm_msg *)bufst)->size) + 12) {\n    buf_size = (((struct pt_comm_msg *)bufst)->size) + 12;\n    if (buf_size < 4096)\n      buf_size = 4096;\n    if (bufst)\n      bufst = realloc(bufst, buf_size);\n    else\n      bufst = malloc(buf_size);\n    if (!bufst)\n      return 3;\n  }\n\n  *buf = bufst;\n\n  recv_size = 0;\n  for (i = 0; i < 10; i++) {\n        size_t r = recv(sock, bufst","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_build_msg(pt_comm_message_t **msg_ptr, size_t size, int type) {\n    pt_comm_message_t *msg;\n    if (buf_prepare(sizeof(pt_comm_message_t) + size) == -1) {\n        return -1;\n    }\n    msg = *msg_ptr = buf->data;\n    msg->len = size;\n    msg->type = type;\n    return 0;\n}\n","function_prediction":"int pt_comm_build_msg_name_conflict(struct pt_comm_msg *msg, uint32_t len, uint32_t type) {\n  if (len + sizeof(struct pt_comm_msg) + 4 > bufst.size) {\n    bufst.size = (len + sizeof(struct pt_comm_msg) + 4) * 2;\n    if (bufst.size < 4096)\n      bufst.size = 4096;\n    if (bufst.buf)\n      bufst.buf = realloc(bufst.buf, bufst.size);\n    else\n      bufst.buf = malloc(bufst.size);\n    if (!bufst.buf)\n      return -1;\n  }\n  msg->buf = bufst.buf;\n  msg->len = len;\n  msg->type = type;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_send_type(int fd, int type) {\n    pt_comm_message_t *msg;\n    if (pt_comm_build_msg(&msg, 0, type) == -1) {\n        return -1;\n    }\n    return pt_comm_send_msg(fd, msg);\n}\n","function_prediction":"int pt_comm_send_type_name_conflict(int sock, int type) {\n  if (sizeof(bufst->type) + sizeof(bufst->len) > sizeof(bufst->data)) {\n    bufst = realloc(bufst, sizeof(bufst->type) + sizeof(bufst->len) +\n                               sizeof(bufst->data));\n    if (bufst == NULL) {\n      return -1;\n    }\n  }\n\n  bufst->len = 0;\n  bufst->type = type;\n\n  if (send(sock, bufst, sizeof(bufst->type) + sizeof(bufst->len), 0) == -1) {\n    return -1;\n  }\n\n  if (bufst->len == 0) {\n    return 0;\n  }\n\n  if (send(sock, bufst->data, bufst->len, 0) == -1) {\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_send_msg(int fd, pt_comm_message_t *msg) {\n    ssize_t retval;\n    retval = send(fd, msg, sizeof(pt_comm_message_t), 0);\n    if (retval == -1) {\n        return -1;\n    }\n    if (msg->len == 0) {\n        return 0;\n    }\n    retval = send(fd, msg->data, msg->len, 0);\n    if (retval == -1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int pt_comm_send_msg_name_conflict(int sock, struct pt_comm_msg *msg) {\n  if (send(sock, msg, sizeof(struct pt_comm_msg), 0) == -1)\n    return -1;\n\n  if (msg->len) {\n    if (send(sock, msg->data, msg->len, 0) == -1)\n      return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"int pt_comm_close(int fd, const char *addrstr) {\n    if (addrstr != ((void *)0)) {\n        unlink(addrstr);\n    }\n    return close(fd);\n}\n","function_prediction":"void pt_comm_close_name_conflict(int fd, const char *fifo) {\n  if (fifo)\n    unlink(fifo);\n  close(fd);\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_comm.c"}
{"compilable":0,"function":"static int has_color(void) {\n    if (output_is_tty == -1) {\n        output_is_tty = isatty(1);\n    }\n    return output_is_tty == 1 ? 1 : 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/common/trace_type.c"}
{"compilable":0,"function":"static int pt_send_msg(int fd) {\n    if (clictx.pft.type != (1 << 0)) {\n        pt_comm_message_t *msg;\n        if (pt_comm_build_msg(&msg, sizeof(pt_filter_t), PT_MSG_DO_FILTER) == -1) {\n            return -1;\n        }\n        pt_filter_pack_filter_msg(&clictx.pft, msg->data);\n        if (pt_comm_send_msg(fd, msg) == -1) {\n            return -1;\n        }\n    }\n    if (clictx.pft.type != (1 << 1)) {\n        return pt_comm_send_type(fd, PT_MSG_DO_TRACE);\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/src/trace.c"}
{"compilable":0,"function":"int pt_status_main(void) {\n    int ret, try_ptrace;\n    try_ptrace = 0;\n    if (!clictx.ptrace) {\n        ret = status_ext();\n        if (ret == -1) {\n            printf(\"Fetch status error\\n\");\n            try_ptrace = 1;\n        } else if (ret == -2) {\n            printf(\"Operation timed out, no response received, make sure PHP process is active and extension already installed.\\n\");\n            try_ptrace = 1;\n        }\n    }\n    try_ptrace = 0;\n    if (clictx.ptrace || try_ptrace) {\n        ret = status_ptrace();\n    }\n    return ret;\n}\n","function_prediction":"int pt_status_main_name_conflict(void) {\n  int ret;\n\n  if (0) {\n    pt_log(0, \"C_COMPILE/silkCut_phptrace/src/status.c\", 144,\n           \"ptrace supported only on Linux\");\n    return -1;\n  }\n\n  ret = status_ext();\n  if (ret == -1) {\n    puts(\"Fetch status error\");\n  } else if (ret == -2) {\n    puts(\"Operation timed out, no response received, make sure PHP process is \"\n         \"active and extension already installed.\");\n  }\n\n  if (0) {\n    pt_log(0, \"C_COMPILE/silkCut_phptrace/src/status.c\", 144,\n           \"ptrace supported only on Linux\");\n    return -1;\n  }\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/src/status.c"}
{"compilable":0,"function":"sds sdsempty(void) {\n    return sdsnewlen(\"\", 0);\n}\n","function_prediction":"struct sds *sdsempty_name_conflict(void) {\n  struct sds *sds = malloc(sizeof(struct sds));\n  if (sds == NULL)\n    return NULL;\n  sds->len = 0;\n  sds->data[0] = '\\0';\n  return sds;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsnew(const char *init) {\n    size_t initlen = (init == ((void *)0)) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n","function_prediction":"sds sdsnewlen(const void *init, size_t initlen) {\n  struct sdshdr *sh;\n\n  if (init) {\n    sh = malloc(sizeof(struct sdshdr) + initlen + 1);\n    if (sh == NULL)\n      return NULL;\n    sh->len = initlen;\n    sh->free = 0;\n    if (initlen != 0)\n      memcpy(sh + 1, init, initlen);\n    sh->buf[initlen] = '\\0';\n  } else {\n    sh = calloc(sizeof(struct sdshdr) + initlen + 1, 1);\n    if (sh == NULL)\n      return NULL;\n    sh->len = 0;\n    sh->free = initlen;\n    sh->buf[0] = '\\0';\n  }\n  return (char *)(sh + 1);\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}\n","function_prediction":"sds sdsdup_name_conflict(const sds s) {\n  struct sdshdr *sh = (void *)(s - (sizeof(struct sdshdr)));\n  struct sdshdr *newsh;\n  sds ret;\n\n  newsh = malloc(sizeof(struct sdshdr) + sh->len + 1);\n  if (newsh == NULL)\n    return NULL;\n  newsh->len = sh->len;\n  newsh->free = 0;\n  ret = (char *)(newsh + 1);\n  if (sh->len)\n    memcpy(ret, s, sh->len);\n  ret[sh->len] = '\\0';\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsMakeRoomFor(sds s, size_t addlen) {\n    struct sdshdr *sh, *newsh;\n    size_t free = sdsavail(s);\n    size_t len, newlen;\n    if (free >= addlen)\n        return s;\n    len = sdslen(s);\n    sh = (void *)(s - sizeof *sh);\n    ;\n    newlen = (len + addlen);\n    if (newlen < (1024 * 1024))\n        newlen *= 2;\n    else\n        newlen += (1024 * 1024);\n    newsh = realloc(sh, sizeof *newsh + newlen + 1);\n    if (newsh == ((void *)0))\n        return ((void *)0);\n    newsh->free = newlen - len;\n    return newsh->buf;\n}\n","function_prediction":"sds sdsMakeRoomFor_name_conflict(sds s, size_t addlen) {\n  struct sdshdr *sh, *newsh;\n  size_t free = s[-1];\n  size_t len, newlen;\n\n  if (free >= addlen)\n    return s;\n\n  sh = (void *)(s - (sizeof(struct sdshdr)));\n  len = sh->len;\n  newlen = (len + addlen);\n\n  if (newlen < (1 << 18))\n    newlen *= 2;\n  else\n    newlen += (1 << 18);\n\n  newsh = realloc(sh, sizeof(*sh) + newlen + 1);\n  if (newsh == NULL)\n    return NULL;\n\n  newsh->free = newlen - len;\n  return (char *)(newsh + 1);\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsRemoveFreeSpace(sds s) {\n    struct sdshdr *sh;\n    sh = (void *)(s - sizeof *sh);\n    ;\n    sh = realloc(sh, sizeof *sh + sh->len + 1);\n    sh->free = 0;\n    return sh->buf;\n}\n","function_prediction":"sds sdsRemoveFreeSpace_name_conflict(sds s) {\n  struct sdshdr *sh = (void *)(s - (sizeof(struct sdshdr)));\n  s = (sds)realloc(sh, sizeof(struct sdshdr) + sh->free + 1);\n  sh = (void *)(s - (sizeof(struct sdshdr)));\n  sh->free = 0;\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"size_t sdsAllocSize(sds s) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    ;\n    return sizeof (*sh) + sh->len + sh->free + 1;\n}\n","function_prediction":"size_t sdsAllocSize_name_conflict(sds s) {\n  return ((size_t)(((sds)(((char *)(s)) - sizeof(struct sdshdr)))->len +\n                   ((sds)(((char *)(s)) - sizeof(struct sdshdr)))->free + 1));\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsgrowzero(sds s, size_t len) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    size_t totlen, curlen = sh->len;\n    if (len <= curlen)\n        return s;\n    s = sdsMakeRoomFor(s, len - curlen);\n    if (s == ((void *)0))\n        return ((void *)0);\n    sh = (void *)(s - sizeof *sh);\n    memset(s + curlen, 0, (len - curlen + 1));\n    totlen = sh->len + sh->free;\n    sh->len = len;\n    sh->free = totlen - sh->len;\n    return s;\n}\n","function_prediction":"sds sdsgrowzero_name_conflict(sds s, size_t len) {\n  struct sdshdr *sh = (void *)(s - (sizeof(struct sdshdr)));\n  size_t totlen;\n\n  if (len <= sh->free)\n    return s;\n\n  if (len - sh->free > sh->len) {\n    totlen = sh->len + (len - sh->free) + 16384;\n    sh = realloc(sh, sizeof(*sh) + totlen);\n    if (sh == NULL)\n      return NULL;\n    sh->free = totlen - sh->len;\n  }\n  memset(s + sh->len, 0, len - sh->len + 1);\n  sh->len = len;\n  sh->free = sh->free + (sh->len - len);\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n","function_prediction":"sds sdscat_name_conflict(sds s, const char *t) {\n  struct sdshdr *sh = (void *)(s - sizeof *sh);\n  size_t totlen = sh->len + strlen(t);\n  sds new = NULL;\n\n  if (sh->free < strlen(t)) {\n    new = (sds)realloc(sh, sizeof(struct sdshdr) + totlen + 1);\n    if (new == NULL)\n      return NULL;\n    new = new + sizeof *sh;\n    new[0] = sh->len - totlen;\n    sh = (void *)(new - sizeof *sh);\n  }\n\n  memcpy(s + sh->len, t, strlen(t));\n  sh->free -= strlen(t);\n  sh->len = totlen;\n  s[totlen] = '\\0';\n\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n","function_prediction":"sds sdscatsds_name_conflict(sds s, const sds t) {\n  struct sdshdr *sh, *newsh;\n  size_t totlen = s.len + t.len;\n\n  sh = (void *)(s.buf - (sizeof(struct sdshdr)));\n  if (sh->free < t.len) {\n    newsh = realloc(sh, sizeof(*sh) + totlen + 1);\n    if (newsh == NULL)\n      return NULL;\n\n    sh = newsh;\n    sh->free = sh->len = totlen - s.len;\n    s.buf = (char *)(sh + 1);\n  }\n  memcpy(s.buf + s.len, t.buf, t.len);\n  sh->free -= t.len;\n  sh->len += t.len;\n  s.buf[totlen] = '\\0';\n  s.len = totlen;\n  s.free = sh->free;\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscpylen(sds s, const char *t, size_t len) {\n    struct sdshdr *sh = (void *)(s - sizeof *sh);\n    ;\n    size_t totlen = sh->free + sh->len;\n    if (totlen < len) {\n        s = sdsMakeRoomFor(s, len - sh->len);\n        if (s == ((void *)0))\n            return ((void *)0);\n        sh = (void *)(s - sizeof *sh);\n        ;\n        totlen = sh->free + sh->len;\n    }\n    memcpy(s, t, len);\n    s[len] = '\\x00';\n    sh->len = len;\n    sh->free = totlen - len;\n    return s;\n}\n","function_prediction":"sds sdscpylen_name_conflict(sds s, const char *t, size_t len) {\n  struct sdshdr *sh = (void *)(s - (sizeof(struct sdshdr)));\n  size_t totlen = sh->free + sh->len;\n\n  if (len > totlen) {\n    size_t newfree = (len - sh->len) > 65536 ? len - sh->len : sh->free * 2;\n    struct sdshdr *newsh;\n\n    newsh = (void *)realloc(sh, sizeof(struct sdshdr) + len + newfree + 1);\n    if (newsh == NULL)\n      return NULL;\n    newsh->free = newfree;\n    sh = newsh;\n  }\n  s = (void *)(sh + 1);\n  s = memcpy(s, t, len);\n  s[len] = '\\0';\n  sh->len = (int)len;\n  sh->free = sh->free - len;\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscpy(sds s, const char *t) {\n    return sdscpylen(s, t, strlen(t));\n}\n","function_prediction":"sds sdscpy_name_conflict(sds s, const char *t) {\n  size_t len = strlen(t);\n  struct sdshdr *sh = (void *)(s - sizeof *sh);\n  sds ret;\n\n  if (len + sh->free < sh->len) {\n    ret = s;\n  } else {\n    ret = (sds)realloc(sh, sizeof(*sh) + len + 1);\n    if (ret == NULL)\n      return NULL;\n    sh = (void *)(ret - sizeof *sh);\n    sh->free = sh->len + len + 1 - ret;\n  }\n  memcpy(ret, t, len);\n  ret[len] = '\\0';\n  sh->len = len;\n  sh->free = sh->free - len;\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatprintf(sds s, const char *fmt, ...) {\n    va_list ap;\n    char *t;\n    __builtin_va_start(ap, fmt);\n    t = sdscatvprintf(s, fmt, ap);\n    __builtin_va_end(ap);\n    return t;\n}\n","function_prediction":"sds sdscatprintf_name_conflict(sds s, const char *fmt, ...) {\n  va_list ap;\n  char *buf, *p;\n  size_t len, newlen, avail;\n  struct sdshdr *sh;\n\n  va_start(ap, fmt);\n  len = strlen(s);\n  sh = (struct sdshdr *)(s - (sizeof(struct sdshdr)));\n  avail = sh->free;\n  if (avail < (1 << (5)) || avail >= len) {\n    newlen = (len + 1) * 2;\n    if (newlen < (1 << (5)))\n      newlen = (1 << (5));\n    buf = (char *)realloc(s - sizeof(*sh), newlen + sizeof(*sh));\n    if (buf == NULL)\n      return NULL;\n    s = buf + sizeof(*sh);\n    sh = (struct sdshdr *)(s - (sizeof(struct sdshdr)));\n    sh->free = newlen - len;\n  }\n\n  buf = malloc((1 << (4)));\n  if (buf == NULL)\n    goto cleanup;\n  buf[(1 << (4)) - 2] = '\\0';\n  vsnprintf(buf, (1 << (4)), fmt, ap);\n  if (buf[(1 << (4)) - 2] != '\\0') {\n    free(buf);\n    buf = NULL;\n    goto cleanup;\n  }\n  buf[(1 << (4)) - 2] = '\\0';\n  p = buf;\n  memcpy(s + len, p, strlen(p) + 1);\n  sh->free -= (strlen(p) + 1);\n  sh->len += (strlen(p) + 1);\n  s[len + strlen(p) + 1] = '\\0';\n  free(buf);\n  buf = NULL;\ncleanup:\n  if (buf)\n    free(buf);\n  va_end(ap);\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int sdscmp(const sds s1, const sds s2) {\n    size_t l1, l2, minlen;\n    int cmp;\n    l1 = sdslen(s1);\n    l2 = sdslen(s2);\n    minlen = (l1 < l2) ? l1 : l2;\n    cmp = memcmp(s1, s2, minlen);\n    if (cmp == 0)\n        return l1 - l2;\n    return cmp;\n}\n","function_prediction":"int sdscmp_name_conflict(const void *a, const void *b) {\n  size_t la = ((struct sdshdr *)((char *)a - (sizeof(struct sdshdr))))->len;\n  size_t lb = ((struct sdshdr *)((char *)b - (sizeof(struct sdshdr))))->len;\n  int cmp = memcmp(a, b, la < lb ? la : lb);\n  return cmp == 0 ? la - lb : cmp;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {\n    int elements = 0, slots = 5, start = 0, j;\n    sds *tokens;\n    if (seplen < 1 || len < 0)\n        return ((void *)0);\n    tokens = malloc(sizeof(sds) * slots);\n    if (tokens == ((void *)0))\n        return ((void *)0);\n    if (len == 0) {\n        *count = 0;\n        return tokens;\n    }\n    for (j = 0; j < (len - (seplen - 1)); j++) {\n        if (slots < elements + 2) {\n            sds *newtokens;\n            slots *= 2;\n            newtokens = realloc(tokens, sizeof(sds) * slots);\n            if (newtokens == ((void *)0))\n                goto cleanup;\n            tokens = newtokens;\n        }\n        if ((seplen == 1 && *(s + j) == sep[0]) || (memcmp(s + j, sep, seplen) == 0)) {\n            tokens[elements] = sdsnewlen(s + start, j - start);\n            if (tokens[elements] == ((void *)0))\n                goto cleanup;\n            elements++;\n            start = j + seplen;\n            j = j + seplen - 1;\n        }\n    }\n    tokens[elements] = sdsnewlen(s + start, len - start);\n    if (tokens[elements] == ((void *)0))\n        goto cleanup;\n    elements++;\n    *count = elements;\n    return tokens;\n  cleanup:\n    {\n        int i;\n        for (i = 0; i < elements; i++)\n            sdsfree(tokens[i]);\n        free(tokens);\n        *count = 0;\n        return ((void *)0);\n    }\n}\n","function_prediction":"char **sdssplitlen(const char *s, int len, const char *c, int clen,\n                   int *count) {\n  int i, j, k, l, m, n, o, p, q, r, sz;\n  char **v, *t;\n\n  if (clen <= 0 || len < 0)\n    return NULL;\n\n  if (len == 0) {\n    *count = 0;\n    return NULL;\n  }\n\n  sz = 5;\n  v = malloc(sz * sizeof(char *));\n  if (v == NULL)\n    goto err;\n\n  i = j = k = 0;\n  l = len - clen + 1;\n  while (i < l) {\n    if (sz <= k + 1) {\n      sz *= 2;\n      v = realloc(v, sz * sizeof(char *));\n      if (v == NULL)\n        goto err;\n    }\n\n    if (clen == 1 && s[i] == c[0]) {\n      i++;\n      continue;\n    }\n\n    if (!memcmp(s + i, c, clen)) {\n      m = i - j;\n      t = malloc(m + 1 + clen + 1);\n      if (t == NULL)\n        goto err;\n      t[0] = m;\n      t[1] = '\\0';\n      if (m)\n        memcpy(t + 2, s + j, m);\n      t[m + 2] = '\\0';\n      v[k++] = t;\n      i += clen;\n      j = i;\n    } else {\n      i++;\n    }\n  }\n\n  m = len - j;\n  t = malloc(m + 1 + clen + 1);\n  if (t == NULL)\n    goto err;\n  t[0] = m;\n  t[1] = '\\0';\n  if (m)\n    memcpy(t + 2, s + j, m);\n  t[m + 2] = '\\0';\n  v[k++] = t","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsfromlonglong(long long value) {\n    char buf[32], *p;\n    unsigned long long v;\n    v = (value < 0) ? -value : value;\n    p = buf + 31;\n    do {\n        *p-- = '0' + (v % 10);\n        v /= 10;\n    } while (v);\n    if (value < 0)\n        *p-- = '-';\n    p++;\n    return sdsnewlen(p, 32 - (p - buf));\n}\n","function_prediction":"sds sdsfromlonglong_name_conflict(long long value) {\n  char buf[32];\n  char *p = buf + 32;\n  int neg = (value < 0);\n  unsigned long v = (neg ? -value : value);\n\n  p--;\n  do {\n    *p = (v % 10) + '0';\n    v /= 10;\n    p--;\n  } while (v > 0);\n  if (neg)\n    *p = '-';\n\n  size_t len = (size_t)(buf + 32 - p);\n  sds s = malloc(len + 1 + 1);\n  if (s == NULL)\n    return NULL;\n  s[0] = len;\n  s[1] = 0;\n  if (len > 0)\n    memcpy(s + 2, p, len);\n  s[len + 1] = '\\0';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdscatrepr(sds s, const char *p, size_t len) {\n    s = sdscatlen(s, \"\\\"\", 1);\n    while (len--)\n        {\n            switch (*p) {\n              case '\\\\':\n              case '\"':\n                s = sdscatprintf(s, \"\\\\%c\", *p);\n                break;\n              case '\\n':\n                s = sdscatlen(s, \"\\\\n\", 2);\n                break;\n              case '\\r':\n                s = sdscatlen(s, \"\\\\r\", 2);\n                break;\n              case '\\t':\n                s = sdscatlen(s, \"\\\\t\", 2);\n                break;\n              case '\\a':\n                s = sdscatlen(s, \"\\\\a\", 2);\n                break;\n              case '\\b':\n                s = sdscatlen(s, \"\\\\b\", 2);\n                break;\n              default:\n                if (((*__ctype_b_loc())[(int)((*p))] & (unsigned short)_ISprint))\n                    s = sdscatprintf(s, \"%c\", *p);\n                else\n                    s = sdscatprintf(s, \"\\\\x%02x\", (unsigned char)*p);\n                break;\n            }\n            p++;\n        }\n    return sdscatlen(s, \"\\\"\", 1);\n}\n","function_prediction":"sds sdscatrepr_name_conflict(sds s, const char *p, size_t len) {\n  size_t cur = s[-2];\n  unsigned char ch;\n\n  if (s[-1] == 0) {\n    s = (sds)realloc(s - sizeof(struct sdshdr), cur + len + 3);\n    if (s == NULL)\n      return NULL;\n    s[2] = (char)(cur + len + 3);\n    s[3] = (char)(len + 1);\n  }\n  s[cur++] = '\"';\n  s[-2] = (char)cur;\n  s[-1]--;\n  s[cur] = '\\0';\n\n  while (len--) {\n    ch = (unsigned char)*p++;\n    switch (ch) {\n    case '\\\\':\n      s = sdscatprintf(s, \"\\\\\\\\\");\n      break;\n    case '\"':\n      s = sdscatprintf(s, \"\\\\\\\"\");\n      break;\n    case '\\n':\n      s = sdscatprintf(s, \"\\\\n\");\n      break;\n    case '\\r':\n      s = sdscatprintf(s, \"\\\\r\");\n      break;\n    case '\\t':\n      s = sdscatprintf(s, \"\\\\t\");\n      break;\n    case '\\a':\n      s = sdscatprintf(s, \"\\\\a\");\n      break;\n    case '\\b':\n      s = sdscatprintf(s, \"\\\\b\");\n      break;\n    default:\n      if (((ch) >= 0 && (ch) <= 127 && isprint(ch)) ||\n          (__ctype_b_loc()->*((signed int (*)[256])((128)) + (ch)) &\n           (0x01 | 0x02 | 0x04)))\n        s = sdscatprintf(s, \"%c\", ch);\n      else\n        s = sdscatprintf(s, \"\\\\x%02x\", ch);\n      break;\n    }\n  }\n\n  cur = s[-2];\n    if (s[-","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int is_hex_digit(char c) {\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');\n}\n","function_prediction":"int is_hex_digit_name_conflict(char c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n         (c >= 'A' && c <= 'F');\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"int hex_digit_to_int(char c) {\n    switch (c) {\n      case '0':\n        return 0;\n      case '1':\n        return 1;\n      case '2':\n        return 2;\n      case '3':\n        return 3;\n      case '4':\n        return 4;\n      case '5':\n        return 5;\n      case '6':\n        return 6;\n      case '7':\n        return 7;\n      case '8':\n        return 8;\n      case '9':\n        return 9;\n      case 'a':\n      case 'A':\n        return 10;\n      case 'b':\n      case 'B':\n        return 11;\n      case 'c':\n      case 'C':\n        return 12;\n      case 'd':\n      case 'D':\n        return 13;\n      case 'e':\n      case 'E':\n        return 14;\n      case 'f':\n      case 'F':\n        return 15;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int hex_digit_to_int_name_conflict(char c) {\n  switch (c) {\n  case '0':\n    return 0;\n  case '1':\n    return 1;\n  case '2':\n    return 2;\n  case '3':\n    return 3;\n  case '4':\n    return 4;\n  case '5':\n    return 5;\n  case '6':\n    return 6;\n  case '7':\n    return 7;\n  case '8':\n    return 8;\n  case '9':\n    return 9;\n  case 'a':\n    return 10;\n  case 'b':\n    return 11;\n  case 'c':\n    return 12;\n  case 'd':\n    return 13;\n  case 'e':\n    return 14;\n  case 'f':\n    return 15;\n  default:\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds *sdssplitargs(const char *line, int *argc) {\n    const char *p = line;\n    char *current = ((void *)0);\n    char **vector = ((void *)0);\n    *argc = 0;\n    while (1)\n        {\n            while (*p && ((*__ctype_b_loc())[(int)((*p))] & (unsigned short)_ISspace))\n                p++;\n            if (*p) {\n                int inq = 0;\n                int insq = 0;\n                int done = 0;\n                if (current == ((void *)0))\n                    current = sdsempty();\n                while (!done)\n                    {\n                        if (inq) {\n                            if (*p == '\\\\' && *(p + 1) == 'x' && is_hex_digit(*(p + 2)) && is_hex_digit(*(p + 3))) {\n                                unsigned char byte;\n                                byte = (hex_digit_to_int(*(p + 2)) * 16) + hex_digit_to_int(*(p + 3));\n                                current = sdscatlen(current, (char *)&byte, 1);\n                                p += 3;\n                            } else if (*p == '\\\\' && *(p + 1)) {\n                                char c;\n                                p++;\n                                switch (*p) {\n                                  case 'n':\n                                    c = '\\n';\n                                    break;\n                                  case 'r':\n                                    c = '\\r';\n                                    break;\n                                  case 't':\n                                    c = '\\t';\n                                    break;\n                                  case 'b':\n                                    c = '\\b';\n                                    break;\n                                  case 'a':\n                                    c = '\\a';\n                                    break;\n                                  default:\n                                    c = *p;\n                                    break;\n                                }\n                                current = sdscatlen(current, &c, 1);\n                            } else if (*p == '\"') {\n                                if (*(p + 1) && !((*__ctype_b_loc())[(int)((*(p + 1)))] & (unsigned short)_ISspace))\n                                    goto err;\n                                done = 1;\n                            } else if (!*p) {\n                                goto err;\n                            } else {\n                                current = sdscatlen(current, p, 1);\n                            }\n                        } else if (insq) {\n                            if (*p == '\\\\' && *(p + 1) == '\\'') {\n                                p++;\n                                current = sdscatlen(current, \"'\", 1);\n                            } else if (*p == '\\'') {\n                                if (*(p + 1) && !((*__ctype_b_loc())[(int)((*(p + 1)))] & (unsigned short)_ISspace))\n                                    goto err;\n                                done = 1;\n                            } else if (!*p) {\n                                goto err;\n                            } else {\n                                current = sdscatlen(current, p, 1);\n                            }\n                        } else {\n                            switch (*p) {\n                              case ' ':\n                              case '\\n':\n                              case '\\r':\n                              case '\\t':\n                              case '\\x00':\n                                done = 1;\n                                break;\n                              case '\"':\n                                inq = 1;\n                                break;\n                              case '\\'':\n                                insq = 1;\n                                break;\n                              default:\n                                current = sdscatlen(current, p, 1);\n                                break;\n                            }\n                        }\n                        if (*p)\n                            p++;\n                    }\n                vector = realloc(vector, ((*argc) + 1) * sizeof(char *));\n                vector[*argc] = current;\n                (*argc)++;\n                current = ((void *)0);\n            } else {\n                if (vector == ((void *)0))\n                    vector = malloc(sizeof(void *));\n                return vector;\n            }\n        }\n  err:\n    while ((*argc)--)\n        sdsfree(vector[*argc]);\n    free(vector);\n    if (current)\n        sdsfree(current);\n    *argc = 0;\n    return ((void *)0);\n}\n","function_prediction":"char **sdssplitargs_name_conflict(char *s, int *argc) {\n  char **argv;\n  char *p, *q, *r;\n  int i, j, k, l, m, n, o, qq;\n  const struct _ctype_t *ct;\n\n  *argc = 0;\n  argv = NULL;\n  while (*s) {\n    while (__ctype_b_loc()->ct[(unsigned char)*s] & 0x20)\n      s++;\n    p = malloc(sizeof(char *) + 1);\n    if (p) {\n      p[0] = '\\0';\n      p++;\n    }\n    q = p;\n    i = j = k = l = m = n = o = 0;\n    while (*s) {\n      if (i) {\n        if (j) {\n          if (k) {\n            if (l) {\n              if (m) {\n                if (n) {\n                  if (o) {\n                    if (*s == '\\\\') {\n                      if (*(s + 1) == '\\'') {\n                        *q++ = *(s + 1);\n                        s += 2;\n                        i = j = k = l = m = n = o = 0;\n                      }\n                    } else if (*s == '\\'') {\n                      s++;\n                      goto end;\n                    } else if (*s == '\\0') {\n                      goto end;\n                    } else {\n                      *q++ = *s;\n                      s++;\n                      i = j = k = l = m = n = o = 0;\n                    }\n                  } else {\n                    if (*s == '\\\\') {\n                      if (*(s + 1) == '\\'') {\n                        *q++ = *(s + 1);\n                        s += 2;\n                        i = j = k = l = m = n = o = 0;\n                      }\n                    } else if (*s == '\\'') {\n                      s++;\n                      goto end;\n                    } else if (*s == '\\0') {\n                      goto end;\n                    } else {\n                      *q++ = *s;\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {\n    size_t j, i, l = sdslen(s);\n    for (j = 0; j < l; j++) {\n        for (i = 0; i < setlen; i++) {\n            if (s[j] == from[i]) {\n                s[j] = to[i];\n                break;\n            }\n        }\n    }\n    return s;\n}\n","function_prediction":"char *sdsmapchars_name_conflict(char *s, char *from, char *to, size_t len) {\n  char *p, *end;\n  size_t i;\n\n  if (!(((sdshdr4_t *)((char *)(s) - sizeof(sdshdr4_t)))->len))\n    return s;\n  p = s;\n  end = s + (((sdshdr4_t *)((char *)(s) - sizeof(sdshdr4_t)))->len);\n  while (p != end) {\n    for (i = 0; i < len; i++) {\n      if (*p == from[i]) {\n        *p = to[i];\n        break;\n      }\n    }\n    p++;\n  }\n  return s;\n}","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsjoin(char **argv, int argc, char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n    for (j = 0; j < argc; j++) {\n        join = sdscat(join, argv[j]);\n        if (j != argc - 1)\n            join = sdscatlen(join, sep, seplen);\n    }\n    return join;\n}\n","function_prediction":"sds sdsjoinsds(sds *sds, int num, char *sep, size_t seplen) {\n  sds new = malloc(9);\n  if (new) {\n    new[0] = 0;\n    new[1] = 0;\n  }\n  for (int i = 0; i < num; i++) {\n    size_t len = strlen(sds[i]);\n    size_t curlen = new[-1];\n    if (new[-2] < len) {\n      size_t newlen =\n          (((curlen + len) < 1024 * 1024) ? (curlen + len) * 2\n                                          : curlen + len + 1024 * 1024);\n      new = realloc(new - 1, newlen + 9);\n      if (new) {\n        new[2] = newlen - curlen;\n      } else {\n        return new;\n      }\n    }\n    if (new) {\n      memcpy(new + curlen, sds[i], len);\n      new[-2] -= len;\n      new[-1] = curlen + len;\n      new[curlen + len] = 0;\n    } else {\n      return new;\n    }\n    if (i == num - 1) {\n      continue;\n    }\n    curlen = new[-1];\n    if (new[-2] < seplen) {\n      size_t newlen =\n          (((curlen + seplen) < 1024 * 1024) ? (curlen + seplen) * 2\n                                             : curlen + seplen + 1024 * 1024);\n      new = realloc(new - 1, newlen + 9);\n      if (new) {\n        new[2] = newlen - curlen;\n      } else {\n        return new;\n      }\n    }\n    if (new) {\n      memcpy(new + curlen, sep, seplen);\n      new[-2] -= seplen;\n      new[-1] = curlen + seplen;\n            new[curlen +","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n    for (j = 0; j < argc; j++) {\n        join = sdscatsds(join, argv[j]);\n        if (j != argc - 1)\n            join = sdscatlen(join, sep, seplen);\n    }\n    return join;\n}\n","function_prediction":"sds sdsjoinsds_name_conflict(const sds strings[], int count, const char *sep, size_t seplen) {\n  sds s;\n  size_t totlen = 0, curlen, slen;\n  int j;\n\n  for (j = 0; j < count; j++) {\n    slen = ((sds)strings[j])[1];\n    totlen += slen;\n    if (j != 0)\n      totlen += seplen;\n  }\n  s = malloc(totlen + 11);\n  if (s == NULL)\n    return NULL;\n  s[0] = s[1] = s[2] = s[3] = s[4] = s[5] = s[6] = s[7] = s[8] = s[9] = 0;\n  curlen = totlen;\n  for (j = 0; j < count; j++) {\n    slen = ((sds)strings[j])[1];\n    if (curlen < slen + 1) {\n      s = realloc(s, curlen + slen + seplen + 11);\n      if (s == NULL)\n        return NULL;\n      s[9] = (char)(slen + seplen);\n      s[10] = (char)(slen + seplen >> 8);\n      curlen = slen + seplen;\n    }\n    memcpy(s + totlen - curlen, strings[j], slen);\n    curlen -= slen;\n    totlen -= curlen;\n    if (j != 0) {\n      if (curlen < seplen + 1) {\n        s = realloc(s, totlen + seplen + 11);\n        if (s == NULL)\n          return NULL;\n        s[9] = (char)(seplen);\n        s[10] = (char)(seplen >> 8);\n        curlen = seplen;\n      }\n      memcpy(s + totlen - curlen, sep, seplen);\n      curlen -= seplen;\n      totlen -= curlen;\n    }\n","pass":0,"source_file":"C_COMPILE/silkCut_phptrace/deps/sds/sds.c"}
{"compilable":0,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"uint64_t jbg_ceil_half_name_conflict(uint64_t x, int64_t n) {\n  return (x & ((1ULL << n) - 1)) ? (x >> n) + 1 : (x >> n);\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"size_t jbg_stripes_name_conflict(size_t stripes, size_t size, int bits) {\n  size_t n = (size >> bits) + ((size & ((1ULL << bits) - 1)) ? 1 : 0);\n  return (n / stripes) + (n % stripes ? 1 : 0);\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg_strerror_name_conflict(int err) {\n  if (err < 0 || err >= 144)\n    return \"Unknown error code passed to jbg_strerror_name_conflict()\";\n  return errmsg[err >> 4];\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"const unsigned char *jbg_next_pscdms_name_conflict(const unsigned char *buf, size_t len) {\n  const unsigned char *p;\n  size_t l;\n\n  if (len < 2)\n    return NULL;\n\n  if (buf[0] != 0xff) {\n    p = memchr(buf, 0xff, len - 1);\n    if (p == NULL)\n      return buf;\n    l = p - buf;\n    len -= l;\n    buf += l;\n  } else {\n    p = buf;\n  }\n\n  while (p[0] == 0xff && p[1] == 0x00) {\n    p += 2;\n    len -= 2;\n    if (len < 2)\n      return NULL;\n  }\n\n  switch (p[1]) {\n  case 0x00:\n    return p;\n  case 0x01:\n    return NULL;\n  case 0x05:\n    p += 6;\n    len -= 6;\n    if (len < 6)\n      return NULL;\n    break;\n  case 0x06:\n    p += 8;\n    len -= 8;\n    if (len < 8)\n      return NULL;\n    break;\n  case 0x07:\n    p += 6;\n    len -= 6;\n    if (len < 6)\n      return NULL;\n    l = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];\n    p += l;\n    len -= l;\n    if (len < l)\n      return NULL;\n    break;\n  default:\n    p += 2;\n    len -= 2;\n    if (len < 2)\n      return NULL;\n    break;\n  }\n\n  return p;\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"int jbg_newlen_name_conflict(unsigned char *buf, size_t len) {\n  unsigned char *p;\n  int newlen = 32;\n\n  if (len < 20)\n    return newlen;\n\n  p = buf + 20;\n  if ((buf[5] & 0x07) == 0x06)\n    p = buf + 21;\n\n  if (p >= buf + len)\n    return newlen;\n\n  while (1) {\n    p = jbg_next_pscdms(p, len - (p - buf));\n    if (p == NULL)\n      return 96;\n    if (p == buf + len)\n      break;\n    if (p[0] == 0xff) {\n      if (p[1] == 0x04)\n        return 64;\n      if (p[1] == 0x05) {\n        if (p - buf + 5 < 3) {\n          buf[2] = p[2];\n          buf[3] = p[3];\n          buf[4] = p[4];\n          buf[5] = p[5];\n        } else {\n          buf[2] = p[2];\n          newlen = 0;\n        }\n        break;\n      }\n    }\n  }\n\n  return newlen;\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg85_strerror_name_conflict(int err) {\n  if (err < 0 || err >= 128)\n    return \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n  return errmsg[err >> 4];\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"uint64_t jbg_ceil_half_name_conflict(uint64_t x, int64_t n) {\n  return (x & ((1ULL << n) - 1)) ? (x >> n) + 1 : (x >> n);\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"size_t jbg_stripes_name_conflict(size_t stripes, size_t size, int bits) {\n  size_t n = (size >> bits) + ((size & ((1ULL << bits) - 1)) ? 1 : 0);\n  return (n / stripes) + (n % stripes ? 1 : 0);\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg_strerror_name_conflict(int err) {\n  if (err < 0 || err >= 144)\n    return \"Unknown error code passed to jbg_strerror_name_conflict()\";\n  return errmsg[err >> 4];\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"const unsigned char *jbg_next_pscdms_name_conflict(const unsigned char *buf, size_t len) {\n  const unsigned char *p = buf;\n  size_t l = len;\n\n  if (l < 2)\n    return NULL;\n\n  if (*p != 0xff) {\n    while ((p = memchr(buf, 0xff, l - 1)) != NULL) {\n      l -= p - buf;\n      p += 2;\n      if (p[0] == 0xff && p[1] == 0x00)\n        continue;\n      break;\n    }\n  } else {\n    p += 2;\n    l -= 2;\n  }\n\n  if (l < 2)\n    return NULL;\n\n  switch (p[0]) {\n  case 0x00:\n    return p;\n  case 0x01:\n    return NULL;\n  case 0x05:\n    p += 6;\n    l -= 6;\n    if (l < 6)\n      return NULL;\n    break;\n  case 0x06:\n    p += 8;\n    l -= 8;\n    if (l < 8)\n      return NULL;\n    break;\n  case 0x07:\n    p += 6;\n    l -= 6;\n    if (l < 6)\n      return NULL;\n    {\n      uint32_t n;\n      n = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];\n      p += n;\n      l -= n;\n      if (l < n)\n        return NULL;\n    }\n    break;\n  default:\n    p += 2;\n    l -= 2;\n    break;\n  }\n\n  return p;\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"int jbg_newlen_name_conflict(unsigned char *buf, size_t len) {\n  unsigned char *p;\n  int newlen = 32;\n\n  if (len < 20)\n    return newlen;\n\n  p = buf + 20;\n  if ((buf[5] & 0x07) == 0x06)\n    p = buf + 21;\n\n  if (p >= buf + len)\n    return newlen;\n\n  while (1) {\n    p = jbg_next_pscdms(p, len - (p - buf));\n    if (p == NULL)\n      return 96;\n    if (p == buf + len)\n      break;\n    if (p[0] == 0xff) {\n      if (p[1] == 0x04)\n        return 64;\n      if (p[1] == 0x05) {\n        if (p - buf + 5 < 3) {\n          buf[2] = p[2];\n          buf[3] = p[3];\n          buf[4] = p[4];\n          buf[5] = p[5];\n        } else {\n          buf[2] = p[2];\n          newlen = 0;\n        }\n        break;\n      }\n    }\n  }\n  return newlen;\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg85_strerror_name_conflict(int err) {\n  if (err < 0 || err >= 128)\n    return \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n  return errmsg[err >> 4];\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"static int test_cycle(unsigned char **orig_image, int width, int height, int options, int order, int layers, int planes, unsigned long l0, int mx, long correct_length, const char *test_id) {\n    struct jbg_enc_state sje;\n    struct jbg_dec_state sjd;\n    int trouble = 0;\n    long l;\n    size_t plane_size;\n    int i, result;\n    unsigned char **image;\n    plane_size = ((width + 7) / 8) * height;\n    image = (unsigned char **)checkedmalloc(planes * sizeof(unsigned char *));\n    for (i = 0; i < planes; i++) {\n        image[i] = (unsigned char *)checkedmalloc(plane_size);\n        memcpy(image[i], orig_image[i], plane_size);\n    }\n    printf(\"\\nTest %s.1: Encoding ...\\n\", test_id);\n    testbuf_len = 0;\n    jbg_enc_init(&sje, width, height, planes, image, testbuf_writel, ((void *)0));\n    jbg_enc_layers(&sje, layers);\n    jbg_enc_options(&sje, order, options, l0, mx, 0);\n    jbg_enc_out(&sje);\n    jbg_enc_free(&sje);\n    for (i = 0; i < planes; i++)\n        free(image[i]);\n    free(image);\n    printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n    if (correct_length >= 0)\n        if (testbuf_len == correct_length)\n            puts(\"PASSED\");\n        else {\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\", correct_length);\n        }\n    else\n        puts(\"\");\n    printf(\"Test %s.2: Decoding whole chunk ...\\n\", test_id);\n    jbg_dec_init(&sjd);\n    result = jbg_dec_in(&sjd, testbuf, testbuf_len, ((void *)0));\n    if (result != (0 << 4)) {\n        printf(\"Decoder complained with return value %d: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg_strerror(result));\n        trouble++;\n    } else {\n        printf(\"Image comparison: \");\n        result = 1;\n        for (i = 0; i < planes; i++) {\n            if (memcmp(orig_image[i], sjd.lhp[layers & 1][i], ((width + 7) / 8) * height)) {\n                result = 0;\n                trouble++;\n                printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD for plane %d\\n\", i);\n            }\n        }\n        if (result)\n            puts(\"PASSED\");\n    }\n    jbg_dec_free(&sjd);\n    printf(\"Test %s.3: Decoding with single-byte feed ...\\n\", test_id);\n    jbg_dec_init(&sjd);\n    result = (2 << 4);\n    for (l = 0; l < testbuf_len; l++) {\n        result = jbg_dec_in(&sjd, testbuf + l, 1, ((void *)0));\n        if (l < testbuf_len - 1 && result != (2 << 4)) {\n            printf(\"Decoder complained with return value %d at byte %ld: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, l, jbg_strerror(result));\n            trouble++;\n            break;\n        }\n    }\n    if (l == testbuf_len) {\n        if (result != (0 << 4)) {\n            printf(\"Decoder complained with return value %d at final byte: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg_strerror(result));\n            trouble++;\n        } else {\n            printf(\"Image comparison: \");\n            result = 1;\n            for (i = 0; i < planes; i++) {\n                if (memcmp(orig_image[i], sjd.lhp[layers & 1][i], ((width + 7) / 8) * height)) {\n                    result = 0;\n                    trouble++;\n                    printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD for plane %d\\n\", i);\n                }\n            }\n            if (result)\n                puts(\"PASSED\");\n        }\n    }\n    jbg_dec_free(&sjd);\n    puts(\"\");\n    return trouble != 0;\n}\n","function_prediction":"int test_cycle(unsigned char **ref, int w, int h, int n, int l, int m, int p,\n               int q, int r, long int bie_len, char *name) {\n  int i, j, k, ret, errs = 0;\n  unsigned char *buf[150];\n  jbg_enc_t enc;\n  jbg_dec_t dec;\n  size_t size = (w + 7) / 8 * h * p;\n\n  for (i = 0; i < p; i++) {\n    if (!(buf[i] = malloc(size))) {\n      fprintf(stderr, \"Sorry, not enough memory available!\\n\");\n      exit(1);\n    }\n    memcpy(buf[i], ref[i], size);\n  }\n\n  printf(\"\\nTest %s.1: Encoding ...\\n\", name);\n  testbuf_len = 0;\n  jbg_enc_init(&enc, w, h, p, buf, testbuf_writel, 0);\n  jbg_enc_layers(&enc, m);\n  jbg_enc_options(&enc, l, n, q, r, 0);\n  jbg_enc_out(&enc);\n  jbg_enc_free(&enc);\n\n  for (i = 0; i < p; i++)\n    free(buf[i]);\n  free(buf);\n\n  printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n  if (bie_len != -1) {\n    if (testbuf_len != bie_len) {\n      printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\",\n             bie_len);\n      errs++;\n    } else\n      printf(\"PASSED\\n\");\n  } else\n    printf(\"\\n\");\n\n  printf(\"Test %s.2: Decoding whole chunk ...\\n\", name);\n  jbg_dec_init(&dec);\n    ret = jbg_dec_in(&dec, testbuf, testbuf_len,","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/tstcodec.c"}
{"compilable":0,"function":"unsigned long jbg_ceil_half(unsigned long x, int n) {\n    unsigned long mask;\n    ((void)(0));\n    mask = (1UL << n) - 1;\n    return (x >> n) + ((mask & x) != 0);\n}\n","function_prediction":"uint64_t jbg_ceil_half_name_conflict(uint64_t x, int64_t n) {\n  return (x & ((1ULL << n) - 1)) ? (x >> n) + 1 : (x >> n);\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":1,"function":"unsigned long jbg_stripes(unsigned long l0, unsigned long yd, unsigned long d) {\n    unsigned long y0 = jbg_ceil_half(yd, d);\n    return y0 / l0 + (y0 % l0 != 0);\n}\n","function_prediction":"size_t jbg_stripes_name_conflict(size_t stripes, size_t size, int bits) {\n  size_t n = (size >> bits) + ((size & ((1ULL << bits) - 1)) ? 1 : 0);\n  return (n / stripes) + (n % stripes ? 1 : 0);\n}","pass":1,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":1,"function":"const char *jbg_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg_strerror_name_conflict(int err) {\n  if (err < 0 || err >= 144)\n    return \"Unknown error code passed to jbg_strerror_name_conflict()\";\n  return errmsg[err >> 4];\n}","pass":1,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":0,"function":"unsigned char *jbg_next_pscdms(unsigned char *p, size_t len) {\n    unsigned char *pp;\n    unsigned long l;\n    if (len < 2)\n        return ((void *)0);\n    if (p[0] != 255 || p[1] == 0) {\n        do {\n            while (p[0] == 255 && p[1] == 0)\n                {\n                    p += 2;\n                    len -= 2;\n                    if (len < 2)\n                        return ((void *)0);\n                }\n            ((void)(0));\n            pp = (unsigned char *)memchr(p, 255, len - 1);\n            if (!pp)\n                return ((void *)0);\n            l = pp - p;\n            ((void)(0));\n            p += l;\n            len -= l;\n        } while (p[1] == 0);\n    } else {\n        switch (p[1]) {\n          case 2:\n          case 3:\n          case 4:\n            return p + 2;\n          case 5:\n            if (len < 6)\n                return ((void *)0);\n            return p + 6;\n          case 6:\n            if (len < 8)\n                return ((void *)0);\n            return p + 8;\n          case 7:\n            if (len < 6)\n                return ((void *)0);\n            l = (((long)p[2] << 24) | ((long)p[3] << 16) | ((long)p[4] << 8) | (long)p[5]);\n            if (len - 6 < l)\n                return ((void *)0);\n            return p + 6 + l;\n          default:\n            return ((void *)0);\n        }\n    }\n    return p;\n}\n","function_prediction":"const unsigned char *jbg_next_pscdms_name_conflict(const unsigned char *buf, size_t len) {\n  const unsigned char *p = buf;\n  size_t l = len;\n\n  if (l < 2)\n    return NULL;\n\n  if (*p != 0xff) {\n    while ((p = memchr(buf, 0xff, l - 1)) != NULL) {\n      l -= p - buf;\n      p++;\n      if (p[0] == 0xff && p[1] == 0x00)\n        continue;\n      break;\n    }\n  } else {\n    p++;\n    l--;\n  }\n\n  if (l < 2)\n    return NULL;\n\n  switch (p[0]) {\n  case 0x00:\n    return p;\n  case 0x01:\n    return NULL;\n  case 0x05:\n    p += 6;\n    l -= 6;\n    if (l < 6)\n      return NULL;\n    break;\n  case 0x06:\n    p += 8;\n    l -= 8;\n    if (l < 8)\n      return NULL;\n    break;\n  case 0x07:\n    p += 6;\n    l -= 6;\n    if (l < 6)\n      return NULL;\n    {\n      uint32_t len = (((uint32_t)(p[0]) << 24) | ((uint32_t)(p[1]) << 16) |\n                      ((uint32_t)(p[2]) << 8) | ((uint32_t)(p[3]) << 0));\n      p += 4;\n      l -= 4;\n      if (l < len)\n        return NULL;\n      p += len;\n      l -= len;\n    }\n    break;\n  default:\n    p += 2;\n    l -= 2;\n    break;\n  }\n\n  return p;\n}","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":1,"function":"int jbg_newlen(unsigned char *bie, size_t len) {\n    unsigned char *p = bie + 20;\n    int i;\n    if (len < 20)\n        return (2 << 4);\n    if ((bie[19] & (4 | 2 | 1)) == (4 | 2))\n        p += 1728;\n    if (p >= bie + len)\n        return (2 << 4);\n    while ((p = jbg_next_pscdms(p, len - (p - bie))))\n        {\n            if (p == bie + len)\n                return (0 << 4);\n            else if (p[0] == 255)\n                switch (p[1]) {\n                  case 5:\n                    for (i = 0; i < 4; i++) {\n                        bie[8 + i] = p[2 + i];\n                    }\n                    return (0 << 4);\n                  case 4:\n                    return (4 << 4);\n                }\n        }\n    return (6 << 4) | 0;\n}\n","function_prediction":"int jbg_newlen_name_conflict(unsigned char *buf, size_t len) {\n  unsigned char *p;\n  int newlen = 32;\n\n  if (len < 20)\n    return newlen;\n\n  p = buf + 20;\n  if ((buf[5] & 0x07) == 0x06)\n    p = buf + 21;\n\n  if (p >= buf + len)\n    return newlen;\n\n  while (1) {\n    p = jbg_next_pscdms(p, len - (p - buf));\n    if (p == NULL)\n      return 96;\n    if (p == buf + len)\n      break;\n    if (p[0] == 0xff) {\n      if (p[1] == 0x04)\n        return 64;\n      if (p[1] == 0x05) {\n        if (p - buf + 5 < 3) {\n          buf[2] = p[2];\n          buf[3] = p[3];\n          buf[4] = p[4];\n          buf[5] = p[5];\n        } else {\n          buf[2] = p[2];\n        }\n        break;\n      }\n    }\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig.c"}
{"compilable":1,"function":"const char *jbg85_strerror(int errnum) {\n    errnum >>= 4;\n    if (errnum < 0 || (unsigned int)errnum >= sizeof (errmsg) / sizeof (errmsg[0]))\n        return \"Unknown error code passed to jbg85_strerror()\";\n    return errmsg[errnum];\n}\n","function_prediction":"const char *jbg85_strerror_name_conflict(int err) {\n  if (err < 0 || err >= 128)\n    return \"Unknown error code passed to jbg85_strerror_name_conflict()\";\n  return errmsg[err >> 4];\n}","pass":1,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/jbig85.c"}
{"compilable":0,"function":"static int test_cycle(unsigned char *orig_image, int width, int height, int options, unsigned long l0, int mx, long correct_length, const char *test_id) {\n    struct jbg85_enc_state sje;\n    struct jbg85_dec_state sjd;\n    int trouble = 0;\n    long l;\n    size_t plane_size, buffer_len;\n    int i, result;\n    unsigned char *image, *buffer;\n    size_t bpl;\n    size_t cnt;\n    bpl = (width + 7) / 8;\n    plane_size = bpl * height;\n    image = (unsigned char *)checkedmalloc(plane_size);\n    memcpy(image, orig_image, plane_size);\n    printf(\"\\nTest-85 %s.1: Encoding ...\\n\", test_id);\n    testbuf_len = 0;\n    jbg85_enc_init(&sje, width, height, testbuf_writel, ((void *)0));\n    jbg85_enc_options(&sje, options, l0, mx);\n    for (i = 0; i < height; i++)\n        jbg85_enc_lineout(&sje, image + i * bpl, image + (i - 1) * bpl, image + (i - 2) * bpl);\n    free(image);\n    printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n    if (correct_length >= 0)\n        if (testbuf_len == correct_length)\n            puts(\"PASSED\");\n        else {\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\", correct_length);\n        }\n    else\n        puts(\"\");\n    buffer_len = ((width >> 3) + !!(width & 7)) * 3;\n    buffer = (unsigned char *)checkedmalloc(buffer_len);\n    image = (unsigned char *)checkedmalloc(plane_size);\n    printf(\"Test-85 %s.2: Decoding whole chunk ...\\n\", test_id);\n    jbg85_dec_init(&sjd, buffer, buffer_len, line_out, image);\n    result = jbg85_dec_in(&sjd, testbuf, testbuf_len, &cnt);\n    if (result != (0 << 4)) {\n        printf(\"Decoder complained with return value 0x%02x: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg85_strerror(result));\n        printf(\"%ld bytes of BIE read, %lu lines decoded.\\n\", (long)cnt, sjd.y);\n        trouble++;\n    } else {\n        printf(\"Image comparison: \");\n        result = 1;\n        if (memcmp(orig_image, image, plane_size)) {\n            result = 0;\n            trouble++;\n            printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\");\n        }\n        if (result)\n            puts(\"PASSED\");\n    }\n    free(image);\n    image = (unsigned char *)checkedmalloc(plane_size);\n    printf(\"Test-85 %s.3: Decoding with single-byte feed ...\\n\", test_id);\n    jbg85_dec_init(&sjd, buffer, buffer_len, line_out, image);\n    result = (2 << 4);\n    for (l = 0; l < testbuf_len; l++) {\n        result = jbg85_dec_in(&sjd, testbuf + l, 1, ((void *)0));\n        if (l < testbuf_len - 1 && result != (2 << 4)) {\n            printf(\"Decoder complained with return value 0x%02x at byte %ld: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, l, jbg85_strerror(result));\n            trouble++;\n            break;\n        }\n    }\n    if (l == testbuf_len) {\n        if (result != (0 << 4)) {\n            printf(\"Decoder complained with return value 0x%02x at final byte: F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\\nCause: '%s'\\n\", result, jbg85_strerror(result));\n            trouble++;\n        } else {\n            printf(\"Image comparison: \");\n            result = 1;\n            if (memcmp(orig_image, image, plane_size)) {\n                result = 0;\n                trouble++;\n                printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD\");\n            }\n            if (result)\n                puts(\"PASSED\");\n        }\n    }\n    free(image);\n    puts(\"\");\n    return trouble != 0;\n}\n","function_prediction":"int test_cycle_constprop_0(unsigned char *img, int opt_flags, int opt_level,\n                           int opt_misc, long bie_len, char *test_name) {\n  unsigned char *img_copy = checkedmalloc(292443);\n  memcpy(img_copy, img, 292443);\n\n  printf(\"\\nTest-85 %s.1: Encoding ...\\n\", test_name);\n  testbuf_len = 0;\n  struct jbg85_enc_state enc;\n  jbg85_enc_init(&enc, 2008, 2015, testbuf_writel, NULL);\n  jbg85_enc_options(&enc, opt_flags, opt_level, opt_misc);\n  for (size_t i = 0; i < 292443; i += 245)\n    jbg85_enc_lineout(&enc, img_copy + i, img_copy + i - 245,\n                      img_copy + i - 570);\n  free(img_copy);\n\n  printf(\"Encoded BIE has %6ld bytes: \", testbuf_len);\n  if (testbuf_len != bie_len) {\n    printf(\"F\\bFA\\bAI\\bIL\\bLE\\bED\\bD, correct would have been %ld\\n\", bie_len);\n    return 1;\n  }\n  printf(\"PASSED\\n\");\n\n  int retval = 0;\n  unsigned char *img_copy2 = checkedmalloc(765);\n  unsigned char *img_dec = checkedmalloc(292443);\n  printf(\"Test-85 %s.2: Decoding whole chunk ...\\n\", test_name);\n  struct jbg85_dec_state dec;\n  jbg85_dec_init(&dec, img_copy2, 765, line_out, img_dec);\n  size_t bie_read;\n  int ret = jbg85_dec_in(&dec, testbuf, testbuf_len, &bie","pass":0,"source_file":"C_COMPILE/Distrotech_jbigkit/libjbig/tstcodec85.c"}
{"compilable":1,"function":"int discovery() {\n    DIR *dir;\n    struct dirent *ent;\n    bool comma = 0;\n    if ((dir = opendir(\"/sys/kernel/debug/ieee80211/\")) != ((void *)0)) {\n        printf(\"{\\\"data\\\":[\");\n        while ((ent = readdir(dir)) != ((void *)0))\n            {\n                if (strcmp(\".\", ent->d_name) && strcmp(\"..\", ent->d_name)) {\n                    if (comma)\n                        printf(\",\");\n                    printf(\"{\\\"{#PHY}\\\":\\\"%s\\\"}\", ent->d_name);\n                    comma = 1;\n                }\n            }\n        printf(\"]}\\n\");\n        closedir(dir);\n    } else {\n        perror(\"\");\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int discovery_name_conflict() {\n  DIR *dir;\n  struct dirent *ent;\n  int first = 0;\n\n  if ((dir = opendir(\"/sys/kernel/debug/ieee80211/\")) == NULL) {\n    perror(\"\");\n    return 1;\n  }\n\n  printf(\"{\\\"data\\\":[\");\n\n  while ((ent = readdir(dir)) != NULL) {\n    if (ent->d_name[0] == '.' && ent->d_name[1] == '\\0')\n      continue;\n    if (ent->d_name[0] == '.' && ent->d_name[1] == '.' &&\n        ent->d_name[2] == '\\0')\n      continue;\n\n    if (first)\n      printf(\",\");\n    else\n      first = 1;\n\n    printf(\"{\\\"{#PHY}\\\":\\\"%s\\\"}\", ent->d_name);\n  }\n\n  printf(\"]}\\n\");\n\n  closedir(dir);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":1,"function":"int get_param(char *phy, char *stat) {\n    char *filename = ((void *)0);\n    FILE *f = ((void *)0);\n    phy = basename(phy);\n    stat = basename(stat);\n    if (asprintf(&filename, \"/sys/kernel/debug/ieee80211/%s/statistics/%s\", phy, stat) > 0)\n        f = fopen(filename, \"r\");\n    if (f != ((void *)0)) {\n        char temp[256];\n        while (fgets(temp, 256, f) != ((void *)0))\n            printf(\"%s\", temp);\n        fclose(f);\n    } else {\n        perror(\"\");\n        return 1;\n    }\n    free(filename);\n    return 0;\n}\n","function_prediction":"int get_param_name_conflict(char *ifname, char *param) {\n  FILE *f;\n  char *path = NULL;\n  char buf[256];\n\n  if (asprintf(&path, \"/sys/kernel/debug/ieee80211/%s/statistics/%s\",\n               basename(ifname), basename(param)) < 1) {\n    perror(\"\");\n    return 1;\n  }\n\n  f = fopen(path, \"r\");\n  if (!f) {\n    perror(\"\");\n    return 1;\n  }\n\n  while (fgets(buf, sizeof(buf), f))\n    printf(\"%s\", buf);\n\n  fclose(f);\n  free(path);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":1,"function":"int usage(char *name) {\n    fprintf(stderr, \"Usage:\\n\");\n    fprintf(stderr, \" %s discovery\\n\", name);\n    fprintf(stderr, \" => print mac80211.phydiscovery discovery rule\\n\");\n    fprintf(stderr, \" %s PHY STAT\\n\", name);\n    fprintf(stderr, \" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as root\\n\");\n    return 1;\n}\n","function_prediction":"int usage_name_conflict(char *progname) {\n  fprintf(stderr, \"Usage:\\n\");\n  fprintf(stderr, \" %s discovery\\n\", progname);\n  fprintf(stderr, \" => print mac80211.phydiscovery discovery rule\\n\");\n  fprintf(stderr, \" %s PHY STAT\\n\", progname);\n  fprintf(stderr,\n          \" => cat /sys/kernel/debug/ieee80211/PHY/statistics/STAT as root\\n\");\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/jp-bennett_packages/admin/zabbix/files/zabbix_helper_mac80211.c"}
{"compilable":0,"function":"static char *xasprintf(const char *fmt, ...) {\n    va_list ap;\n    char *ret;\n    __builtin_va_start(ap, fmt);\n    ret = xvasprintf(fmt, ap);\n    __builtin_va_end(ap);\n    return ret;\n}\n","function_prediction":"char *xasprintf_constprop_0(int a1, int a2, int a3, int a4, int a5, int a6,\n                            int a7, int a8, int a9, int a10, int a11, int a12,\n                            int a13, int a14) {\n  char *buf;\n  int len;\n  char *p;\n  char *q;\n  char *r;\n  char *s;\n  char *t;\n  char *u;\n  char *v;\n  char *w;\n  char *x;\n  char *y;\n  char *z;\n  char *aa;\n  char *ab;\n  char *ac;\n  char *ad;\n  char *ae;\n  char *af;\n  char *ag;\n  char *ah;\n  char *ai;\n  char *aj;\n  char *ak;\n  char *al;\n  char *am;\n  char *an;\n  char *ao;\n  char *ap;\n  char *aq;\n  char *ar;\n  char *as;\n  char *at;\n  char *au;\n  char *av;\n  char *aw;\n  char *ax;\n  char *ay;\n  char *az;\n  char *ba;\n  char *bb;\n  char *bc;\n  char *bd;\n  char *be;\n  char *bf;\n  char *bg;\n  char *bh;\n  char *bi;\n  char *bj;\n  char *bk;\n  char *bl;\n  char *bm;\n  char *bn;\n  char *bo;\n  char *bp;\n  char *bq;\n  char *br;\n  char *bs;\n  char *bt;\n  char *bu;\n  char *bv;\n  char *bw;\n  char *bx;\n  char *by;\n  char *bz;\n  char *ca;\n  char *cb;\n  char *cc;\n  char *cd;\n  char *ce;\n  char *cf;\n  char *","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":0,"function":"static char *fieldcpy(char *dst, char *fld) {\n    while (*fld && *fld != ':')\n        fld++;\n    if (!*(fld++))\n        return ((void *)0);\n    while (((*__ctype_b_loc())[(int)((*fld))] & (unsigned short)_ISspace))\n        fld++;\n    return strcpy(dst, fld);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":0,"function":"static int dotranslatewgetpercent(int low, int high, int end, char *str) {\n    int ch;\n    int val, lastval;\n    lastval = val = 0;\n    while ((ch = getchar()) != (-1))\n        {\n            if (((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISdigit)) {\n                val *= 10;\n                val += ch - '0';\n            } else if (ch == '%') {\n                float f = (float)val / 100. * (high - low) + low;\n                if (str) {\n                    printf(\"P: %d %d %s\\n\", (int)f, end, str);\n                } else {\n                    printf(\"P: %d %d\\n\", (int)f, end);\n                }\n                lastval = val;\n            } else {\n                val = 0;\n            }\n        }\n    return lastval == 100;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jp-bennett_packages/admin/debootstrap/files/pkgdetails.c"}
{"compilable":0,"function":"static int luaO_int2fb(unsigned int x) {\n    int e = 0;\n    while (x >= 16)\n        {\n            x = (x + 1) >> 1;\n            e++;\n        }\n    if (x < 8)\n        return x;\n    else\n        return ((e + 1) << 3) | (((int)((x))) - 8);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int luaO_fb2int(int x) {\n    int e = (x >> 3) & 31;\n    if (e == 0)\n        return x;\n    else\n        return ((x & 7) + 8) << (e - 1);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int luaO_log2(unsigned int x) {\n    static const lu_byte log_2[256] = {0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};\n    int l = -1;\n    while (x >= 256)\n        {\n            l += 8;\n            x >>= 8;\n        }\n    return l + log_2[x];\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int computesizes(int nums[], int *narray) {\n    int i;\n    int twotoi;\n    int a = 0;\n    int na = 0;\n    int n = 0;\n    for (i = 0 , twotoi = 1; twotoi / 2 < *narray; i++ , twotoi *= 2) {\n        if (nums[i] > 0) {\n            a += nums[i];\n            if (a > twotoi / 2) {\n                n = twotoi;\n                na = a;\n            }\n        }\n        if (a == *narray)\n            break;\n    }\n    *narray = n;\n    return na;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static UnOpr getunopr(int op) {\n    switch (op) {\n      case TK_NOT:\n        return OPR_NOT;\n      case '-':\n        return OPR_MINUS;\n      case '#':\n        return OPR_LEN;\n      default:\n        return OPR_NOUNOPR;\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static BinOpr getbinopr(int op) {\n    switch (op) {\n      case '+':\n        return OPR_ADD;\n      case '-':\n        return OPR_SUB;\n      case '*':\n        return OPR_MUL;\n      case '/':\n        return OPR_DIV;\n      case '%':\n        return OPR_MOD;\n      case '^':\n        return OPR_POW;\n      case TK_CONCAT:\n        return OPR_CONCAT;\n      case TK_NE:\n        return OPR_NE;\n      case TK_EQ:\n        return OPR_EQ;\n      case '<':\n        return OPR_LT;\n      case TK_LE:\n        return OPR_LE;\n      case '>':\n        return OPR_GT;\n      case TK_GE:\n        return OPR_GE;\n      case TK_AND:\n        return OPR_AND;\n      case TK_OR:\n        return OPR_OR;\n      default:\n        return OPR_NOBINOPR;\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int block_follow(int token) {\n    switch (token) {\n      case TK_ELSE:\n      case TK_ELSEIF:\n      case TK_END:\n      case TK_UNTIL:\n      case TK_EOS:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static ptrdiff_t posrelat(ptrdiff_t pos, size_t len) {\n    if (pos < 0)\n        pos += (ptrdiff_t)len + 1;\n    return (pos >= 0) ? pos : 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int match_class(int c, int cl) {\n    int res;\n    switch (tolower(cl)) {\n      case 'a':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha);\n        break;\n      case 'c':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_IScntrl);\n        break;\n      case 'd':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit);\n        break;\n      case 'l':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISlower);\n        break;\n      case 'p':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISpunct);\n        break;\n      case 's':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISspace);\n        break;\n      case 'u':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISupper);\n        break;\n      case 'w':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalnum);\n        break;\n      case 'x':\n        res = ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISxdigit);\n        break;\n      case 'z':\n        res = (c == 0);\n        break;\n      default:\n        return (cl == c);\n    }\n    return (((*__ctype_b_loc())[(int)((cl))] & (unsigned short)_ISlower) ? res : !res);\n}\n","function_prediction":"int match_class_name_conflict(int c, int i) {\n  int r;\n  const unsigned short *p;\n\n  switch (__ctype_tolower_loc()[(unsigned char)i]) {\n  case 'a':\n    p = __ctype_b_loc();\n    r = (p[0][c] & 0x00000400) != 0;\n    break;\n  case 'c':\n    p = __ctype_b_loc();\n    r = (p[0][c] & 0x00000002) != 0;\n    break;\n  case 'd':\n    p = __ctype_b_loc();\n    r = (p[0][c] & 0x00000800) != 0;\n    break;\n  case 'l':\n    p = __ctype_b_loc();\n    r = (p[0][c] & 0x00000200) != 0;\n    break;\n  case 'p':\n    p = __ctype_b_loc();\n    r = (p[0][c] & 0x00000004) != 0;\n    break;\n  case 's':\n    p = __ctype_b_loc();\n    r = (p[0][c] & 0x00002000) != 0;\n    break;\n  case 'u':\n    p = __ctype_b_loc();\n    r = (p[0][c] & 0x00000100) != 0;\n    break;\n  case 'w':\n    p = __ctype_b_loc();\n    r = (p[0][c] & 0x00000008) != 0;\n    break;\n  case 'x':\n    p = __ctype_b_loc();\n    r = (p[0][c] & 0x00001000) != 0;\n    break;\n  case 'z':\n    p = __ctype_","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int matchbracketclass(int c, const char *p, const char *ec) {\n    int sig = 1;\n    if (*(p + 1) == '^') {\n        sig = 0;\n        p++;\n    }\n    while (++p < ec)\n        {\n            if (*p == '%') {\n                p++;\n                if (match_class(c, ((unsigned char)(*p))))\n                    return sig;\n            } else if ((*(p + 1) == '-') && (p + 2 < ec)) {\n                p += 2;\n                if (((unsigned char)(*(p - 2))) <= c && c <= ((unsigned char)(*p)))\n                    return sig;\n            } else if (((unsigned char)(*p)) == c)\n                return sig;\n        }\n    return !sig;\n}\n","function_prediction":"int matchbracketclass_name_conflict(int c, const char *p, const char *pend) {\n  int negate = 0;\n\n  if (*p == '^') {\n    negate = 1;\n    p++;\n  }\n\n  for (; p < pend; p++) {\n    int match = 0;\n\n    if (*p == '%') {\n      p++;\n      switch (*p) {\n      case 'a':\n        match = (__ctype_b_loc()->bits[(c) >> 3] & (1 << ((c) & 7))) &&\n                !(__ctype_b_loc()->bits[(c) >> 3] & (1 << (7)));\n        break;\n      case 'c':\n        match = (__ctype_b_loc()->bits[(c) >> 3] & (1 << ((c) & 7))) &&\n                !(__ctype_b_loc()->bits[(c) >> 3] & (1 << (2)));\n        break;\n      case 'd':\n        match = (__ctype_b_loc()->bits[(c) >> 3] & (1 << ((c) & 7))) &&\n                !(__ctype_b_loc()->bits[(c) >> 3] & (1 << (3)));\n        break;\n      case 'l':\n        match = (__ctype_b_loc()->bits[(c) >> 3] & (1 << ((c) & 7))) &&\n                !(__ctype_b_loc()->bits[(c) >> 3] & (1 << (9)));\n        break;\n      case 'p':\n        match = (__ctype_b_loc()->bits[(c) >> 3] & (1 << ((c) & 7))) &&\n                !(__ctype_b_loc()->bits[(c) >> 3] & (1 << (1)));\n        break;\n      case 's':\n        match = (__ctype_b_loc()->bits[(c) >> 3] & (1 << ((c) & 7))) &&\n                !(__ctype_b_loc()->bits[(c) >> 3] & (1 << (13)));\n        break;\n      case 'u':\n    match = (__ctype_","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static int singlematch(int c, const char *p, const char *ep) {\n    switch (*p) {\n      case '.':\n        return 1;\n      case '%':\n        return match_class(c, ((unsigned char)(*(p + 1))));\n      case '[':\n        return matchbracketclass(c, p, ep - 1);\n      default:\n        return (((unsigned char)(*p)) == c);\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static const char *lmemfind(const char *s1, size_t l1, const char *s2, size_t l2) {\n    if (l2 == 0)\n        return s1;\n    else if (l2 > l1)\n        return ((void *)0);\n    else {\n        const char *init;\n        l2--;\n        l1 = l1 - l2;\n        while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != ((void *)0))\n            {\n                init++;\n                if (memcmp(init, s2 + 1, l2) == 0)\n                    return init - 1;\n                else {\n                    l1 -= init - s1;\n                    s1 = init;\n                }\n            }\n        return ((void *)0);\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/gameview_WareCocos2dx/lua/luajit/LuaJIT-2.0.1/src/host/minilua.c"}
{"compilable":0,"function":"static inline char base64_encode_value(char value_in) {\n    static const char *encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    return value_in > 63 ? '=' : encoding[(int)value_in];\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":0,"function":"size_t base64_encode_block(const char *plaintext_in, size_t length_in, char *code_out, base64_encodestate *state_in) {\n    const char *plainchar = plaintext_in;\n    const char *const plaintextend = plaintext_in + length_in;\n    char *codechar = code_out;\n    char result;\n    char fragment;\n    result = state_in->result;\n    switch (state_in->step) {\n        while (1)\n            {\n              case step_A:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_A;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)((fragment & 252) >> 2);\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 3) << 4);\n              case step_B:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_B;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)(result | ((fragment & 240) >> 4));\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 15) << 2);\n              case step_C:\n                if (plainchar == plaintextend) {\n                    state_in->result = result;\n                    state_in->step = step_C;\n                    return (size_t)(codechar - code_out);\n                }\n                fragment = *plainchar++;\n                result = (char)(result | ((fragment & 192) >> 6));\n                *codechar++ = base64_encode_value(result);\n                result = (char)((fragment & 63) >> 0);\n                *codechar++ = base64_encode_value(result);\n                ++(state_in->stepcount);\n            }\n    }\n    return (size_t)(codechar - code_out);\n}\n","function_prediction":"int base64_encode_blockend(char *code_out, base64_encodestate *state_in) {\n  char *codechar = (char *)code_out;\n\n  switch (state_in->step) {\n  case 1:\n    *codechar++ =\n        (state_in->result < 64 ? \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrs\"\n                                 \"tuvwxyz0123456789+/\"[state_in->result]\n                               : '=');\n    state_in->result = 64;\n    state_in->step = 2;\n  case 2:\n    *codechar++ =\n        (state_in->result < 64 ? \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrs\"\n                                 \"tuvwxyz0123456789+/\"[state_in->result]\n                               : '=');\n    state_in->result = 64;\n    state_in->step = 0;\n    break;\n  default:\n    return 0;\n  }\n\n  return (int)(codechar - code_out);\n}","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":1,"function":"size_t base64_encode_blockend(char *code_out, base64_encodestate *state_in) {\n    char *codechar = code_out;\n    switch (state_in->step) {\n      case step_B:\n        *codechar++ = base64_encode_value(state_in->result);\n        *codechar++ = '=';\n        *codechar++ = '=';\n        break;\n      case step_C:\n        *codechar++ = base64_encode_value(state_in->result);\n        *codechar++ = '=';\n        break;\n      case step_A:\n        break;\n    }\n    return (size_t)(codechar - code_out);\n}\n","function_prediction":"int base64_encode_blockend_name_conflict(char *code_out, base64_encodestate *state_in) {\n  char *base64_chars =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  if (state_in->step == 1) {\n    code_out[0] = base64_chars[(int)state_in->result];\n    code_out[1] = '=';\n    code_out[2] = '=';\n    return 3;\n  } else if (state_in->step == 2) {\n    code_out[0] = base64_chars[(int)state_in->result];\n    code_out[1] = '=';\n    return 2;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/holke_libsc/libb64/cencode.c"}
{"compilable":0,"function":"static inline char base64_decode_value(char value_in) {\n    static const char decoding[] = {62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51};\n    static const char decoding_size = (char)sizeof (decoding);\n    value_in -= 43;\n    return (value_in < 0 || value_in >= decoding_size) ? -1 : decoding[(int)value_in];\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cdecode.c"}
{"compilable":0,"function":"size_t base64_decode_block(const char *code_in, size_t length_in, char *plaintext_out, base64_decodestate *state_in) {\n    const char *codechar = code_in;\n    char *plainchar = plaintext_out;\n    char fragment;\n    *plainchar = state_in->plainchar;\n    switch (state_in->step) {\n        while (1)\n            {\n              case step_a:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_a;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)((fragment & 63) << 2);\n              case step_b:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_b;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | ((fragment & 48) >> 4));\n                ++plainchar;\n                *plainchar = (char)((fragment & 15) << 4);\n              case step_c:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_c;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | ((fragment & 60) >> 2));\n                ++plainchar;\n                *plainchar = (char)((fragment & 3) << 6);\n              case step_d:\n                do {\n                    if (codechar == code_in + length_in) {\n                        state_in->step = step_d;\n                        state_in->plainchar = *plainchar;\n                        return (size_t)(plainchar - plaintext_out);\n                    }\n                    fragment = base64_decode_value(*codechar++);\n                } while (fragment < 0);\n                *plainchar = (char)(*plainchar | (fragment & 63));\n                ++plainchar;\n            }\n    }\n    return (size_t)(plainchar - plaintext_out);\n}\n","function_prediction":"size_t base64_decode_block(const char *code_in, size_t len_in,\n                           char *plaintext_out, base64_decodestate *state_in) {\n  const char *code = code_in;\n  char *plaintext = plaintext_out;\n  base64_decodestate state = *state_in;\n\n  *plaintext_out = state.result;\n\n  switch (state.step) {\n    while (1) {\n    case step_A:\n      if (code == code_in + len_in) {\n        state.step = step_A;\n        *state_in = state;\n        return plaintext - plaintext_out;\n      }\n      if (!((*code) >= 0 && (*code) <= 122))\n        goto step_A;\n      if (decoding_0[*code - 43] < 0)\n        goto step_A;\n      state.result = (decoding_0[*code - 43] << 2);\n      *plaintext = (char)(state.result);\n      state.step = step_B;\n      ++plaintext;\n      ++code;\n      break;\n    case step_B:\n      if (code == code_in + len_in) {\n        state.step = step_B;\n        *state_in = state;\n        return plaintext - plaintext_out;\n      }\n      if (!((*code) >= 0 && (*code) <= 122))\n        goto step_B;\n      if (decoding_0[*code - 43] < 0)\n        goto step_B;\n      state.result |= (decoding_0[*code - 43] >> 4);\n      *plaintext = (char)(state.result);\n      state.result = (decoding_0[*code - 43] << 4);\n      state.step = step_C;\n      ++plaintext;\n      ++code;\n      break;\n    case step_C:\n      if (code == code_in + len_in) {\n      state.","pass":0,"source_file":"C_COMPILE/holke_libsc/libb64/cdecode.c"}
{"compilable":0,"function":"static int argindex(int n) {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int argindex_name_conflict(int n) {\n  int i;\n  char *p;\n\n  if (argv == NULL || argv[0] == NULL || argv[1] == NULL)\n    return -1;\n\n  for (i = 1; argv[i] != NULL; i++) {\n    p = argv[i];\n    if (p[0] == '-' || p[0] == '+' || strchr(p, '=') != NULL) {\n      if (p[0] == '-' && p[1] == '-' && p[2] == '\\0')\n        continue;\n      if (n-- == 0)\n        return i;\n    }\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":1,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"int OptNArgs_name_conflict(void) {\n  int n = 0;\n  char **p;\n\n  if (argv == NULL)\n    return 0;\n  if (*argv == NULL)\n    return 0;\n  for (p = argv + 1; *p != NULL; p++) {\n    if ((**p == '-' || **p == '+') && strchr(*p, '=') == NULL)\n      n++;\n    else if (**p == '-' && *(*p + 1) == '-' && *(*p + 2) == '\\0')\n      break;\n    else\n      n++;\n  }\n  return n;\n}","pass":1,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *OptArg(int n) {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"char *OptArg_name_conflict(char *opt) {\n  int i;\n\n  i = argindex(opt);\n  if (i < 0)\n    return NULL;\n  return argv[i];\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *pathsearch(char *argv0, char *name, int modemask) {\n    const char *pathlist;\n    char *pathbufptr;\n    char *pathbuf;\n    char *path, *cp;\n    char c;\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(((int)strlen(argv0)) + ((int)strlen(name)) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        pathbuf = (char *)malloc(((int)strlen(pathlist)) + 1);\n        path = (char *)malloc(((int)strlen(pathlist)) + ((int)strlen(name)) + 2);\n        if ((pathbuf != 0) && (path != 0)) {\n            pathbufptr = pathbuf;\n            strcpy(pathbuf, pathlist);\n            while (*pathbuf)\n                {\n                    cp = strchr(pathbuf, ':');\n                    if (cp == 0)\n                        cp = &pathbuf[((int)strlen(pathbuf))];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathbuf, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathbuf[0] = 0;\n                    else\n                        pathbuf = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n            free(pathbufptr);\n        }\n    }\n    return path;\n}\n","function_prediction":"char *pathsearch_name_conflict(const char *name, const char *file, int mode) {\n  char *path, *p, *q, *r, *s;\n  int len;\n\n  if ((p = strrchr(name, '/'))) {\n    *p = '\\0';\n    len = strlen(name) + strlen(file) + 2;\n    if (!(s = malloc(len)))\n      return NULL;\n    sprintf(s, \"%s/%s\", name, file);\n    *p = '/';\n    return s;\n  }\n\n  if ((path = getenv(\"PATH\")) == NULL)\n    path = \".:/bin:/usr/bin\";\n\n  len = strlen(path) + 1;\n  if (!(p = malloc(len)))\n    return NULL;\n\n  len = strlen(path) + strlen(file) + 2;\n  if (!(s = malloc(len)))\n    return NULL;\n\n  memcpy(p, path, len);\n\n  for (q = p; *q; q = r + 1) {\n    if ((r = strchr(q, ':')))\n      *r = '\\0';\n    else\n      r = q + strlen(q);\n    *r = '\\0';\n    sprintf(s, \"%s/%s\", q, file);\n    *r = ':';\n    if (!access(s, mode))\n      return s;\n  }\n\n  free(p);\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    s = (char *)calloc(size, 1);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    return s;\n}\n","function_prediction":"void *SetNew_name_conflict(void) {\n  void *p = calloc(size, 1);\n  if (p == NULL)\n    memory_error();\n  return p;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":1,"function":"int SetUnion(char *s1, char *s2) {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"int SetUnion_name_conflict(char *a, char *b) {\n  int i, changed = 0;\n\n  for (i = 0; i < size; i++)\n    if (b[i] && !a[i]) {\n      a[i] = 1;\n      changed = 1;\n    }\n\n  return changed;\n}","pass":1,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":1,"function":"int strhash(const char *x) {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"int strhash_name_conflict(char *s) {\n  int h = 0;\n  while (*s)\n    h = h * 13 + *s++;\n  return h;\n}","pass":1,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"const char *Strsafe(const char *y) {\n    const char *z;\n    char *cpy;\n    if (y == 0)\n        return 0;\n    z = Strsafe_find(y);\n    if (z == 0 && (cpy = (char *)malloc(((int)strlen(y)) + 1)) != 0) {\n        strcpy(cpy, y);\n        z = cpy;\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"char *Strsafe_name_conflict(char *s) {\n  int i, j, k, l, m, n, o;\n  char *p, *q, *r, *t;\n  struct strsafe_node *u, *v, *w, *x, *y;\n\n  if (s == NULL)\n    return NULL;\n\n  if (x1a == NULL)\n    return s;\n\n  i = 0;\n  for (p = s; *p != '\\0'; p++)\n    i = (i * 13) + *p;\n  i &= (x1a->size - 1);\n\n  for (u = x1a->table[i]; u != NULL; u = u->next)\n    if (!strcmp(u->s, s))\n      return u->s;\n\n  n = strlen(s);\n  t = (char *)malloc(n + 1);\n  if (t == NULL) {\n    memory_error();\n    return NULL;\n  }\n  memcpy(t, s, n + 1);\n\n  Strsafe_name_conflict_insert(t);\n\n  return t;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(const char *data) {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"int Strsafe_insert_name_conflict(char *str) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  char *a, *b, *c, *d, *e, *f, *g, *h, *i1, *j1, *k1, *l1, *m1, *n1, *o1, *p1,\n      *q1, *r1, *s1, *t1, *u1, *v1, *w1, *x1, *y1, *z1;\n  struct Strsafe_node *a1, *b1, *c1, *d1, *e1, *f1, *g1, *h1, *i2, *j2, *k2,\n      *l2, *m2, *n2, *o2, *p2, *q2, *r2, *s2, *t2, *u2, *v2, *w2, *x2, *y2, *z2;\n  struct Strsafe_node *A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L, *M, *N,\n      *O, *P, *Q, *R, *S, *T, *U, *V, *W, *X, *Y, *Z;\n\n  if (x1a == NULL)\n    return 0;\n\n  i = j = k = l = m = n = o = p = q = r = s = t = u = v = w = x = y = z = 0;\n  a = b = c = d = e = f = g = h = i1 = j1 = k1 = l1 = m1 = n1 = o1 = p1 = q1 =\n      r1 = s1 = t1 = u1 = v1 = w1 = x1 = y1 = z1 = NULL;\n  a1 = b1 = c1 = d1 = e1 = f1 = g1 = h1 = i2 = j2 = k2 = l","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"const char *Strsafe_find(const char *key) {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"char *Strsafe_find_name_conflict(char *s) {\n  int h;\n  struct Strsafe_node *p;\n\n  if (x1a == NULL)\n    return NULL;\n\n  h = 0;\n  while (*s)\n    h = (h * 13) + *s++;\n  h &= x1a->mask;\n\n  for (p = x1a->table[h]; p; p = p->next)\n    if (!strcmp(p->s, s))\n      return p->s;\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":1,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"int Symbol_count_name_conflict() {\n  if (x2a == NULL)\n    return 0;\n  return x2a->count;\n}","pass":1,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"int Configcmp(const char *_a, const char *_b) {\n    const struct config *a = (struct config *)_a;\n    const struct config *b = (struct config *)_b;\n    int x;\n    x = a->rp->index - b->rp->index;\n    if (x == 0)\n        x = a->dot - b->dot;\n    return x;\n}\n","function_prediction":"int Configcmp_name_conflict(const void *a, const void *b) {\n  int diff;\n  const struct config *ca = a;\n  const struct config *cb = b;\n\n  diff = ca->data[13] - cb->data[13];\n  if (diff == 0)\n    diff = ca->id - cb->id;\n  return diff;\n}","pass":0,"source_file":"C_COMPILE/gavinp_chromium/third_party/sqlite/src/tool/lemon.c"}
{"compilable":0,"function":"static int check_path(char *path) {\n    if (!path)\n        return 0;\n    return access(path, 4) != -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":1,"function":"char *get_config_path(char *default_path, char *pbuf, size_t bufsize) {\n    char buf[512];\n    char *path = default_path;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"PROXYCHAINS_CONF_FILE\");\n    if (check_path(path))\n        goto have;\n    path = getcwd(buf, sizeof (buf));\n    snprintf(pbuf, bufsize, \"%s/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"HOME\");\n    snprintf(pbuf, bufsize, \"%s/.proxychains/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    perror(\"couldnt find configuration file\");\n    exit(1);\n    return ((void *)0);\n  have:\n    return path;\n}\n","function_prediction":"char *get_config_path_name_conflict(char *arg_path, char *buf, size_t buf_size) {\n  char cwd[512];\n\n  if (arg_path && access(arg_path, 4) != -1)\n    return arg_path;\n\n  char *env_path = getenv(\"PROXYCHAINS_CONF_FILE\");\n  if (env_path && access(env_path, 4) != -1)\n    return env_path;\n\n  snprintf(buf, buf_size, \"%s/%s\", getcwd(cwd, sizeof(cwd)),\n           \"proxychains.conf\");\n  if (buf && access(buf, 4) != -1)\n    return buf;\n\n  snprintf(buf, buf_size, \"%s/.proxychains/%s\", getenv(\"HOME\"),\n           \"proxychains.conf\");\n  if (buf && access(buf, 4) != -1)\n    return buf;\n\n  if (access(\"/etc/proxychains.conf\", 4) != -1)\n    return \"/etc/proxychains.conf\";\n\n  if (access(\"/etc/proxychains.conf\", 4) != -1)\n    return \"/etc/proxychains.conf\";\n\n  perror(\"couldnt find configuration file\");\n  exit(1);\n}","pass":1,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":0,"function":"static int check_path(char *path) {\n    if (!path)\n        return 0;\n    return access(path, 4) != -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":1,"function":"char *get_config_path(char *default_path, char *pbuf, size_t bufsize) {\n    char buf[512];\n    char *path = default_path;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"PROXYCHAINS_CONF_FILE\");\n    if (check_path(path))\n        goto have;\n    path = getcwd(buf, sizeof (buf));\n    snprintf(pbuf, bufsize, \"%s/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = getenv(\"HOME\");\n    snprintf(pbuf, bufsize, \"%s/.proxychains/%s\", path, \"proxychains.conf\");\n    path = pbuf;\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    path = \"/etc/proxychains.conf\";\n    if (check_path(path))\n        goto have;\n    perror(\"couldnt find configuration file\");\n    exit(1);\n    return ((void *)0);\n  have:\n    return path;\n}\n","function_prediction":"char *get_config_path_name_conflict(char *arg_path, char *buf, size_t buf_size) {\n  char cwd[512];\n\n  if (arg_path && access(arg_path, 4) != -1)\n    return arg_path;\n\n  char *env_path = getenv(\"PROXYCHAINS_CONF_FILE\");\n  if (env_path && access(env_path, 4) != -1)\n    return env_path;\n\n  snprintf(buf, buf_size, \"%s/%s\", getcwd(cwd, sizeof(cwd)),\n           \"proxychains.conf\");\n  if (buf && access(buf, 4) != -1)\n    return buf;\n\n  snprintf(buf, buf_size, \"%s/.proxychains/%s\", getenv(\"HOME\"),\n           \"proxychains.conf\");\n  if (buf && access(buf, 4) != -1)\n    return buf;\n\n  if (access(\"/etc/proxychains.conf\", 4) != -1)\n    return \"/etc/proxychains.conf\";\n\n  if (access(\"/etc/proxychains.conf\", 4) != -1)\n    return \"/etc/proxychains.conf\";\n\n  perror(\"couldnt find configuration file\");\n  exit(1);\n}","pass":1,"source_file":"C_COMPILE/sh1nu11bi_proxychains-ng/src/common.c"}
{"compilable":1,"function":"int info(int level, const char *fmt, ...) {\n    va_list ap;\n    int length;\n    if (level > verbose)\n        return 0;\n    __builtin_va_start(ap, fmt);\n    length = vfprintf(stdout, fmt, ap);\n    __builtin_va_end(ap);\n    return length;\n}\n","function_prediction":"int info_name_conflict(int level, char *fmt, ...) {\n  va_list ap;\n  int ret;\n\n  if (level > verbose)\n    return 0;\n\n  va_start(ap, fmt);\n  ret = vfprintf(stdout, fmt, ap);\n  va_end(ap);\n\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"unsigned short CALC_CRC1a(unsigned short crc, uint8_t byte) {\n    int i = 8;\n    unsigned short b = byte << 8;\n    while (i--)\n        {\n            crc = (crc << 1) ^ (((crc ^ b) & 32768) ? 4129 : 0);\n            b <<= 1;\n        }\n    return crc;\n}\n","function_prediction":"unsigned short CALC_CRC1a_name_conflict(unsigned short crc, unsigned char data) {\n  int i;\n  for (i = 0; i < 8; i++) {\n    if ((crc & 0x8000) ^ (data & 0x80))\n      crc = (crc << 1) ^ 0x1021;\n    else\n      crc = crc << 1;\n    data <<= 1;\n  }\n  return crc;\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"const char *detokenize(uint8_t *src, int maxsize) {\n    static char buff[8192];\n    char *dst = buff;\n    int string = 0;\n    while (0 != *src && maxsize-- > 0)\n        {\n            if (string) {\n                if ('\"' == *src)\n                    string = 0;\n                if (*src >= 32 && *src < 127)\n                    *dst++ = *src;\n                else\n                    dst += sprintf(dst, \"\\\\%03o\", *src);\n            } else {\n                if (255 == *src) {\n                    src++;\n                    if (*src < 128 + 26)\n                        dst += sprintf(dst, \"%s\", token[*src]);\n                    else\n                        dst += sprintf(dst, \"<ff%02x>\", *src);\n                } else if (*src > 127) {\n                    dst += sprintf(dst, \"%s\", token[*src & 127]);\n                } else {\n                    *dst++ = *src;\n                    if ('\"' == *src)\n                        string = 1;\n                }\n            }\n            src++;\n        }\n    *dst = '\\x00';\n    return buff;\n}\n","function_prediction":"char *detokenize_name_conflict(char *s, int max) {\n  static char buff[5];\n  char *p = buff;\n  int c;\n  int in_string = 0;\n\n  while ((c = *s++) && --max > 0) {\n    if (in_string) {\n      if (c == '\"')\n        in_string = 0;\n      else if (c < 32 || c >= 127)\n        p += sprintf(p, \"\\\\%03o\", c);\n      else\n        *p++ = c;\n    } else {\n      if (c == 255) {\n        if (s[0] < 154)\n          p += sprintf(p, \"%s\", token[s[0]]);\n        else\n          p += sprintf(p, \"<ff%02x>\", s[0]);\n        s++;\n      } else if (c & 0x80)\n        p += sprintf(p, \"%s\", token[c & 0x7f]);\n      else {\n        *p++ = c;\n        if (c == '\"')\n          in_string = 1;\n      }\n    }\n  }\n  *p = '\\0';\n  return buff;\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int dmk_scan_sectors(track_stat_t *ts) {\n    uint8_t *p;\n    int ip;\n    unsigned long dp;\n    unsigned long dd;\n    unsigned long len;\n    unsigned short crc, c;\n    dam_t *dam;\n    memset(ts, 0, sizeof (*ts));\n    for (ip = 0; ip < 128; ip += 2) {\n        p = dmk.track;\n        dam = &ts->sector[ip / 2];\n        dp = p[ip + 0] + 256 * p[ip + 1];\n        if (0 == dp)\n            break;\n        dd = dp & 32768;\n        dp = dp & ~32768;\n        info(1, \"#%02x @%04x\", ip / 2, dp);\n        crc = 65535;\n        if (32768 == dd) {\n            dam->flags |= 1;\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n        }\n        if (p[dp] != 254) {\n            info(1, \" - not pointing to AM (0xfe)\\n\");\n            dam->flags |= 2;\n            ts->am_bad += 1;\n            continue;\n        }\n        ts->am_good += 1;\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->c = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->h = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->r = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->n = p[dp];\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        len = 1 << (7 + (dam->n & 3));\n        info(1, \" C:%02x H:%02x R:%02x N:%02x\", dam->c, dam->h, dam->r, dam->n);\n        c = 256 * p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        c = c | p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        if (c == crc) {\n            info(1, \" AM-CRC:good\");\n            dam->flags &= ~4;\n        } else {\n            info(1, \" AM-CRC:bad (%04x != %04x)\", c, crc);\n            dam->flags |= 4;\n            ts->am_crc_bad += 1;\n        }\n        for (; dp < (256UL * dmk.trklen[1] + dmk.trklen[0]); dp++) {\n            if (p[dp] >= 248 && p[dp] <= 251)\n                break;\n        }\n        if (dp >= (256UL * dmk.trklen[1] + dmk.trklen[0])) {\n            info(1, \" no DAM!\\n\");\n            dam->flags |= 8;\n            ts->dam_missing += 1;\n            continue;\n        }\n        crc = 65535;\n        if (32768 == dd) {\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n            crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (161)) & 255]) & 65535);\n        }\n        switch (p[dp]) {\n          case 248:\n          case 249:\n          case 250:\n            dam->flags |= 32;\n            break;\n          case 251:\n            dam->flags &= ~32;\n            break;\n        }\n        crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n        info(1, \" DAM:%02x\", p[dp]);\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        dam->dp = dp;\n        dam->flags |= 128;\n        while (len-- > 0)\n            {\n                if (0 != (dam->flags & 128) && 229 != p[dp])\n                    dam->flags &= ~128;\n                crc = ((((crc) << 8) ^ crc16[(((crc) >> 8) ^ (p[dp])) & 255]) & 65535);\n                dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n            }\n        c = 256 * p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        c = c | p[dp];\n        dp += ((dd) ? 1 : (dmk.flags & 64) ? 1 : 2);\n        if (c == crc) {\n            info(1, \" DAM-CRC:good\");\n            dam->flags &= ~16;\n        } else {\n            info(1, \" DAM-CRC:bad (%04x != %04x)\", c, crc);\n            dam->flags |= 16;\n            ts->dam_crc_bad += 1;\n        }\n        if (dam->flags & 128)\n            info(1, \" empty\");\n        info(1, \"\\n\");\n    }\n    ts->sector_count = ip / 2;\n    info(1, \"\\n\");\n    if (0 == ts->am_bad && 0 == ts->am_crc_bad && 0 == ts->dam_crc_bad)\n        ts->perfect = 1;\n    return 0;\n}\n","function_prediction":"int dmk_scan_sectors_name_conflict(struct dmk_sector *sectors) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  unsigned short crc;\n  unsigned char *dmk_ptr;\n\n  for (i = 0; i < 128; i++) {\n    sectors[i].flags = 0;\n    sectors[i].dam_offset = 0;\n  }\n\n  dmk_ptr = dmk;\n\n  for (i = 0; i < 128; i++) {\n    j = (dmk_ptr[0x10] + (dmk_ptr[0x11] << 8));\n    if (j == 0)\n      break;\n\n    info_constprop_0(1, \"#%02x @%04x\", i, j);\n\n    if (j & 0x8000) {\n      sectors[i].flags |= 0x01;\n      k = 0xcd;\n      l = 0xb400;\n    } else {\n      k = 0xff;\n      l = 0xff00;\n    }\n\n    if (dmk_ptr[j + 0x00] != 0xfe) {\n      info_constprop_0(1, \" - not pointing to AM (0xfe)\\n\");\n      sectors[i].flags |= 0x02;\n      sectors[0].am_errors++;\n      continue;\n    }\n\n    sectors[0].am_count++;\n\n    crc = crc16[k ^ dmk_ptr[j + 0x00]];\n    if (j & 0x8000) {\n      sectors[i].c = dmk_ptr[j + 0x01];\n      crc = crc16[(l ^ crc) >> 8];\n      sectors[i].h = dmk_ptr[j + 0x02];\n      crc = crc16[(crc ^ sectors[i].c) >> 8];\n    sectors[i].r = d","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int dmk_sort_by_sector(track_stat_t *ts) {\n    qsort(ts->sector, ts->sector_count, sizeof(dam_t), qsort_sector);\n    return 0;\n}\n","function_prediction":"int dmk_sort_by_sector_name_conflict(struct dmk_header *h) {\n  qsort(&h->sector_table[1], h->sector_table[0], sizeof(struct dmk_sector),\n        qsort_sector);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"const char *newdos_flags_str(newdos_dirent_t *de) {\n    static char flags[13];\n    flags[0] = de->fl0 & 64 ? 'S' : '.';\n    flags[1] = de->fl0 & 8 ? 'I' : '.';\n    flags[2] = de->fl0 & 16 ? 'U' : '.';\n    if (de->fl0 & 64) {\n        flags[3] = de->fl1 & 128 ? 'E' : '.';\n        flags[4] = de->fl1 & 64 ? 'C' : '.';\n        flags[5] = de->fl1 & 1 ? '0' : '.';\n        flags[6] = de->fl1 & 2 ? '1' : '.';\n        flags[7] = de->fl1 & 4 ? '2' : '.';\n        flags[8] = de->fl0 & 8 ? '3' : '.';\n        flags[9] = de->fl0 & 32 ? 'U' : '.';\n        flags[10] = de->fl0 & 64 ? 'A' : '.';\n    } else {\n        flags[3] = '.';\n        flags[4] = '.';\n        flags[5] = '.';\n        flags[6] = '.';\n        flags[7] = '.';\n        flags[8] = '.';\n        flags[9] = '.';\n        flags[10] = '.';\n    }\n    flags[11] = '0' + (de->fl0 & 7);\n    flags[12] = '\\x00';\n    return flags;\n}\n","function_prediction":"char *newdos_flags_str_name_conflict(unsigned char *flags) {\n  static char flags_str[16];\n\n  flags_str[0] = (flags[0] & 0x40) ? 'S' : 's';\n  flags_str[1] = (flags[0] & 0x08) ? 'I' : 'i';\n  flags_str[2] = (flags[0] & 0x10) ? 'U' : 'u';\n  flags_str[3] = (flags[0] & 0x40) ? '.' : ' ';\n  flags_str[4] = (flags[0] & 0x40) ? '.' : ' ';\n  flags_str[5] = (flags[0] & 0x40) ? '.' : ' ';\n  flags_str[6] = (flags[0] & 0x08) ? '3' : ' ';\n  flags_str[7] = (flags[0] & 0x01) ? '2' : ' ';\n  flags_str[8] = (flags[0] & 0x02) ? '1' : ' ';\n  flags_str[9] = (flags[0] & 0x20) ? 'U' : 'u';\n  flags_str[10] = (flags[0] & 0x40) ? 'A' : 'a';\n  flags_str[11] = (flags[0] & 0x04) + '0';\n  flags_str[12] = '\\0';\n\n  return flags_str;\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"const char *binstr(int val, int bits) {\n    static char buff[33];\n    int i;\n    if (bits > 32)\n        bits = 32;\n    for (i = 0; i < bits; i++ , val >>= 1)\n        buff[i] = '0' + (val & 1);\n    buff[bits] = '\\x00';\n    return buff;\n}\n","function_prediction":"char *binstr_name_conflict(int n, int len) {\n  static char buff[33];\n  int i;\n\n  if (len > 32)\n    len = 32;\n  for (i = 0; i < len; i++) {\n    buff[i] = (n & 1) + '0';\n    n >>= 1;\n  }\n  buff[i] = '\\0';\n  return buff;\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"const char *dmk_filename_ext(newdos_dirent_t *de, char delim) {\n    static char name[13];\n    char *dst, *src;\n    int i;\n    dst = name;\n    for (i = 0 , src = de->filename; i < 8; i++) {\n        if (*src == ' ')\n            break;\n        *dst++ = *src++;\n    }\n    if (*de->extension != ' ') {\n        *dst++ = delim;\n        for (i = 0 , src = de->extension; i < 3; i++) {\n            if (*src == ' ')\n                break;\n            *dst++ = *src++;\n        }\n    }\n    *dst = '\\x00';\n    return name;\n}\n","function_prediction":"char *dmk_filename_ext_name_conflict(char *name, char ext) {\n  char *p = name_0;\n  int i;\n\n  for (i = 0; i < 12; i++) {\n    if (name[i + 5] == ' ')\n      break;\n    *p++ = name[i + 5];\n  }\n\n  if (name[i + 5] != ' ') {\n    *p++ = ext;\n    if (name[i + 5] != ' ') {\n      *p++ = name[i + 5];\n      if (name[i + 6] != ' ') {\n        *p++ = name[i + 6];\n        if (name[i + 7] != ' ')\n          *p++ = name[i + 7];\n      }\n    }\n  }\n\n  *p = '\\0';\n\n  return name_0;\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"int verify_bas(uint8_t *buff, int *psize) {\n    int state, offs;\n    int addr = 0;\n    int line = 0;\n    int blen = 0;\n    int lcnt = 0;\n    if (255 != *buff) {\n        info(0, \"BASIC data does not start with 0xff (0x%02x)\\n\", *buff);\n        return -1;\n    }\n    info(2, \"*** verify BAS\\n\");\n    state = 0;\n    for (offs = 0; offs < *psize; offs++) {\n        switch (state) {\n          case 0:\n            state = 1;\n            break;\n          case 1:\n            addr = buff[offs];\n            state = 2;\n            break;\n          case 2:\n            addr = 256 * buff[offs] + addr;\n            state = 3;\n            if (0 == addr) {\n                if (offs + 1 < *psize) {\n                    info(1, \"  data after program (0x%x)\\n\", *psize - 1 - offs);\n                }\n                *psize = offs + 1;\n            }\n            break;\n          case 3:\n            line = buff[offs];\n            state = 4;\n            break;\n          case 4:\n            line = 256 * buff[offs] + line;\n            state = 5;\n            info(2, \"  line %5d at 0x%04x\", line, addr);\n            blen = 0;\n            break;\n          case 5:\n            blen += 1;\n            if (0 != buff[offs])\n                break;\n            info(2, \" - 0x%02x bytes\\n\", blen);\n            state = 1;\n            lcnt++;\n            break;\n        }\n    }\n    info(2, \"  %d lines\\n\", lcnt);\n    return 0;\n}\n","function_prediction":"int verify_bas_name_conflict(unsigned char *bas, int *lines) {\n  if (*bas != 0xff) {\n    info_constprop_1(2, \"BASIC data does not start with 0xff (0x%02x)\\n\", *bas);\n    return -1;\n  }\n  info(2, \"*** verify BAS\\n\");\n  if (*lines < 1) {\n    info(2, \"  %d lines\\n\", *lines);\n    return 0;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int verify_cmd(uint8_t *buff, int *psize) {\n    int state, offs;\n    int blen = 0;\n    int addr = 0;\n    int chain = 0;\n    int badr = 0;\n    info(2, \"*** verify CMD\\n\");\n    state = 0;\n    chain = 0;\n    for (offs = 0; offs < *psize; offs++) {\n        switch (state) {\n          case 0:\n            switch (buff[offs]) {\n              case 1:\n                state = 1;\n                break;\n              case 2:\n                state = 2;\n                break;\n              default:\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  comment block type 0x%02x\\n\", buff[offs]);\n                state = 3;\n                break;\n            }\n            break;\n          case 1:\n            blen = buff[offs];\n            state = 4;\n            break;\n          case 2:\n            blen = buff[offs];\n            state = 5;\n            if (2 != blen) {\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  bogus entry block length (%02x)\\n\", blen);\n                blen = 2;\n                buff[offs] = 2;\n            }\n            break;\n          case 3:\n            blen = buff[offs];\n            state = 6;\n            break;\n          case 4:\n            blen--;\n            addr = buff[offs];\n            state = 7;\n            break;\n          case 5:\n            blen--;\n            badr = buff[offs];\n            state = 8;\n            break;\n          case 6:\n            if (--blen <= 0)\n                state = 0;\n            break;\n          case 7:\n            blen--;\n            addr = 256 * buff[offs] + addr;\n            state = 9;\n            if (blen <= 0)\n                blen += 256;\n            if (addr != chain) {\n                if (chain)\n                    info(2, \" - %04x\\n\", chain - 1);\n                chain = 0;\n                info(1, \"  data at %04x\", addr);\n            }\n            chain = addr;\n            break;\n          case 8:\n            blen--;\n            badr = 256 * buff[offs] + badr;\n            if (chain)\n                info(2, \" - %04x\\n\", chain - 1);\n            chain = 0;\n            info(1, \"  entry point at 0x%04x\\n\", badr);\n            if (offs + 1 < *psize)\n                info(1, \"  data after entry point (0x%x)\\n\", *psize - 1 - offs);\n            *psize = offs + 1;\n            break;\n          case 9:\n            chain += 1;\n            if (--blen <= 0)\n                state = 0;\n            break;\n        }\n    }\n    if (chain)\n        info(2, \" - %04x\\n\", chain - 1);\n    return 0;\n}\n","function_prediction":"int verify_cmd_name_conflict(struct cmd_list *cmd, struct cmd_list *cmd_list) {\n  int i;\n\n  info(2, \"*** verify CMD\\n\");\n\n  for (i = 0; i < cmd_list->count; i++) {\n    switch (cmd_list->cmd[i]) {\n    case CMD_NOP:\n      break;\n    case CMD_WRITE:\n      break;\n    case CMD_READ:\n      break;\n    case CMD_ERASE:\n      break;\n    case CMD_ERASE_ALL:\n      break;\n    case CMD_ERASE_VERIFY:\n      break;\n    case CMD_ERASE_VERIFY_ALL:\n      break;\n    case CMD_ERASE_PROGRAM:\n      break;\n    case CMD_ERASE_PROGRAM_VERIFY:\n      break;\n    case CMD_ERASE_PROGRAM_VERIFY_ALL:\n      break;\n    case CMD_ERASE_PROGRAM_VERIFY_ALL_SAME:\n      break;\n    case CMD_ERASE_PROGRAM_VERIFY_ALL_DIFF:\n      break;\n    case CMD_ERASE_PROGRAM_VERIFY_ALL_SAME_DIFF:\n      break;\n    case CMD_ERASE_PROGRAM_VERIFY_ALL_DIFF_SAME:\n      break;\n    case CMD_ERASE_PROGRAM_VERIFY_ALL_SAME_DIFF_SAME:\n      break;\n    case CMD_ERASE_PROGRAM_VERIFY_ALL_DIFF_SAME_DIFF:\n      break;\n    case CMD_ERASE_PROGRAM_VERIFY_ALL_SAME_DIFF_SAME_DIFF:\n      break;\n    case CMD_ERASE_PROGRAM_VERIFY_ALL_DIFF_SAME_DIFF_SAME:\n      break;\n    case CMD_ERASE_PROGRAM_VERIFY_ALL_SAME_DIFF_SAME_DI","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int verify_txt(uint8_t *buff, int *psize) {\n    int offs;\n    uint8_t *dst;\n    dst = memchr(buff, '\\x03', *psize);\n    offs = dst ? (int)(dst - buff) : *psize;\n    if (offs + 1 < *psize) {\n        info(1, \"  data after end-of-file code ^C (0x%x)\\n\", *psize - 1 - offs);\n        *psize = offs + 1;\n    }\n    dst = memchr(buff, '\\x00', *psize);\n    offs = dst ? (int)(dst - buff) : *psize;\n    if (offs + 1 < *psize) {\n        info(1, \"  data after end-of-file code ^@ (0x%x)\\n\", *psize - 1 - offs);\n        *psize = offs + 1;\n    }\n    return 0;\n}\n","function_prediction":"int verify_txt_name_conflict(const unsigned char *buf, int *len) {\n  int i;\n\n  i = memchr(buf, 0x03, *len) - buf;\n  if (i + 1 < *len) {\n    info_constprop_0(1, \"  data after end-of-file code ^C (0x%x)\\n\",\n                     *len - i - 1);\n    *len = i + 1;\n  }\n\n  i = memchr(buf, 0x00, *len) - buf;\n  if (i + 1 < *len) {\n    info_constprop_0(1, \"  data after end-of-file code ^@ (0x%x)\\n\",\n                     *len - i - 1);\n    *len = i + 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"int hexdump_bas(uint8_t *buff, int size) {\n    int state, offs;\n    int addr = 0;\n    int line = 0;\n    int blen = 0;\n    int lcnt = 0;\n    state = 0;\n    for (offs = 0; offs < size; offs++) {\n        switch (state) {\n          case 0:\n            state = 1;\n            break;\n          case 1:\n            addr = buff[offs];\n            state = 2;\n            break;\n          case 2:\n            addr = 256 * buff[offs] + addr;\n            state = 3;\n            if (0 == addr)\n                offs = size;\n            break;\n          case 3:\n            line = buff[offs];\n            state = 4;\n            break;\n          case 4:\n            line = 256 * buff[offs] + line;\n            info(0, \"%05x:(%04x) %5d\", offs, addr, line);\n            blen = 0;\n            state = 5;\n            break;\n          case 5:\n            blen += 1;\n            if (0 != buff[offs])\n                break;\n            info(0, \" %s\\n\", detokenize(buff + offs - blen + 1, blen));\n            state = 1;\n            lcnt++;\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int hexdump_bas_name_conflict(const void *buf, int len) {\n  if (len <= 0)\n    return 0;\n\n  return (int)(((hexdump_bas_name_conflict_t)0x0000000000000000)(buf, 0));\n}","pass":0,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"int hexdump_cmd(uint8_t *buff, int size) {\n    int state, offs;\n    int blen = 0;\n    int addr = 0;\n    int chain = 0;\n    int badr = 0;\n    int bcnt = 0;\n    int i;\n    state = 0;\n    chain = 0;\n    for (offs = 0; offs < size; offs++) {\n        switch (state) {\n          case 0:\n            switch (buff[offs]) {\n              case 1:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 1;\n                break;\n              case 2:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 2;\n                break;\n              default:\n                info(0, \"%05x: %02x\", offs, buff[offs]);\n                state = 3;\n                break;\n            }\n            break;\n          case 1:\n            blen = buff[offs];\n            state = 4;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 2:\n            blen = buff[offs];\n            state = 5;\n            if (2 != blen) {\n                blen = 2;\n            }\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 3:\n            blen = buff[offs];\n            bcnt = 0;\n            state = 6;\n            info(0, \" %02x (comment length %03x)\\n\", buff[offs], blen);\n            break;\n          case 4:\n            blen--;\n            addr = buff[offs];\n            state = 7;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 5:\n            blen--;\n            badr = buff[offs];\n            state = 8;\n            info(0, \" %02x\", buff[offs]);\n            break;\n          case 6:\n            if (0 == (bcnt & 15))\n                info(0, \"%05x:(%04x)\", offs, bcnt);\n            info(0, \" %02x\", buff[offs]);\n            bcnt++;\n            if (0 == (bcnt & 15))\n                info(0, \"\\n\");\n            if (--blen <= 0) {\n                if (0 != (bcnt & 15))\n                    info(0, \"\\n\");\n                state = 0;\n            }\n            break;\n          case 7:\n            blen--;\n            addr = 256 * buff[offs] + addr;\n            state = 9;\n            bcnt = 0;\n            if (blen <= 0)\n                blen += 256;\n            info(0, \" %02x (data length %03x @ %04x)\\n\", buff[offs], blen, addr);\n            break;\n          case 8:\n            blen--;\n            badr = 256 * buff[offs] + badr;\n            bcnt = 0;\n            info(0, \" %02x (entry point %04x)\\n\", buff[offs], badr);\n            offs = size;\n            break;\n          case 9:\n            if (0 == (bcnt & 15))\n                info(0, \"%05x:(%04x)\", offs, addr + bcnt);\n            info(0, \" %02x\", buff[offs]);\n            bcnt++;\n            if (0 == (bcnt & 15)) {\n                info(0, \" - \");\n                for (i = -15; i <= 0; i++)\n                    info(0, \"%c\", ((buff[offs + i]) < 32 || (buff[offs + i]) > 126 ? '.' : (buff[offs + i])));\n                info(0, \"\\n\");\n            }\n            if (--blen <= 0) {\n                if (0 != (bcnt & 15)) {\n                    info(0, \"%-*s - \", 3 * (16 - (bcnt & 15)), \"\");\n                    for (i = -(bcnt & 15); i <= 0; i++)\n                        info(0, \"%c\", ((buff[offs + i]) < 32 || (buff[offs + i]) > 126 ? '.' : (buff[offs + i])));\n                    info(0, \"\\n\");\n                }\n                state = 0;\n            }\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int hexdump_cmd_name_conflict(int argc, char **argv) {\n  if (argc < 1)\n    return 0;\n\n  return hexdump_file(argv[0]);\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":1,"function":"int hexdump_raw(uint8_t *buff, int size) {\n    int y, x;\n    for (y = 0; y < size; y += 16) {\n        info(0, \"%05x:\", y);\n        for (x = 0; x < 16; x++)\n            info(0, \" %02x\", buff[y + x]);\n        info(0, \" - \");\n        for (x = 0; x < 16; x++)\n            info(0, \"%c\", ((buff[y + x]) < 32 || (buff[y + x]) > 126 ? '.' : (buff[y + x])));\n        info(0, \"\\n\");\n    }\n    return 0;\n}\n","function_prediction":"int hexdump_raw_name_conflict(const void *data, int len) {\n  const unsigned char *p = data;\n  int i, j;\n\n  for (i = 0; i < len; i += 16) {\n    info_constprop_1(0, \"%05x:\", i);\n    for (j = 0; j < 16; j++)\n      info_constprop_1(0, \" %02x\", p[i + j]);\n    info_constprop_1(0, \"  \");\n    for (j = 0; j < 16; j++)\n      info_constprop_1(0, \"%c\",\n                       p[i + j] >= 0x20 && p[i + j] < 0x7f ? p[i + j] : '.');\n    info_constprop_1(0, \"\\n\");\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/schnitzeltony_z80/src/dmktool.c"}
{"compilable":0,"function":"unsigned long HTcopy(char *ul) {\n    unsigned long retval;\n    memcpy(&retval, ul, sizeof (retval));\n    return retval;\n}\n","function_prediction":"HT *HTcopy_name_conflict(HT *ht) { return ht->copy; }","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long SparseMemory(u_long cBuckets, u_long cOccupied) {\n    return (cOccupied * sizeof(HTItem) + ((((cBuckets) - 1) >> (0 + 6)) + 1) * sizeof(SparseBin));\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long DenseMemory(u_long cBuckets, u_long cOccupied) {\n    return cBuckets * sizeof(HTItem);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":0,"function":"static u_long NextPow2(u_long x) {\n    if (((x << 1) >> 1) != x)\n        x >>= 1;\n    while ((x & (x - 1)) != 0)\n        x &= (x - 1);\n    return x << 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/samuel2015_sparsehash/experimental/libchash.c"}
{"compilable":1,"function":"int sendAll(SOCKET s, char *buf, int len) {\n    int total = 0;\n    int bytesleft = len;\n    int n = 0;\n    while (total < len)\n        {\n            n = send(s, buf + total, bytesleft, MSG_NOSIGNAL);\n            if (n == -1) {\n                break;\n            }\n            total += n;\n            bytesleft -= n;\n        }\n    return n == -1 ? 0 : total;\n}\n","function_prediction":"int sendAll_name_conflict(int sock, char *buf, int len) {\n  int total = 0;\n  int bytesleft = len;\n  int n;\n\n  while (total < len) {\n    n = send(sock, buf + total, bytesleft, 0x4000);\n    if (n == -1)\n      break;\n    total += n;\n    bytesleft -= n;\n  }\n\n  return total;\n}","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"int sendFileArg(char *filename) {\n    int i, f;\n    if ((f = open(filename, 0)) < 0) {\n        perror(\"--nailgun-filearg\");\n        return 1;\n    }\n    i = read(f, buf, (2048));\n    while (i > 0)\n        {\n            sendChunk(i, 'L', buf);\n            i = read(f, buf, (2048));\n        }\n    if (i < 0) {\n        perror(\"--nailgun-filearg\");\n        return 1;\n    }\n    sendChunk(0, 'L', buf);\n    close(f);\n    return 0;\n}\n","function_prediction":"int sendFileArg_name_conflict(char *fileName) {\n  int fd = open(fileName, 0);\n  if (fd < 0) {\n    perror(\"--nailgun-filearg\");\n    return 1;\n  }\n  int n;\n  while ((n = read(fd, buf, 2048)) > 0) {\n    sendChunk(n, 76, buf);\n  }\n  if (n < 0) {\n    perror(\"--nailgun-filearg\");\n    return 1;\n  }\n  sendChunk_constprop_0(76);\n  close(fd);\n  return n;\n}","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"unsigned long recvToBuffer(unsigned long len) {\n    unsigned long bytesRead = 0;\n    while (bytesRead < len)\n        {\n            int thisPass = recv(nailgunsocket, buf + bytesRead, len - bytesRead, MSG_WAITALL);\n            if (thisPass == 0 || thisPass == -1) {\n                perror(\"recv\");\n                handleSocketClose();\n            }\n            bytesRead += thisPass;\n        }\n    return bytesRead;\n}\n","function_prediction":"size_t recvToBuffer_name_conflict(size_t size) {\n  size_t total = 0;\n  while (total < size) {\n    ssize_t r = recv(nailgunsocket, buf + total, size - total, 0x0100);\n    if (r == -1 || r == 0) {\n      perror(\"recv\");\n      handleSocketClose();\n    }\n    total += r;\n  }\n  return total;\n}","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"int processStdin() {\n    int bytesread = read(0, buf, (2048));\n    if (bytesread > 0) {\n        sendStdin(buf, bytesread);\n    } else if (bytesread == 0) {\n        processEof();\n    }\n    return (bytesread);\n}\n","function_prediction":"int processStdin_name_conflict() {\n  int n = read(0, buf, 2048);\n  if (n > 0) {\n    readyToSend = 0;\n    sendChunk(n, '0' + 48, buf);\n  } else if (n == 0) {\n    sendChunk_constprop_0('.');\n  }\n  return n;\n}","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"int intervalMillis(struct timeval end, struct timeval start) {\n    return ((end.tv_sec - start.tv_sec) * 1000) + ((end.tv_usec - start.tv_usec) / 1000);\n}\n","function_prediction":"int intervalMillis_name_conflict(struct timeval end, struct timeval start) {\n  return (end.tv_sec - start.tv_sec) * 1000 +\n         (end.tv_usec - start.tv_usec) / 1000;\n}","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"char *shortClientName(char *s) {\n    char *result = strrchr(s, '/');\n    return ((result == ((void *)0)) ? s : result + 1);\n}\n","function_prediction":"char *shortClientName_name_conflict(char *name) {\n  char *p = strrchr(name, '/');\n  if (p)\n    return p + 1;\n  else\n    return name;\n}","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"int isNailgunClientName(char *s) {\n    return (!(strcmp(s, \"ng\")));\n}\n","function_prediction":"int isNailgunClientName_name_conflict(const char *name) { return !strcmp(name, \"ng\"); }","pass":1,"source_file":"C_COMPILE/bocon13_buck/third-party/nailgun/nailgun-client/ng.c"}
{"compilable":1,"function":"pid_t do_driver(char *driver) {\n    pid_t child;\n    int pipe[2];\n    if (socketpair(1, SOCK_STREAM, 0, pipe) < 0)\n        err_sys(\"can't create socketpair\");\n    if ((child = fork()) < 0)\n        err_sys(\"fork error\");\n    else if (child == 0) {\n        close(pipe[1]);\n        if (dup2(1, 2) != 2)\n            err_sys(\"dup2 error to sterr\");\n        if (dup2(pipe[0], 0) != 0)\n            err_sys(\"dup2 error to stdin\");\n        if (dup2(pipe[0], 1) != 1)\n            err_sys(\"dup2 error to stdout\");\n        close(pipe[0]);\n        execlp(driver, driver, (char *)0);\n        err_sys(\"execlp error for: %s\", driver);\n    }\n    close(pipe[0]);\n    if (dup2(pipe[1], 0) != 0)\n        err_sys(\"dup2 error to stdin\");\n    if (dup2(pipe[1], 1) != 1)\n        err_sys(\"dup2 error to stdout\");\n    close(pipe[1]);\n    return child;\n}\n","function_prediction":"pid_t do_driver_name_conflict(const char *cmd) {\n  int fd[2];\n  pid_t pid;\n\n  if (socketpair(1, 1, 0, fd) < 0)\n    err_sys(\"can't create socketpair\");\n\n  if ((pid = fork()) < 0)\n    err_sys(\"fork error\");\n  else if (pid == 0) {\n    close(fd[1]);\n    if (dup2(1, 2) != 2)\n      err_sys(\"dup2 error to sterr\");\n    if (dup2(fd[0], 0) != 0)\n      err_sys(\"dup2 error to stdin\");\n    if (dup2(fd[0], 1) != 1)\n      err_sys(\"dup2 error to stdout\");\n    close(fd[0]);\n    execlp(cmd, cmd, (char *)0);\n    err_sys(\"execlp error for: %s\", cmd);\n  }\n\n  close(fd[0]);\n  if (dup2(fd[1], 0) != 0)\n    err_sys(\"dup2 error to stdin\");\n  if (dup2(fd[1], 1) != 1)\n    err_sys(\"dup2 error to stdout\");\n  close(fd[1]);\n\n  return pid;\n}","pass":1,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/driver.c"}
{"compilable":1,"function":"int tty_cbreak(int fd) {\n    struct termios buf;\n    if (tcgetattr(fd, &save_termios) < 0)\n        return (-1);\n    buf = save_termios;\n    buf.c_lflag &= ~(8 | 2);\n    buf.c_cc[6] = 1;\n    buf.c_cc[5] = 0;\n    if (tcsetattr(fd, 2, &buf) < 0)\n        return (-1);\n    ttystate = CBREAK;\n    ttysavefd = fd;\n    return (0);\n}\n","function_prediction":"int tty_cbreak_name_conflict(int fd) {\n  struct termios t;\n\n  if (tcgetattr(fd, &save_termios) < 0)\n    return -1;\n\n  t = save_termios;\n\n  t.c_lflag &= ~(ECHO | ICANON);\n  t.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n  t.c_cflag &= ~(CSIZE | PARENB);\n  t.c_cflag |= CS8;\n  t.c_oflag &= ~(OPOST);\n  t.c_cc[VMIN] = 1;\n  t.c_cc[VTIME] = 0;\n\n  if (tcsetattr(fd, 2, &t) < 0)\n    return -1;\n\n  ttysavefd = fd;\n  ttystate = 2;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":1,"function":"int tty_raw(int fd) {\n    struct termios buf;\n    if (tcgetattr(fd, &save_termios) < 0)\n        return (-1);\n    buf = save_termios;\n    buf.c_lflag &= ~(8 | 2 | 32768 | 1);\n    buf.c_iflag &= ~(2 | 256 | 16 | 32 | 1024);\n    buf.c_cflag &= ~(48 | 256);\n    buf.c_cflag |= 48;\n    buf.c_oflag &= ~(1);\n    buf.c_cc[6] = 1;\n    buf.c_cc[5] = 0;\n    if (tcsetattr(fd, 2, &buf) < 0)\n        return (-1);\n    ttystate = RAW;\n    ttysavefd = fd;\n    return (0);\n}\n","function_prediction":"int tty_raw_name_conflict(int fd) {\n  struct termios tty;\n  int r;\n\n  r = tcgetattr(fd, &save_termios);\n  if (r < 0)\n    return -1;\n\n  tty = save_termios;\n\n  tty.c_iflag &=\n      ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON);\n  tty.c_oflag &= ~OPOST;\n  tty.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);\n  tty.c_cflag &= ~(CSIZE | PARENB);\n  tty.c_cflag |= CS8;\n\n  tty.c_cc[VMIN] = 1;\n  tty.c_cc[VTIME] = 0;\n\n  r = tcsetattr(fd, 2, &tty);\n  if (r < 0)\n    return -1;\n\n  ttysavefd = fd;\n  ttystate = 1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":1,"function":"int tty_reset(int fd) {\n    if (ttystate != CBREAK && ttystate != RAW)\n        return (0);\n    if (tcsetattr(fd, 2, &save_termios) < 0)\n        return (-1);\n    ttystate = RESET;\n    return (0);\n}\n","function_prediction":"int tty_reset_name_conflict(int fd) {\n  if (ttystate != 1 && ttystate != 2)\n    return 0;\n\n  if (tcsetattr(fd, 2, &save_termios) < 0)\n    return -1;\n\n  ttystate = 0;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":0,"function":"struct termios *tty_termios(void) {\n    return (&save_termios);\n}\n","function_prediction":"struct termios *tty_termios_name_conflict(void) { return &save_termios; }","pass":0,"source_file":"C_COMPILE/bdube_infrastructure-puppet/modules/rootbin_asf/files/bin/apue/ttymodes.c"}
{"compilable":1,"function":"int func1(void) {\n    return 42;\n}\n","function_prediction":"int func1_name_conflict(void) { return 42; }","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/exclusion/hello.c"}
{"compilable":1,"function":"int hello2() {\n    printf(\"Hello, two!\\n\");\n    return 0;\n}\n","function_prediction":"int hello2_name_conflict(void) {\n  puts(\"Hello, two!\");\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/msvs/uldi2010/hello2.c"}
{"compilable":1,"function":"int asm_function() {\n    return 41;\n}\n","function_prediction":"int asm_function_name_conflict(void) {\n  int a = 10;\n  int b = 15;\n  int c = 0;\n\n  c = a + b;\n\n  return c;\n}","pass":0,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/rules/src/subdir4/program.c"}
{"compilable":1,"function":"int func1(void) {\n    return 42;\n}\n","function_prediction":"int func1_name_conflict(void) { return 42; }","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/product/hello.c"}
{"compilable":1,"function":"int hello2() {\n    printf(\"Hello, two!\\n\");\n    return 0;\n}\n","function_prediction":"int hello2_name_conflict(void) {\n  puts(\"Hello, two!\");\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/msvs/uldi2010/hello2.c"}
{"compilable":1,"function":"int funcB() {\n    return 3;\n}\n","function_prediction":"int funcB_name_conflict(void) { return 3; }","pass":1,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/dependencies/b/b3.c"}
{"compilable":0,"function":"int funcA() {\n    return funcB();\n}\n","function_prediction":"void funcA_name_conflict(void) { funcB(); }","pass":0,"source_file":"C_COMPILE/jholloman_node-gyp/gyp/test/dependencies/a.c"}
{"compilable":0,"function":"char *create_pkt(char *ip) {\n    char *ptr;\n    char *adr;\n    char *token;\n    int fd;\n    int arp_proto = htons(2054);\n    int hw_tp = htons(1);\n    int pro_type = htons(2048);\n    int hw_size = 6;\n    int pr_size = 4;\n    int opcode = htons(1);\n    int i;\n    unsigned char seq;\n    struct ifreq buffer;\n    struct sockaddr_in *ipadd;\n    ptr = malloc(sizeof(char[44]));\n    memset(ptr, 0, sizeof(char[44]));\n    fd = socket(2, SOCK_DGRAM, IPPROTO_IP);\n    memset(&buffer, 0, sizeof (buffer));\n    strcpy(buffer.ifr_ifrn.ifrn_name, \"wlan0\");\n    ioctl(fd, 35111, &buffer);\n    close(fd);\n    memcpy(ptr, \"\\377\\377\\377\\377\\377\\377\", 6);\n    memcpy(ptr + 6, buffer.ifr_ifru.ifru_addr.sa_data, 6);\n    memcpy(ptr + (2 * 6), &arp_proto, 2);\n    memcpy(ptr + 14, &hw_tp, 2);\n    memcpy(ptr + 14 + 2, &pro_type, 2);\n    memcpy(ptr + 14 + 4, &hw_size, 1);\n    memcpy(ptr + 14 + 5, &pr_size, 1);\n    memcpy(ptr + 14 + 6, &opcode, 2);\n    memcpy(ptr + 14 + 8, buffer.ifr_ifru.ifru_addr.sa_data, 6);\n    memset(&buffer, 0, sizeof buffer);\n    strcpy(buffer.ifr_ifrn.ifrn_name, \"wlan0\");\n    fd = socket(2, SOCK_DGRAM, 0);\n    if (ioctl(fd, 35093, &buffer) == -1)\n        printf(\"ioctl ip checking error\\n\");\n    close(fd);\n    ipadd = (struct sockaddr_in *)&(buffer.ifr_ifru.ifru_addr);\n    adr = inet_ntoa(ipadd->sin_addr);\n    printf(\"alamat ipmu adalah : %s\\n\", adr);\n    token = strtok(adr, \".\");\n    while (token != ((void *)0))\n        {\n            seq = atoi(token);\n            memcpy(ptr + 14 + 8 + 6 + i, &seq, 1);\n            token = strtok(((void *)0), \".\");\n            i++;\n        }\n    i = 0;\n    token = strtok(ip, \".\");\n    while (token != ((void *)0))\n        {\n            seq = atoi(token);\n            memcpy(ptr + 14 + 8 + (2 * 6) + 4 + i, &seq, 1);\n            token = strtok(((void *)0), \".\");\n            i++;\n        }\n    return ptr;\n}\n","function_prediction":"struct ethhdr *create_pkt_name_conflict(char *ip_dest) {\n  struct ethhdr *pkt;\n  pkt = calloc(44, sizeof(char));\n\n  int sockfd;\n  struct ifreq ifr;\n\n  sockfd = socket(2, 2, 0);\n\n  ifr.ifr_addr.sa_family = 0;\n  ifr.ifr_name[0] = 'w';\n  ifr.ifr_name[1] = 'l';\n  ifr.ifr_name[2] = 'a';\n  ifr.ifr_name[3] = 'n';\n  ifr.ifr_name[4] = '0';\n  ifr.ifr_name[5] = 0;\n\n  ioctl(sockfd, 0x8927, &ifr);\n  close(sockfd);\n\n  pkt->h_dest[0] = 0xff;\n  pkt->h_dest[1] = 0xff;\n  pkt->h_proto = 0x0800;\n  pkt->h_source[0] = 0x00;\n  pkt->h_source[1] = 0x00;\n  pkt->h_source[2] = 0x00;\n  pkt->h_source[3] = 0x00;\n  pkt->h_source[4] = 0x00;\n  pkt->h_source[5] = 0x00;\n  pkt->h_source[6] = 0x00;\n  pkt->h_source[7] = 0x00;\n  pkt->h_source[8] = 0x00;\n  pkt->h_source[9] = 0x00;\n  pkt->h_source[10] = 0x00;\n  pkt->h_source[11] = 0x00;\n  pkt->h_source[12] = 0x00;\n  pkt->h_source[13] = 0x00;\n  pkt->h_source[14] = 0x0","pass":0,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":1,"function":"int are_equal(const unsigned char *str1, const unsigned char *str2, int len) {\n    int i;\n    for (i = 0; i < len; i++) {\n        if (!(*(str1 + i) & *(str2 + i)))\n            return 0;\n    }\n    return 1;\n}\n","function_prediction":"int are_equal_name_conflict(const unsigned char *a, const unsigned char *b, int len) {\n  int i;\n  for (i = 0; i < len; i++) {\n    if ((a[i] & b[i]) == 0)\n      return 0;\n  }\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":1,"function":"int create_socket() {\n    int fd;\n    fd = socket(17, SOCK_RAW, htons(2054));\n    if (fd == -1)\n        printf(\"socket error\\n\");\n    return fd;\n}\n","function_prediction":"int create_socket_name_conflict() {\n  int sockfd;\n\n  if ((sockfd = socket(17, 3, 1544)) == -1) {\n    puts(\"socket error\");\n    return -1;\n  }\n\n  return sockfd;\n}","pass":1,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":1,"function":"int examine_addr(char *addr) {\n    char *ex;\n    char sec_addr[3];\n    char *token;\n    unsigned int tes;\n    int chk_ip = 0;\n    ex = strchr(addr, ' ');\n    if (ex != ((void *)0)) {\n        printf(\"alamat yang di masukkan salah, mohon jangan ada spasi\\n\");\n        return 0;\n    }\n    token = strtok(addr, \".\");\n    while (token != ((void *)0))\n        {\n            chk_ip++;\n            tes = atoi(token);\n            if (tes > 255) {\n                printf(\"alamat ip tidak ada yang lebih dari 255\\n\");\n                return 0;\n            }\n            token = strtok(((void *)0), \".\");\n        }\n    if (chk_ip != 4) {\n        printf(\"alamat tidak valid\\n\");\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"int examine_addr_name_conflict(char *addr) {\n  char *token;\n  int count = 0;\n\n  if (strchr(addr, ' ') != NULL) {\n    puts(\"alamat yang di masukkan salah, mohon jangan ada spasi\");\n    return 0;\n  }\n\n  token = strtok(addr, \".\");\n  while (token != NULL) {\n    if (strtol(token, NULL, 10) > 255) {\n      puts(\"alamat ip tidak ada yang lebih dari 255\");\n      return 0;\n    }\n    count++;\n    token = strtok(NULL, \".\");\n  }\n\n  if (count != 4) {\n    puts(\"alamat tidak valid\");\n    return 0;\n  }\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/genomexyz_read_mac/mac_read.c"}
{"compilable":0,"function":"static int make_user_test(void) {\n    struct user *user = psylbm_make_user();\n    psylbm_free_user(user);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/test/domain_test.c"}
{"compilable":0,"function":"static int make_bookmark_test(void) {\n    struct bookmark *bookmark = psylbm_make_bookmark();\n    psylbm_free_bookmark(bookmark);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/test/domain_test.c"}
{"compilable":0,"function":"static int parse_insert_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_INSERT;\n    const char *curr = &buffer[4];\n    {\n        char *dst = &message->message.insert.name[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.title[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.volume_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.chapter_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.page_str[0];\n        while (*curr != '|')\n            *(dst++) = *(curr++);\n        curr++;\n    }\n    if (*curr == 0)\n        goto error;\n    {\n        char *dst = &message->message.insert.token[0];\n        while (*curr != 0 && *curr != '|')\n            *(dst++) = *(curr++);\n    }\n    if (*curr != 0) {\n        curr++;\n        char *dst = &message->message.insert.book_id_str[0];\n        while (*curr != 0)\n            *(dst++) = *(curr++);\n    }\n    message->message.insert.volume = atoi(message->message.insert.volume_str);\n    message->message.insert.chapter = atoi(message->message.insert.chapter_str);\n    message->message.insert.page = atoi(message->message.insert.page_str);\n    message->message.insert.book_id = atoi(message->message.insert.book_id_str);\n    return 0;\n  error:\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_auth_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_AUTH;\n    const char *curr = &buffer[5];\n    char *username = &message->message.auth.username[0];\n    while (*curr != '|')\n        *(username++) = *(curr++);\n    curr++;\n    char *password = &message->message.auth.password[0];\n    while (*curr != 0)\n        *(password++) = *(curr++);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_register_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_REGISTER;\n    struct received_message recv_mess = {0};\n    const size_t max_username_len = sizeof (recv_mess.message.regist.username) - 1;\n    const char *curr = &buffer[4];\n    char *username = &message->message.regist.username[0];\n    size_t count = 0;\n    while (*curr != '|')\n        {\n            if (count == max_username_len)\n                break;\n            *(username++) = *(curr++);\n            count++;\n        }\n    curr++;\n    char *password = &message->message.regist.password[0];\n    while (*curr != 0)\n        *(password++) = *(curr++);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_delete_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_DELETE;\n    const char *curr = &buffer[4];\n    char *bookmark_id_str = &message->message.delete.bookmark_id_str[0];\n    while (*curr != '|')\n        *(bookmark_id_str++) = *(curr++);\n    curr++;\n    char *token = &message->message.delete.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    message->message.delete.bookmark_id = atoi(message->message.delete.bookmark_id_str);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_purge_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_PURGE;\n    const char *curr = &buffer[6];\n    char *token = &message->message.purge.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_sync_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_SYNC;\n    const char *curr = &buffer[5];\n    char *token = &message->message.sync.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"static int parse_syncdata_message(const char *buffer, struct received_message *message) {\n    message->type = MESS_SYNCDATA;\n    const char *curr = &buffer[9];\n    char *token = &message->message.syncdata.token[0];\n    while (*curr != 0)\n        *(token++) = *(curr++);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/protocol.c"}
{"compilable":0,"function":"char *psylbm_strndup(const unsigned char *src, size_t len) {\n    const size_t c_str_len = len + 1;\n    char *ret = calloc(1, sizeof(char) * c_str_len);\n    memcpy(ret, src, len);\n    ret[len] = 0;\n    return ret;\n}\n","function_prediction":"char *psylbm_strndup_name_conflict(const char *s, size_t n) {\n  char *p = calloc(1, n + 1);\n  p = memcpy(p, s, n);\n  p[n] = '\\0';\n  return p;\n}","pass":0,"source_file":"C_COMPILE/psyomn_psylbm/src/common.c"}
{"compilable":0,"function":"char *get_executable() {\n    char buffer[4096];\n    snprintf(buffer, 4096, \"/proc/%u/exe\", getpid());\n    char *filename = malloc(4096);\n    ssize_t len = readlink(buffer, filename, 4096);\n    if (len == -1) {\n        fprintf(stderr, \"Can't get executable name from %s - %s\\n\", buffer, strerror((*__errno_location())));\n        exit(-1);\n    } else if (len >= 4096) {\n        fprintf(LOGFILE, \"Executable name %.*s is longer than %d characters.\\n\", 4096, filename, 4096);\n        exit(-1);\n    }\n    filename[len] = '\\x00';\n    return filename;\n}\n","function_prediction":"char *get_executable_name_conflict() {\n  char path[4096];\n  char *buf;\n  ssize_t len;\n\n  snprintf(path, 4096, \"/proc/%u/exe\", getpid());\n  buf = malloc(4096);\n  len = readlink(path, buf, 4096);\n  if (len == -1) {\n    fprintf(stderr, \"Can't get executable name from %s - %s\\n\", path,\n            strerror(*__errno_location()));\n    exit(-1);\n  }\n  if (len >= 4096) {\n    fprintf(LOGFILE, \"Executable name %.*s is longer than %d characters.\\n\",\n            4096, buf, 4096);\n    exit(-1);\n  }\n  buf[len] = '\\0';\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int check_taskcontroller_permissions(char *executable_file) {\n    (*__errno_location()) = 0;\n    char *resolved_path = realpath(executable_file, ((void *)0));\n    if (resolved_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Error resolving the canonical name for the executable : %s!\", strerror((*__errno_location())));\n        return -1;\n    }\n    struct stat filestat;\n    (*__errno_location()) = 0;\n    if (stat(resolved_path, &filestat) != 0) {\n        fprintf(LOGFILE, \"Could not stat the executable : %s!.\\n\", strerror((*__errno_location())));\n        return -1;\n    }\n    uid_t binary_euid = filestat.st_uid;\n    gid_t binary_gid = filestat.st_gid;\n    if (binary_euid != 0) {\n        fprintf(LOGFILE, \"The task-controller binary should be user-owned by root.\\n\");\n        return -1;\n    }\n    if (binary_gid != getgid()) {\n        fprintf(LOGFILE, \"The configured tasktracker group %d is different from the group of the executable %d\\n\", getgid(), binary_gid);\n        return -1;\n    }\n    if ((filestat.st_mode & ((256 >> 3) >> 3)) == ((256 >> 3) >> 3) || (filestat.st_mode & ((128 >> 3) >> 3)) == ((128 >> 3) >> 3) || (filestat.st_mode & ((64 >> 3) >> 3)) == ((64 >> 3) >> 3)) {\n        fprintf(LOGFILE, \"The task-controller binary should not have read or write or execute for others.\\n\");\n        return -1;\n    }\n    if ((filestat.st_mode & 2048) == 0) {\n        fprintf(LOGFILE, \"The task-controller binary should be set setuid.\\n\");\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int check_taskcontroller_permissions_name_conflict(const char *path) {\n  char *real_path;\n  struct stat st;\n  int ret;\n\n  *__errno_location() = 0;\n  real_path = realpath(path, NULL);\n  if (real_path == NULL) {\n    fprintf(LOGFILE,\n            \"Error resolving the canonical name for the executable : %s!\",\n            strerror(*__errno_location()));\n    return -1;\n  }\n  *__errno_location() = 0;\n  ret = stat(real_path, &st);\n  if (ret != 0) {\n    fprintf(LOGFILE, \"Could not stat the executable : %s!.\\n\",\n            strerror(*__errno_location()));\n    return -1;\n  }\n  if (st.st_uid != 0) {\n    fprintf(LOGFILE,\n            \"The task-controller binary should be user-owned by root.\\n\");\n    return -1;\n  }\n  if (st.st_gid != getgid()) {\n    fprintf(LOGFILE,\n            \"The configured tasktracker group %d is different from the group \"\n            \"of the executable %d\\n\",\n            getgid(), st.st_gid);\n    return -1;\n  }\n  if (st.st_mode & 07) {\n    fprintf(LOGFILE, \"The task-controller binary should not have read or write \"\n                     \"or execute for others.\\n\");\n    return -1;\n  }\n  if (!(st.st_mode & 01000)) {\n    fprintf(LOGFILE, \"The task-controller binary should be set setuid.\\n\");\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int change_effective_user(uid_t user, gid_t group) {\n    if (geteuid() == user) {\n        return 0;\n    }\n    if (seteuid(0) != 0) {\n        return -1;\n    }\n    if (setegid(group) != 0) {\n        fprintf(LOGFILE, \"Failed to set effective group id %d - %s\\n\", group, strerror((*__errno_location())));\n        return -1;\n    }\n    if (seteuid(user) != 0) {\n        fprintf(LOGFILE, \"Failed to set effective user id %d - %s\\n\", user, strerror((*__errno_location())));\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int change_effective_user_name_conflict(uid_t uid, gid_t gid) {\n  if (geteuid() == uid)\n    return 0;\n\n  if (seteuid(0))\n    return -1;\n\n  if (setegid(gid)) {\n    fprintf(LOGFILE, \"Failed to set effective group id %d - %s\\n\", gid,\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  if (seteuid(uid)) {\n    fprintf(LOGFILE, \"Failed to set effective user id %d - %s\\n\", uid,\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int change_user(uid_t user, gid_t group) {\n    if (user == getuid() && user == geteuid() && group == getgid() && group == getegid()) {\n        return 0;\n    }\n    if (seteuid(0) != 0) {\n        fprintf(LOGFILE, \"unable to reacquire root - %s\\n\", strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    if (setgid(group) != 0) {\n        fprintf(LOGFILE, \"unable to set group to %d - %s\\n\", group, strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    if (setuid(user) != 0) {\n        fprintf(LOGFILE, \"unable to set user to %d - %s\\n\", user, strerror((*__errno_location())));\n        fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(), geteuid(), getegid());\n        return SETUID_OPER_FAILED;\n    }\n    return 0;\n}\n","function_prediction":"int change_user_name_conflict(uid_t uid, gid_t gid) {\n  if (getuid() == uid && geteuid() == uid && getgid() == gid &&\n      getegid() == gid)\n    return 0;\n\n  if (!seteuid(0)) {\n    if (!setgid(gid)) {\n      if (!setuid(uid))\n        return 0;\n      fprintf(LOGFILE, \"unable to set user to %d - %s\\n\", uid,\n              strerror(*__errno_location()));\n    } else\n      fprintf(LOGFILE, \"unable to set group to %d - %s\\n\", gid,\n              strerror(*__errno_location()));\n    fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(),\n            geteuid(), getegid());\n    return 6;\n  }\n  fprintf(LOGFILE, \"unable to reacquire root - %s\\n\",\n          strerror(*__errno_location()));\n  fprintf(LOGFILE, \"Real: %d:%d; Effective: %d:%d\\n\", getuid(), getgid(),\n          geteuid(), getegid());\n  return 6;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char **get_mapred_local_dirs(const char *good_local_dirs) {\n    return extract_values(strdup(good_local_dirs));\n}\n","function_prediction":"char **get_mapred_local_dirs_name_conflict(char *mapred_local_dirs) {\n  char *mapred_local_dirs_copy = strdup(mapred_local_dirs);\n  return extract_values(mapred_local_dirs_copy);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *concatenate(char *concat_pattern, char *return_path_name, int numArgs, ...) {\n    va_list ap;\n    __builtin_va_start(ap, numArgs);\n    int strlen_args = 0;\n    char *arg = ((void *)0);\n    int j;\n    for (j = 0; j < numArgs; j++) {\n        arg = __builtin_va_arg(ap, char *);\n        if (arg == ((void *)0)) {\n            fprintf(LOGFILE, \"One of the arguments passed for %s in null.\\n\", return_path_name);\n            return ((void *)0);\n        }\n        strlen_args += strlen(arg);\n    }\n    __builtin_va_end(ap);\n    char *return_path = ((void *)0);\n    int str_len = strlen(concat_pattern) + strlen_args + 1;\n    return_path = (char *)malloc(str_len);\n    if (return_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Unable to allocate memory for %s.\\n\", return_path_name);\n        return ((void *)0);\n    }\n    __builtin_va_start(ap, numArgs);\n    vsnprintf(return_path, str_len, concat_pattern, ap);\n    __builtin_va_end(ap);\n    return return_path;\n}\n","function_prediction":"char *concatenate_constprop_0(char *str1, char *str2, char *str3, char *str4,\n                              char *str5, char *str6, char *str7, char *str8,\n                              char *str9, char *str10, char *str11, char *str12,\n                              char *str13, char *str14) {\n  char *result = NULL;\n  size_t len = 0;\n  va_list args;\n\n  if (str12 == NULL || str13 == NULL) {\n    fprintf(LOGFILE, \"One of the arguments passed for %s in null.\\n\", str10);\n    return NULL;\n  }\n\n  len = strlen(str12) + strlen(str13) + strlen(str9) + 1;\n  result = (char *)malloc(len);\n  if (result == NULL) {\n    fprintf(LOGFILE, \"Unable to allocate memory for %s.\\n\", str10);\n    return NULL;\n  }\n\n  args = (va_list)&str14;\n  vsnprintf(result, len, str9, args);\n\n  return result;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_directory(const char *tt_root, const char *user, const char *jobid) {\n    return concatenate(\"%s/taskTracker/%s/jobcache/%s\", \"job_dir_path\", 3, tt_root, user, jobid);\n}\n","function_prediction":"char *get_job_directory(char *task_tracker_host, char *task_tracker_port,\n                        char *job_id) {\n  return concatenate_constprop_1(\"%s/taskTracker/%s/jobcache/%s\",\n                                 \"job_dir_path\", 3, task_tracker_host,\n                                 task_tracker_port, job_id);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_user_directory(const char *tt_root, const char *user) {\n    return concatenate(\"%s/taskTracker/%s\", \"user_dir_path\", 2, tt_root, user);\n}\n","function_prediction":"char *get_user_directory_name_conflict(char *user_name, char *task_name) {\n  return concatenate_constprop_0(\"%s/taskTracker/%s\", \"user_dir_path\", 2,\n                                 user_name, task_name);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_work_directory(const char *job_dir) {\n    return concatenate(\"%s/work\", \"job work\", 1, job_dir);\n}\n","function_prediction":"char *get_job_work_directory_name_conflict(const char *job_id) {\n  return concatenate_constprop_3(\"%s/work\", \"job work\", 1, job_id);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_attempt_work_directory(const char *tt_root, const char *user, const char *job_id, const char *attempt_id) {\n    return concatenate(\"%s/taskTracker/%s/jobcache/%s/%s/work\", \"attempt_dir_path\", 4, tt_root, user, job_id, attempt_id);\n}\n","function_prediction":"char *get_attempt_work_directory(char *task_dir_path, char *task_name,\n                                 char *job_id, char *attempt_id) {\n  return concatenate_constprop_2(\"%%s/taskTracker/%%s/jobcache/%%s/%%s/work\",\n                                 \"attempt_dir_path\", 4, task_dir_path,\n                                 task_name, job_id, attempt_id);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_task_launcher_file(const char *work_dir) {\n    return concatenate(\"%s/%s\", \"task launcher\", 2, work_dir, \"taskjvm.sh\");\n}\n","function_prediction":"char *get_task_launcher_file_name_conflict(const char *path) {\n  return concatenate_constprop_0(\"%s/%s\", \"task launcher\", 2, path,\n                                 \"taskjvm.sh\");\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_job_log_directory(const char *jobid) {\n    char *log_dir = get_value(\"hadoop.log.dir\");\n    if (log_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Log directory %s is not configured.\\n\", \"hadoop.log.dir\");\n        return ((void *)0);\n    }\n    char *result = concatenate(\"%s/userlogs/%s\", \"job log dir\", 2, log_dir, jobid);\n    if (result == ((void *)0)) {\n        fprintf(LOGFILE, \"failed to get memory in get_job_log_directory for %s and %s\\n\", log_dir, jobid);\n    }\n    free(log_dir);\n    return result;\n}\n","function_prediction":"char *get_job_log_directory_name_conflict(char *job_id) {\n  char *log_dir = NULL;\n  char *job_log_dir = NULL;\n\n  log_dir = get_value(\"hadoop.log.dir\");\n  if (log_dir == NULL) {\n    fprintf(LOGFILE, \"Log directory %s is not configured.\\n\", \"hadoop.log.dir\");\n    return NULL;\n  }\n\n  job_log_dir = concatenate_constprop_0(\"%s/userlogs/%s\", \"job log dir\", 2,\n                                        log_dir, job_id);\n  if (job_log_dir == NULL) {\n    fprintf(LOGFILE,\n            \"failed to get memory in get_job_log_directory_name_conflict for %s and %s\\n\",\n            log_dir, job_id);\n  }\n\n  free(log_dir);\n  return job_log_dir;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"char *get_user_subdirectory(const char *tt_root, const char *user, const char *subdir) {\n    char *user_dir = get_user_directory(tt_root, user);\n    char *result = concatenate(\"%s/%s\", \"user subdir\", 2, user_dir, subdir);\n    free(user_dir);\n    return result;\n}\n","function_prediction":"char *get_user_subdirectory(char *user_dir_path, char *user_name,\n                            char *subdir_name) {\n  char *user_subdir_path = concatenate_constprop_0(\n      \"%s/taskTracker/%s\", \"user_dir_path\", 2, user_dir_path, user_name);\n  char *user_subdir_path_with_subdir = concatenate_constprop_0(\n      \"%s/%s\", \"user subdir\", 2, user_subdir_path, subdir_name);\n  free(user_subdir_path);\n  return user_subdir_path_with_subdir;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int mkdirs(const char *path, mode_t perm) {\n    char *buffer = strdup(path);\n    char *token;\n    int cwd = open(\"/\", 0);\n    if (cwd == -1) {\n        fprintf(LOGFILE, \"Can't open / in %s - %s\\n\", path, strerror((*__errno_location())));\n        free(buffer);\n        return -1;\n    }\n    for (token = strtok(buffer, \"/\"); token != ((void *)0); token = strtok(((void *)0), \"/\")) {\n        if (mkdirat(cwd, token, perm) != 0) {\n            if ((*__errno_location()) != 17) {\n                fprintf(LOGFILE, \"Can't create directory %s in %s - %s\\n\", token, path, strerror((*__errno_location())));\n                close(cwd);\n                free(buffer);\n                return -1;\n            }\n        }\n        int new_dir = openat(cwd, token, 0);\n        close(cwd);\n        cwd = new_dir;\n        if (cwd == -1) {\n            fprintf(LOGFILE, \"Can't open %s in %s - %s\\n\", token, path, strerror((*__errno_location())));\n            free(buffer);\n            return -1;\n        }\n    }\n    free(buffer);\n    close(cwd);\n    return 0;\n}\n","function_prediction":"int mkdirs_name_conflict(const char *path, mode_t mode) {\n  char *path_copy = strdup(path);\n  char *dir;\n  int fd = open(\"/\", 0);\n\n  if (fd == -1) {\n    fprintf(LOGFILE, \"Can't open / in %s - %s\\n\", path,\n            strerror(*__errno_location()));\n    free(path_copy);\n    return -1;\n  }\n\n  for (dir = strtok(path_copy, \"/\"); dir; dir = strtok(NULL, \"/\")) {\n    int rc = mkdirat(fd, dir, mode);\n    if (rc && *__errno_location() != 17) {\n      fprintf(LOGFILE, \"Can't create directory %s in %s - %s\\n\", dir, path,\n              strerror(*__errno_location()));\n      close(fd);\n      free(path_copy);\n      return -1;\n    }\n\n    int fd2 = openat(fd, dir, 0);\n    close(fd);\n    if (fd2 == -1) {\n      fprintf(LOGFILE, \"Can't open %s in %s - %s\\n\", dir, path,\n              strerror(*__errno_location()));\n      free(path_copy);\n      return -1;\n    }\n    fd = fd2;\n  }\n\n  free(path_copy);\n  close(fd);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static short get_current_local_dir_count(char **local_dir) {\n    char **local_dir_ptr;\n    short count = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        ++count;\n    }\n    return count;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static char *get_nth_local_dir(char **local_dir, int nth) {\n    char **local_dir_ptr;\n    short count = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        if (count == nth) {\n            return strdup(*local_dir_ptr);\n        }\n        ++count;\n    }\n    fprintf(LOGFILE, \"Invalid index %d for %d local directories\\n\", nth, count);\n    return ((void *)0);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static char *get_random_local_dir(char **local_dir) {\n    struct timeval tv;\n    short nth;\n    gettimeofday(&tv, ((void *)0));\n    srand((long)tv.tv_sec * 1000000 + tv.tv_usec);\n    short cnt = get_current_local_dir_count(local_dir);\n    if (cnt == 0) {\n        fprintf(LOGFILE, \"No valid local directories\\n\");\n        return ((void *)0);\n    }\n    nth = rand() % cnt;\n    return get_nth_local_dir(local_dir, nth);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int create_attempt_directories(const char *user, const char *good_local_dirs, const char *job_id, const char *task_id) {\n    const mode_t perms = (256 | 128 | 64) | (256 >> 3) | (64 >> 3);\n    if (job_id == ((void *)0) || task_id == ((void *)0) || user == ((void *)0)) {\n        fprintf(LOGFILE, \"Either task_id is null or the user passed is null.\\n\");\n        return -1;\n    }\n    int result = 0;\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    if (local_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could not be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    char **local_dir_ptr;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        char *task_dir = get_attempt_work_directory(*local_dir_ptr, user, job_id, task_id);\n        if (task_dir == ((void *)0)) {\n            free_values(local_dir);\n            return -1;\n        }\n        if (mkdirs(task_dir, perms) != 0) {\n            free(task_dir);\n        } else {\n            free(task_dir);\n        }\n    }\n    char *job_task_name = malloc(strlen(job_id) + strlen(task_id) + 2);\n    char *real_task_dir = ((void *)0);\n    char *real_job_dir = ((void *)0);\n    char *random_local_dir = ((void *)0);\n    char *link_task_log_dir = ((void *)0);\n    if (job_task_name == ((void *)0)) {\n        fprintf(LOGFILE, \"Malloc of job task name failed\\n\");\n        result = -1;\n    } else {\n        sprintf(job_task_name, \"%s/%s\", job_id, task_id);\n        link_task_log_dir = get_job_log_directory(job_task_name);\n        random_local_dir = get_random_local_dir(local_dir);\n        if (random_local_dir == ((void *)0)) {\n            result = -1;\n            goto cleanup;\n        }\n        real_job_dir = malloc(strlen(random_local_dir) + strlen(\"userlogs\") + strlen(job_id) + 3);\n        if (real_job_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc of real job directory failed\\n\");\n            result = -1;\n            goto cleanup;\n        }\n        real_task_dir = malloc(strlen(random_local_dir) + strlen(\"userlogs\") + strlen(job_id) + strlen(task_id) + 4);\n        if (real_task_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc of real task directory failed\\n\");\n            result = -1;\n            goto cleanup;\n        }\n        sprintf(real_job_dir, \"%s/userlogs/%s\", random_local_dir, job_id);\n        result = create_directory_for_user(real_job_dir);\n        if (result != 0) {\n            result = -1;\n            goto cleanup;\n        }\n        sprintf(real_task_dir, \"%s/userlogs/%s/%s\", random_local_dir, job_id, task_id);\n        result = mkdirs(real_task_dir, perms);\n        if (result != 0) {\n            result = -1;\n            goto cleanup;\n        }\n        result = symlink(real_task_dir, link_task_log_dir);\n        if (result != 0) {\n            fprintf(LOGFILE, \"Failed to create symlink %s to %s - %s\\n\", link_task_log_dir, real_task_dir, strerror((*__errno_location())));\n            result = -1;\n        }\n    }\n  cleanup:\n    free(random_local_dir);\n    free(job_task_name);\n    free(link_task_log_dir);\n    free(real_job_dir);\n    free(real_task_dir);\n    free_values(local_dir);\n    return result;\n}\n","function_prediction":"int create_attempt_directories(char *user, char *job_id, char *task_id,\n                               char *attempt_id) {\n\n  if (attempt_id == NULL || user == NULL || task_id == NULL) {\n    fprintf(LOGFILE, \"Either task_id is null or the user passed is null.\\n\");\n    return -1;\n  }\n\n  char *mapred_local_dirs = strdup(\"mapred.local.dir\");\n  char **local_dirs = extract_values(mapred_local_dirs);\n  if (local_dirs == NULL) {\n    fprintf(LOGFILE, \"Good mapred local directories could not be obtained.\\n\");\n    return 5;\n  }\n\n  int i = 0;\n  while (local_dirs[i] != NULL) {\n    char *attempt_dir_path = concatenate_constprop_2(\n        \"%s/taskTracker/%s/jobcache/%s/%s/work\", \"attempt_dir_path\", 4,\n        local_dirs[i], user, task_id);\n    if (attempt_dir_path == NULL) {\n      free_values(local_dirs);\n      return -1;\n    }\n    mkdirs(attempt_dir_path, 0750, attempt_id);\n    free(attempt_dir_path);\n    i++;\n  }\n\n  char *job_task_name = malloc(strlen(task_id) + strlen(attempt_id) + 2);\n  if (job_task_name == NULL) {\n    fprintf(LOGFILE, \"Malloc of job task name failed\\n\");\n    goto cleanup;\n  }\n  sprintf(job_task_name, \"%s/%s\", task_id, attempt_id);\n\n  char *job_log_dir = NULL;\n  char *log_dir = get_value(\"hadoop.log.dir\");\n  if (log_dir != NULL) {\n        job_log_dir = concatenate_constprop_0(\"%s/userlogs/%s\", \"job log","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int set_user(const char *user) {\n    if (user_detail != ((void *)0)) {\n        free(user_detail);\n        user_detail = ((void *)0);\n    }\n    user_detail = check_user(user);\n    if (user_detail == ((void *)0)) {\n        return -1;\n    }\n    return change_effective_user(user_detail->pw_uid, user_detail->pw_gid);\n}\n","function_prediction":"int set_user_name_conflict(void) {\n  int uid, gid;\n\n  if (user_detail) {\n    free(user_detail);\n    user_detail = NULL;\n  }\n\n  user_detail = check_user();\n  if (!user_detail)\n    return -1;\n\n  uid = user_detail->pw_uid;\n  gid = user_detail->pw_gid;\n\n  if (uid == geteuid())\n    return 0;\n\n  if (!seteuid(0)) {\n    if (!setegid(gid)) {\n      if (!seteuid(uid))\n        return 0;\n      else\n        fprintf(LOGFILE, \"Failed to set effective user id %d - %s\\n\", uid,\n                strerror(*__errno_location()));\n    } else\n      fprintf(LOGFILE, \"Failed to set effective group id %d - %s\\n\", gid,\n              strerror(*__errno_location()));\n  }\n\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int change_owner(const char *path, uid_t user, gid_t group) {\n    if (geteuid() == user && getegid() == group) {\n        return 0;\n    } else {\n        uid_t old_user = geteuid();\n        gid_t old_group = getegid();\n        if (change_effective_user(0, group) != 0) {\n            return -1;\n        }\n        if (chown(path, user, group) != 0) {\n            fprintf(LOGFILE, \"Can't chown %s to %d:%d - %s\\n\", path, user, group, strerror((*__errno_location())));\n            return -1;\n        }\n        return change_effective_user(old_user, old_group);\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int create_directory_for_user(const char *path) {\n    mode_t permissions = (256 | 128 | 64) | (256 >> 3) | (64 >> 3) | 1024;\n    uid_t user = geteuid();\n    gid_t group = getegid();\n    int ret = 0;\n    uid_t root = 0;\n    if (getuid() == root) {\n        ret = change_effective_user(root, tt_gid);\n    }\n    if (ret == 0) {\n        if (mkdir(path, permissions) == 0 || (*__errno_location()) == 17) {\n            if (chmod(path, permissions) != 0) {\n                fprintf(LOGFILE, \"Can't chmod %s to add the sticky bit - %s\\n\", path, strerror((*__errno_location())));\n                ret = -1;\n            } else if (change_owner(path, user, tt_gid) != 0) {\n                ret = -1;\n            }\n        } else {\n            fprintf(LOGFILE, \"Failed to create directory %s - %s\\n\", path, strerror((*__errno_location())));\n            ret = -1;\n        }\n    }\n    if (change_effective_user(user, group) != 0) {\n        ret = -1;\n    }\n    return ret;\n}\n","function_prediction":"int create_directory_for_user_name_conflict(const char *dir) {\n  int ret = 0;\n  uid_t orig_uid = geteuid();\n  gid_t orig_gid = getegid();\n\n  if (getuid() == 0) {\n    if (change_effective_user(0, tt_gid))\n      goto out;\n  }\n\n  if (!mkdir(dir, 0750)) {\n    ret = -1;\n    fprintf(LOGFILE, \"Failed to create directory %s - %s\\n\", dir,\n            strerror(*__errno_location()));\n    if (*__errno_location() == 17)\n      ret = 0;\n    goto out;\n  }\n\n  if (chmod(dir, 0750)) {\n    fprintf(LOGFILE, \"Can't chmod %s to add the sticky bit - %s\\n\", dir,\n            strerror(*__errno_location()));\n    ret = -1;\n    goto out;\n  }\n\n  if (orig_uid == geteuid() && orig_gid == getegid())\n    goto out;\n\n  if (change_effective_user(0, tt_gid)) {\n    ret = -1;\n    goto out;\n  }\n\n  if (chown(dir, orig_uid, tt_gid)) {\n    fprintf(LOGFILE, \"Can't chown %s to %d:%d - %s\\n\", dir, orig_uid, tt_gid,\n            strerror(*__errno_location()));\n    ret = -1;\n    goto out;\n  }\n\n  if (change_effective_user(orig_uid, orig_gid))\n    ret = -1;\n\nout:\n  if (change_effective_user(orig_uid, orig_gid))\n    ret = -1;\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int open_file_as_task_tracker(const char *filename) {\n    uid_t user = geteuid();\n    gid_t group = getegid();\n    if (change_effective_user(tt_uid, tt_gid) != 0) {\n        return -1;\n    }\n    int result = open(filename, 0);\n    if (result == -1) {\n        fprintf(LOGFILE, \"Can't open file %s as task tracker - %s\\n\", filename, strerror((*__errno_location())));\n    }\n    if (change_effective_user(user, group)) {\n        result = -1;\n    }\n    return result;\n}\n","function_prediction":"int open_file_as_task_tracker_name_conflict(const char *filename) {\n  int fd;\n  uid_t old_uid = geteuid();\n  gid_t old_gid = getegid();\n\n  if (!change_effective_user(tt_uid)) {\n    fd = open(filename, 0);\n    if (fd == -1)\n      fprintf(LOGFILE, \"Can't open file %s as task tracker - %s\\n\", filename,\n              strerror(*__errno_location()));\n    if (!change_effective_user(old_uid, old_gid))\n      return fd;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int copy_file(int input, const char *in_filename, const char *out_filename, mode_t perm) {\n    const int buffer_size = 128 * 1024;\n    char buffer[buffer_size];\n    int out_fd = open(out_filename, 1 | 64 | 128 | 131072, perm);\n    if (out_fd == -1) {\n        fprintf(LOGFILE, \"Can't open %s for output - %s\\n\", out_filename, strerror((*__errno_location())));\n        return -1;\n    }\n    ssize_t len = read(input, buffer, buffer_size);\n    while (len > 0)\n        {\n            ssize_t pos = 0;\n            while (pos < len)\n                {\n                    ssize_t write_result = write(out_fd, buffer + pos, len - pos);\n                    if (write_result <= 0) {\n                        fprintf(LOGFILE, \"Error writing to %s - %s\\n\", out_filename, strerror((*__errno_location())));\n                        close(out_fd);\n                        return -1;\n                    }\n                    pos += write_result;\n                }\n            len = read(input, buffer, buffer_size);\n        }\n    if (len < 0) {\n        fprintf(LOGFILE, \"Failed to read file %s - %s\\n\", in_filename, strerror((*__errno_location())));\n        close(out_fd);\n        return -1;\n    }\n    if (close(out_fd) != 0) {\n        fprintf(LOGFILE, \"Failed to close file %s - %s\\n\", out_filename, strerror((*__errno_location())));\n        return -1;\n    }\n    close(input);\n    return 0;\n}\n","function_prediction":"int copy_file_name_conflict(int in_fd, char *in_name, char *out_name, mode_t mode) {\n  int out_fd;\n  ssize_t bytes_read, bytes_written, total_written;\n  char buffer[131072];\n\n  out_fd = open(out_name, 0600 | O_CREAT | O_TRUNC, mode);\n  if (out_fd == -1) {\n    fprintf(LOGFILE, \"Can't open %s for output - %s\\n\", out_name,\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  bytes_read = read(in_fd, buffer, 131072);\n  while (bytes_read > 0) {\n    total_written = 0;\n    do {\n      bytes_written =\n          write(out_fd, buffer + total_written, bytes_read - total_written);\n      if (bytes_written <= 0) {\n        fprintf(LOGFILE, \"Error writing to %s - %s\\n\", out_name,\n                strerror(*__errno_location()));\n        close(out_fd);\n        return -1;\n      }\n      total_written += bytes_written;\n    } while (total_written < bytes_read);\n    bytes_read = read(in_fd, buffer, 131072);\n  }\n\n  if (bytes_read < 0) {\n    fprintf(LOGFILE, \"Failed to read file %s - %s\\n\", in_name,\n            strerror(*__errno_location()));\n    close(out_fd);\n    return -1;\n  }\n\n  if (close(out_fd)) {\n    fprintf(LOGFILE, \"Failed to close file %s - %s\\n\", out_name,\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  close(in_fd);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int initialize_user(const char *user, const char *good_local_dirs) {\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    if (local_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could ot be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    char *user_dir;\n    char **local_dir_ptr = local_dir;\n    int failed = 0;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != 0; ++local_dir_ptr) {\n        user_dir = get_user_directory(*local_dir_ptr, user);\n        if (user_dir == ((void *)0)) {\n            fprintf(LOGFILE, \"Couldn't get userdir directory for %s.\\n\", user);\n            failed = 1;\n            break;\n        }\n        if (create_directory_for_user(user_dir) != 0) {\n            failed = 1;\n        }\n        free(user_dir);\n    }\n    free_values(local_dir);\n    return failed ? INITIALIZE_USER_FAILED : 0;\n}\n","function_prediction":"int initialize_user_name_conflict(char *user, char *mapred_local_dirs) {\n  char *user_dir_path;\n  char **values;\n  int i;\n  int ret;\n  int created_dir = 0;\n\n  values = extract_values(strdup(mapred_local_dirs));\n  if (values == NULL) {\n    fprintf(LOGFILE, \"Good mapred local directories could ot be obtained.\\n\");\n    return 5;\n  }\n\n  for (i = 0; values[i] != NULL; i++) {\n    user_dir_path = concatenate_constprop_0(\n        \"%s/taskTracker/%s\", \"user_dir_path\", 2, values[i], user);\n    if (user_dir_path == NULL) {\n      fprintf(LOGFILE, \"Couldn't get userdir directory for %s.\\n\", user);\n      free_values(values);\n      return 20;\n    }\n\n    ret = create_directory_for_user(user_dir_path);\n    if (ret != 0) {\n      created_dir = 1;\n    }\n\n    free(user_dir_path);\n  }\n\n  free_values(values);\n\n  if (created_dir) {\n    return 20;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int initialize_job(const char *user, const char *good_local_dirs, const char *jobid, const char *credentials, const char *job_xml, char *const *args) {\n    if (jobid == ((void *)0) || user == ((void *)0)) {\n        fprintf(LOGFILE, \"Either jobid is null or the user passed is null.\\n\");\n        return INVALID_ARGUMENT_NUMBER;\n    }\n    int result = initialize_user(user, good_local_dirs);\n    if (result != 0) {\n        return result;\n    }\n    char *job_log_dir = get_job_log_directory(jobid);\n    if (job_log_dir == ((void *)0)) {\n        return -1;\n    }\n    result = create_directory_for_user(job_log_dir);\n    free(job_log_dir);\n    if (result != 0) {\n        return -1;\n    }\n    int cred_file = open_file_as_task_tracker(credentials);\n    if (cred_file == -1) {\n        return -1;\n    }\n    int job_file = open_file_as_task_tracker(job_xml);\n    if (job_file == -1) {\n        return -1;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return -1;\n    }\n    mode_t permissions = (256 | 128 | 64) | (256 >> 3) | (64 >> 3);\n    char **tt_roots = get_mapred_local_dirs(good_local_dirs);\n    if (tt_roots == ((void *)0)) {\n        return INVALID_TT_ROOT;\n    }\n    char **tt_root;\n    char *primary_job_dir = ((void *)0);\n    for (tt_root = tt_roots; *tt_root != ((void *)0); ++tt_root) {\n        char *job_dir = get_job_directory(*tt_root, user, jobid);\n        if (job_dir == ((void *)0)) {\n        } else if (mkdirs(job_dir, permissions) != 0) {\n            free(job_dir);\n        } else if (primary_job_dir == ((void *)0)) {\n            primary_job_dir = job_dir;\n        } else {\n            free(job_dir);\n        }\n    }\n    free_values(tt_roots);\n    if (primary_job_dir == ((void *)0)) {\n        fprintf(LOGFILE, \"Did not create any job directories\\n\");\n        return -1;\n    }\n    char *cred_file_name = concatenate(\"%s/%s\", \"cred file\", 2, primary_job_dir, \"jobToken\");\n    if (cred_file_name == ((void *)0)) {\n        return -1;\n    }\n    if (copy_file(cred_file, credentials, cred_file_name, 256 | 128) != 0) {\n        return -1;\n    }\n    char *job_file_name = concatenate(\"%s/%s\", \"job file\", 2, primary_job_dir, \"job.xml\");\n    if (job_file_name == ((void *)0)) {\n        return -1;\n    }\n    if (copy_file(job_file, job_xml, job_file_name, 256 | 128 | (256 >> 3)) != 0) {\n        return -1;\n    }\n    fclose(stdin);\n    fflush(LOGFILE);\n    if (LOGFILE != stdout) {\n        fclose(stdout);\n    }\n    fclose(stderr);\n    chdir(primary_job_dir);\n    execvp(args[0], args);\n    fprintf(LOGFILE, \"Failure to exec job initialization process - %s\\n\", strerror((*__errno_location())));\n    return -1;\n}\n","function_prediction":"int initialize_job(char *jobid, char *job_name, char *user, char *cred_file,\n                   char *job_file, char **argv) {\n  int ret = 0;\n  int fd_cred = 0;\n  int fd_job = 0;\n  char *job_dir_path = NULL;\n  char *job_log_dir = NULL;\n  char *job_dir_path_with_jobid = NULL;\n  char *job_log_dir_with_jobid = NULL;\n  char *job_dir_path_with_jobid_cred = NULL;\n  char *job_dir_path_with_jobid_job = NULL;\n  char *job_log_dir_with_jobid_cred = NULL;\n  char *job_log_dir_with_jobid_job = NULL;\n  char *job_dir_path_with_jobid_cred_file = NULL;\n  char *job_dir_path_with_jobid_job_file = NULL;\n  char *job_log_dir_with_jobid_cred_file = NULL;\n  char *job_log_dir_with_jobid_job_file = NULL;\n  char *job_dir_path_with_jobid_cred_file_path = NULL;\n  char *job_dir_path_with_jobid_job_file_path = NULL;\n  char *job_log_dir_with_jobid_cred_file_path = NULL;\n  char *job_log_dir_with_jobid_job_file_path = NULL;\n  char *job_dir_path_with_jobid_cred_file_path_with_job_name = NULL;\n  char *job_dir_path_with_jobid_job_file_path_with_job_name = NULL;\n  char *job_log_dir_with_jobid_cred_file_path_with_job_name = NULL;\n  char *job_log_dir_with_jobid_job_file_path_with_job_name = NULL;\n  char *job_dir_path_with_jobid_cred_file_path","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int run_task_as_user(const char *user, const char *good_local_dirs, const char *job_id, const char *task_id, const char *work_dir, const char *script_name) {\n    int exit_code = -1;\n    char *task_script_path = ((void *)0);\n    if (create_attempt_directories(user, good_local_dirs, job_id, task_id) != 0) {\n        goto cleanup;\n    }\n    int task_file_source = open_file_as_task_tracker(script_name);\n    if (task_file_source == -1) {\n        goto cleanup;\n    }\n    task_script_path = get_task_launcher_file(work_dir);\n    if (task_script_path == ((void *)0)) {\n        exit_code = OUT_OF_MEMORY;\n        goto cleanup;\n    }\n    if (copy_file(task_file_source, script_name, task_script_path, (256 | 128 | 64)) != 0) {\n        goto cleanup;\n    }\n    fcloseall();\n    umask(23);\n    if (chdir(work_dir) != 0) {\n        fprintf(LOGFILE, \"Can't change directory to %s -%s\\n\", work_dir, strerror((*__errno_location())));\n        goto cleanup;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        exit_code = SETUID_OPER_FAILED;\n        goto cleanup;\n    }\n    if (execlp(task_script_path, task_script_path, ((void *)0)) != 0) {\n        fprintf(LOGFILE, \"Couldn't execute the task jvm file %s - %s\", task_script_path, strerror((*__errno_location())));\n        exit_code = UNABLE_TO_EXECUTE_TASK_SCRIPT;\n        goto cleanup;\n    }\n    exit_code = 0;\n  cleanup:\n    free(task_script_path);\n    return exit_code;\n}\n","function_prediction":"int run_task_as_user(char *task_id, char *task_dir, char *task_jvm_file,\n                     char *task_jvm_file_path, char *task_jvm_file_name) {\n  int ret = 0;\n  int fd = -1;\n  char *task_jvm_file_path_name = NULL;\n\n  ret = create_attempt_directories(task_id, task_dir);\n  if (ret != 0)\n    goto cleanup;\n\n  fd = open_file_as_task_tracker(task_jvm_file_path_name);\n  if (fd == -1)\n    goto cleanup;\n\n  task_jvm_file_path_name = concatenate_constprop_0(\"%s/%s\", \"task launcher\", 2,\n                                                    task_dir, \"taskjvm.sh\");\n  if (task_jvm_file_path_name == NULL) {\n    ret = 18;\n    goto cleanup;\n  }\n\n  ret = copy_file(fd, task_jvm_file_path_name, task_jvm_file_path, 0700);\n  if (ret != 0)\n    goto cleanup;\n\n  fcloseall();\n\n  umask(027);\n\n  ret = chdir(task_dir);\n  if (ret != 0) {\n    fprintf(LOGFILE, \"Can't change directory to %s -%s\\n\", task_dir,\n            strerror(*__errno_location()));\n    goto cleanup;\n  }\n\n  ret = change_user(user_detail[2], user_detail[3]);\n  if (ret != 0)\n    goto cleanup;\n\n  ret = execlp(task_jvm_file_path_name, task_jvm_file_path_name, NULL);\n  if (ret != 0) {\n    fprintf(LOGFILE, \"Couldn't execute the task jvm file %s - %s\",\n            task_jvm_file_path_name, strerror(*__errno_location()));\n    goto cleanup;\n  }\n\n  ret = 6;\n\n  clean","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int signal_user_task(const char *user, int pid, int sig) {\n    if (pid <= 0) {\n        return INVALID_TASK_PID;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return SETUID_OPER_FAILED;\n    }\n    int has_group = 1;\n    if (kill(-pid, 0) < 0) {\n        if (kill(pid, 0) < 0) {\n            if ((*__errno_location()) == 3) {\n                return INVALID_TASK_PID;\n            }\n            fprintf(LOGFILE, \"Error signalling task %d with %d - %s\\n\", pid, sig, strerror((*__errno_location())));\n            return -1;\n        } else {\n            has_group = 0;\n        }\n    }\n    if (kill((has_group ? -1 : 1) * pid, sig) < 0) {\n        if ((*__errno_location()) != 3) {\n            fprintf(LOGFILE, \"Error signalling process group %d with signal %d - %s\\n\", -pid, sig, strerror((*__errno_location())));\n            return UNABLE_TO_KILL_TASK;\n        } else {\n            return INVALID_TASK_PID;\n        }\n    }\n    fprintf(LOGFILE, \"Killing process %s%d with %d\\n\", (has_group ? \"group \" : \"\"), pid, sig);\n    return 0;\n}\n","function_prediction":"int signal_user_task_name_conflict(int argc, int task_id, int signal) {\n  int ret;\n\n  if (task_id <= 0)\n    return 9;\n\n  if (change_user(user_detail[2]))\n    return 6;\n\n  if (kill(-task_id, 0) >= 0)\n    ret = kill(-task_id, signal);\n  else if (kill(task_id, 0) >= 0)\n    ret = kill(task_id, signal);\n  else {\n    if (*__errno_location() == 3)\n      return 9;\n    fprintf(LOGFILE, \"Error signalling task %d with %d - %s\\n\", task_id, signal,\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  if (ret < 0) {\n    if (*__errno_location() == 3)\n      return 9;\n    fprintf(LOGFILE, \"Error signalling process group %d with signal %d - %s\\n\",\n            -task_id, signal, strerror(*__errno_location()));\n    return 8;\n  }\n\n  fprintf(LOGFILE, \"Killing process %s%d with %d\\n\",\n          (kill(-task_id, 0) >= 0) ? \"group \" : \"\", task_id, signal);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int rmdir_as_tasktracker(const char *path) {\n    int user_uid = geteuid();\n    int user_gid = getegid();\n    int ret = change_effective_user(tt_uid, tt_gid);\n    if (ret == 0) {\n        if (rmdir(path) != 0) {\n            fprintf(LOGFILE, \"rmdir of %s failed - %s\\n\", path, strerror((*__errno_location())));\n            ret = -1;\n        }\n    }\n    if (change_effective_user(user_uid, user_gid) != 0) {\n        ret = -1;\n    }\n    return ret;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int delete_path(const char *full_path, int needs_tt_user) {\n    int exit_code = 0;\n    if (full_path == ((void *)0)) {\n        fprintf(LOGFILE, \"Path is null\\n\");\n        exit_code = UNABLE_TO_BUILD_PATH;\n    } else {\n        char *(paths[]) = {strdup(full_path), 0};\n        if (paths[0] == ((void *)0)) {\n            fprintf(LOGFILE, \"Malloc failed in delete_path\\n\");\n            return -1;\n        }\n        if (access(full_path, 0) != 0) {\n            if ((*__errno_location()) == 2) {\n                free(paths[0]);\n                return 0;\n            }\n        }\n        FTS *tree = fts_open(paths, 16 | 64, ((void *)0));\n        FTSENT *entry = ((void *)0);\n        int ret = 0;\n        if (tree == ((void *)0)) {\n            fprintf(LOGFILE, \"Cannot open file traversal structure for the path %s:%s.\\n\", full_path, strerror((*__errno_location())));\n            free(paths[0]);\n            return -1;\n        }\n        while (((entry = fts_read(tree)) != ((void *)0)) && exit_code == 0)\n            {\n                switch (entry->fts_info) {\n                  case 6:\n                    if (!needs_tt_user || strcmp(entry->fts_path, full_path) != 0) {\n                        if (rmdir(entry->fts_accpath) != 0) {\n                            fprintf(LOGFILE, \"Couldn't delete directory %s - %s\\n\", entry->fts_path, strerror((*__errno_location())));\n                            exit_code = -1;\n                        }\n                    }\n                    break;\n                  case 8:\n                  case 12:\n                  case 13:\n                  case 3:\n                    if (unlink(entry->fts_accpath) != 0) {\n                        fprintf(LOGFILE, \"Couldn't delete file %s - %s\\n\", entry->fts_path, strerror((*__errno_location())));\n                        exit_code = -1;\n                    }\n                    break;\n                  case 4:\n                    fprintf(LOGFILE, \"Unreadable directory %s. Skipping..\\n\", entry->fts_path);\n                    break;\n                  case 1:\n                    if ((entry->fts_statp->st_mode & 128) == 0) {\n                        fprintf(LOGFILE, \"Unreadable directory %s, chmoding.\\n\", entry->fts_path);\n                        if (chmod(entry->fts_accpath, 448) != 0) {\n                            fprintf(LOGFILE, \"Error chmoding %s - %s, continuing\\n\", entry->fts_path, strerror((*__errno_location())));\n                        }\n                    }\n                    break;\n                  case 10:\n                    fprintf(LOGFILE, \"Directory not found %s\\n\", entry->fts_path);\n                    break;\n                  case 2:\n                  case 5:\n                  case 11:\n                    break;\n                  case 7:\n                    fprintf(LOGFILE, \"Error traversing directory %s - %s\\n\", entry->fts_path, strerror(entry->fts_errno));\n                    exit_code = -1;\n                    break;\n                    break;\n                  default:\n                    exit_code = -1;\n                    break;\n                }\n            }\n        ret = fts_close(tree);\n        if (exit_code == 0 && ret != 0) {\n            fprintf(LOGFILE, \"Error in fts_close while deleting %s\\n\", full_path);\n            exit_code = -1;\n        }\n        if (needs_tt_user) {\n            exit_code = rmdir_as_tasktracker(full_path);\n        }\n        free(paths[0]);\n    }\n    return exit_code;\n}\n","function_prediction":"int delete_path_name_conflict(char *path, int delete_dir) {\n  FTS *fts;\n  FTSENT *curr;\n  char *paths[2];\n  int ret = 0;\n  int euid, egid;\n\n  if (path == NULL) {\n    fprintf(LOGFILE, \"Path is null\\n\");\n    return 21;\n  }\n\n  paths[0] = strdup(path);\n  paths[1] = NULL;\n\n  if (paths[0] == NULL) {\n    fprintf(LOGFILE, \"Malloc failed in delete_path_name_conflict\\n\");\n    return -1;\n  }\n\n  if (!access(path, 0) || *(__errno_location()) == 2) {\n    free(paths[0]);\n    return 0;\n  }\n\n  fts = fts_open(paths, 0x00000050, NULL);\n  if (fts == NULL) {\n    fprintf(LOGFILE,\n            \"Cannot open file traversal structure for the path %s:%s.\\n\", path,\n            strerror(*__errno_location()));\n    free(paths[0]);\n    return -1;\n  }\n\n  while ((curr = fts_read(fts)) != NULL) {\n    switch (curr->fts_info) {\n    case FTS_D:\n      if (delete_dir && !strcmp(curr->fts_path, path)) {\n        if (rmdir(curr->fts_accpath) != 0) {\n          fprintf(LOGFILE, \"Couldn't delete directory %s - %s\\n\",\n                  curr->fts_path, strerror(*__errno_location()));\n          ret = -1;\n        }\n      } else if (rmdir(curr->fts_accpath) != 0) {\n        fprintf(LOGFILE, \"Couldn't delete directory %s - %s\\n\", curr->fts_path,\n                strerror(*__errno_location()));\n        ret = -1;\n      }\n      break;\n    case","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int delete_as_user(const char *user, const char *good_local_dirs, const char *subdir) {\n    int ret = 0;\n    char **tt_roots = get_mapred_local_dirs(good_local_dirs);\n    char **ptr;\n    if (tt_roots == ((void *)0) || *tt_roots == ((void *)0)) {\n        fprintf(LOGFILE, \"Good mapred local directories could ot be obtained.\\n\");\n        return INVALID_TT_ROOT;\n    }\n    for (ptr = tt_roots; *ptr != ((void *)0); ++ptr) {\n        char *full_path = get_user_subdirectory(*ptr, user, subdir);\n        if (full_path == ((void *)0)) {\n            return -1;\n        }\n        int this_ret = delete_path(full_path, strlen(subdir) == 0);\n        free(full_path);\n        if (this_ret != 0) {\n            ret = this_ret;\n        }\n    }\n    free_values(tt_roots);\n    return ret;\n}\n","function_prediction":"int delete_as_user_name_conflict(char *user_dir_path, char *user_subdirs, char *user_dir) {\n  char *user_subdirs_copy = strdup(user_subdirs);\n  char **user_subdirs_values = extract_values(user_subdirs_copy);\n  if (user_subdirs_values == NULL) {\n    fwrite(\"Good mapred local directories could ot be obtained.\\n\", 1, 52,\n           LOGFILE);\n    return 5;\n  }\n\n  int ret = 0;\n  int i = 0;\n  while (user_subdirs_values[i] != NULL) {\n    char *user_subdir_path =\n        concatenate_constprop_0(\"%s/taskTracker/%s\", \"user_dir_path\", 2,\n                                user_subdirs_values[i], user_dir_path);\n    char *user_subdir_path_full = concatenate_constprop_0(\n        \"%s/%s\", \"user subdir\", 2, user_subdir_path, user_dir);\n    free(user_subdir_path);\n    if (user_subdir_path_full == NULL) {\n      return -1;\n    }\n\n    int ret_i = delete_path(user_subdir_path_full, user_dir[0] == '\\0');\n    free(user_subdir_path_full);\n\n    if (ret_i != 0) {\n      ret = ret_i;\n    }\n\n    i++;\n  }\n\n  free_values(user_subdirs_values);\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int delete_log_directory(const char *subdir, const char *good_local_dirs) {\n    char *job_log_dir = get_job_log_directory(subdir);\n    int ret = -1;\n    if (job_log_dir == ((void *)0))\n        return ret;\n    delete_path(job_log_dir, 1);\n    char **local_dir = get_mapred_local_dirs(good_local_dirs);\n    char **local_dir_ptr;\n    for (local_dir_ptr = local_dir; *local_dir_ptr != ((void *)0); ++local_dir_ptr) {\n        char *mapred_local_log_dir = concatenate(\"%s/userlogs/%s\", \"mapred local job log dir\", 2, *local_dir_ptr, subdir);\n        if (mapred_local_log_dir != ((void *)0)) {\n            delete_path(mapred_local_log_dir, 1);\n            free(mapred_local_log_dir);\n        } else\n            fprintf(LOGFILE, \"Failed to delete mapred local log dir for jobid %s\\n\", subdir);\n    }\n    free(job_log_dir);\n    free_values(local_dir);\n    return 0;\n}\n","function_prediction":"int delete_log_directory_name_conflict(char *jobid, char *job_tracker_host) {\n  char *job_log_dir = NULL;\n  char *mapred_local_log_dir = NULL;\n  char *mapred_local_job_log_dir = NULL;\n  char *job_tracker_host_copy = NULL;\n  char **values = NULL;\n  char **p = NULL;\n\n  job_log_dir = get_value(\"hadoop.log.dir\");\n  if (job_log_dir == NULL) {\n    fprintf(LOGFILE, \"Log directory %s is not configured.\\n\", \"hadoop.log.dir\");\n    return -1;\n  }\n\n  mapred_local_job_log_dir = concatenate_constprop_0(\n      \"%s/userlogs/%s\", \"job log dir\", 2, job_log_dir, jobid);\n  if (mapred_local_job_log_dir == NULL) {\n    fprintf(LOGFILE,\n            \"failed to get memory in get_job_log_directory for %s and %s\\n\",\n            job_log_dir, jobid);\n    free(job_log_dir);\n    return -1;\n  }\n  free(job_log_dir);\n\n  delete_path(mapred_local_job_log_dir, 1);\n\n  job_tracker_host_copy = strdup(job_tracker_host);\n  values = extract_values(job_tracker_host_copy);\n\n  for (p = values; *p != NULL; p++) {\n    mapred_local_log_dir = concatenate_constprop_0(\n        \"%s/userlogs/%s\", \"mapred local job log dir\", 2, *p, jobid);\n    if (mapred_local_log_dir == NULL) {\n      fprintf(LOGFILE, \"Failed to delete mapred local log dir for jobid %s\\n\",\n              jobid);\n      continue;\n    }\n    delete_path(mapred_local_log_dir, 1);\n    free(mapred_local_log_dir);\n  }\n\n  free(mapred_local_job_log_dir);\n free_values(values","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"int run_command_as_user(const char *user, char *const *args) {\n    if (user == ((void *)0)) {\n        fprintf(LOGFILE, \"The user passed is null.\\n\");\n        return INVALID_ARGUMENT_NUMBER;\n    }\n    if (change_user(user_detail->pw_uid, user_detail->pw_gid) != 0) {\n        return -1;\n    }\n    execvp(args[0], args);\n    fprintf(LOGFILE, \"Failure to exec command - %s\\n\", strerror((*__errno_location())));\n    return -1;\n}\n","function_prediction":"int run_command_as_user_name_conflict(user_t *user, char **argv) {\n  if (user == NULL) {\n    fprintf(LOGFILE, \"The user passed is null.\\n\");\n    return 1;\n  }\n\n  if (!change_user(user_detail[2], user_detail[3])) {\n    execvp(argv[0], argv);\n    fprintf(LOGFILE, \"Failure to exec command - %s\\n\",\n            strerror(*__errno_location()));\n    return -1;\n  }\n\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/task-controller.c"}
{"compilable":0,"function":"static int is_only_root_writable(const char *file) {\n    struct stat file_stat;\n    if (stat(file, &file_stat) != 0) {\n        fprintf(LOGFILE, \"Can't stat file %s - %s\\n\", file, strerror((*__errno_location())));\n        return 0;\n    }\n    if (file_stat.st_uid != 0) {\n        fprintf(LOGFILE, \"File %s must be owned by root, but is owned by %d\\n\", file, file_stat.st_uid);\n        return 0;\n    }\n    if ((file_stat.st_mode & ((128 >> 3) | ((128 >> 3) >> 3))) != 0) {\n        fprintf(LOGFILE, \"File %s must not be world or group writable, but is %03o\\n\", file, file_stat.st_mode & (~61440));\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"int check_configuration_permissions(const char *file_name) {\n    char *dir = strdup(file_name);\n    char *buffer = dir;\n    do {\n        if (!is_only_root_writable(dir)) {\n            free(buffer);\n            return -1;\n        }\n        dir = dirname(dir);\n    } while (strcmp(dir, \"/\") != 0);\n    free(buffer);\n    return 0;\n}\n","function_prediction":"int check_configuration_permissions_name_conflict(const char *path) {\n  char *path_copy = strdup(path);\n  char *path_copy_ptr = path_copy;\n  struct stat statbuf;\n\n  while (1) {\n    if (stat(path_copy_ptr, &statbuf)) {\n      fprintf(LOGFILE, \"Can't stat file %s - %s\\n\", path_copy_ptr,\n              strerror(*__errno_location()));\n      free(path_copy);\n      return -1;\n    }\n\n    if (statbuf.st_uid != 0) {\n      fprintf(LOGFILE, \"File %s must be owned by root, but is owned by %d\\n\",\n              path_copy_ptr, statbuf.st_uid);\n      free(path_copy);\n      return -1;\n    }\n\n    if (statbuf.st_mode & 002 || statbuf.st_mode & 00012) {\n      fprintf(LOGFILE,\n              \"File %s must not be world or group writable, but is %03o\\n\",\n              path_copy_ptr, statbuf.st_mode & 0777);\n      free(path_copy);\n      return -1;\n    }\n\n    path_copy_ptr = dirname(path_copy_ptr);\n    if (path_copy_ptr[0] == '/' && path_copy_ptr[1] == '\\0')\n      break;\n  }\n\n  free(path_copy);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char *get_value(const char *key) {\n    int count;\n    for (count = 0; count < config.size; count++) {\n        if (strcmp(config.confdetails[count]->key, key) == 0) {\n            return strdup(config.confdetails[count]->value);\n        }\n    }\n    return ((void *)0);\n}\n","function_prediction":"char *get_value_name_conflict(char *key) {\n  int i;\n  for (i = 0; i < config.count; i++) {\n    if (!strcmp(config.data[i][0], key))\n      return strdup(config.data[i][1]);\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char **get_values(const char *key) {\n    char *value = get_value(key);\n    return extract_values(value);\n}\n","function_prediction":"void get_values_name_conflict(char *key) {\n  int i;\n  char *value;\n\n  for (i = 0; i < config.count; i++) {\n    if (!strcmp(config.entries[i][0], key)) {\n      value = strdup(config.entries[i][1]);\n      extract_values(value);\n      return;\n    }\n  }\n  extract_values(NULL);\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"char **extract_values(char *value) {\n    char **toPass = ((void *)0);\n    char *tempTok = ((void *)0);\n    char *tempstr = ((void *)0);\n    int size = 0;\n    int toPassSize = 10;\n    if (value != ((void *)0)) {\n        toPass = (char **)malloc(sizeof(char *) * toPassSize);\n        tempTok = strtok_r((char *)value, \",\", &tempstr);\n        while (tempTok != ((void *)0))\n            {\n                toPass[size++] = tempTok;\n                if (size == toPassSize) {\n                    toPassSize += 10;\n                    toPass = (char **)realloc(toPass, (sizeof(char *) * (10 * toPassSize)));\n                }\n                tempTok = strtok_r(((void *)0), \",\", &tempstr);\n            }\n    }\n    if (size > 0) {\n        toPass[size] = ((void *)0);\n    }\n    return toPass;\n}\n","function_prediction":"char **extract_values_name_conflict(char *values) {\n  char **result = NULL;\n  char *saveptr = NULL;\n  char *token = NULL;\n  int i = 0;\n  int max = 10;\n\n  if (values == NULL)\n    return NULL;\n\n  result = malloc(sizeof(char *) * max);\n\n  token = strtok_r(values, \",\", &saveptr);\n  while (token != NULL) {\n    result[i++] = token;\n    if (i == max) {\n      max += 10;\n      result = realloc(result, sizeof(char *) * max);\n    }\n    token = strtok_r(NULL, \",\", &saveptr);\n  }\n  result[i] = NULL;\n\n  return result;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/impl/configuration.c"}
{"compilable":0,"function":"int write_config_file(char *file_name) {\n    FILE *file;\n    file = fopen(file_name, \"w\");\n    if (file == ((void *)0)) {\n        printf(\"Failed to open %s.\\n\", file_name);\n        return 1;\n    }\n    fprintf(file, \"mapred.local.dir=/tmp/test-task-controller/local-1\");\n    int i;\n    for (i = 2; i < 5; ++i) {\n        fprintf(file, \",/tmp/test-task-controller/local-%d\", i);\n    }\n    fprintf(file, \"\\n\");\n    fprintf(file, \"hadoop.log.dir=/tmp/test-task-controller/logs\\n\");\n    fclose(file);\n    return 0;\n}\n","function_prediction":"int write_config_file_name_conflict(char *file_name) {\n  FILE *fp = fopen(file_name, \"w\");\n  if (fp == NULL) {\n    printf(\"Failed to open %s.\\n\", file_name);\n    return 1;\n  }\n\n  fprintf(fp, \"mapred.local.dir=/tmp/test-task-controller/local-1\");\n  fprintf(fp, \",/tmp/test-task-controller/local-%d\", 2);\n  fprintf(fp, \",/tmp/test-task-controller/local-%d\", 3);\n  fprintf(fp, \",/tmp/test-task-controller/local-%d\", 4);\n  fprintf(fp, \"\\n\");\n  fprintf(fp, \"hadoop.log.dir=/tmp/test-task-controller/logs\\n\");\n  fclose(fp);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhaobj_MyHadoop/src/c++/task-controller/test/test-task-controller.c"}
{"compilable":0,"function":"int edgecmp(Fibnode *a, Fibnode *b) {\n    Edge *e, *f;\n    e = (Edge *)a;\n    f = (Edge *)b;\n    if (e->dist < f->dist)\n        return -1;\n    if (e->dist > f->dist)\n        return 1;\n    return 0;\n}\n","function_prediction":"int edgecmp_name_conflict(const void *a, const void *b) {\n  if (((struct edge *)a)->weight > ((struct edge *)b)->weight)\n    return 1;\n  else if (((struct edge *)a)->weight < ((struct edge *)b)->weight)\n    return -1;\n  else\n    return 0;\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/prim.c"}
{"compilable":0,"function":"int prim(int start) {\n    Fibheap pq;\n    Node *n;\n    Edge *e;\n    int primsum;\n    fibinit(&pq, edgecmp);\n    n = nodedata(start);\n    n->intree = 1;\n    primsum = 0;\n    insertedges(&pq, n);\n    while (pq.min != ((void *)0))\n        {\n            e = (Edge *)pq.min;\n            if (fibdeletemin(&pq) < 0)\n                sysfatal(\"deletion failed\");\n            n = e->node;\n            if (n->intree)\n                continue;\n            n->intree = 1;\n            primsum += e->dist;\n            insertedges(&pq, n);\n        }\n    fibfree(&pq);\n    return primsum;\n}\n","function_prediction":"int prim_name_conflict(int start) {\n  int cost = 0;\n  struct node *n, *m, *p, *q, *r, *s;\n  struct fibheap h;\n\n  h.cmp = edgecmp;\n  h.min = NULL;\n  h.n = 0;\n\n  n = &nodes[start];\n  n->mark = 1;\n\n  for (p = n->edges; p; p = p->next) {\n    if (!p->to->mark) {\n      p->mark = 0;\n      p->mark2 = 0;\n      p->prev = p->next = NULL;\n      p->left = p->right = p;\n      if (h.min) {\n        q = h.min->left;\n        q->right = p;\n        p->left = q;\n        h.min->left = p;\n        p->right = q->right;\n        q->right->left = p;\n        if (h.cmp(h.min, p) > 0)\n          h.min = p;\n      } else\n        h.min = p;\n    }\n  }\n\n  while (h.min) {\n    if (fibdeletemin(&h) < 0)\n      sysfatal(\"deletion failed\");\n    n = h.min->key;\n    if (!n->mark) {\n      cost += n->cost;\n      for (p = n->edges; p; p = p->next) {\n        if (!p->to->mark) {\n          p->mark2 = 0;\n          p->mark = 0;\n          p->prev = p->next = NULL;\n          p->left = p->right = p;\n          if (h.min) {\n            q = h.min->left;\n            q->right = p;\n            p->left = q;\n            h.min->left = p;\n            p->right = q->right;\n            q->right->left = p;\n   if (","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/prim.c"}
{"compilable":0,"function":"int intcmp(Fibnode *x, Fibnode *y) {\n    Int *s, *t;\n    s = (Int *)x;\n    t = (Int *)y;\n    if (s->i < t->i)\n        return -1;\n    if (s->i > t->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"int intcmp_name_conflict(const void *a, const void *b) {\n  if (((struct int_node *)a)->val < ((struct int_node *)b)->val)\n    return -1;\n  else if (((struct int_node *)a)->val > ((struct int_node *)b)->val)\n    return 1;\n  else\n    return 0;\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/fibheaptest.c"}
{"compilable":0,"function":"int nodecmp(Fibnode *a, Fibnode *b) {\n    Node *m, *n;\n    m = (Node *)a;\n    n = (Node *)b;\n    if (m->dist < n->dist)\n        return -1;\n    if (m->dist > n->dist)\n        return 1;\n    return 0;\n}\n","function_prediction":"int nodecmp_name_conflict(const void *a, const void *b) {\n  const struct node *na = a;\n  const struct node *nb = b;\n\n  if (na->weight > nb->weight)\n    return 1;\n  if (na->weight < nb->weight)\n    return -1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/dijkstra.c"}
{"compilable":0,"function":"int Intcmp(Avl *a, Avl *b) {\n    Int *ai, *bi;\n    ai = (Int *)a;\n    bi = (Int *)b;\n    if (ai->i < bi->i)\n        return -1;\n    if (ai->i > bi->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"int Intcmp_name_conflict(const void *a, const void *b) {\n  if ((((struct int_s *)a)->val) < (((struct int_s *)b)->val))\n    return -1;\n  else if ((((struct int_s *)a)->val) > (((struct int_s *)b)->val))\n    return 1;\n  else\n    return 0;\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/avltest.c"}
{"compilable":0,"function":"int depth(Avl *n) {\n    int dl, dr, d;\n    if (n == ((void *)0))\n        return 0;\n    dl = depth(n->c[0]);\n    dr = depth(n->c[1]);\n    d = dl > dr ? dl : dr;\n    return d + 1;\n}\n","function_prediction":"int depth_part_0(struct node *node) {\n  int depth = 0;\n  int depth_left = 0;\n  int depth_right = 0;\n\n  if (node->left != NULL) {\n    depth_left = depth_part_0(node->left);\n  }\n  if (node->right != NULL) {\n    depth_right = depth_part_0(node->right);\n  }\n\n  if (depth_left > depth_right) {\n    depth = depth_left + 1;\n  } else {\n    depth = depth_right + 1;\n  }\n\n  return depth;\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/tests/avltest.c"}
{"compilable":0,"function":"int nodecmp(Avl *a, Avl *b) {\n    Node *m, *n;\n    m = (Node *)a;\n    n = (Node *)b;\n    return strcmp(m->key, n->key);\n}\n","function_prediction":"int nodecmp_name_conflict(const void *a, const void *b) {\n  return strcmp(((struct node *)a)->name, ((struct node *)b)->name);\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/doc/avlexample.c"}
{"compilable":0,"function":"int intcmp(Fibnode *x, Fibnode *y) {\n    Int *s, *t;\n    s = (Int *)x;\n    t = (Int *)y;\n    if (s->i < t->i)\n        return -1;\n    if (s->i > t->i)\n        return 1;\n    return 0;\n}\n","function_prediction":"int intcmp_name_conflict(const void *a, const void *b) {\n  if (((struct int_node *)a)->val < ((struct int_node *)b)->val)\n    return -1;\n  else if (((struct int_node *)a)->val > ((struct int_node *)b)->val)\n    return 1;\n  else\n    return 0;\n}","pass":0,"source_file":"C_COMPILE/spewspews_bsp/doc/fibheaptest.c"}
{"compilable":1,"function":"uint32_t pcg32_random_r(pcg32_random_t *rng) {\n    uint64_t oldstate = rng->state;\n    rng->state = oldstate * 6364136223846793005ULL + rng->inc;\n    uint32_t xorshifted = ((oldstate >> 18U) ^ oldstate) >> 27U;\n    uint32_t rot = oldstate >> 59U;\n    return (xorshifted >> rot) | (xorshifted << ((-rot) & 31));\n}\n","function_prediction":"uint32_t pcg32_random_r_name_conflict(pcg32_random_t *rng) {\n  uint64_t oldstate = rng->state;\n  rng->state = oldstate * 6364136223846793005ULL + rng->inc;\n  uint32_t xorshifted = ((oldstate >> 18u) ^ oldstate) >> 27u;\n  uint32_t rot = oldstate >> 59u;\n  return (xorshifted >> rot) | (xorshifted << ((-rot) & 31));\n}","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":0,"function":"uint32_t pcg32_random() {\n    return pcg32_random_r(&pcg32_global);\n}\n","function_prediction":"uint32_t pcg32_random_name_conflict(void) {\n  uint64_t oldstate = pcg32_global;\n  pcg32_global = oldstate * 6364136223846793005ULL + (DAT_00117178);\n  uint32_t xorshifted = ((oldstate >> 18u) ^ oldstate) >> 27u;\n  uint32_t rot = oldstate >> 59u;\n  return (xorshifted >> rot) | (xorshifted << ((-rot) & 31));\n}","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":1,"function":"uint32_t pcg32_boundedrand_r(pcg32_random_t *rng, uint32_t bound) {\n    uint32_t threshold = -bound % bound;\n    for (;;) {\n        uint32_t r = pcg32_random_r(rng);\n        if (r >= threshold)\n            return r % bound;\n    }\n}\n","function_prediction":"uint32_t pcg32_boundedrand_r_name_conflict(pcg32_random_t *rng, uint32_t bound) {\n  uint32_t threshold = -bound % bound;\n  for (;;) {\n    uint32_t r = pcg32_random_r(rng);\n    if (r >= threshold)\n      return r % bound;\n  }\n}","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":0,"function":"uint32_t pcg32_boundedrand(uint32_t bound) {\n    return pcg32_boundedrand_r(&pcg32_global, bound);\n}\n","function_prediction":"uint32_t pcg32_boundedrand_r(pcg32_random_t *rng, uint32_t bound) {\n  uint32_t threshold = -bound % bound;\n\n  for (;;) {\n    uint32_t x = pcg32_random_r(rng);\n    if (x >= threshold)\n      return x % bound;\n  }\n}","pass":0,"source_file":"C_COMPILE/simonhb1990_RACIPE-1.0/pcg_basic.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"const char *get_key_name_name_conflict(int key) {\n  switch (key) {\n  case 0x1b:\n    return \"Escape\";\n  case 0x00561F0002:\n    return \"F1\";\n  case 0x00561F0003:\n    return \"F2\";\n  case 0x00561F0004:\n    return \"F3\";\n  case 0x00561F0005:\n    return \"F4\";\n  case 0x00561F0006:\n    return \"F5\";\n  case 0x00561F0007:\n    return \"F6\";\n  case 0x00561F0008:\n    return \"F7\";\n  case 0x00561F0009:\n    return \"F8\";\n  case 0x00561F000A:\n    return \"F9\";\n  case 0x00561F000B:\n    return \"F10\";\n  case 0x00561F000C:\n    return \"F11\";\n  case 0x00561F000D:\n    return \"F12\";\n  case 0x00561F0026:\n    return \"Up\";\n  case 0x00561F0027:\n    return \"Down\";\n  case 0x00561F0028:\n    return \"Right\";\n  case 0x00561F0029:\n    return \"Left\";\n  case 0x00561F002A:\n    return \"CtrlUp\";\n  case 0x00561F002B:\n    return \"CtrlDown\";\n  case 0x00561F002C:\n    return \"CtrlRight\";\n  case 0x00561F002D:\n    return","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"int decode_regular_key_pressed_name_conflict(void) {\n  int c = getc(stdin);\n  if ((c & 0xf8) == 0xf0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int c3 = getc(stdin);\n    int c4 = getc(stdin);\n    int key = (c & 0x0f) * 0x40000 + (c1 & 0x7f) * 0x1000 + (c2 & 0x7f) * 0x40 +\n              (c3 & 0x7f);\n    if (key < 0x10000)\n      return key;\n    else\n      return -1;\n  } else if ((c & 0xf0) == 0xe0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int key = (c & 0x1f) * 0x1000 + (c1 & 0x7f) * 0x40 + (c2 & 0x7f);\n    if (key < 0x800)\n      return key;\n    else\n      return -1;\n  } else if ((c & 0xe0) == 0xc0) {\n    int c1 = getc(stdin);\n    int key = (c & 0x3f) * 0x40 + (c1 & 0x7f);\n    if (key < 0x80)\n      return key;\n    else\n      return -1;\n  } else if (c >= 0) {\n    return c & 0xff;\n  } else {\n    return -1;\n  }\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"int decode_key_pressed_name_conflict() {\n  int c = getc(stdin);\n\n  if (c == '\\n')\n    return 0x561F002E;\n\n  if (c >= 0 && c <= 27) {\n    switch (c) {\n    case 0:\n      return 0x561F0033;\n    case 8:\n      return 0x561F0031;\n    case 9:\n      return 0x561F0000;\n    case 27:\n      c = getc(stdin);\n      if (c == 'O') {\n        c = getc(stdin);\n        switch (c) {\n        case 'P':\n          return 0x561F0032;\n        case 'Q':\n          return 0x561F0034;\n        case 'R':\n          return 0x561F002F;\n        case 'S':\n          return 0x561F0036;\n        default:\n          return -1;\n        }\n      } else if (c == '[') {\n        c = getc(stdin);\n        switch (c) {\n        case 'A':\n          return 0x561F0026;\n        case 'B':\n          return 0x561F0027;\n        case 'C':\n          return 0x561F0028;\n        case 'D':\n          return 0x561F0029;\n        case 'F':\n          return 0x561F0038;\n        case 'H':\n          return 0x561F0035;\n        case '1':\n          c = getc(stdin);\n          if (c == ';') {\n            c = getc(stdin);\n            if (c == '5') {\n              c = getc(stdin);\n              switch (c) {\n              case '~':\n                return 0x561F00E9;\n              case '","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"int is_special_name_conflict(int c) {\n  return (c < 0x20 || c == 0x7f || c == 0xA0 ||\n          (c >= 0x10000 && (c & 0x56000000) == 0x56000000));\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"const char *get_key_name_name_conflict(int key) {\n  switch (key) {\n  case 0x1b:\n    return \"Escape\";\n  case 0x00561F0002:\n    return \"F1\";\n  case 0x00561F0003:\n    return \"F2\";\n  case 0x00561F0004:\n    return \"F3\";\n  case 0x00561F0005:\n    return \"F4\";\n  case 0x00561F0006:\n    return \"F5\";\n  case 0x00561F0007:\n    return \"F6\";\n  case 0x00561F0008:\n    return \"F7\";\n  case 0x00561F0009:\n    return \"F8\";\n  case 0x00561F000A:\n    return \"F9\";\n  case 0x00561F000B:\n    return \"F10\";\n  case 0x00561F000C:\n    return \"F11\";\n  case 0x00561F000D:\n    return \"F12\";\n  case 0x00561F0026:\n    return \"Shift\";\n  case 0x00561F0027:\n    return \"Ctrl\";\n  case 0x00561F0028:\n    return \"Alt\";\n  case 0x00561F0029:\n    return \"Super\";\n  case 0x00561F002A:\n    return \"CtrlUp\";\n  case 0x00561F002B:\n    return \"CtrlDown\";\n  case 0x00561F002C:\n    return \"CtrlRight\";\n  case 0x00561F002D:\n    return","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"int decode_regular_key_pressed_name_conflict(void) {\n  int c = getc(stdin);\n  if ((c & 0xf8) == 0xf0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int c3 = getc(stdin);\n    int c4 = getc(stdin);\n    int key = (c & 0x0f) * 0x40000 + (c1 & 0x7f) * 0x1000 + (c2 & 0x7f) * 0x40 +\n              (c3 & 0x7f);\n    if (key < 0x10000)\n      return key;\n    else\n      return -1;\n  } else if ((c & 0xf0) == 0xe0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int key = (c & 0x1f) * 0x1000 + (c1 & 0x7f) * 0x40 + (c2 & 0x7f);\n    if (key < 0x800)\n      return key;\n    else\n      return -1;\n  } else if ((c & 0xe0) == 0xc0) {\n    int c1 = getc(stdin);\n    int key = (c & 0x3f) * 0x40 + (c1 & 0x7f);\n    if (key < 0x80)\n      return key;\n    else\n      return -1;\n  } else if (c >= 0) {\n    return c & 0xff;\n  } else {\n    return -1;\n  }\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"int decode_key_pressed_name_conflict(void) {\n  int c = getc(stdin);\n\n  switch (c) {\n  case '\\n':\n    return 0x561F002E;\n  case 0x7F:\n    return 0x561F0030;\n  case 0x08:\n    return 0x561F0031;\n  case 0x09:\n    return 0x561F0000;\n  case 0x1B:\n    switch (getc(stdin)) {\n    case '[':\n      switch (getc(stdin)) {\n      case 'A':\n        return 0x561F0026;\n      case 'B':\n        return 0x561F0027;\n      case 'C':\n        return 0x561F0028;\n      case 'D':\n        return 0x561F0029;\n      case 'F':\n        return 0x561F0038;\n      case 'H':\n        return 0x561F0035;\n      case '8':\n        if (getc(stdin) == '~')\n          return 0x561F0038;\n        break;\n      case '7':\n        if (getc(stdin) == '~')\n          return 0x561F0035;\n        break;\n      case '3':\n        if (getc(stdin) == '~')\n          return 0x561F002F;\n        break;\n      case '5':\n        if (getc(stdin) == '~')\n          return 0x561F0036;\n        break;\n      case '6':\n        if (getc(stdin) == '~')\n          return 0x561F0037;\n        break;\n      case '2':\n        switch (getc(stdin)) {\n        case '~':\n          return 0x561F0034","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"int is_special_name_conflict(int c) {\n  return (c < 0x20 || c == 0x7f || c == 0xA0 ||\n          (c >= 0x10000 && (c & 0x56000000) == 0x56000000));\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"char *search_completion_name_conflict(char *str, int len) {\n  static char line[4096];\n  char *p, *q;\n  int i;\n\n  memsize = len;\n  p = lfind(str, completions, &current_num_completions, 16384, compl_eqcompar);\n  if (p) {\n    q = p + ((((long)p - (long)completions) / 16384) * 16384);\n    len = current_num_completions -\n          ((((long)p - (long)completions) / 16384) * 16384);\n    if (lfind(p, p, &len, 16384, compl_neqcompar) == NULL)\n      q = completions + current_num_completions * 16384;\n    if ((((long)p - (long)completions) / 16384) == current_num_completions - 1)\n      return p + len;\n    for (i = 0; p[i] && p[i] == q[i]; i++)\n      line[i] = p[i];\n    line[i] = 0;\n  }\n  return p ? line : NULL;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"int is_stopkey_name_conflict(int c) {\n  switch (c) {\n  case ' ':\n  case '\\t':\n  case '\\n':\n  case '\\r':\n  case ',':\n  case ';':\n  case '(':\n  case ')':\n  case '[':\n  case ']':\n  case '{':\n  case '}':\n  case '<':\n  case '>':\n  case '=':\n  case '\\'':\n  case '\"':\n  case '`':\n  case '|':\n  case '&':\n  case '^':\n  case '$':\n  case '#':\n  case '~':\n  case '\\\\':\n  case '?':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"char *getline_complete_name_conflict(char *prompt) {\n  int key, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  char *completion;\n  char *cp;\n  char *cp2;\n  char *cp3;\n  char *cp4;\n  char *cp5;\n  char *cp6;\n  char *cp7;\n  char *cp8;\n  char *cp9;\n  char *cp10;\n  char *cp11;\n  char *cp12;\n  char *cp13;\n  char *cp14;\n  char *cp15;\n  char *cp16;\n  char *cp17;\n  char *cp18;\n  char *cp19;\n  char *cp20;\n  char *cp21;\n  char *cp22;\n  char *cp23;\n  char *cp24;\n  char *cp25;\n  char *cp26;\n  char *cp27;\n  char *cp28;\n  char *cp29;\n  char *cp30;\n  char *cp31;\n  char *cp32;\n  char *cp33;\n  char *cp34;\n  char *cp35;\n  char *cp36;\n  char *cp37;\n  char *cp38;\n  char *cp39;\n  char *cp40;\n  char *cp41;\n  char *cp42;\n  char *cp43;\n  char *cp44;\n  char *cp45;\n  char *cp46;\n  char *cp47;\n  char *cp48;\n  char *cp49;\n  char *cp50;\n  char *cp51;\n  char *cp52;\n  char *cp53;\n  char *cp54;\n  char *cp55;\n  char *cp56;\n  char *cp57;\n  char *","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"void init_completions(void) {\n  int i, j;\n\n  qsort(completions, current_num_completions, 1024 * sizeof(char),\n        compl_lesscomp);\n\n  for (i = 0; i < current_num_completions; i++) {\n    for (j = 0; j < 1024; j++) {\n      if (completions[i * 1024 + j] == 0) {\n        current_num_completions++;\n        completions[i * 1024 + j] = 0;\n        return;\n      }\n    }\n    memset(&completions[i * 1024], 0, 1024 * sizeof(char));\n  }\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"int completion_exists_name_conflict(char *str) {\n  int i;\n  char str_copy[4096];\n\n  for (i = 0; i < 4096; i++) {\n    if (str[i] == '\\0') {\n      memsize = i;\n      break;\n    }\n    str_copy[i] = str[i];\n  }\n  str_copy[i] = '\\0';\n\n  if (lfind(str_copy, completions, &current_num_completions, 4096,\n            compl_eqcompar) != NULL)\n    return 1;\n  else\n    return 0;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"const char *get_key_name_name_conflict(int key) {\n  switch (key) {\n  case 0x1b:\n    return \"Escape\";\n  case 0x00561F0002:\n    return \"F1\";\n  case 0x00561F0003:\n    return \"F2\";\n  case 0x00561F0004:\n    return \"F3\";\n  case 0x00561F0005:\n    return \"F4\";\n  case 0x00561F0006:\n    return \"F5\";\n  case 0x00561F0007:\n    return \"F6\";\n  case 0x00561F0008:\n    return \"F7\";\n  case 0x00561F0009:\n    return \"F8\";\n  case 0x00561F000A:\n    return \"F9\";\n  case 0x00561F000B:\n    return \"F10\";\n  case 0x00561F000C:\n    return \"F11\";\n  case 0x00561F000D:\n    return \"F12\";\n  case 0x00561F0026:\n    return \"Shift\";\n  case 0x00561F0027:\n    return \"Ctrl\";\n  case 0x00561F0028:\n    return \"Alt\";\n  case 0x00561F0029:\n    return \"Super\";\n  case 0x00561F002A:\n    return \"CtrlUp\";\n  case 0x00561F002B:\n    return \"CtrlDown\";\n  case 0x00561F002C:\n    return \"CtrlRight\";\n  case 0x00561F002D:\n    return","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"int decode_regular_key_pressed_name_conflict(void) {\n  int c = getc(stdin);\n  if ((c & 0xf8) == 0xf0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int c3 = getc(stdin);\n    int c4 = getc(stdin);\n    int key = (c & 0x0f) * 0x40000 + (c1 & 0x7f) * 0x1000 + (c2 & 0x7f) * 0x40 +\n              (c3 & 0x7f);\n    if (key < 0x10000)\n      return key;\n    else\n      return -1;\n  } else if ((c & 0xf0) == 0xe0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int key = (c & 0x1f) * 0x1000 + (c1 & 0x7f) * 0x40 + (c2 & 0x7f);\n    if (key < 0x800)\n      return key;\n    else\n      return -1;\n  } else if ((c & 0xe0) == 0xc0) {\n    int c1 = getc(stdin);\n    int key = (c & 0x3f) * 0x40 + (c1 & 0x7f);\n    if (key < 0x80)\n      return key;\n    else\n      return -1;\n  } else if (c >= 0) {\n    return c & 0xff;\n  } else {\n    return -1;\n  }\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"int decode_key_pressed_name_conflict(void) {\n  int c = getc(stdin);\n\n  switch (c) {\n  case '\\n':\n    return 0x561F002E;\n  case 0x7F:\n    return 0x561F0030;\n  case 0x08:\n    return 0x561F0031;\n  case 0x09:\n    return 0x561F0000;\n  case 0x1B:\n    switch (getc(stdin)) {\n    case '[':\n      switch (getc(stdin)) {\n      case 'A':\n        return 0x561F0026;\n      case 'B':\n        return 0x561F0027;\n      case 'C':\n        return 0x561F0028;\n      case 'D':\n        return 0x561F0029;\n      case 'F':\n        return 0x561F0038;\n      case 'H':\n        return 0x561F0035;\n      case '8':\n        if (getc(stdin) == '~')\n          return 0x561F0038;\n        break;\n      case '7':\n        if (getc(stdin) == '~')\n          return 0x561F0035;\n        break;\n      case '3':\n        if (getc(stdin) == '~')\n          return 0x561F002F;\n        break;\n      case '5':\n        if (getc(stdin) == '~')\n          return 0x561F0036;\n        break;\n      case '6':\n        if (getc(stdin) == '~')\n          return 0x561F0037;\n        break;\n      case '2':\n        switch (getc(stdin)) {\n        case '~':\n          return 0x561F0034","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"int is_special_name_conflict(int c) {\n  return (c < 0x20 || c == 0x7f || c == 0xA0 ||\n          (c >= 0x10000 && (c & 0x56000000) == 0x56000000));\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"char *search_completion_name_conflict(char *str, int len) {\n  static char line[4096];\n  char *p, *q;\n  int i;\n\n  memsize = len;\n  p = lfind(str, completions, &current_num_completions, 16384, compl_eqcompar);\n  if (p) {\n    q = p + ((((long)p - (long)&completions[0]) / 16384) * 16384);\n    len = current_num_completions -\n          ((((long)p - (long)&completions[0]) / 16384) * 16384);\n    if (p && len)\n      p = lfind(p, p, &len, 16384, compl_neqcompar);\n    if (!p)\n      p = &completions[current_num_completions * 16384];\n    if ((((long)p - (long)&completions[0]) / 16384) ==\n        current_num_completions - 1)\n      return p + len;\n    for (i = 0; p[i]; i++) {\n      if (p[i] != q[i])\n        break;\n      line[i] = p[i];\n    }\n    line[i] = 0;\n  }\n  return line;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"int is_stopkey_name_conflict(int c) {\n  switch (c) {\n  case ' ':\n  case '\\t':\n  case '\\n':\n  case '\\r':\n  case ',':\n  case ';':\n  case '(':\n  case ')':\n  case '[':\n  case ']':\n  case '{':\n  case '}':\n  case '<':\n  case '>':\n  case '=':\n  case '\\'':\n  case '\"':\n  case '`':\n  case '|':\n  case '&':\n  case '^':\n  case '$':\n  case '#':\n  case '~':\n  case '\\\\':\n  case '?':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"char *getline_complete_name_conflict(char *prompt) {\n  int key, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  char *completion;\n  char *cp;\n  char *cp2;\n  char *cp3;\n  char *cp4;\n  char *cp5;\n  char *cp6;\n  char *cp7;\n  char *cp8;\n  char *cp9;\n  char *cp10;\n  char *cp11;\n  char *cp12;\n  char *cp13;\n  char *cp14;\n  char *cp15;\n  char *cp16;\n  char *cp17;\n  char *cp18;\n  char *cp19;\n  char *cp20;\n  char *cp21;\n  char *cp22;\n  char *cp23;\n  char *cp24;\n  char *cp25;\n  char *cp26;\n  char *cp27;\n  char *cp28;\n  char *cp29;\n  char *cp30;\n  char *cp31;\n  char *cp32;\n  char *cp33;\n  char *cp34;\n  char *cp35;\n  char *cp36;\n  char *cp37;\n  char *cp38;\n  char *cp39;\n  char *cp40;\n  char *cp41;\n  char *cp42;\n  char *cp43;\n  char *cp44;\n  char *cp45;\n  char *cp46;\n  char *cp47;\n  char *cp48;\n  char *cp49;\n  char *cp50;\n  char *cp51;\n  char *cp52;\n  char *cp53;\n  char *cp54;\n  char *cp55;\n  char *cp56;\n  char *cp57;\n  char *","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"void init_completions(void) {\n  int i, j;\n\n  qsort(completions, current_num_completions, 1024 * sizeof(char),\n        compl_lesscomp);\n\n  for (i = 0; i < current_num_completions; i++) {\n    for (j = 0; j < 1024; j++) {\n      if (completions[i * 1024 + j] == 0) {\n        current_num_completions++;\n        completions[i * 1024 + j] = 0;\n        return;\n      }\n    }\n    memset(&completions[i * 1024], 0, 1024 * sizeof(char));\n  }\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"int completion_exists_name_conflict(char *str) {\n  int i;\n  char str_copy[4096];\n\n  for (i = 0; i < 4096; i++) {\n    if (str[i] == '\\0') {\n      memsize = i;\n      break;\n    }\n    str_copy[i] = str[i];\n  }\n  str_copy[i] = '\\0';\n\n  if (lfind(str_copy, completions, &current_num_completions, 4096,\n            compl_eqcompar) != NULL)\n    return 1;\n  else\n    return 0;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"const char *get_key_name(int key) {\n    switch (key) {\n      case Enter:\n        return \"Enter\";\n      case Tab:\n        return \"Tab\";\n      case Escape:\n        return \"Escape\";\n      case Delete:\n        return \"Delete\";\n      case Backspace:\n        return \"Backspace\";\n      case CtrlBackspace:\n        return \"CtrlBackspace\";\n      case F1:\n        return \"F1\";\n      case F2:\n        return \"F2\";\n      case F3:\n        return \"F3\";\n      case F4:\n        return \"F4\";\n      case F5:\n        return \"F5\";\n      case F6:\n        return \"F6\";\n      case F7:\n        return \"F7\";\n      case F8:\n        return \"F8\";\n      case F9:\n        return \"F9\";\n      case F10:\n        return \"F10\";\n      case F11:\n        return \"F11\";\n      case F12:\n        return \"F12\";\n      case Left:\n        return \"\\342\\206\\220\";\n      case Up:\n        return \"\\342\\206\\221\";\n      case Right:\n        return \"\\342\\206\\222\";\n      case Down:\n        return \"\\342\\206\\223\";\n      case CtrlUp:\n        return \"CtrlUp\";\n      case CtrlDown:\n        return \"CtrlDown\";\n      case CtrlRight:\n        return \"CtrlRight\";\n      case CtrlLeft:\n        return \"CtrlLeft\";\n      case Insert:\n        return \"Insert\";\n      case Home:\n        return \"Home\";\n      case PageUp:\n        return \"PageUp\";\n      case PageDown:\n        return \"PageDown\";\n      case End:\n        return \"End\";\n      default:\n        return \"unknown\";\n    }\n}\n","function_prediction":"const char *get_key_name_name_conflict(int key) {\n  switch (key) {\n  case 0x1b:\n    return \"Escape\";\n  case 0x00561F0002:\n    return \"F1\";\n  case 0x00561F0003:\n    return \"F2\";\n  case 0x00561F0004:\n    return \"F3\";\n  case 0x00561F0005:\n    return \"F4\";\n  case 0x00561F0006:\n    return \"F5\";\n  case 0x00561F0007:\n    return \"F6\";\n  case 0x00561F0008:\n    return \"F7\";\n  case 0x00561F0009:\n    return \"F8\";\n  case 0x00561F000A:\n    return \"F9\";\n  case 0x00561F000B:\n    return \"F10\";\n  case 0x00561F000C:\n    return \"F11\";\n  case 0x00561F000D:\n    return \"F12\";\n  case 0x00561F0026:\n    return \"Up\";\n  case 0x00561F0027:\n    return \"Down\";\n  case 0x00561F0028:\n    return \"Right\";\n  case 0x00561F0029:\n    return \"Left\";\n  case 0x00561F002A:\n    return \"CtrlUp\";\n  case 0x00561F002B:\n    return \"CtrlDown\";\n  case 0x00561F002C:\n    return \"CtrlRight\";\n  case 0x00561F002D:\n    return","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"int decode_regular_key_pressed() {\n    int result;\n    unsigned char c[4];\n    c[0] = getc(stdin);\n    if ((c[0] & 248) == 240) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[3] = getc(stdin);\n        ;\n        c[0] &= 15;\n        c[1] &= 127;\n        c[2] &= 127;\n        c[3] &= 127;\n        result = c[3] + (((uint32_t)c[2]) << 6) + (((uint32_t)c[1]) << 12) + (((uint32_t)c[0]) << 18);\n        if (result < (1 << 16)) {\n            return -1;\n        }\n    } else if ((c[0] & 240) == 224) {\n        c[1] = getc(stdin);\n        ;\n        c[2] = getc(stdin);\n        ;\n        c[0] &= 31;\n        c[1] &= 127;\n        c[2] &= 127;\n        result = c[2] + (((uint32_t)c[1]) << 6) + (((uint32_t)c[0]) << 12);\n        if (result < (1 << 11)) {\n            return -1;\n        }\n    } else if ((c[0] & 224) == 192) {\n        c[1] = getc(stdin);\n        ;\n        c[0] &= 63;\n        c[1] &= 127;\n        result = c[1] + (((uint32_t)c[0]) << 6);\n        if (result < (1 << 7)) {\n            return -1;\n        }\n    } else {\n        if ((c[0] & 128) == 0) {\n            result = c[0];\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}\n","function_prediction":"int decode_regular_key_pressed_name_conflict(void) {\n  int c = getc(stdin);\n  if ((c & 0xf8) == 0xf0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int c3 = getc(stdin);\n    int c4 = getc(stdin);\n    int key = (c & 0x0f) * 0x40000 + (c1 & 0x7f) * 0x1000 + (c2 & 0x7f) * 0x40 +\n              (c3 & 0x7f);\n    if (key < 0x10000)\n      return key;\n    else\n      return -1;\n  } else if ((c & 0xf0) == 0xe0) {\n    int c1 = getc(stdin);\n    int c2 = getc(stdin);\n    int key = (c & 0x1f) * 0x1000 + (c1 & 0x7f) * 0x40 + (c2 & 0x7f);\n    if (key < 0x800)\n      return key;\n    else\n      return -1;\n  } else if ((c & 0xe0) == 0xc0) {\n    int c1 = getc(stdin);\n    int key = (c & 0x3f) * 0x40 + (c1 & 0x7f);\n    if (key < 0x80)\n      return key;\n    else\n      return -1;\n  } else if (c >= 0) {\n    return c & 0xff;\n  } else {\n    return -1;\n  }\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int decode_key_pressed() {\n    int c = getc(stdin);\n    int d;\n    int c_tmp;\n    if (c == LF)\n        return Enter;\n    if (c == '\\t')\n        return Tab;\n    if (c == 127)\n        return Backspace;\n    if (c == 8)\n        return CtrlBackspace;\n    if (c == (-1) || c == -1) {\n        return EoF;\n    }\n    if (c == 23) {\n        return CtrlW;\n    }\n    if (c == 0) {\n        return CtrlSpace;\n    }\n    if (c != Escape) {\n        ungetc(c, stdin);\n        return decode_regular_key_pressed();\n    }\n    c_tmp = c = getc(stdin);\n    if (c == 'O') {\n        c = getc(stdin);\n        if (c < 'P' || c > 'S')\n            return -1;\n        return F1 + c - 'P';\n    }\n    if (c == '[') {\n        switch (getc(stdin)) {\n          case 'A':\n            return (Up);\n          case 'B':\n            return (Down);\n          case 'C':\n            return (Right);\n          case 'D':\n            return (Left);\n          case '1':\n            c = getc(stdin);\n            d = getc(stdin);\n            if (c == ';' && d == '5') {\n                char e = getc(stdin);\n                switch (e) {\n                  case 'A':\n                    return (CtrlUp);\n                  case 'B':\n                    return (CtrlDown);\n                  case 'C':\n                    return (CtrlRight);\n                  case 'D':\n                    return (CtrlLeft);\n                }\n            }\n            if (d != 126) {\n                return -1;\n            }\n            if (c == '6') {\n                return -1;\n            }\n            if (c > '9') {\n                return -1;\n            }\n            if (c > '6')\n                c--;\n            return (F1 + c - '1');\n          case '2':\n            c = getc(stdin);\n            if (c == '~')\n                return (Insert);\n            if (c == '2')\n                return -1;\n            if (c > '4')\n                return -1;\n            if (c > '2')\n                c--;\n            if (getc(stdin) != 126)\n                return -1;\n            return (F9 + c - '0');\n          case '3':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Delete);\n          case '5':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageUp);\n          case '6':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (PageDown);\n          case '7':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (Home);\n          case '8':\n            d = getc(stdin);\n            if (d != 126) {\n                return -1;\n            }\n            return (End);\n          case 'F':\n            return (End);\n          case 'H':\n            return (Home);\n          default:\n            return -1;\n        }\n    }\n    ungetc(c_tmp, stdin);\n    return (Escape);\n}\n","function_prediction":"int decode_key_pressed_name_conflict(void) {\n  int c = getc(stdin);\n\n  switch (c) {\n  case -1:\n    return 4;\n  case '\\n':\n    return 0x561F002E;\n  case 8:\n    return 0x561F0031;\n  case 9:\n    return 0x561F0000;\n  case 0x1B:\n    c = getc(stdin);\n    if (c == '[') {\n      c = getc(stdin);\n      switch (c) {\n      case 'A':\n        return 0x561F0026;\n      case 'B':\n        return 0x561F0027;\n      case 'C':\n        return 0x561F0028;\n      case 'D':\n        return 0x561F0029;\n      case 'F':\n        return 0x561F0038;\n      case 'H':\n        return 0x561F0035;\n      case '1':\n        c = getc(stdin);\n        if (c == ';') {\n          c = getc(stdin);\n          if (c == '5') {\n            c = getc(stdin);\n            if (c == '~' || c == '6' || c == '7' || c == '8') {\n              return 0x561F00E9 + c;\n            }\n          } else if (c == '~' && c >= '6' && c <= '9') {\n            return 0x561F00D1 + c - '6';\n          }\n        }\n        break;\n      case '2':\n        c = getc(stdin);\n        if (c == '~') {\n          return 0x561F0034;\n        } else if (c != '2' && c != '3' && c != '4') {\n          c = getc(stdin);\n     if (c","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":1,"function":"bool is_special(int key) {\n    return (key < ' ') || ((key & specialMask) == specialMask);\n}\n","function_prediction":"int is_special_name_conflict(int c) {\n  return (c < 0x20 || c == 0x7f || c == 0xA0 ||\n          (c >= 0x10000 && (c & 0x56000000) == 0x56000000));\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/special_keys.c"}
{"compilable":0,"function":"int *search_completion(int *begin, int size) {\n    int *it_begin, *it_end;\n    compute_completion_ranges(begin, size, &it_begin, &it_end);\n    if (!it_begin || !size) {\n        return 0;\n    }\n    size_t num_negative = (it_end - it_begin) / 4096;\n    int *keypart = it_begin;\n    if (((keypart - &completions[0][0]) / 4096 == current_num_completions - 1)) {\n        return keypart + size;\n    } else {\n        int i;\n        static int line[4096];\n        for (i = 0; keypart[i]; ++i) {\n            if (keypart[size + i] != keypart[size + i + 4096 * (num_negative - 1)]) {\n                break;\n            }\n            line[i] = keypart[i + size];\n        }\n        line[i] = 0;\n        return line;\n    }\n}\n","function_prediction":"char *search_completion_name_conflict(char *str, int len) {\n  static char line[4096];\n  char *p, *q;\n  int i;\n\n  memsize = len;\n  p = lfind(str, completions, &current_num_completions, 16384, compl_eqcompar);\n  if (p) {\n    q = lfind(p, p, &(current_num_completions - (p - completions) / 4096),\n              16384, compl_neqcompar);\n    if (!q)\n      q = completions + current_num_completions * 16384;\n    if ((p - completions) / 4096 != current_num_completions - 1) {\n      for (i = 0; p[i] && p[i] == q[i]; i++)\n        line[i] = p[i];\n      line[i] = '\\0';\n    }\n    return p + len;\n  }\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"bool is_stopkey(int c) {\n    return c == '.' || c == '/' || c == '[' || c == ' ';\n}\n","function_prediction":"int is_stopkey_name_conflict(int c) {\n  switch (c) {\n  case ' ':\n  case '\\t':\n  case '\\n':\n  case '\\r':\n  case ',':\n  case ';':\n  case '(':\n  case ')':\n  case '[':\n  case ']':\n  case '{':\n  case '}':\n  case '<':\n  case '>':\n  case '=':\n  case '\\'':\n  case '\"':\n  case '`':\n  case '|':\n  case '&':\n  case '^':\n  case '$':\n  case '#':\n  case '~':\n  case '\\\\':\n  case '?':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':\n  case '!/':","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"char *getline_complete(const char *prompt) {\n    ;\n    memset(line, 0, sizeof (line));\n    gprompt = prompt;\n    static char line_t[4096];\n    sighandler_t def_handler = signal(2, sighandler);\n    int current_history_entry = last_history_entry + 1;\n    int c, i;\n    line_len = 0;\n    cursorpos = 0;\n    int cons_tabs = 0;\n    if (current_history_entry >= 200)\n        current_history_entry = 0;\n    echo_disable();\n    printf(\"\\033[4h\");\n    print_prompt(prompt);\n    ;\n    while (1)\n        {\n            c = decode_key_pressed();\n            ;\n            if (c == -1) {\n                puts(\"\\nInvalid input sequence!\");\n                break;\n            }\n            if (!is_special(c)) {\n                putc_utf8(c);\n                memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                line[cursorpos] = c;\n                cursorpos++;\n                line_len++;\n                cons_tabs = 0;\n            } else {\n                if (c == CtrlLeft && cursorpos) {\n                    int moves = 0;\n                    do {\n                        cursorpos--;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos);\n                    printf(\"\\033[%dD\", moves);\n                }\n                if (c == CtrlRight && cursorpos < line_len) {\n                    int moves = 0;\n                    do {\n                        cursorpos++;\n                        moves++;\n                    } while (!(is_stopkey(line[cursorpos])) && cursorpos < line_len);\n                    printf(\"\\033[%dC\", moves);\n                }\n                if (c == Left && cursorpos) {\n                    printf(\"\\033[%dD\", 1);\n                    cursorpos--;\n                }\n                if (c == Right && cursorpos < line_len) {\n                    printf(\"\\033[%dC\", 1);\n                    cursorpos++;\n                }\n                if (c == Home) {\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                        cursorpos = 0;\n                    }\n                }\n                if (c == End) {\n                    if (cursorpos != line_len) {\n                        printf(\"\\033[%dC\", line_len - cursorpos);\n                        cursorpos = line_len;\n                    }\n                }\n                if ((c == Backspace && cursorpos) || (c == Delete && cursorpos < line_len)) {\n                    line_len--;\n                    if (c == Backspace) {\n                        cursorpos--;\n                        printf(\"\\033[%dD\", 1);\n                    }\n                    memmove(&line[cursorpos], &line[cursorpos + 1], sizeof(int) * (line_len - cursorpos));\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (c == CtrlW) {\n                    int kill_begin = cursorpos;\n                    int kill_end = cursorpos == line_len ? cursorpos : cursorpos + 1;\n                    while (!(is_stopkey(line[kill_begin])) && kill_begin)\n                        {\n                            kill_begin--;\n                        }\n                    while (!(is_stopkey(line[kill_end])) && kill_end < line_len)\n                        {\n                            kill_end++;\n                        }\n                    memmove(&line[kill_begin], &line[kill_end], sizeof(int) * (line_len - kill_end));\n                    if (cursorpos > kill_begin) {\n                        printf(\"\\033[%dD\", cursorpos - kill_begin);\n                        cursorpos = kill_begin;\n                    }\n                    line_len -= kill_end - kill_begin;\n                    printf(\"\\033[K\");\n                    if (cursorpos != line_len) {\n                        for (i = cursorpos; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                    }\n                }\n                if (total_history_entries && (c == Up || c == Down)) {\n                    if (c == Up)\n                        current_history_entry--;\n                    if (c == Down)\n                        current_history_entry++;\n                    if ((int)(current_history_entry) >= (int)(total_history_entries)) {\n                        current_history_entry = 0;\n                    }\n                    if ((int)(current_history_entry) < 0) {\n                        current_history_entry = total_history_entries - 1;\n                    }\n                    if (cursorpos) {\n                        printf(\"\\033[%dD\", cursorpos);\n                    }\n                    printf(\"\\033[K\");\n                    cursorpos = 0;\n                    line_len = 0;\n                    for (i = 0; history[current_history_entry][i]; ++i) {\n                        putc_utf8(history[current_history_entry][i]);\n                        line[cursorpos] = history[current_history_entry][i];\n                        cursorpos++;\n                        line_len++;\n                    }\n                }\n                if (c == Tab && !cursorpos) {\n                    cons_tabs++;\n                } else if (c == Tab && cursorpos) {\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        {\n                            cplpos--;\n                        }\n                    int *cpl = &line[cplpos];\n                    cpl = search_completion(cpl, cursorpos - cplpos);\n                    if (cpl) {\n                        printf(\"\\033[K\");\n                        for (i = 0; cpl[i]; ++i) {\n                            putc_utf8(cpl[i]);\n                            memmove(&line[cursorpos + 1], &line[cursorpos], sizeof(int) * (line_len - cursorpos));\n                            line[cursorpos] = cpl[i];\n                            cursorpos++;\n                            line_len++;\n                        }\n                        if (cursorpos != line_len) {\n                            for (i = cursorpos; i != line_len; ++i)\n                                putc_utf8(line[i]);\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        }\n                    }\n                    cons_tabs++;\n                } else {\n                    cons_tabs = 0;\n                }\n                if (c == Tab && cons_tabs > 1) {\n                    printf(\"\\033[%dm\", 1);\n                    puts(\"\\npossible completions are:\");\n                    printf(\"\\033[%dm\", 0);\n                    if (!cursorpos) {\n                        print_all_completions(line, 0);\n                        print_prompt(prompt);\n                        for (i = 0; i != line_len; ++i)\n                            putc_utf8(line[i]);\n                        if (line_len != cursorpos)\n                            printf(\"\\033[%dD\", line_len - cursorpos);\n                        ;\n                        continue;\n                    }\n                    int cplpos = cursorpos;\n                    while (line[cplpos - 1] != ' ' && cplpos)\n                        cplpos--;\n                    int *cpl = &line[cplpos];\n                    print_all_completions(cpl, cursorpos - cplpos);\n                    print_prompt(prompt);\n                    for (i = 0; i != line_len; ++i)\n                        putc_utf8(line[i]);\n                    if (line_len != cursorpos)\n                        printf(\"\\033[%dD\", line_len - cursorpos);\n                }\n            }\n            if (c == EoF || c == Enter) {\n                puts(\"\");\n                ;\n                break;\n            }\n            ;\n        }\n    ;\n    printf(\"\\033[4l\");\n    echo_enable();\n    signal(2, def_handler);\n    memset(&line[line_len], 0, sizeof (history[0]) - sizeof(int) * line_len);\n    if (memcmp(line, history[last_history_entry], sizeof (line))) {\n        last_history_entry++;\n        if (last_history_entry == 200) {\n            last_history_entry = 0;\n        }\n        if (total_history_entries < last_history_entry + 1) {\n            total_history_entries = last_history_entry + 1;\n        }\n        memset(history[last_history_entry], 0, sizeof (history[0]));\n        memcpy(history[last_history_entry], line, line_len * 4);\n    }\n    if (!line_len && c == EoF) {\n        signal(2, def_handler);\n        gprompt = 0;\n        ;\n        return 0;\n    }\n    gprompt = 0;\n    trans_utf8(line_t, line);\n    ;\n    return line_t;\n}\n","function_prediction":"char *getline_complete_name_conflict(char *prompt) {\n  int key, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  char *completion;\n  char *cp;\n  char *cp2;\n  char *cp3;\n  char *cp4;\n  char *cp5;\n  char *cp6;\n  char *cp7;\n  char *cp8;\n  char *cp9;\n  char *cp10;\n  char *cp11;\n  char *cp12;\n  char *cp13;\n  char *cp14;\n  char *cp15;\n  char *cp16;\n  char *cp17;\n  char *cp18;\n  char *cp19;\n  char *cp20;\n  char *cp21;\n  char *cp22;\n  char *cp23;\n  char *cp24;\n  char *cp25;\n  char *cp26;\n  char *cp27;\n  char *cp28;\n  char *cp29;\n  char *cp30;\n  char *cp31;\n  char *cp32;\n  char *cp33;\n  char *cp34;\n  char *cp35;\n  char *cp36;\n  char *cp37;\n  char *cp38;\n  char *cp39;\n  char *cp40;\n  char *cp41;\n  char *cp42;\n  char *cp43;\n  char *cp44;\n  char *cp45;\n  char *cp46;\n  char *cp47;\n  char *cp48;\n  char *cp49;\n  char *cp50;\n  char *cp51;\n  char *cp52;\n  char *cp53;\n  char *cp54;\n  char *cp55;\n  char *cp56;\n  char *cp57;\n  char *","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"int init_completion(const char *compl) {\n    int i;\n    if (current_num_completions == 2048) {\n        return 1;\n    }\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i >= 4096 - 1) {\n            memset(&completions[current_num_completions][0], 0, sizeof (completions[i]));\n            ;\n            return 1;\n        }\n        completions[current_num_completions][i] = compl[i];\n    }\n    completions[current_num_completions][i] = 0;\n    current_num_completions++;\n    ;\n    return 0;\n}\n","function_prediction":"void init_completions(void) {\n  int i, j;\n\n  qsort(completions, current_num_completions, 1024 * sizeof(char),\n        compl_lesscomp);\n\n  for (i = 0; i < current_num_completions; i++) {\n    for (j = 0; j < 1024; j++) {\n      if (completions[i * 1024 + j] == 0) {\n        current_num_completions++;\n        completions[i * 1024 + j] = 0;\n        return;\n      }\n    }\n    memset(&completions[i * 1024], 0, 1024 * sizeof(char));\n  }\n}","pass":0,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":1,"function":"int completion_exists(const char *compl) {\n    int i;\n    int *it_begin;\n    int tmp[4096];\n    ;\n    for (i = 0; compl[i]; ++i) {\n        if (i == 4096 - 1) {\n            break;\n        }\n        tmp[i] = compl[i];\n    }\n    tmp[i] = 0;\n    memsize = i;\n    it_begin = (int *)(lfind(tmp, completions, &current_num_completions, sizeof (completions[0]), compl_eqcompar));\n    ;\n    return it_begin != ((void *)0);\n}\n","function_prediction":"int completion_exists_name_conflict(char *str) {\n  int i;\n  char str_copy[4096];\n\n  for (i = 0; i < 4096; i++) {\n    if (str[i] == '\\0') {\n      memsize = i;\n      break;\n    }\n    str_copy[i] = str[i];\n  }\n  str_copy[memsize] = '\\0';\n\n  if (lfind(str_copy, completions, &current_num_completions, 4096,\n            compl_eqcompar) != NULL)\n    return 1;\n  else\n    return 0;\n}","pass":1,"source_file":"C_COMPILE/maciek-27_aclib/auto_complete.c"}
{"compilable":0,"function":"static int beenhere(int syms, int len, int left, int mem, int rem) {\n    size_t index;\n    size_t offset;\n    int bit;\n    size_t length;\n    char *vector;\n    index = (((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) + (left >> 1) - 1) * (max - 1) + len - 1);\n    mem -= 1 << root;\n    offset = (mem >> 3) + rem;\n    offset = ((offset * (offset + 1)) >> 1) + rem;\n    bit = 1 << (mem & 7);\n    length = done[index].len;\n    if (offset < length && (done[index].vec[offset] & bit) != 0)\n        return 1;\n    if (length <= offset) {\n        if (length) {\n            do {\n                length <<= 1;\n            } while (length <= offset);\n            vector = realloc(done[index].vec, length);\n            if (vector != ((void *)0))\n                memset(vector + done[index].len, 0, length - done[index].len);\n        } else {\n            length = 1 << (len - root);\n            while (length <= offset)\n                length <<= 1;\n            vector = calloc(length, sizeof(char));\n        }\n        if (vector == ((void *)0)) {\n            fputs(\"abort: unable to allocate enough memory\\n\", stderr);\n            cleanup();\n            exit(1);\n        }\n        done[index].len = length;\n        done[index].vec = vector;\n    }\n    done[index].vec[offset] |= bit;\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/sergiobenrocha2_mgba/src/third-party/zlib/examples/enough.c"}
{"compilable":0,"function":"int unique_chars(char str[]) {\n    char c;\n    int i, j, len = strlen(str);\n    for (i = 0; i < len; i++) {\n        c = str[i];\n        for (j = i + 1; j < len; j++) {\n            if (str[j] == c)\n                return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"int unique_chars2(char *str) {\n  int len = strlen(str);\n  int i, j;\n  int count[26] = {0};\n\n  for (i = 0; i < len; i++) {\n    count[str[i] - 'a']++;\n  }\n\n  for (i = 0; i < 26; i++) {\n    if (count[i] > 1)\n      return 0;\n  }\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/mohangorai_Collection/unique_chars.c"}
{"compilable":0,"function":"int unique_chars2(char str[]) {\n    char freq[26];\n    int i, len = strlen(str);\n    for (i = 0; i < 26; i++)\n        freq[i] = 0;\n    for (i = 0; i < len; i++)\n        freq[tolower(str[i]) - 'a']++;\n    for (i = 0; i < 26; i++)\n        if (freq[i] > 1)\n            return 0;\n    return 1;\n}\n","function_prediction":"bool unique_chars2_name_conflict(char *str) {\n  int len = strlen(str);\n  int char_set[26] = {0};\n  for (int i = 0; i < len; i++) {\n    char_set[str[i] - 'a']++;\n  }\n  for (int i = 0; i < 26; i++) {\n    if (char_set[i] > 1) {\n      return false;\n    }\n  }\n  return true;\n}","pass":0,"source_file":"C_COMPILE/mohangorai_Collection/unique_chars.c"}
{"compilable":1,"function":"int *shuffle(int n) {\n    int *shuffled = (int *)calloc(n, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        shuffled[i] = i;\n    }\n    int temp;\n    for (int i = n - 1; i >= 0; i--) {\n        int pos = rand() % (i + 1);\n        temp = shuffled[i];\n        shuffled[i] = shuffled[pos];\n        shuffled[pos] = temp;\n    }\n    return shuffled;\n}\n","function_prediction":"int *shuffle_name_conflict(int n) {\n  int *a, t, i;\n\n  a = (int *)calloc(n, sizeof(int));\n  for (i = 0; i < n; i++)\n    a[i] = i;\n  for (i = n - 1; i >= 0; i--) {\n    t = a[i];\n    a[i] = a[rand() % (i + 1)];\n    a[rand() % (i + 1)] = t;\n  }\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":1,"function":"int check_prefix(const char *prefix, const char *str) {\n    return strncmp(prefix, str, strlen(prefix)) == 0;\n}\n","function_prediction":"int check_prefix_name_conflict(const char *prefix, const char *str) {\n  return !strncmp(prefix, str, strlen(prefix));\n}","pass":1,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":0,"function":"int read_labels(int **vector, int out_instances, int out_nodes, char *filename) {\n    FILE *labelset = fopen(filename, \"r\");\n    int bufflen = 20;\n    char *line = (char *)calloc(bufflen, sizeof(char));\n    int i = 0;\n    int min = 2147483647;\n    int max = (-2147483647 - 1);\n    while (fgets(line, bufflen, labelset))\n        {\n            (*vector)[i] = atoi(line);\n            if ((*vector)[i] < min)\n                min = (*vector)[i];\n            if ((*vector)[i] > max)\n                max = (*vector)[i];\n            i++;\n            if (i > out_instances) {\n                fprintf(stderr, \"ERROR: Too few allocated out rows!\\n\");\n                exit(1);\n            }\n        }\n    if (pow(2., out_nodes) < (max - min)) {\n        fprintf(stderr, \"ERROR: Too few nodes to represent the outputs!\\n\");\n        exit(1);\n    }\n    if (min != 0) {\n        for (int i = 0; i < out_instances; i++)\n            (*vector)[i] -= min;\n    }\n    free(line);\n    fclose(labelset);\n    return min;\n}\n","function_prediction":"int read_labels_name_conflict(struct data *d, int out_rows, int out_cols, char *filename) {\n\n  FILE *fp;\n  char *line;\n  int i, min, max;\n\n  min = 2147483647;\n  max = -2147483648;\n\n  fp = fopen(filename, \"r\");\n  line = (char *)calloc(20, sizeof(char));\n\n  i = 0;\n  while (fgets(line, 20, fp) != NULL) {\n    d->out[i] = (int)strtol(line, NULL, 10);\n    if (d->out[i] < min) {\n      min = d->out[i];\n    }\n    if (d->out[i] > max) {\n      max = d->out[i];\n    }\n    i++;\n    if (i > out_rows) {\n      fprintf(stderr, \"ERROR: Too few allocated out rows!\\n\");\n      exit(1);\n    }\n  }\n\n  if (pow(2, out_cols) < (max - min)) {\n    fprintf(stderr, \"ERROR: Too few nodes to represent the outputs!\\n\");\n    exit(1);\n  }\n\n  if (min != 0) {\n    for (i = 0; i < out_rows; i++) {\n      d->out[i] -= min;\n    }\n  }\n\n  free(line);\n  fclose(fp);\n\n  return min;\n}","pass":0,"source_file":"C_COMPILE/jeevangelista_NeuralNetwork/NeuralNet.c"}
{"compilable":1,"function":"char *remove_whitespace(char *str) {\n    char *end;\n    while (((*__ctype_b_loc())[(int)((*str))] & (unsigned short)_ISspace))\n        str++;\n    if (*str == 0)\n        return str;\n    end = str + strlen(str) - 1;\n    while (end > str && ((*__ctype_b_loc())[(int)((*end))] & (unsigned short)_ISspace))\n        end--;\n    *(end + 1) = 0;\n    return str;\n}\n","function_prediction":"char *remove_whitespace_name_conflict(char *str) {\n  const unsigned char *map = __ctype_b_loc();\n  char *end;\n\n  while (map[(unsigned char)*str] & (0x20))\n    str++;\n\n  if (*str == '\\0')\n    return str;\n\n  end = str + strlen(str) - 1;\n  while (end > str && (map[(unsigned char)*end] & (0x20)))\n    end--;\n\n  *++end = '\\0';\n\n  return str;\n}","pass":1,"source_file":"C_COMPILE/kevinvandervlist_kesh/tokenize.c"}
{"compilable":0,"function":"int p(z)\n    int z;\n {\n    putchar(\"UniBwM\"[z % 6]);\n}\n","function_prediction":"void p_name_conflict(int i) {\n  char *s = \"UniBwM\";\n  p_name_conflictutchar(s[i % 6]);\n}","pass":0,"source_file":"C_COMPILE/florianl_stander/stander.c"}
{"compilable":0,"function":"unsigned int get_baud(unsigned int baud_rate) {\n    unsigned int BAUD = 0;\n    switch (baud_rate) {\n      case 921600:\n        BAUD = 4103;\n        break;\n      case 460800:\n        BAUD = 4100;\n        break;\n      case 230400:\n        BAUD = 4099;\n        break;\n      case 115200:\n        BAUD = 4098;\n        break;\n      default:\n        printf(\"Baud rate not recognized, using default B57600\\n\");\n      case 57600:\n        BAUD = 4097;\n        break;\n      case 38400:\n        BAUD = 15;\n        break;\n      case 19200:\n        BAUD = 14;\n        break;\n      case 9600:\n        BAUD = 13;\n        break;\n      case 4800:\n        BAUD = 12;\n        break;\n      case 2400:\n        BAUD = 11;\n        break;\n      case 1800:\n        BAUD = 10;\n        break;\n      case 1200:\n        BAUD = 9;\n        break;\n      case 600:\n        BAUD = 8;\n        break;\n      case 300:\n        BAUD = 7;\n        break;\n      case 200:\n        BAUD = 6;\n        break;\n      case 150:\n        BAUD = 5;\n        break;\n      case 134:\n        BAUD = 4;\n        break;\n      case 110:\n        BAUD = 3;\n        break;\n      case 75:\n        BAUD = 2;\n        break;\n      case 50:\n        BAUD = 1;\n        break;\n    }\n    return BAUD;\n}\n","function_prediction":"int get_baud_name_conflict(int baud) {\n  switch (baud) {\n  case 50:\n    return 1;\n  case 75:\n    return 2;\n  case 110:\n    return 3;\n  case 134:\n    return 4;\n  case 150:\n    return 5;\n  case 200:\n    return 6;\n  case 300:\n    return 7;\n  case 600:\n    return 8;\n  case 1200:\n    return 9;\n  case 1800:\n    return 10;\n  case 2400:\n    return 11;\n  case 4800:\n    return 12;\n  case 9600:\n    return 13;\n  case 19200:\n    return 14;\n  case 38400:\n    return 15;\n  case 57600:\n    return 16;\n  case 115200:\n    return 17;\n  case 230400:\n    return 18;\n  case 460800:\n    return 19;\n  case 921600:\n    return 20;\n  case 1843200:\n    return 21;\n  case 3686400:\n    return 22;\n  case 5000000:\n    return 23;\n  case 5760000:\n    return 24;\n  case 9216000:\n    return 25;\n  case 10000000:\n    return 26;\n  case 11520000:\n    return 27;\n  case 15000000:\n    return 28;\n  case 20000000:\n    return 29;\n  case 25000000:\n    return 30;\n  case 30000000:\n    return","pass":0,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":0,"function":"int serial_init(char *port_name, unsigned int baud) {\n    struct termios orig_termios, cur_termios;\n    int br = get_baud(baud);\n    fd = open(port_name, 2 | 256 | 2048);\n    if (fd == -1) {\n        printf(\"opening modem serial device : fd < 0\\n\");\n        return -1;\n    }\n    if (tcgetattr(fd, &orig_termios)) {\n        printf(\"getting modem serial device attr\\n\");\n        return -2;\n    }\n    cur_termios = orig_termios;\n    cur_termios.c_iflag &= ~(1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 1024 | 2048 | 4096 | 8192);\n    cur_termios.c_iflag |= 2;\n    cur_termios.c_oflag &= ~(1 | 4 | 8 | 16 | 32);\n    cur_termios.c_cflag &= ~(48 | 64 | 128 | 256 | 512 | 1024 | 2048);\n    cur_termios.c_cflag |= 128 | 48 | 2048;\n    cur_termios.c_cflag &= ~(2147483648U);\n    cur_termios.c_lflag &= ~(1 | 2 | 32768 | 8 | 4096 | 16384);\n    cur_termios.c_lflag |= 128;\n    if (cfsetspeed(&cur_termios, br)) {\n        printf(\"setting modem serial device speed\\n\");\n        return -3;\n    }\n    if (tcsetattr(fd, 1, &cur_termios)) {\n        printf(\"setting modem serial device attr\\n\");\n        return -4;\n    }\n    return 0;\n}\n","function_prediction":"int serial_init_name_conflict(char *device, int baud) {\n  struct termios tty;\n  struct termios tty_old;\n  int baudrate = get_baud(baud);\n\n  fd = open(device, O_RDWR | O_NOCTTY | O_NDELAY);\n  if (fd == -1) {\n    printf(\"opening modem serial device : fd < 0\\n\");\n    return -1;\n  }\n\n  if (tcgetattr(fd, &tty) != 0) {\n    printf(\"getting modem serial device attr\\n\");\n    return -2;\n  }\n\n  tty_old = tty;\n\n  tty.c_cflag &= ~PARENB;\n  tty.c_cflag &= ~CSTOPB;\n  tty.c_cflag &= ~CSIZE;\n  tty.c_cflag |= CS8;\n\n  tty.c_cflag &= ~CRTSCTS;\n  tty.c_cflag |= CREAD | CLOCAL;\n  tty.c_cflag &= ~HUPCL;\n\n  tty.c_iflag &= ~(IXON | IXOFF | IXANY);\n  tty.c_iflag &= ~(ICANON | ECHO | ECHOE | ISIG);\n\n  tty.c_oflag &= ~OPOST;\n\n  tty.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG | IEXTEN);\n\n  tty.c_cc[VTIME] = 1;\n  tty.c_cc[VMIN] = 0;\n\n  tty.c_cflag &= ~CBAUD;\n  tty.c_cflag |= BOTHER;\n\n  if (cfsetspeed(&tty, baudrate) != 0) {\n    printf(\"setting modem serial device speed\\n\");\n    return -3;\n  }\n\n  if (tcsetattr(fd, TCSANOW, &tty) != 0) {\n    printf(\"setting modem serial device attr\\n\");\n    return -4;\n  }\n\n  return","pass":0,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":0,"function":"bool in_download_range(int download_id) {\n    if (download_id <= log_index.last_completed_log && download_id > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","function_prediction":"int in_download_range_name_conflict(int index) {\n  return (index <= log_index[1] && index > 0);\n}","pass":0,"source_file":"C_COMPILE/tcunis_paparazzi/sw/logalizer/sdlogger_download.c"}
{"compilable":1,"function":"char *uri_decode(char *uri) {\n    int i = 0;\n    int ptr = 0;\n    char *command;\n    char hexa[3];\n    char code;\n    command = (char *)malloc(strlen(uri));\n    for (i = 0; i < strlen(uri); i++) {\n        switch (*(uri + i)) {\n          case '+':\n            *(command + ptr) = ' ';\n            ptr++;\n            break;\n          case '%':\n            sprintf(hexa, \"%c%c\\000\", *(uri + i + 1), *(uri + i + 2));\n            i += 2;\n            sscanf(hexa, \"%x\", &code);\n            *(command + ptr) = code;\n            ptr++;\n            break;\n          default:\n            *(command + ptr) = *(uri + i);\n            ptr++;\n            break;\n        }\n    }\n    *(command + ptr) = '\\x00';\n    return command;\n}\n","function_prediction":"char *uri_decode_name_conflict(char *str) {\n  char *pstr = malloc(strlen(str));\n  char *pstr_tmp = pstr;\n  char tmp[3];\n  char ch;\n  int i;\n\n  for (i = 0; i < strlen(str); i++) {\n    if (str[i] == '%') {\n      sprintf(tmp, \"%c%c\", str[i + 1], str[i + 2]);\n      __isoc99_sscanf(tmp, \"%x\", &ch);\n      i += 2;\n    } else if (str[i] == '+') {\n      ch = ' ';\n    } else {\n      ch = str[i];\n    }\n    *pstr++ = ch;\n  }\n  *pstr = '\\0';\n  return pstr_tmp;\n}","pass":1,"source_file":"C_COMPILE/certego_webshell/fuzzdb-webshell/c/cmd.c"}
{"compilable":1,"function":"char *uri_decode(char *uri) {\n    int i = 0;\n    int ptr = 0;\n    char *command;\n    char hexa[3];\n    char code;\n    command = (char *)malloc(strlen(uri));\n    for (i = 0; i < strlen(uri); i++) {\n        switch (*(uri + i)) {\n          case '+':\n            *(command + ptr) = ' ';\n            ptr++;\n            break;\n          case '%':\n            sprintf(hexa, \"%c%c\\000\", *(uri + i + 1), *(uri + i + 2));\n            i += 2;\n            sscanf(hexa, \"%x\", &code);\n            *(command + ptr) = code;\n            ptr++;\n            break;\n          default:\n            *(command + ptr) = *(uri + i);\n            ptr++;\n            break;\n        }\n    }\n    *(command + ptr) = '\\x00';\n    return command;\n}\n","function_prediction":"char *uri_decode_name_conflict(char *str) {\n  char *pstr = malloc(strlen(str));\n  char *pstr_tmp = pstr;\n  char tmp[3];\n  char ch;\n  int i;\n\n  for (i = 0; i < strlen(str); i++) {\n    if (str[i] == '%') {\n      sprintf(tmp, \"%c%c\", str[i + 1], str[i + 2]);\n      __isoc99_sscanf(tmp, \"%x\", &ch);\n      i += 2;\n    } else if (str[i] == '+') {\n      ch = ' ';\n    } else {\n      ch = str[i];\n    }\n    *pstr++ = ch;\n  }\n  *pstr = '\\0';\n  return pstr_tmp;\n}","pass":1,"source_file":"C_COMPILE/certego_webshell/web-malware-collection-13-06-2012/Other/cmd.c"}
{"compilable":1,"function":"static int isAlphanum(int c) {\n    return ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$' || c == '\\\\' || c > 126);\n}\n","function_prediction":"int isAlphanum_name_conflict(int c) {\n  return (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') ||\n         (c >= '$' && c <= ';') || (c == '\\\\') || (c >= '~');\n}","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":0,"function":"static int get() {\n    int c = theLookahead;\n    theLookahead = (-1);\n    if (c == (-1)) {\n        c = getc(stdin);\n    }\n    if (c >= ' ' || c == '\\n' || c == (-1)) {\n        return c;\n    }\n    if (c == '\\r') {\n        return '\\n';\n    }\n    return ' ';\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":0,"function":"static int peek() {\n    theLookahead = get();\n    return theLookahead;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":0,"function":"static int next() {\n    int c = get();\n    if (c == '/') {\n        switch (peek()) {\n          case '/':\n            for (;;) {\n                c = get();\n                if (c <= '\\n') {\n                    return c;\n                }\n            }\n          case '*':\n            get();\n            for (;;) {\n                switch (get()) {\n                  case '*':\n                    if (peek() == '/') {\n                        get();\n                        return ' ';\n                    }\n                    break;\n                  case (-1):\n                    fprintf(stderr, \"Error: JSMIN Unterminated comment.\\n\");\n                    exit(1);\n                }\n            }\n          default:\n            return c;\n        }\n    }\n    return c;\n}\n","function_prediction":"int next_name_conflict() {\n  int c;\n  if (theLookahead != -1) {\n    c = theLookahead;\n    theLookahead = -1;\n    if (c == ' ' || c == '\\n' || c == '\\r' || c == -1) {\n      return c;\n    }\n    if (c == '/') {\n      theLookahead = -1;\n      return c;\n    }\n    theLookahead = -1;\n    return ' ';\n  }\n  c = getc(stdin);\n  if (c == ' ' || c == '\\n' || c == '\\r' || c == -1) {\n    return c;\n  }\n  if (c == '/') {\n    theLookahead = getc(stdin);\n    if (theLookahead == -1 || theLookahead == '\\n' || theLookahead == '\\r' ||\n        theLookahead == ' ') {\n      theLookahead = -1;\n      return '/';\n    }\n    if (theLookahead == '*') {\n      theLookahead = -1;\n      while (1) {\n        while (1) {\n          if (theLookahead != -1) {\n            break;\n          }\n          theLookahead = getc(stdin);\n          if (theLookahead == -1 || theLookahead == '\\n' ||\n              theLookahead == '\\r' || theLookahead == ' ') {\n            break;\n          }\n        }\n        if (theLookahead == -1) {\n          continue;\n        }\n        theLookahead = -1;\n        while (theLookahead == -1 && (theLookahead = getc(stdin)) != -1 &&\n               theLookahead != '\\n' && theLookahead != '\\r' &&\n               theLookahead != ' ') {\n        }\n        if (theLookahead == '*') {\n          theLookahead = -1;\n          break;\n        }\n        theLookahead = -1;\n      }\n      if (theLookahead == -","pass":0,"source_file":"C_COMPILE/TrashTeam-hackaton_truc/public/js/lib/OpenLayers/tools/jsmin.c"}
{"compilable":1,"function":"int readNlSock(int sockFd, char *bufPtr, size_t buf_size, int seqNum, int pId) {\n    struct nlmsghdr *nlHdr;\n    int readLen = 0, msgLen = 0;\n    do {\n        if ((readLen = recv(sockFd, bufPtr, buf_size - msgLen, 0)) < 0) {\n            perror(\"SOCK READ: \");\n            return -1;\n        }\n        nlHdr = (struct nlmsghdr *)bufPtr;\n        if ((((readLen) >= (int)sizeof(struct nlmsghdr) && (nlHdr)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlHdr)->nlmsg_len <= (readLen)) == 0) || (nlHdr->nlmsg_type == 2)) {\n            perror(\"Error in recieved packet\");\n            return -1;\n        }\n        if (nlHdr->nlmsg_type == 3) {\n            break;\n        } else {\n            bufPtr += readLen;\n            msgLen += readLen;\n        }\n        if ((nlHdr->nlmsg_flags & 2) == 0) {\n            break;\n        }\n    } while ((nlHdr->nlmsg_seq != seqNum) || (nlHdr->nlmsg_pid != pId));\n    return msgLen;\n}\n","function_prediction":"int readNlSock_name_conflict(int sock, char *buf, size_t len, int pid, int seq) {\n  int rcvd = 0;\n  int total = 0;\n\n  while (1) {\n    if ((rcvd = recv(sock, buf, len - total, 0)) < 0) {\n      perror(\"SOCK READ: \");\n      return -1;\n    }\n\n    if (rcvd < 16 || *(int *)buf < 16 || rcvd < *(int *)buf ||\n        *(short *)(buf + 2) == 2) {\n      perror(\"Error in recieved packet\");\n      return -1;\n    }\n\n    if (*(short *)(buf + 2) == 3)\n      return total;\n\n    total += rcvd;\n\n    if (!(*(char *)(buf + 6) & 2))\n      return total;\n\n    if (*(int *)buf == pid && *(short *)(buf + 4) == seq)\n      return total;\n\n    buf += rcvd;\n  }\n}","pass":1,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":0,"function":"int parseRoutes(struct nlmsghdr *nlHdr, struct route_info *rtInfo) {\n    struct rtmsg *rtMsg;\n    struct rtattr *rtAttr;\n    int rtLen;\n    rtMsg = (struct rtmsg *)((void *)(((char *)nlHdr) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    if ((rtMsg->rtm_family != 2) || (rtMsg->rtm_table != RT_TABLE_MAIN))\n        return -1;\n    rtAttr = (struct rtattr *)((struct rtattr *)(((char *)(rtMsg)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1))));\n    rtLen = ((nlHdr)->nlmsg_len - ((((((sizeof(struct rtmsg))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    for (; ((rtLen) >= (int)sizeof(struct rtattr) && (rtAttr)->rta_len >= sizeof(struct rtattr) && (rtAttr)->rta_len <= (rtLen)); rtAttr = ((rtLen) -= ((((rtAttr)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rtAttr)) + ((((rtAttr)->rta_len) + 4U - 1) & ~(4U - 1))))) {\n        switch (rtAttr->rta_type) {\n          case RTA_OIF:\n            if_indextoname(*(int *)((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), rtInfo->ifName);\n            break;\n          case RTA_GATEWAY:\n            memcpy(&rtInfo->gateWay, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->gateWay));\n            break;\n          case RTA_PREFSRC:\n            memcpy(&rtInfo->srcAddr, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->srcAddr));\n            break;\n          case RTA_DST:\n            memcpy(&rtInfo->dstAddr, ((void *)(((char *)(rtAttr)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))), sizeof (rtInfo->dstAddr));\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int parseRoutes_name_conflict(unsigned char *buf, struct route *route) {\n  struct rt_msghdr *rtm;\n  struct rt_entry *rt;\n  int len;\n  int rt_len;\n\n  if (buf[2] != 2 || buf[3] != 0xfe)\n    return -1;\n\n  len = buf[1] - sizeof(struct rt_msghdr);\n  rtm = (struct rt_msghdr *)(buf + sizeof(struct rt_msghdr));\n\n  while (len > 3) {\n    rt_len = rtm->rt_len;\n    if (rt_len < 4 || rt_len > len)\n      break;\n\n    rt = (struct rt_entry *)rtm;\n    switch (rt->rt_type) {\n    case 1:\n      route->rt_flags = rt->rt_flags;\n      break;\n    case 4:\n      if_indextoname(rt->rt_ifscope, &route->rt_ifname);\n      break;\n    case 5:\n      route->rt_metric = rt->rt_metric;\n      break;\n    case 7:\n      route->rt_pref = rt->rt_pref;\n      break;\n    }\n\n    rtm = (struct rt_entry *)((char *)rtm + (rt_len + 3) & ~3);\n    len -= rt_len;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":0,"function":"int get_gatewayip(char *gatewayip, socklen_t size) {\n    int found_gatewayip = 0;\n    struct nlmsghdr *nlMsg;\n    struct route_info route_info;\n    char msgBuf[8192];\n    int sock, len, msgSeq = 0;\n    if ((sock = socket(16, SOCK_DGRAM, 0)) < 0) {\n        perror(\"Socket Creation: \");\n        return (-1);\n    }\n    memset(msgBuf, 0, sizeof (msgBuf));\n    nlMsg = (struct nlmsghdr *)msgBuf;\n    nlMsg->nlmsg_len = ((sizeof(struct rtmsg)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))));\n    nlMsg->nlmsg_type = RTM_GETROUTE;\n    nlMsg->nlmsg_flags = (256 | 512) | 1;\n    nlMsg->nlmsg_seq = msgSeq++;\n    nlMsg->nlmsg_pid = getpid();\n    if (send(sock, nlMsg, nlMsg->nlmsg_len, 0) < 0) {\n        fprintf(stderr, \"Write To Socket Failed...\\n\");\n        return -1;\n    }\n    if ((len = readNlSock(sock, msgBuf, sizeof (msgBuf), msgSeq, getpid())) < 0) {\n        fprintf(stderr, \"Read From Socket Failed...\\n\");\n        return -1;\n    }\n    for (; ((len) >= (int)sizeof(struct nlmsghdr) && (nlMsg)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlMsg)->nlmsg_len <= (len)); nlMsg = ((len) -= ((((nlMsg)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlMsg)) + ((((nlMsg)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n        memset(&route_info, 0, sizeof (route_info));\n        if (parseRoutes(nlMsg, &route_info) < 0)\n            continue;\n        if (strstr((char *)inet_ntoa(route_info.dstAddr), \"0.0.0.0\")) {\n            inet_ntop(2, &route_info.gateWay, gatewayip, size);\n            found_gatewayip = 1;\n            break;\n        }\n    }\n    close(sock);\n    return found_gatewayip;\n}\n","function_prediction":"int get_gatewayip_name_conflict(char *ip, socklen_t ip_len) {\n  int sockfd;\n  int ret;\n  int len;\n  char buf[8192];\n  struct sockaddr_nl sa;\n  struct nlmsghdr *nlh;\n  struct rtmsg *rtm;\n  struct rtattr *rta;\n  struct in_addr dst;\n\n  sockfd = socket(0x10, 2, 0);\n  if (sockfd < 0) {\n    perror(\"Socket Creation: \");\n    return -1;\n  }\n\n  sa.nl_family = 0x1c;\n  sa.nl_groups = 0;\n  sa.nl_pid = getpid();\n\n  len = sizeof(struct rtmsg);\n\n  nlh = (struct nlmsghdr *)buf;\n  nlh->nlmsg_len = len;\n  nlh->nlmsg_type = 0x01;\n  nlh->nlmsg_flags = 0x00;\n  nlh->nlmsg_seq = time(NULL);\n  nlh->nlmsg_pid = getpid();\n\n  ret = send(sockfd, buf, nlh->nlmsg_len, 0);\n  if (ret < 0) {\n    fprintf(stderr, \"Write To Socket Failed...\\n\");\n    return -1;\n  }\n\n  len = readNlSock(sockfd, buf, 8192, 1, getpid());\n  if (len < 0) {\n    fprintf(stderr, \"Read From Socket Failed...\\n\");\n    return -1;\n  }\n\n  nlh = (struct nlmsghdr *)buf;\n  while (len >= sizeof(*nlh)) {\n    rtm = (struct rtmsg *)NLMSG_DATA(nlh);\n    if (rtm->rtm_family < 16) {\n      rta = (struct rtattr *)RTM_RTA(rtm);\n      if (rta->rta_type <= len) {\n        dst.s_addr = 0;\n    if (parseRoutes(","pass":0,"source_file":"C_COMPILE/nikkolasg_arp/gateway.c"}
{"compilable":1,"function":"int compare_mac(MAC *m1, MAC *m2) {\n    return memcmp(m1, m2, 6);\n}\n","function_prediction":"int compare_mac_name_conflict(const void *a, const void *b) { return memcmp(a, b, 6); }","pass":1,"source_file":"C_COMPILE/nikkolasg_arp/test_misc.c"}
{"compilable":1,"function":"int compare_ip(IP *ip1, IP *ip2) {\n    return memcmp(ip1, ip2, 4);\n}\n","function_prediction":"int compare_ip_name_conflict(const void *a, const void *b) {\n  return memcmp(a, b, sizeof(struct in_addr));\n}","pass":1,"source_file":"C_COMPILE/nikkolasg_arp/test_misc.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len;\n  unsigned long hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = hash * 257 + word[i];\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 1 + (unsigned int)length;\n  for (hash = 0; length > 0; length--)\n    hash = hash * a + (unsigned int)word[length - 1];\n  hash = hash % 500000000;\n  a = vocab_hash[hash];\n  while (a != -1) {\n    if (!strcmp(word, vocab[a].word))\n      return a;\n    else\n      hash = (hash + 1) % 500000000;\n    a = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  long long len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 500000000;\n  while (vocab_hash[hash] != -1) {\n    hash = (hash + 1) % 500000000;\n  }\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len, hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = (hash << 8) + word[i];\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 0;\n  hash = 0;\n  for (int i = 0; i < length; i++) {\n    hash = hash * 257 + word[i];\n    a = a * 257 + word[i];\n  }\n  hash = hash % 30000000;\n  a = a % 30000000;\n  int hentry = vocab_hash[hash];\n  while (hentry != -1) {\n    if (!strcmp(word, vocab[hentry].word)) {\n      return hentry;\n    }\n    hash = (hash + 1) % 30000000;\n    a = (a + 1) % 30000000;\n    hentry = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  int length = strlen(word) + 1;\n  if (length > 100)\n    length = 100;\n  vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 30000000;\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 30000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/simonlin0604_word2vec/word2vec.c"}
{"compilable":1,"function":"char *rat(char *message) {\n    char *cyphertext = (char *)malloc(sizeof(char) * strlen(message));\n    int i;\n    for (i = 0; i < strlen(message); i++) {\n        cyphertext[i] = (isalpha(message[i])) ? (((message[i] + 13 - 'a') % 26) + 'a') : message[i];\n    }\n    return cyphertext;\n}\n","function_prediction":"char *rat_name_conflict(char *s) {\n  size_t len = strlen(s);\n  char *r = malloc(len);\n  for (size_t i = 0; i < len; i++) {\n    char c = s[i];\n    if (isalpha(c)) {\n      c = 'a' + (c - 'T') % 26;\n    }\n    r[i] = c;\n  }\n  return r;\n}","pass":1,"source_file":"C_COMPILE/chamoysvoice_rat13/rat13.c"}
{"compilable":1,"function":"int is_delimeter(char c) {\n    int ii = 0;\n    char dlms[] = \"\\t\\r\\n (){}[]+-*/%\\\"'&|^~:;<>.,\";\n    while (dlms[ii])\n        {\n            if (c == dlms[ii++])\n                return 1;\n        }\n    return 0;\n}\n","function_prediction":"int is_delimeter_name_conflict(char c) {\n  char delimeter[] = \" \\n\\t\";\n  int i;\n\n  for (i = 0; delimeter[i] != '\\0'; i++) {\n    if (c == delimeter[i])\n      return (1);\n  }\n  return (0);\n}","pass":0,"source_file":"C_COMPILE/lboulard_cscope/contrib/webcscope/hilite.c"}
{"compilable":1,"function":"int is_keyword(char *str) {\n    char *kwords[] = {\"asm\", \"auto\", \"break\", \"case\", \"cdecl\", \"char\", \"class\", \"const\", \"continue\", \"default\", \"delete\", \"do\", \"double\", \"else\", \"enum\", \"extern\", \"far\", \"float\", \"for\", \"friend\", \"goto\", \"huge\", \"if\", \"inline\", \"int\", \"interrupt\", \"long\", \"near\", \"new\", \"operator\", \"pascal\", \"private\", \"protected\", \"public\", \"register\", \"return\", \"short\", \"signed\", \"sizeof\", \"static\", \"struct\", \"switch\", \"template\", \"this\", \"typedef\", \"union\", \"unsigned\", \"virtual\", \"void\", \"volatile\", \"while\", ((void *)0)};\n    int ii = 0;\n    int jj;\n    int check;\n    while (kwords[ii])\n        {\n            jj = 0;\n            check = 1;\n            while (kwords[ii][jj] && check)\n                {\n                    if (str[jj] != kwords[ii][jj]) {\n                        check = 0;\n                    }\n                    jj++;\n                }\n            if (check)\n                return 1;\n            ii++;\n        }\n    return 0;\n}\n","function_prediction":"int is_keyword_name_conflict(char *str) {\n  char *keywords[] = {\"asm\",    \"auto\",     \"break\",   \"case\",   \"char\",\n                      \"const\",  \"continue\", \"default\", \"do\",     \"double\",\n                      \"else\",   \"enum\",     \"extern\",  \"float\",  \"for\",\n                      \"goto\",   \"if\",       \"int\",     \"long\",   \"register\",\n                      \"return\", \"short\",    \"signed\",  \"sizeof\", \"static\",\n                      \"struct\", \"switch\",   \"typedef\", \"union\",  \"unsigned\",\n                      \"void\",   \"volatile\", \"while\"};\n\n  int i, j;\n\n  for (i = 0; i < 30; i++) {\n    for (j = 0; keywords[i][j] != '\\0'; j++) {\n      if (str[j] != keywords[i][j])\n        break;\n    }\n\n    if (keywords[i][j] == '\\0')\n      return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/lboulard_cscope/contrib/webcscope/hilite.c"}
{"compilable":0,"function":"static int load_uca_file(MY_UCA *uca, size_t maxchar, int *pageloaded) {\n    char str[512];\n    size_t lineno, out_of_range_chars = 0;\n    char *weights[64];\n    for (lineno = 0; fgets(str, sizeof (str), stdin); lineno++) {\n        char *comment;\n        char *weight;\n        char *s, *ch[6];\n        size_t codenum, i, code;\n        MY_UCA_ITEM *item = ((void *)0);\n        if (*str == '\\r' || *str == '\\n' || *str == '#')\n            continue;\n        if (*str == '@' && !strncmp(str, \"@version \", 9)) {\n            const char *value;\n            if (strtok(str, \" \\r\\n\\t\") && (value = strtok(((void *)0), \" \\r\\n\\t\")))\n                snprintf(uca->version, 32, value);\n            continue;\n        }\n        if ((code = strtol(str, ((void *)0), 16)) > maxchar) {\n            out_of_range_chars++;\n            continue;\n        }\n        if ((comment = strchr(str, '#'))) {\n            *comment++ = '\\x00';\n            for (; *comment == ' '; comment++)\n                ;\n        } else {\n            fprintf(stderr, \"Warning: could not parse line #%d:\\n'%s'\\n\", lineno, str);\n            continue;\n        }\n        if ((weight = strchr(str, ';'))) {\n            *weight++ = '\\x00';\n            for (; *weight == ' '; weight++)\n                ;\n        } else {\n            fprintf(stderr, \"Warning: could not parse line #%d:\\n%s\\n\", lineno, str);\n            continue;\n        }\n        for (codenum = 0 , s = strtok(str, \" \\t\"); s; codenum++ , s = strtok(((void *)0), \" \\t\")) {\n            if (codenum == 6) {\n                fprintf(stderr, \"Contraction length is too long (%d) line #%d\", codenum, lineno);\n                exit(1);\n            }\n            ch[codenum] = s;\n            ch[codenum + 1] = 0;\n        }\n        if (codenum > 1) {\n            MY_UCA_CONTRACTION *c = &uca->contraction[uca->ncontractions++];\n            size_t i;\n            if (uca->ncontractions >= 1024) {\n                fprintf(stderr, \"Too many contractions (%d) at line #%d\\nRebuild with a bigger MY_UCA_MAXCONTRACTIONS value\\n\", uca->ncontractions, lineno);\n                exit(1);\n            }\n            for (i = 0; i < 6; i++) {\n                c->ch[i] = (i < codenum) ? (uint)strtol(ch[i], ((void *)0), 16) : 0;\n            }\n            if (uca->debug)\n                fprintf(stderr, \"Contraction: %04X-%04X-%04X\\n\", c->ch[0], c->ch[1], c->ch[2]);\n            item = &c->item;\n        } else {\n            item = &uca->item[code];\n        }\n        item->num = 0;\n        s = strtok(weight, \" []\");\n        while (s)\n            {\n                if (item->num >= 64) {\n                    fprintf(stderr, \"Line #%d has more than %d weights\\n\", lineno, 64);\n                    fprintf(stderr, \"Can't continue.\\n\");\n                    exit(1);\n                }\n                weights[item->num] = s;\n                s = strtok(((void *)0), \" []\");\n                item->num++;\n            }\n        for (i = 0; i < item->num; i++) {\n            size_t level = 0;\n            if (i >= 8) {\n                fprintf(stderr, \"Warning: at line %d: character %04X has more than %d many weights (%d). Skipping the extra weights.\\n\", lineno, code, 8, item->num);\n                item->num = 8;\n                break;\n            }\n            for (s = weights[i]; *s;) {\n                char *endptr;\n                size_t part = strtol(s + 1, &endptr, 16);\n                if (i < 8) {\n                    item->weight[level][i] = part;\n                } else {\n                    fprintf(stderr, \"Too many weights (%d) at line %d\\n\", i, lineno);\n                    exit(1);\n                }\n                s = endptr;\n                level++;\n            }\n        }\n        pageloaded[code >> 8]++;\n    }\n    if (out_of_range_chars)\n        fprintf(stderr, \"%d out-of-range characters skipped\\n\", out_of_range_chars);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static char *prefix_name(MY_UCA *uca) {\n    static char prefix[32];\n    char *s, *d;\n    strcpy(prefix, \"uca\");\n    for (s = uca->version , d = prefix + strlen(prefix); *s; s++) {\n        if ((*s >= '0' && *s <= '9') || (*s >= 'a' && *s <= 'z'))\n            *d++ = *s;\n    }\n    *d = '\\x00';\n    return prefix;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static char *page_name(MY_UCA *uca, size_t page, size_t level) {\n    static char page_name_buf[120];\n    snprintf(page_name_buf, sizeof (page_name_buf), \"%s_p%03X%s\", prefix_name(uca), page, pname[level]);\n    return page_name_buf;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static size_t normalize_weight(MY_UCA_ITEM *item, size_t level, uint16 *weight, size_t weight_elements) {\n    size_t num, i;\n    memset(weight, 0, weight_elements * sizeof (*weight));\n    for (num = 0 , i = 0; i < item->num && i < 8; i++) {\n        if (item->weight[level][i]) {\n            weight[num] = item->weight[level][i];\n            num++;\n        }\n    }\n    return num;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static int weight_cmp(uint16 *w1, uint16 *w2, size_t len) {\n    size_t i;\n    for (i = 0; i < len; i++) {\n        if (w1[i] != w2[i])\n            return 1;\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static int get_int_option(const char *str, const char *name, int *num) {\n    size_t namelen = strlen(name);\n    if (!strncmp(str, name, namelen)) {\n        *num = atoi(str + namelen);\n        if (*num == 0 && str[namelen] != '0') {\n            fprintf(stderr, \"\\nBad numeric option value: %s\\n\\n\", str);\n            usage(stderr, 1);\n        }\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"void get_int_option_part_0(char *arg) {\n  fprintf(stderr, \"\\nBad numeric option value: %s\\n\\n\", arg);\n  usage_constprop_0(stderr);\n}","pass":0,"source_file":"C_COMPILE/tsthght_SQLAdvisor/strings/uca-dump.c"}
{"compilable":0,"function":"static _Bool is_color_enabled(void) {\n    const char *env = getenv(\"LESS\");\n    return (env != 0 && (strstr(env, \"-r\") != 0 || strstr(env, \"-R\") != 0));\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/frugalware_frugalware-stable/source/apps/lesspipe/code2color.c"}
{"compilable":0,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int argindex_name_conflict(int n) {\n  int i;\n  char *p;\n\n  if (argv == NULL || argv[0] == NULL || argv[1] == NULL)\n    return -1;\n\n  for (i = 1; argv[i] != NULL; i++) {\n    p = argv[i];\n    if (p[0] == '-' || p[0] == '+' || strchr(p, '=') != NULL) {\n      if (p[0] == '-' && p[1] == '-' && p[2] == '\\0')\n        continue;\n      if (n-- == 0)\n        return i;\n    }\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"int OptNArgs_name_conflict(void) {\n  int n = 0;\n  char **p;\n\n  if (argv == NULL)\n    return 0;\n  if (*argv == NULL)\n    return 0;\n  for (p = argv + 1; *p != NULL; p++) {\n    if ((**p == '-' || **p == '+') && strchr(*p, '=') == NULL)\n      n++;\n    else if (**p == '-' && *(*p + 1) == '-' && *(*p + 2) == '\\0')\n      break;\n    else\n      n++;\n  }\n  return n;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"char *OptArg_name_conflict(char *opt) {\n  int i;\n\n  i = argindex(opt);\n  if (i < 0)\n    return NULL;\n  return argv[i];\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"char *pathsearch_name_conflict(const char *path, const char *name, int mode) {\n  char *p, *q, *r, *s;\n  int c;\n\n  if ((p = strrchr(path, '/'))) {\n    c = *p;\n    *p = 0;\n    s = malloc(strlen(path) + strlen(name) + 2);\n    if (s)\n      sprintf(s, \"%s/%s\", path, name);\n    *p = c;\n    return s;\n  }\n  if ((s = getenv(\"PATH\")) == NULL)\n    s = \".:/bin:/usr/bin\";\n  r = malloc(strlen(s) + strlen(name) + 2);\n  if (r == NULL)\n    return NULL;\n  for (p = s; *p;) {\n    q = strchr(p, ':');\n    if (q == NULL)\n      q = p + strlen(p);\n    c = *q;\n    *q = 0;\n    sprintf(r, \"%s/%s\", p, name);\n    *q = c;\n    if (c)\n      p = q + 1;\n    else\n      p = \"\";\n    if (!access(r, mode))\n      return r;\n  }\n  return r;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"void *SetNew_name_conflict(void) {\n  void *p;\n  int s = size;\n\n  if ((p = malloc(s)) == NULL)\n    memory_error();\n  if (s > 0)\n    p = memset(p, 0, s);\n  return p;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"int SetAdd_name_conflict(char *set, int index) {\n  char old = set[index];\n  set[index] = 1;\n  return old == 0;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"int SetUnion_name_conflict(char *a, char *b) {\n  int i, changed = 0;\n\n  for (i = 0; i < size; i++)\n    if (b[i] && !a[i]) {\n      a[i] = 1;\n      changed = 1;\n    }\n\n  return changed;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"int strhash_name_conflict(char *s) {\n  int h = 0;\n  while (*s)\n    h = h * 13 + *s++;\n  return h;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"char *Strsafe_name_conflict(char *s) {\n  int i, j, k, l, m, n, o;\n  char *p, *q, *r, *t;\n  struct strsafe_node *u;\n\n  if (x1a == NULL)\n    return s;\n\n  i = 0;\n  for (p = s; *p; p++)\n    i = (i * 13 + *p) % x1a->size;\n\n  for (u = x1a->table[i]; u; u = u->next)\n    if (!strcmp(u->s, s))\n      return u->s;\n\n  t = (char *)malloc(strlen(s) + 1);\n  if (t == NULL)\n    memory_error();\n  memcpy(t, s, strlen(s) + 1);\n\n  Strsafe_name_conflict_insert(t);\n\n  return t;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"int Strsafe_insert_name_conflict(char *str) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  char *a, *b, *c, *d, *e, *f, *g, *h, *i1, *j1, *k1, *l1, *m1, *n1, *o1, *p1,\n      *q1, *r1, *s1, *t1, *u1, *v1, *w1, *x1, *y1, *z1;\n  struct Strsafe_node *a1, *b1, *c1, *d1, *e1, *f1, *g1, *h1, *i2, *j2, *k2,\n      *l2, *m2, *n2, *o2, *p2, *q2, *r2, *s2, *t2, *u2, *v2, *w2, *x2, *y2, *z2;\n  struct Strsafe_node *A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L, *M, *N,\n      *O, *P, *Q, *R, *S, *T, *U, *V, *W, *X, *Y, *Z;\n\n  if (x1a == NULL)\n    return 0;\n\n  i = j = k = l = m = n = o = p = q = r = s = t = u = v = w = x = y = z = 0;\n  a = b = c = d = e = f = g = h = i1 = j1 = k1 = l1 = m1 = n1 = o1 = p1 = q1 =\n      r1 = s1 = t1 = u1 = v1 = w1 = x1 = y1 = z1 = NULL;\n  a1 = b1 = c1 = d1 = e1 = f1 = g1 = h1 = i2 = j2 = k2 = l","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"char *Strsafe_find_name_conflict(char *s) {\n  int h;\n  struct Strsafe_node *p;\n\n  if (x1a == NULL)\n    return NULL;\n\n  h = 0;\n  while (*s)\n    h = (h * 13) + *s++;\n  h &= x1a->mask;\n\n  for (p = x1a->table[h]; p; p = p->next)\n    if (!strcmp(p->s, s))\n      return p->s;\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":1,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"int Symbol_count_name_conflict() {\n  if (x2a == NULL)\n    return 0;\n  return x2a->count;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/zephir/parser/lemon.c"}
{"compilable":0,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int argindex_name_conflict(int n) {\n  int i;\n  char *p;\n\n  if (argv == NULL || argv[0] == NULL || argv[1] == NULL)\n    return -1;\n\n  for (i = 1; argv[i] != NULL; i++) {\n    p = argv[i];\n    if (p[0] == '-' || p[0] == '+' || strchr(p, '=') != NULL) {\n      if (p[0] == '-' && p[1] == '-' && p[2] == '\\0')\n        continue;\n      if (n-- == 0)\n        return i;\n    }\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"int OptNArgs_name_conflict(void) {\n  int n = 0;\n  char **p;\n\n  if (argv == NULL)\n    return 0;\n  if (*argv == NULL)\n    return 0;\n  for (p = argv + 1; *p != NULL; p++) {\n    if ((**p == '-' || **p == '+') && strchr(*p, '=') == NULL)\n      n++;\n    else if (**p == '-' && *(*p + 1) == '-' && *(*p + 2) == '\\0')\n      break;\n    else\n      n++;\n  }\n  return n;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"char *OptArg_name_conflict(char *opt) {\n  int i;\n\n  i = argindex(opt);\n  if (i < 0)\n    return NULL;\n  return argv[i];\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"char *pathsearch_name_conflict(const char *path, const char *name, int mode) {\n  char *p, *q, *r, *s;\n  int c;\n\n  if ((p = strrchr(path, '/'))) {\n    c = *p;\n    *p = 0;\n    s = malloc(strlen(path) + strlen(name) + 2);\n    if (s)\n      sprintf(s, \"%s/%s\", path, name);\n    *p = c;\n    return s;\n  }\n  if ((s = getenv(\"PATH\")) == NULL)\n    s = \".:/bin:/usr/bin\";\n  r = malloc(strlen(s) + strlen(name) + 2);\n  if (r == NULL)\n    return NULL;\n  for (p = s; *p;) {\n    q = strchr(p, ':');\n    if (q == NULL)\n      q = p + strlen(p);\n    c = *q;\n    *q = 0;\n    sprintf(r, \"%s/%s\", p, name);\n    *q = c;\n    if (c)\n      p = q + 1;\n    else\n      p = \"\";\n    if (!access(r, mode))\n      return r;\n  }\n  return r;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"void *SetNew_name_conflict(void) {\n  void *p;\n  int s = size;\n\n  if ((p = malloc(s)) == NULL)\n    memory_error();\n  if (s > 0)\n    p = memset(p, 0, s);\n  return p;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"int SetAdd_name_conflict(char *set, int index) {\n  char old = set[index];\n  set[index] = 1;\n  return old == 0;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"int SetUnion_name_conflict(char *a, char *b) {\n  int i, changed = 0;\n\n  for (i = 0; i < size; i++)\n    if (b[i] && !a[i]) {\n      a[i] = 1;\n      changed = 1;\n    }\n\n  return changed;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"int strhash_name_conflict(char *s) {\n  int h = 0;\n  while (*s)\n    h = h * 13 + *s++;\n  return h;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"char *Strsafe_name_conflict(char *s) {\n  int i, j, k, l, m, n;\n  char *p, *q, *r, *t;\n  struct strsafe_node *x;\n\n  if (x1a == NULL)\n    return s;\n\n  i = 0;\n  while (*s)\n    i = i * 13 + *s++;\n  i = i & (x1a->size - 1);\n\n  for (x = x1a->table[i]; x; x = x->next)\n    if (!strcmp(x->s, s))\n      return x->s;\n\n  p = (char *)malloc(strlen(s) + 1);\n  if (p == NULL)\n    memory_error();\n  memcpy(p, s, strlen(s) + 1);\n\n  Strsafe_name_conflict_insert(p);\n\n  return p;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"int Strsafe_insert_name_conflict(char *str) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  char *a, *b, *c, *d, *e, *f, *g, *h, *i1, *j1, *k1, *l1, *m1, *n1, *o1, *p1,\n      *q1, *r1, *s1, *t1, *u1, *v1, *w1, *x1, *y1, *z1;\n  struct Strsafe_node *a1, *b1, *c1, *d1, *e1, *f1, *g1, *h1, *i2, *j2, *k2,\n      *l2, *m2, *n2, *o2, *p2, *q2, *r2, *s2, *t2, *u2, *v2, *w2, *x2, *y2, *z2;\n  struct Strsafe_node *A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L, *M, *N,\n      *O, *P, *Q, *R, *S, *T, *U, *V, *W, *X, *Y, *Z;\n\n  if (x1a == NULL)\n    return 0;\n\n  i = j = k = l = m = n = o = p = q = r = s = t = u = v = w = x = y = z = 0;\n  a = b = c = d = e = f = g = h = i1 = j1 = k1 = l1 = m1 = n1 = o1 = p1 = q1 =\n      r1 = s1 = t1 = u1 = v1 = w1 = x1 = y1 = z1 = NULL;\n  a1 = b1 = c1 = d1 = e1 = f1 = g1 = h1 = i2 = j2 = k2 = l","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"char *Strsafe_find_name_conflict(char *s) {\n  int h;\n  struct Strsafe_node *p;\n\n  if (x1a == NULL)\n    return NULL;\n\n  h = 0;\n  while (*s)\n    h = (h * 13) + *s++;\n  h &= x1a->mask;\n\n  for (p = x1a->table[h]; p; p = p->next)\n    if (!strcmp(p->s, s))\n      return p->s;\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":1,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"int Symbol_count_name_conflict() {\n  if (x2a == NULL)\n    return 0;\n  return x2a->count;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/annotations/lemon.c"}
{"compilable":0,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int argindex_name_conflict(int n) {\n  int i;\n  char *p;\n\n  if (argv == NULL || argv[0] == NULL || argv[1] == NULL)\n    return -1;\n\n  for (i = 1; argv[i] != NULL; i++) {\n    p = argv[i];\n    if (p[0] == '-' || p[0] == '+' || strchr(p, '=') != NULL) {\n      if (p[0] == '-' && p[1] == '-' && p[2] == '\\0')\n        continue;\n      if (n-- == 0)\n        return i;\n    }\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"int OptNArgs_name_conflict(void) {\n  int n = 0;\n  char **p;\n\n  if (argv == NULL)\n    return 0;\n  if (*argv == NULL)\n    return 0;\n  for (p = argv + 1; *p != NULL; p++) {\n    if ((**p == '-' || **p == '+') && strchr(*p, '=') == NULL)\n      n++;\n    else if (**p == '-' && *(*p + 1) == '-' && *(*p + 2) == '\\0')\n      break;\n    else\n      n++;\n  }\n  return n;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"char *OptArg_name_conflict(char *opt) {\n  int i;\n\n  i = argindex(opt);\n  if (i < 0)\n    return NULL;\n  return argv[i];\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"char *pathsearch_name_conflict(const char *path, const char *name, int mode) {\n  char *p, *q, *r, *s;\n  int c;\n\n  if ((p = strrchr(path, '/'))) {\n    c = *p;\n    *p = 0;\n    s = malloc(strlen(path) + strlen(name) + 2);\n    if (s)\n      sprintf(s, \"%s/%s\", path, name);\n    *p = c;\n    return s;\n  }\n  if ((s = getenv(\"PATH\")) == NULL)\n    s = \".:/bin:/usr/bin\";\n  r = malloc(strlen(s) + strlen(name) + 2);\n  if (r == NULL)\n    return NULL;\n  for (p = s; *p;) {\n    q = strchr(p, ':');\n    if (q == NULL)\n      q = p + strlen(p);\n    c = *q;\n    *q = 0;\n    sprintf(r, \"%s/%s\", p, name);\n    *q = c;\n    if (c)\n      p = q + 1;\n    else\n      p = \"\";\n    if (!access(r, mode))\n      return r;\n  }\n  return r;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"void *SetNew_name_conflict(void) {\n  void *p;\n  int s = size;\n\n  if ((p = malloc(s)) == NULL)\n    memory_error();\n  if (s > 0)\n    p = memset(p, 0, s);\n  return p;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"int SetAdd_name_conflict(char *set, int index) {\n  char old = set[index];\n  set[index] = 1;\n  return old == 0;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"int SetUnion_name_conflict(char *a, char *b) {\n  int i, changed = 0;\n\n  for (i = 0; i < size; i++)\n    if (b[i] && !a[i]) {\n      a[i] = 1;\n      changed = 1;\n    }\n\n  return changed;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"int strhash_name_conflict(char *s) {\n  int h = 0;\n  while (*s)\n    h = h * 13 + *s++;\n  return h;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"char *Strsafe_name_conflict(char *s) {\n  int i, j, k, l, m, n;\n  char *p, *q, *r, *t;\n  struct strsafe_node *x;\n\n  if (x1a == NULL)\n    return s;\n\n  i = 0;\n  while (s[i] != '\\0')\n    i = i * 13 + s[i];\n  i = i & (x1a->size - 1);\n\n  for (x = x1a->table[i]; x != NULL; x = x->next)\n    if (!strcmp(x->s, s))\n      return x->s;\n\n  p = (char *)malloc(strlen(s) + 1);\n  if (p == NULL)\n    memory_error();\n  memcpy(p, s, strlen(s) + 1);\n\n  Strsafe_name_conflict_insert(p);\n\n  return p;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"int Strsafe_insert_name_conflict(char *str) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  char *a, *b, *c, *d, *e, *f, *g, *h, *i1, *j1, *k1, *l1, *m1, *n1, *o1, *p1,\n      *q1, *r1, *s1, *t1, *u1, *v1, *w1, *x1, *y1, *z1;\n  struct Strsafe_node *a1, *b1, *c1, *d1, *e1, *f1, *g1, *h1, *i2, *j2, *k2,\n      *l2, *m2, *n2, *o2, *p2, *q2, *r2, *s2, *t2, *u2, *v2, *w2, *x2, *y2, *z2;\n  struct Strsafe_node *A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L, *M, *N,\n      *O, *P, *Q, *R, *S, *T, *U, *V, *W, *X, *Y, *Z;\n\n  if (x1a == NULL)\n    return 0;\n\n  i = j = k = l = m = n = o = p = q = r = s = t = u = v = w = x = y = z = 0;\n  a = b = c = d = e = f = g = h = i1 = j1 = k1 = l1 = m1 = n1 = o1 = p1 = q1 =\n      r1 = s1 = t1 = u1 = v1 = w1 = x1 = y1 = z1 = NULL;\n  a1 = b1 = c1 = d1 = e1 = f1 = g1 = h1 = i2 = j2 = k2 = l","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"char *Strsafe_find_name_conflict(char *s) {\n  int h;\n  struct Strsafe_node *p;\n\n  if (x1a == NULL)\n    return NULL;\n\n  h = 0;\n  while (*s)\n    h = (h * 13) + *s++;\n  h &= x1a->mask;\n\n  for (p = x1a->table[h]; p; p = p->next)\n    if (!strcmp(p->s, s))\n      return p->s;\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":1,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"int Symbol_count_name_conflict() {\n  if (x2a == NULL)\n    return 0;\n  return x2a->count;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/model/query/lemon.c"}
{"compilable":0,"function":"static int findbreak(msg, min, max)\n    char *msg;\n    int min;\n    int max;\n {\n    int i, spot;\n    char c;\n    for (i = spot = min; i <= max; i++) {\n        c = msg[i];\n        if (c == '\\t')\n            msg[i] = ' ';\n        if (c == '\\n') {\n            msg[i] = ' ';\n            spot = i;\n            break;\n        }\n        if (c == 0) {\n            spot = i;\n            break;\n        }\n        if (c == '-' && i < max - 1)\n            spot = i + 1;\n        if (c == ' ')\n            spot = i;\n    }\n    return spot;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int argindex(n)\n    int n;\n {\n    int i;\n    int dashdash = 0;\n    if (argv != 0 && *argv != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0)) {\n                if (n == 0)\n                    return i;\n                n--;\n            }\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int argindex_name_conflict(int n) {\n  int i;\n  char *p;\n\n  if (argv == NULL || argv[0] == NULL || argv[1] == NULL)\n    return -1;\n\n  for (i = 1; argv[i] != NULL; i++) {\n    p = argv[i];\n    if (p[0] == '-' || p[0] == '+' || strchr(p, '=') != NULL) {\n      if (p[0] == '-' && p[1] == '-' && p[2] == '\\0')\n        continue;\n      if (n-- == 0)\n        return i;\n    }\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":1,"function":"int OptNArgs() {\n    int cnt = 0;\n    int dashdash = 0;\n    int i;\n    if (argv != 0 && argv[0] != 0) {\n        for (i = 1; argv[i]; i++) {\n            if (dashdash || !((argv[i])[0] == '-' || (argv[i])[0] == '+' || strchr((argv[i]), '=') != 0))\n                cnt++;\n            if (strcmp(argv[i], \"--\") == 0)\n                dashdash = 1;\n        }\n    }\n    return cnt;\n}\n","function_prediction":"int OptNArgs_name_conflict(void) {\n  int n = 0;\n  char **p;\n\n  if (argv == NULL)\n    return 0;\n  if (*argv == NULL)\n    return 0;\n  for (p = argv + 1; *p != NULL; p++) {\n    if ((**p == '-' || **p == '+') && strchr(*p, '=') == NULL)\n      n++;\n    else if (**p == '-' && *(*p + 1) == '-' && *(*p + 2) == '\\0')\n      break;\n    else\n      n++;\n  }\n  return n;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *OptArg(n)\n    int n;\n {\n    int i;\n    i = argindex(n);\n    return i >= 0 ? argv[i] : 0;\n}\n","function_prediction":"char *OptArg_name_conflict(char *opt) {\n  int i;\n\n  i = argindex(opt);\n  if (i < 0)\n    return NULL;\n  return argv[i];\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int preprocess_input(char *z) {\n    int i, j, k, n;\n    int exclude = 0;\n    int start;\n    int lineno = 1;\n    int start_lineno;\n    for (i = 0; z[i]; i++) {\n        if (z[i] == '\\n')\n            lineno++;\n        if (z[i] != '%' || (i > 0 && z[i - 1] != '\\n'))\n            continue;\n        if (strncmp(&z[i], \"%endif\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) {\n            if (exclude) {\n                exclude--;\n                if (exclude == 0) {\n                    for (j = start; j < i; j++)\n                        if (z[j] != '\\n')\n                            z[j] = ' ';\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        } else if ((strncmp(&z[i], \"%ifdef\", 6) == 0 && ((*__ctype_b_loc())[(int)((z[i + 6]))] & (unsigned short)_ISspace)) || (strncmp(&z[i], \"%ifndef\", 7) == 0 && ((*__ctype_b_loc())[(int)((z[i + 7]))] & (unsigned short)_ISspace))) {\n            if (exclude) {\n                exclude++;\n            } else {\n                for (j = i + 7; ((*__ctype_b_loc())[(int)((z[j]))] & (unsigned short)_ISspace); j++) {\n                }\n                for (n = 0; z[j + n] && !((*__ctype_b_loc())[(int)((z[j + n]))] & (unsigned short)_ISspace); n++) {\n                }\n                exclude = 1;\n                for (k = 0; k < nDefine; k++) {\n                    if (strncmp(azDefine[k], &z[j], n) == 0 && strlen(azDefine[k]) == n) {\n                        exclude = 0;\n                        break;\n                    }\n                }\n                if (z[i + 3] == 'n')\n                    exclude = !exclude;\n                if (exclude) {\n                    start = i;\n                    start_lineno = lineno;\n                }\n            }\n            for (j = i; z[j] && z[j] != '\\n'; j++)\n                z[j] = ' ';\n        }\n    }\n    if (exclude) {\n        fprintf(stderr, \"unterminated %%ifdef starting on line %d\\n\", start_lineno);\n        exit(1);\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *pathsearch(argv0, name, modemask)\n    char *argv0;\n    char *name;\n    int modemask;\n {\n    char *pathlist;\n    char *path, *cp;\n    char c;\n    extern int access();\n    cp = strrchr(argv0, '/');\n    if (cp) {\n        c = *cp;\n        *cp = 0;\n        path = (char *)malloc(strlen(argv0) + strlen(name) + 2);\n        if (path)\n            sprintf(path, \"%s/%s\", argv0, name);\n        *cp = c;\n    } else {\n        extern char *getenv();\n        pathlist = getenv(\"PATH\");\n        if (pathlist == 0)\n            pathlist = \".:/bin:/usr/bin\";\n        path = (char *)malloc(strlen(pathlist) + strlen(name) + 2);\n        if (path != 0) {\n            while (*pathlist)\n                {\n                    cp = strchr(pathlist, ':');\n                    if (cp == 0)\n                        cp = &pathlist[strlen(pathlist)];\n                    c = *cp;\n                    *cp = 0;\n                    sprintf(path, \"%s/%s\", pathlist, name);\n                    *cp = c;\n                    if (c == 0)\n                        pathlist = \"\";\n                    else\n                        pathlist = &cp[1];\n                    if (access(path, modemask) == 0)\n                        break;\n                }\n        }\n    }\n    return path;\n}\n","function_prediction":"char *pathsearch_name_conflict(const char *path, const char *name, int mode) {\n  char *p, *q, *r, *s;\n  int c;\n\n  if ((p = strrchr(path, '/'))) {\n    c = *p;\n    *p = 0;\n    s = malloc(strlen(path) + strlen(name) + 2);\n    if (s)\n      sprintf(s, \"%s/%s\", path, name);\n    *p = c;\n    return s;\n  }\n  if ((s = getenv(\"PATH\")) == NULL)\n    s = \".:/bin:/usr/bin\";\n  r = malloc(strlen(s) + strlen(name) + 2);\n  if (r == NULL)\n    return NULL;\n  for (p = s; *p;) {\n    q = strchr(p, ':');\n    if (q == NULL)\n      q = p + strlen(p);\n    c = *q;\n    *q = 0;\n    sprintf(r, \"%s/%s\", p, name);\n    *q = c;\n    if (c)\n      p = q + 1;\n    else\n      p = \"\";\n    if (!access(r, mode))\n      return r;\n  }\n  return r;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static const char *minimum_size_type(int lwr, int upr) {\n    if (lwr >= 0) {\n        if (upr <= 255) {\n            return \"unsigned char\";\n        } else if (upr < 65535) {\n            return \"unsigned short int\";\n        } else {\n            return \"unsigned int\";\n        }\n    } else if (lwr >= -127 && upr <= 127) {\n        return \"signed char\";\n    } else if (lwr >= -32767 && upr < 32767) {\n        return \"short\";\n    } else {\n        return \"int\";\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *SetNew() {\n    char *s;\n    int i;\n    s = (char *)malloc(size);\n    if (s == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    for (i = 0; i < size; i++)\n        s[i] = 0;\n    return s;\n}\n","function_prediction":"void *SetNew_name_conflict(void) {\n  void *p;\n  int s = size;\n\n  if ((p = malloc(s)) == NULL)\n    memory_error();\n  if (s > 0)\n    p = memset(p, 0, s);\n  return p;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":1,"function":"int SetAdd(s, e)\n    char *s;\n    int e;\n {\n    int rv;\n    rv = s[e];\n    s[e] = 1;\n    return !rv;\n}\n","function_prediction":"int SetAdd_name_conflict(char *set, int index) {\n  char old = set[index];\n  set[index] = 1;\n  return old == 0;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":1,"function":"int SetUnion(s1, s2)\n    char *s1;\n    char *s2;\n {\n    int i, progress;\n    progress = 0;\n    for (i = 0; i < size; i++) {\n        if (s2[i] == 0)\n            continue;\n        if (s1[i] == 0) {\n            progress = 1;\n            s1[i] = 1;\n        }\n    }\n    return progress;\n}\n","function_prediction":"int SetUnion_name_conflict(char *a, char *b) {\n  int i, changed = 0;\n\n  for (i = 0; i < size; i++)\n    if (b[i] && !a[i]) {\n      a[i] = 1;\n      changed = 1;\n    }\n\n  return changed;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":1,"function":"int strhash(x)\n    char *x;\n {\n    int h = 0;\n    while (*x)\n        h = h * 13 + *(x++);\n    return h;\n}\n","function_prediction":"int strhash_name_conflict(char *s) {\n  int h = 0;\n  while (*s)\n    h = h * 13 + *s++;\n  return h;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *Strsafe(y)\n    char *y;\n {\n    char *z;\n    z = Strsafe_find(y);\n    if (z == 0 && (z = malloc(strlen(y) + 1)) != 0) {\n        strcpy(z, y);\n        Strsafe_insert(z);\n    }\n    if ((z) == 0) {\n        extern void memory_error();\n        memory_error();\n    }\n    ;\n    return z;\n}\n","function_prediction":"char *Strsafe_name_conflict(char *s) {\n  int i, j, k, l, m, n, o;\n  char *p, *q, *r, *t;\n  struct strsafe_node *u;\n\n  if (x1a == NULL)\n    return s;\n\n  i = 0;\n  for (p = s; *p; p++)\n    i = (i * 13 + *p) % x1a->size;\n\n  for (u = x1a->table[i]; u; u = u->next)\n    if (!strcmp(u->s, s))\n      return u->s;\n\n  t = (char *)malloc(strlen(s) + 1);\n  if (t == NULL)\n    memory_error();\n  memcpy(t, s, strlen(s) + 1);\n\n  Strsafe_name_conflict_insert(t);\n\n  return t;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"int Strsafe_insert(data)\n    char *data;\n {\n    x1node *np;\n    int h;\n    int ph;\n    if (x1a == 0)\n        return 0;\n    ph = strhash(data);\n    h = ph & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, data) == 0) {\n                return 0;\n            }\n            np = np->next;\n        }\n    if (x1a->count >= x1a->size) {\n        int i, size;\n        struct s_x1 array;\n        array.size = size = x1a->size * 2;\n        array.count = x1a->count;\n        array.tbl = (x1node *)malloc((sizeof(x1node) + sizeof(x1node *)) * size);\n        if (array.tbl == 0)\n            return 0;\n        array.ht = (x1node **)&(array.tbl[size]);\n        for (i = 0; i < size; i++)\n            array.ht[i] = 0;\n        for (i = 0; i < x1a->count; i++) {\n            x1node *oldnp, *newnp;\n            oldnp = &(x1a->tbl[i]);\n            h = strhash(oldnp->data) & (size - 1);\n            newnp = &(array.tbl[i]);\n            if (array.ht[h])\n                array.ht[h]->from = &(newnp->next);\n            newnp->next = array.ht[h];\n            newnp->data = oldnp->data;\n            newnp->from = &(array.ht[h]);\n            array.ht[h] = newnp;\n        }\n        free(x1a->tbl);\n        *x1a = array;\n    }\n    h = ph & (x1a->size - 1);\n    np = &(x1a->tbl[x1a->count++]);\n    np->data = data;\n    if (x1a->ht[h])\n        x1a->ht[h]->from = &(np->next);\n    np->next = x1a->ht[h];\n    x1a->ht[h] = np;\n    np->from = &(x1a->ht[h]);\n    return 1;\n}\n","function_prediction":"int Strsafe_insert_name_conflict(char *str) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  char *a, *b, *c, *d, *e, *f, *g, *h, *i1, *j1, *k1, *l1, *m1, *n1, *o1, *p1,\n      *q1, *r1, *s1, *t1, *u1, *v1, *w1, *x1, *y1, *z1;\n  struct Strsafe_node *a1, *b1, *c1, *d1, *e1, *f1, *g1, *h1, *i2, *j2, *k2,\n      *l2, *m2, *n2, *o2, *p2, *q2, *r2, *s2, *t2, *u2, *v2, *w2, *x2, *y2, *z2;\n  struct Strsafe_node *A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L, *M, *N,\n      *O, *P, *Q, *R, *S, *T, *U, *V, *W, *X, *Y, *Z;\n\n  if (x1a == NULL)\n    return 0;\n\n  i = j = k = l = m = n = o = p = q = r = s = t = u = v = w = x = y = z = 0;\n  a = b = c = d = e = f = g = h = i1 = j1 = k1 = l1 = m1 = n1 = o1 = p1 = q1 =\n      r1 = s1 = t1 = u1 = v1 = w1 = x1 = y1 = z1 = NULL;\n  a1 = b1 = c1 = d1 = e1 = f1 = g1 = h1 = i2 = j2 = k2 = l","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"char *Strsafe_find(key)\n    char *key;\n {\n    int h;\n    x1node *np;\n    if (x1a == 0)\n        return 0;\n    h = strhash(key) & (x1a->size - 1);\n    np = x1a->ht[h];\n    while (np)\n        {\n            if (strcmp(np->data, key) == 0)\n                break;\n            np = np->next;\n        }\n    return np ? np->data : 0;\n}\n","function_prediction":"char *Strsafe_find_name_conflict(char *s) {\n  int h;\n  struct Strsafe_node *p;\n\n  if (x1a == NULL)\n    return NULL;\n\n  h = 0;\n  while (*s)\n    h = (h * 13) + *s++;\n  h &= x1a->mask;\n\n  for (p = x1a->table[h]; p; p = p->next)\n    if (!strcmp(p->s, s))\n      return p->s;\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":1,"function":"int Symbol_count() {\n    return x2a ? x2a->count : 0;\n}\n","function_prediction":"int Symbol_count_name_conflict() {\n  if (x2a == NULL)\n    return 0;\n  return x2a->count;\n}","pass":1,"source_file":"C_COMPILE/noikiy_tester/phalcon2/cphalcon/ext/phalcon/mvc/view/engine/volt/lemon.c"}
{"compilable":0,"function":"static int parseHex(const char *buf, unsigned long *value) {\n    int len = 0;\n    char ch;\n    *value = 0;\n    while ((ch = buf[len]) != '\\x00')\n        {\n            if (ch >= '0' && ch <= '9') {\n                *value = *value * 16 + (unsigned long)(ch - '0');\n            } else if (ch >= 'A' && ch <= 'F') {\n                *value = *value * 16 + (unsigned long)(ch - 'A' + 10);\n            } else if (ch >= 'a' && ch <= 'f') {\n                *value = *value * 16 + (unsigned long)(ch - 'a' + 10);\n            } else {\n                break;\n            }\n            ++len;\n        }\n    return len;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/ucm2cp.c"}
{"compilable":0,"function":"static int parseHex(const char *buf, unsigned long *value) {\n    int len = 0;\n    char ch;\n    *value = 0;\n    while ((ch = buf[len]) != '\\x00')\n        {\n            if (ch >= '0' && ch <= '9') {\n                *value = *value * 16 + (unsigned long)(ch - '0');\n            } else if (ch >= 'A' && ch <= 'F') {\n                *value = *value * 16 + (unsigned long)(ch - 'A' + 10);\n            } else if (ch >= 'a' && ch <= 'f') {\n                *value = *value * 16 + (unsigned long)(ch - 'a' + 10);\n            } else {\n                break;\n            }\n            ++len;\n        }\n    return len;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/uni2tab.c"}
{"compilable":0,"function":"static int createTables(void) {\n    FILE *file;\n    if ((file = fopen(\"jis.table\", \"wb\")) == ((void *)0)) {\n        if ((file = fopen(\"jis.table\", \"wb\")) == ((void *)0)) {\n            perror(\"jis.table\");\n            return 1;\n        }\n    }\n    writeJis(file);\n    fclose(file);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/xen2_mcs/class/I18N/tools/uni2tab.c"}
{"compilable":1,"function":"int wordCount(char *sentence_array, int *numWords) {\n    if (sentence_array == '\\x00') {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    *numWords = CountWords(sentence_array, 0, 0, 1000);\n    return 0;\n}\n","function_prediction":"int wordCount_name_conflict(char *array, int *numWords) {\n  int num = 0;\n  int length = 0;\n\n  if (array == NULL) {\n    printf(\"ERROR: array entered was null.\\n\");\n    return 1;\n  }\n\n  if (array[0] == ' ') {\n    printf(\"ERROR: the first character in the array was empty. Please start \"\n           \"your sentence from the beginning.\\n\");\n    return 1;\n  }\n\n  if (array[0] == '\\0') {\n    printf(\"number of words: %d\\n\", 1);\n    return 1;\n  }\n\n  length = strlen(array) + 1;\n\n  num = CountWords(array, 0, 1, length);\n\n  *numWords = num;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int CountWords(char *sentence_array, int count, int start, int maxSize) {\n    if (count < 0) {\n        printf(\"ERROR: count needs to be greater than 0.\\n\");\n        return 1;\n    }\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (start > maxSize) {\n        printf(\"ERROR: the start point was greater than the max size.\\n\");\n        return 1;\n    }\n    if (start < 0 || maxSize < 0) {\n        printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n        return 1;\n    }\n    if (sentence_array[0] == ' ') {\n        printf(\"ERROR: the first character in the array was empty. Please start your sentence from the beginning.\\n\");\n        return 1;\n    }\n    int a = 0;\n    while (sentence_array[a] != '\\x00')\n        {\n            a++;\n        }\n    maxSize = a;\n    if (sentence_array[start] == ' ' && sentence_array[start - 1] != ' ' && start != (maxSize - 1)) {\n        count = count + 1;\n    }\n    if (start != maxSize) {\n        count = CountWords(sentence_array, count, (start + 1), maxSize);\n    }\n    if (start == maxSize) {\n        count++;\n        printf(\"number of words: %d\\n\", count);\n        return count;\n    }\n    return count;\n}\n","function_prediction":"int CountWords_name_conflict(char *array, int count, int start, int max) {\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  if (count < 0) {\n    printf(\"ERROR: count needs to be greater than 0.\\n\");\n    return 1;\n  }\n\n  if (array == NULL) {\n    printf(\"ERROR: array entered was null.\\n\");\n    return 1;\n  }\n\n  if (start > max) {\n    printf(\"ERROR: the start point was greater than the max size.\\n\");\n    return 1;\n  }\n\n  if (start < 0 || max < 0) {\n    printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n    return 1;\n  }\n\n  if (array[0] == ' ') {\n    printf(\"ERROR: the first character in the array was empty. Please start \"\n           \"your sentence from the beginning.\\n\");\n    return 1;\n  }\n\n  while (array[max] != '\\0') {\n    max++;\n  }\n\n  while (i != max) {\n    if (array[i] == ' ' && array[i - 1] != ' ') {\n      if (i != start) {\n        count++;\n      }\n    }\n\n    i++;\n  }\n\n  printf(\"number of words: %d\\n\", count + 1);\n\n  return count + 1;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int wordRemove(char *sentence_array, char *word) {\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (word == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    int sizeSentence = 0;\n    while (sentence_array[sizeSentence] != '\\x00')\n        {\n            sizeSentence++;\n        }\n    int sizeWord = 0;\n    while (word[sizeWord] != '\\x00')\n        {\n            sizeWord++;\n        }\n    int head = -1, scanner, stop = sizeSentence - sizeWord;\n    int found = 0;\n    while (head <= stop && found == 0)\n        {\n            head++;\n            scanner = 0;\n            if (sentence_array[head] == word[0]) {\n                while (scanner < sizeWord)\n                    {\n                        found = 1;\n                        if (sentence_array[head + scanner] != word[scanner]) {\n                            found = 0;\n                            break;\n                        }\n                        scanner++;\n                    }\n            }\n        }\n    int i = head;\n    while (sentence_array[i + sizeWord] != '\\x00')\n        {\n            sentence_array[i] = sentence_array[i + sizeWord];\n            i++;\n        }\n    sentence_array[i] = '\\x00';\n    return 0;\n}\n","function_prediction":"int wordRemove_name_conflict(char *array, char *word) {\n  int i, j, k, l, m, n, o;\n\n  if (array == NULL || word == NULL) {\n    puts(\"ERROR: array entered was null.\");\n    return 1;\n  }\n\n  for (i = 0; array[i] != '\\0'; i++)\n    ;\n  for (j = 0; word[j] != '\\0'; j++)\n    ;\n\n  for (k = 0; k < i - j; k++) {\n    if (array[k] == word[0]) {\n      for (l = 0; l < j; l++) {\n        if (array[k + l] != word[l]) {\n          break;\n        }\n      }\n\n      if (l == j) {\n        for (m = k; array[m] != '\\0'; m++) {\n          array[m] = array[m + j];\n        }\n\n        array[m] = '\\0';\n        return 0;\n      }\n    }\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int vowelCheck(char *array, int *vowels) {\n    int i;\n    *vowels = 0;\n    for (i = 0; array[i] != '\\x00'; i++) {\n        if ((array[i] == 'a' || array[i] == 'e' || array[i] == 'i' || array[i] == 'o' || array[i] == 'u') || (array[i] == 'A' || array[i] == 'E' || array[i] == 'I' || array[i] == 'O' || array[i] == 'U')) {\n            *vowels = *vowels + 1;\n        }\n    }\n    printf(\"No. of vowels in %s = %d\\n\", array, *vowels);\n    return 0;\n}\n","function_prediction":"int vowelCheck_name_conflict(char *str, int *vowelCount) {\n  *vowelCount = 0;\n  int i = 0;\n  while (str[i] != '\\0') {\n    if (str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' ||\n        str[i] == 'u' || str[i] == 'A' || str[i] == 'E' || str[i] == 'I' ||\n        str[i] == 'O' || str[i] == 'U') {\n      *vowelCount = *vowelCount + 1;\n    }\n    i++;\n  }\n  printf(\"No. of vowels in %s = %d\\n\", str, *vowelCount);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int subString(char *array1, int index1, int index2) {\n    int position;\n    int i = 0;\n    char input2[100];\n    if (array1 == ((void *)0)) {\n        return 1;\n    }\n    position = index1;\n    for (i = 0; array1[i] != '\\x00'; i++ , position++) {\n        if (position <= index2) {\n            array1[i] = array1[position];\n        } else {\n            array1[i] = ((void *)0);\n        }\n    }\n    return 0;\n}\n","function_prediction":"int subString_name_conflict(char *str, int start, int end) {\n  if (str == NULL) {\n    return 1;\n  }\n\n  int i = 0;\n  while (str[i] != '\\0') {\n    if (i < start) {\n      str[i] = '\\0';\n    } else if (i > end) {\n      str[i - start] = '\\0';\n    } else {\n      str[i - start] = str[i];\n    }\n    i++;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int concatenateStrings(char *str1, char *str2) {\n    int firstArrayLength = 0;\n    int secondArrayLength = 0;\n    while (str1[firstArrayLength] != '\\x00')\n        {\n            firstArrayLength++;\n        }\n    printf(\"%d\", firstArrayLength);\n    while (str2[secondArrayLength] != '\\x00')\n        {\n            str1[firstArrayLength] = str2[secondArrayLength];\n            secondArrayLength++;\n            firstArrayLength++;\n        }\n    str1[firstArrayLength] = '\\x00';\n    return 0;\n}\n","function_prediction":"int concatenateStrings_name_conflict(char *s1, char *s2) {\n  int i, j;\n  for (i = 0; s1[i] != '\\0'; i++)\n    ;\n  printf(\"%d\", i);\n  for (j = 0; s2[j] != '\\0'; j++)\n    s1[i + j] = s2[j];\n  s1[i + j] = '\\0';\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int printString() {\n    char mystring[50];\n    printf(\"Please type a string\\n\\n\");\n    scanf(\"\\n%50[^\\n]s\", mystring);\n    printf(\"%s\\n\", mystring);\n}\n","function_prediction":"int printStringWLen(char *str, int *len) {\n  char str2[50];\n  if (str[0] == '\\0') {\n    printf(\"Error -- array is null\");\n    return 1;\n  } else {\n    *len = strlen(str) + 1;\n    printf(\"You Entered:%s\\n\", str);\n    printf(\"The Length of the string is: %d\\n\", *len);\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int printStringWLen(char *array, int *length) {\n    if (array[0] == '\\x00') {\n        printf(\"Error -- array is null\");\n        return 1;\n    }\n    int number = 0;\n    while (array[number] != '\\x00')\n        {\n            number++;\n        }\n    *length = number;\n    printf(\"You Entered:%s\\n\", array);\n    printf(\"The Length of the string is: %d\\n\", *length);\n    return 0;\n}\n","function_prediction":"int printStringWLen_name_conflict(char *str, int *len) {\n  if (str[0] == '\\0') {\n    printf(\"Error -- array is null\");\n    return 1;\n  }\n  *len = strlen(str + 1) + 1;\n  printf(\"You Entered:%s\\n\", str);\n  printf(\"The Length of the string is: %d\\n\", *len);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int alphaNumeric(char ch) {\n    if (ch >= '0' && ch <= '9') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'A' && ch <= 'Z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'a' && ch <= 'z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else {\n        printf(\"%c is not alphanumeric.\\n\", ch);\n    }\n    return 0;\n}\n","function_prediction":"int alphaNumeric_name_conflict(char c) {\n  if (((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||\n       (c >= '0' && c <= '9'))) {\n    printf(\"|%c| is alphanumeric.\\n\", c);\n  } else {\n    printf(\"%c is not alphanumeric.\\n\", c);\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int testFindLength() {\n    int i, strLength, strLengthResponse = -5, returnValue;\n    for (i = 0; i < numArrays; i++) {\n        strLength = strings[i].length;\n        char *string = malloc(strLength * sizeof(char));\n        string = strings[i].value;\n        strLength = strlen(string);\n        returnValue = printStringWLen(string, &strLengthResponse);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strLengthResponse == -5) {\n            return -2;\n        }\n        if (strLengthResponse != strLength) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int testFindLength_name_conflict() {\n  int i;\n  int len;\n  int ret;\n  int expectedLen;\n  int result = -1;\n  int expectedResult = 0;\n  int expectedLen2 = -5;\n\n  for (i = 0; i < numArrays; i++) {\n    len = strlen(strings[i].string);\n    ret = printStringWLen(strings[i].string, &expectedLen);\n    if (ret != 0) {\n      result = 1;\n      break;\n    }\n    if (expectedLen == expectedLen2) {\n      result = 0;\n      break;\n    }\n    if (expectedLen != len) {\n      result = -1;\n      break;\n    }\n  }\n  return result;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testVowels() {\n    int i, e, numVowels, strLength, strVowelResponse, returnValue;\n    for (e = 0; e < numArrays; e++) {\n        loadArrays();\n        strLength = strings[e].length;\n        char *string = malloc(strLength);\n        string = strings[e].value;\n        numVowels = 0;\n        strVowelResponse = -5;\n        for (i = 0; string[i] != '\\x00'; i++) {\n            if (string[i] == 'a' || string[i] == 'e' || string[i] == 'i' || string[i] == 'o' || string[i] == 'u' || string[i] == 'A' || string[i] == 'E' || string[i] == 'I' || string[i] == 'O' || string[i] == 'U')\n                numVowels++;\n        }\n        returnValue = vowelCheck(string, &strVowelResponse);\n        printf(\"Num Vowels Response -- %d\\n\", strVowelResponse);\n        printf(\"Num Vowels -- %d\\n\", numVowels);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strVowelResponse == -5) {\n            return -2;\n        }\n        if (strVowelResponse != numVowels) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int testVowels_name_conflict() {\n  int i;\n  int numVowels;\n  int numVowelsResponse;\n  int result;\n\n  for (i = 0; i < numArrays; i++) {\n    loadArrays(i);\n\n    numVowelsResponse = -5;\n    numVowels = 0;\n\n    for (int j = 0; strings[i].string[j] != '\\0'; j++) {\n      if (strings[i].string[j] == 'a' || strings[i].string[j] == 'e' ||\n          strings[i].string[j] == 'i' || strings[i].string[j] == 'o' ||\n          strings[i].string[j] == 'u') {\n        numVowels++;\n      }\n    }\n\n    result = vowelCheck(strings[i].string, &numVowelsResponse);\n\n    printf(\"Num Vowels Response -- %d\\n\", numVowelsResponse);\n    printf(\"Num Vowels -- %d\\n\", numVowels);\n\n    if (result != 0) {\n      return 1;\n    } else if (numVowelsResponse == -5) {\n      return -2;\n    } else if (numVowelsResponse != numVowels) {\n      return -1;\n    }\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testNumberWords() {\n    int i, e, numWords, strLength, strWordResponse = -5, returnValue;\n    for (e = 0; e < numArrays; e++) {\n        loadArrays();\n        strLength = strings[e].length;\n        char *string = malloc(strLength);\n        string = strings[e].value;\n        string[0] = 'A';\n        numWords = 1;\n        strWordResponse = 0;\n        for (i = 1; string[i] != '\\x00'; i++) {\n            if ((string[i] == ' ' && string[i - 1] != ' ')) {\n                numWords++;\n            }\n        }\n        returnValue = wordCount(string, &strWordResponse);\n        printf(\"\\n\\n%s\\n NUMBER OF WORDS my %d theirs %d\\n\\n\", string, numWords, strWordResponse);\n        if (returnValue != 0) {\n            return 1;\n        }\n        if (strWordResponse == -5) {\n            return -2;\n        }\n        if (strWordResponse != numWords) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int testNumberWords_name_conflict() {\n  int i, j, numWords, numWords2;\n  char *p;\n  int result = 0;\n  int expected = -5;\n\n  for (i = 0; i < numArrays; i++) {\n    loadArrays(i);\n    p = strings[i];\n    p[0] = 'A';\n    numWords2 = 0;\n    numWords = 1;\n    for (j = 0; p[j] != '\\0'; j++) {\n      if (p[j] == ' ' && p[j + 1] != ' ') {\n        numWords++;\n      }\n    }\n    result = wordCount(strings[i], &numWords2);\n    printf(\"\\n\\n%s\\n NUMBER OF WORDS my %d theirs %d\\n\\n\", strings[i], numWords,\n           numWords2);\n    if (result != 0) {\n      return 1;\n    }\n    if (numWords2 == expected) {\n      return -2;\n    }\n    if (numWords2 != numWords) {\n      return -1;\n    }\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":1,"function":"int testAlphaNumericChar() {\n    int value;\n    int first;\n    int second;\n    int third;\n    value = alphaNumeric('n');\n    if (value == 0) {\n        first = 0;\n    }\n    if (value == 1) {\n        first = 1;\n    }\n    value = alphaNumeric('9');\n    if (value == 0) {\n        second = 0;\n    }\n    if (value == 1) {\n        second = 1;\n    }\n    value = alphaNumeric('!');\n    if (value == 0) {\n        third = 0;\n    }\n    if (value == 1) {\n        third = 1;\n    }\n    if (third == 0 && second == 0 && first == 0) {\n        return 0;\n    } else\n        return 1;\n}\n","function_prediction":"int testAlphaNumericChar_name_conflict() {\n  return alphaNumeric('n') == 1 || alphaNumeric('9') == 1 ||\n         alphaNumeric('!') == 1;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":1,"function":"int testSubString() {\n    char string[] = \"lucille\";\n    subString(string, 2, 5);\n    if (strcmp(string, \"cill\") != 0) {\n        printf(\"Testing Sub String -- %s\\n\", string);\n        return -1;\n    }\n    if (string == ((void *)0)) {\n        return -2;\n    }\n    return 0;\n}\n","function_prediction":"int testSubString_name_conflict() {\n  char str[] = \"culicul\";\n  subString(str, 2, 5);\n  if (!strcmp(str, \"cill\")) {\n    return 0;\n  }\n  printf(\"Testing Sub String -- %s\\n\", str);\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int testConcat() {\n    char string1[500] = \"A melancholy-looking man, he had the appearance of one \";\n    char string2[] = \"who has searched for the leak in life's gas-pipe with a lighted candle - PG Wodehouse\";\n    char stringTotal[] = \"A melancholy-looking man, he had the appearance of one who has searched for the leak in life's gas-pipe with a lighted candle - PG Wodehouse\";\n    int returnValue = concatenateStrings(string1, string2);\n    if (returnValue != 0) {\n        return 1;\n    }\n    int i = 0;\n    while (stringTotal[i] != '\\x00')\n        {\n            if (string1[i] != stringTotal[i]) {\n                return -2;\n            }\n            i++;\n        }\n    return 0;\n}\n","function_prediction":"int testConcat_name_conflict() {\n  char *strings[100];\n  char *result;\n  int i;\n\n  strings[0] = \"no one\";\n  strings[1] = \"foolish\";\n  strings[2] = \"man\";\n  strings[3] = \"he had\";\n  strings[4] = \"a melancholy\";\n  strings[5] = \"looking\";\n  strings[6] = \"face\";\n  strings[7] = \"and\";\n  strings[8] = \"a\";\n  strings[9] = \"sad\";\n  strings[10] = \"expression\";\n  strings[11] = \"on\";\n  strings[12] = \"his\";\n  strings[13] = \"face\";\n  strings[14] = \"and\";\n  strings[15] = \"a\";\n  strings[16] = \"sad\";\n  strings[17] = \"expression\";\n  strings[18] = \"on\";\n  strings[19] = \"his\";\n  strings[20] = \"face\";\n  strings[21] = \"and\";\n  strings[22] = \"a\";\n  strings[23] = \"sad\";\n  strings[24] = \"expression\";\n  strings[25] = \"on\";\n  strings[26] = \"his\";\n  strings[27] = \"face\";\n  strings[28] = \"and\";\n  strings[29] = \"a\";\n  strings[30] = \"sad\";\n  strings[31] = \"expression\";\n  strings[32] = \"on\";\n  strings[33] = \"his\";\n  strings[34] = \"face\";\n  strings[35] = \"and\";\n  strings[36] = \"a\";\n  strings[37] = \"sad\";\n  strings[38] = \"expression\";\n  strings[39] = \"on\";\n  strings[40] = \"his\";\n  strings[41] = \"face\";\n  strings[42] = \"and\";\n  strings[43] = \"a","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":1,"function":"int testRemove() {\n    char chararray[] = \"mother hubbard\";\n    char removeword[] = \"hubbard\";\n    wordRemove(chararray, removeword);\n    if (strcmp(chararray, \"mother \") != 0) {\n        return 0;\n    }\n    if (strcmp(chararray, \"mother\") != 0) {\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"int testRemove_name_conflict() {\n  char str[] = \"motherhood\";\n  char word[] = \"mother\";\n  wordRemove(str, word);\n  return !strcmp(str, \"mother \") && !strcmp(str, \"mother\");\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int generateReport(char *file) {\n    FILE *outFile;\n    outFile = fopen(file, \"a\");\n    int functionResponse, i, numFunctions = 7, numErrors = 0;\n    struct TesterFunction functions[7] = {{\"Find Length Function\", &testFindLength}, {\"Find Vowels Function\", &testVowels}, {\"Find Number of Words Function\", &testNumberWords}, {\"Test if char is alpha-numeric\", &testAlphaNumericChar}, {\"Create Substring function\", &testSubString}, {\"Contatenate Function\", &testConcat}, {\"Remove Word Function\", &testRemove}};\n    addStrings(outFile, \"\\n\\nGenerall Tests ...\\n\");\n    addStrings(outFile, \"-----------------------------------------------------------------\\n\");\n    for (i = 0; i < numFunctions; i++) {\n        functionResponse = functions[i].function();\n        printf(\"Index %d Function %s returned %d\\n\", i, functions[i].name, functionResponse);\n        addStrings(outFile, functions[i].name);\n        switch (functionResponse) {\n          case 0:\n            addStrings(outFile, \" function ---  passed all tests.\\n\\n\");\n            break;\n          case 1:\n            addStrings(outFile, \" function ---- failed to run.\\n\\n\");\n            break;\n          case -1:\n            addStrings(outFile, \" function ---- did not return the correct result\\n\\n\");\n            break;\n          case -2:\n            addStrings(outFile, \" function ---- did not return result\\n\\n\");\n            break;\n        }\n    }\n    addStrings(outFile, \"\\n\\nExtra Targeted Testing ...\\n\");\n    addStrings(outFile, \"-----------------------------------------------------------------\\n\");\n    addStrings(outFile, \"ALL PASS\");\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n-----------------------------------------------------------------\\n\");\n    printf(\"REPORT HAS BEEN SAVED in file '%s' \\n\", file);\n    printf(\"Output fclose - %d\", fclose(outFile));\n    return 0;\n}\n","function_prediction":"int generateReport_name_conflict(char *fileName) {\n  int i;\n  int result;\n  char *functionName[7];\n  int (*testFunction[7])();\n  FILE *fp;\n\n  fp = fopen(fileName, \"a\");\n\n  testFunction[0] = testFindLength;\n  functionName[0] = \"Find Vowels Function\";\n\n  testFunction[1] = testVowels;\n  functionName[1] = \"Find Number of Words Function\";\n\n  testFunction[2] = testNumberWords;\n  functionName[2] = \"Test if char is alpha-numeric\";\n\n  testFunction[3] = testAlphaNumericChar;\n  functionName[3] = \"Create Substring function\";\n\n  testFunction[4] = testSubString;\n  functionName[4] = \"Contatenate Function\";\n\n  testFunction[5] = testConcat;\n  functionName[5] = \"Remove Word Function\";\n\n  testFunction[6] = testRemove;\n  functionName[6] = \"Remove Word Function\";\n\n  fputs(\"\\n\\nGenerall Tests ...\\n\", fp);\n  fputs(\"-----------------------------------------------------------------\\n\",\n        fp);\n\n  for (i = 0; i < 7; i++) {\n    result = testFunction[i]();\n    printf(\"Index %d Function %s returned %d\\n\", i, functionName[i], result);\n    fputs(functionName[i], fp);\n    if (result == 0) {\n      fputs(\" function ---  passed all tests.\\n\\n\", fp);\n    } else if (result > 0) {\n      fputs(\" function ---- failed to run.\\n\\n\", fp);\n    } else if (result == -1) {\n      fputs(\" function ---- did not return result\\n\\n\", fp);\n    } else if (result == -2) {\n      fputs(\" function ---- did not return the correct result\\n\\n\", fp);\n    }\n  }\n\n  fputs","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":1,"function":"int generate_random_string_array(char *array, int array_length) {\n    int i;\n    if (!array) {\n        printf(\"Error: Input array was NULL\\n\");\n        return 1;\n    }\n    if (array_length < 1) {\n        printf(\"Error: required array size < 1\\n\");\n        return 1;\n    }\n    for (i = 0; i < array_length; i++) {\n        switch (rand() % 5) {\n          case 0:\n            array[i] = 'A' + (rand() % 26);\n            break;\n          case 1:\n            array[i] = ' ';\n            break;\n          default:\n            array[i] = 'a' + (rand() % 26);\n            break;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int generate_random_string_array_name_conflict(char *array, int size) {\n  if (array == NULL) {\n    puts(\"Error: Input array was NULL\");\n    return 1;\n  }\n\n  if (size < 1) {\n    puts(\"Error: required array size < 1\");\n    return 1;\n  }\n\n  int i;\n  for (i = 0; i < size; i++) {\n    int r = rand() % 5;\n    if (r == 0) {\n      array[i] = 'A' + (rand() % 26);\n    } else if (r == 1) {\n      array[i] = ' ';\n    } else {\n      array[i] = 'a' + (rand() % 26);\n    }\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":0,"function":"int loadArrays() {\n    int i, currentArrayLength = 10;\n    for (i = 0; i < numArrays; i++) {\n        char array[currentArrayLength];\n        generate_random_string_array(array, currentArrayLength);\n        strings[i].value = malloc(currentArrayLength);\n        strcpy(strings[i].value, array);\n        strings[i].length = currentArrayLength;\n        currentArrayLength *= 5;\n    }\n    return 0;\n}\n","function_prediction":"int loadArrays_name_conflict() {\n  int i, j, k;\n  char str[10];\n  for (i = 0; i < numArrays; i++) {\n    for (j = 0; j < 10; j++) {\n      if (rand() % 5 == 0) {\n        str[j] = 'A' + (rand() % 26);\n      } else if (rand() % 5 == 1) {\n        str[j] = ' ';\n      } else {\n        str[j] = 'a' + (rand() % 26);\n      }\n    }\n    strings[i].str = malloc(10);\n    strcpy(strings[i].str, str);\n    strings[i].len = 10 * (i + 1);\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_tester.c"}
{"compilable":1,"function":"int wordCount_handler(char *array) {\n    int numWords = 0;\n    wordCount(array, &numWords);\n    return 0;\n}\n","function_prediction":"int wordCount_handler_name_conflict(char *input) {\n  int count = 0;\n  wordCount(input, &count);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int wordRemove_handler(char *array) {\n    char wordToRemove[1000];\n    char sentence[1000];\n    askQuestionString(sentence, \"Enter a sentence\");\n    askQuestionString(wordToRemove, \"Enter a word to remove\");\n    wordRemove(sentence, wordToRemove);\n    printf(\"Sentence after '%s' removed -- %s\\n\", wordToRemove, sentence);\n    return 0;\n}\n","function_prediction":"int wordRemove_handler_name_conflict() {\n  char sentence[1000];\n  char word[1000];\n\n  askQuestionString(sentence, \"Enter a sentence\");\n  askQuestionString(word, \"Enter a word to remove\");\n\n  wordRemove(sentence, word);\n\n  printf(\"Sentence after '%s' removed -- %s\\n\", word, sentence);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int vowelCheck_handler(char *array) {\n    int vowels = 0;\n    vowelCheck(array, &vowels);\n    return 0;\n}\n","function_prediction":"int vowelCheck_handler_name_conflict(char *input) {\n  int count = 0;\n  vowelCheck(input, &count);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int subString_handler(char *array) {\n    int start = 0, end = 0;\n    if (askQuestionInt(&start, \"Input start of substring\") == 1 || askQuestionInt(&end, \"Input end of substring\") == 1) {\n        return 1;\n    }\n    subString(array, start, end);\n    printf(\"String has been modified -- new string -- %s\\n\", array);\n    return 0;\n}\n","function_prediction":"int subString_handler_name_conflict(char *string) {\n  int start = 0, end = 0;\n  if (askQuestionInt(&start, \"Input start of substring\") == 1)\n    return 1;\n  if (askQuestionInt(&end, \"Input end of substring\") == 1)\n    return 1;\n  subString(string, start, end);\n  printf(\"String has been modified -- new string -- %s\\n\", string);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int concatStrings_handler(char *array) {\n    char one[100], two[100];\n    if (askQuestionString(one, \"Input first of string\") == 1 || askQuestionString(two, \"Input second of string\") == 1) {\n        return 1;\n    }\n    concatenateStrings(one, two);\n    printf(\"Concatenated Strings -- %s\\n\", one);\n    return 0;\n}\n","function_prediction":"int concatStrings_handler_name_conflict() {\n  char str1[100], str2[100];\n\n  if (askQuestionString(str1, \"Input first of string\") == 1)\n    return 1;\n\n  if (askQuestionString(str2, \"Input second of string\") == 1)\n    return 1;\n\n  concatenateStrings(str1, str2);\n  printf(\"Concatenated Strings -- %s\\n\", str1);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int printHandler(char *array) {\n    printf(\"%s\\n\", array);\n    return 0;\n}\n","function_prediction":"int printHandler_name_conflict(char *msg) {\n  puts(msg);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int isAlpha_handler(char *array) {\n    char c;\n    printf(\"\\nEnter a Char :: \");\n    scanf(\" %c\", &c);\n    int isAlphaNum = alphaNumeric(c);\n    return 0;\n}\n","function_prediction":"int isAlpha_handler_name_conflict() {\n  char ch;\n  printf(\"\\nEnter a Char :: \");\n  __isoc99_scanf(\"%c\", &ch);\n  alphaNumeric(ch);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_main.c"}
{"compilable":1,"function":"int printMenu(char **array, int arrayLength) {\n    int i;\n    printf(\"\\n\\n Created by Nathan Morin for CNIT 315 Purdue University\\n\\n\");\n    for (i = 0; i < arrayLength; i++) {\n        printf(\"\\t%d for %s\\n\", i, array[i]);\n    }\n    return 0;\n}\n","function_prediction":"int printMenu_name_conflict(char *menu[], int numOptions) {\n  int i;\n\n  printf(\"\\n\\n Created by Nathan Morin for CNIT 315 Purdue University\\n\\n\");\n\n  for (i = 0; i < numOptions; i++) {\n    printf(\"\\t%d for %s\\n\", i, menu[i]);\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":1,"function":"int askQuestionInt(int *value, char *q) {\n    printf(\"\\n%s : \", q);\n    scanf(\"%d\", value);\n    if (*value == -1) {\n        return -1;\n    }\n    while (getchar() != '\\n')\n        ;\n    return 0;\n}\n","function_prediction":"int askQuestionInt_name_conflict(int *answer) {\n  printf(\"\\n%s : \", \"Entrez un nombre\");\n  __isoc99_scanf(\"%d\", answer);\n  if (*answer == -1)\n    return -1;\n  while (getc(stdin) != '\\n')\n    ;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":1,"function":"int askQuestionString(char *value, char *q) {\n    printf(\"%s : \", q);\n    scanf(\"%[^\\t\\n]s\", value);\n    printf(\"%s\\n\", value);\n    while (getchar() != '\\n')\n        ;\n    return 0;\n}\n","function_prediction":"int askQuestionString_name_conflict(char *question) {\n  printf(\"%s : \", question);\n  __isoc99_scanf(\"%[^\\t\\n]s\", question);\n  puts(question);\n  while (getc(stdin) != '\\n')\n    ;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/console.c"}
{"compilable":0,"function":"int wordCount(char *sentence_array, int *numWords) {\n    if (sentence_array == '\\x00') {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    *numWords = CountWords(sentence_array, 0, 0, 1000);\n    return 0;\n}\n","function_prediction":"int wordCount_handler(char *input) {\n  int count = 0;\n  wordCount(input, &count);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int CountWords(char *sentence_array, int count, int start, int maxSize) {\n    if (count < 0) {\n        printf(\"ERROR: count needs to be greater than 0.\\n\");\n        return 1;\n    }\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (start > maxSize) {\n        printf(\"ERROR: the start point was greater than the max size.\\n\");\n        return 1;\n    }\n    if (start < 0 || maxSize < 0) {\n        printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n        return 1;\n    }\n    if (sentence_array[0] == ' ') {\n        printf(\"ERROR: the first character in the array was empty. Please start your sentence from the beginning.\\n\");\n        return 1;\n    }\n    int a = 0;\n    while (sentence_array[a] != '\\x00')\n        {\n            a++;\n        }\n    maxSize = a;\n    if (sentence_array[start] == ' ' && sentence_array[start - 1] != ' ' && start != (maxSize - 1)) {\n        count = count + 1;\n    }\n    if (start != maxSize) {\n        count = CountWords(sentence_array, count, (start + 1), maxSize);\n    }\n    if (start == maxSize) {\n        count++;\n        printf(\"number of words: %d\\n\", count);\n        return count;\n    }\n    return count;\n}\n","function_prediction":"int CountWords_name_conflict(char *array, int count, int start, int max) {\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\n  if (count < 0) {\n    printf(\"ERROR: count needs to be greater than 0.\\n\");\n    return 1;\n  }\n\n  if (array == NULL) {\n    printf(\"ERROR: array entered was null.\\n\");\n    return 1;\n  }\n\n  if (start > max) {\n    printf(\"ERROR: the start point was greater than the max size.\\n\");\n    return 1;\n  }\n\n  if (start < 0 || max < 0) {\n    printf(\"ERROR: the start point or the max size were set less than zero.\\n\");\n    return 1;\n  }\n\n  if (array[0] == ' ') {\n    printf(\"ERROR: the first character in the array was empty. Please start \"\n           \"your sentence from the beginning.\\n\");\n    return 1;\n  }\n\n  while (array[max] != '\\0') {\n    max++;\n  }\n\n  while (i != max) {\n    if (array[i] == ' ' && array[i - 1] != ' ') {\n      if (i != start) {\n        count++;\n      }\n    }\n\n    i++;\n  }\n\n  printf(\"number of words: %d\\n\", count + 1);\n\n  return count + 1;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int wordRemove(char *sentence_array, char *word) {\n    if (sentence_array == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    if (word == ((void *)0)) {\n        printf(\"ERROR: array entered was null.\\n\");\n        return 1;\n    }\n    int sizeSentence = 0;\n    while (sentence_array[sizeSentence] != '\\x00')\n        {\n            sizeSentence++;\n        }\n    int sizeWord = 0;\n    while (word[sizeWord] != '\\x00')\n        {\n            sizeWord++;\n        }\n    int head = -1, scanner, stop = sizeSentence - sizeWord;\n    int found = 0;\n    while (head <= stop && found == 0)\n        {\n            head++;\n            scanner = 0;\n            if (sentence_array[head] == word[0]) {\n                while (scanner < sizeWord)\n                    {\n                        found = 1;\n                        if (sentence_array[head + scanner] != word[scanner]) {\n                            found = 0;\n                            break;\n                        }\n                        scanner++;\n                    }\n            }\n        }\n    int i = head;\n    while (sentence_array[i + sizeWord] != '\\x00')\n        {\n            sentence_array[i] = sentence_array[i + sizeWord];\n            i++;\n        }\n    sentence_array[i] = '\\x00';\n    return 0;\n}\n","function_prediction":"int wordRemove_handler() {\n  char sentence[1000];\n  char word[1000];\n\n  askQuestionString(sentence, \"Enter a sentence\");\n  askQuestionString(word, \"Enter a word to remove\");\n\n  wordRemove(sentence, word);\n\n  printf(\"Sentence after '%s' removed -- %s\\n\", word, sentence);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int vowelCheck(char *array, int *vowels) {\n    int i;\n    *vowels = 0;\n    for (i = 0; array[i] != '\\x00'; i++) {\n        if ((array[i] == 'a' || array[i] == 'e' || array[i] == 'i' || array[i] == 'o' || array[i] == 'u') || (array[i] == 'A' || array[i] == 'E' || array[i] == 'I' || array[i] == 'O' || array[i] == 'U')) {\n            *vowels = *vowels + 1;\n        }\n    }\n    printf(\"No. of vowels in %s = %d\\n\", array, *vowels);\n    return 0;\n}\n","function_prediction":"int vowelCheck_handler(char *input) {\n  int count = 0;\n  vowelCheck(input, &count);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int subString(char *array1, int index1, int index2) {\n    int position;\n    int i = 0;\n    char input2[100];\n    if (array1 == ((void *)0)) {\n        return 1;\n    }\n    position = index1;\n    for (i = 0; array1[i] != '\\x00'; i++ , position++) {\n        if (position <= index2) {\n            array1[i] = array1[position];\n        } else {\n            array1[i] = ((void *)0);\n        }\n    }\n    return 0;\n}\n","function_prediction":"int subString_handler(char *string) {\n  int start = 0, end = 0;\n  if (askQuestionInt(&start, \"Input start of substring\") == 1)\n    return 1;\n  if (askQuestionInt(&end, \"Input end of substring\") == 1)\n    return 1;\n  subString(string, start, end);\n  printf(\"String has been modified -- new string -- %s\\n\", string);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int concatenateStrings(char *str1, char *str2) {\n    int firstArrayLength = 0;\n    int secondArrayLength = 0;\n    while (str1[firstArrayLength] != '\\x00')\n        {\n            firstArrayLength++;\n        }\n    printf(\"%d\", firstArrayLength);\n    while (str2[secondArrayLength] != '\\x00')\n        {\n            str1[firstArrayLength] = str2[secondArrayLength];\n            secondArrayLength++;\n            firstArrayLength++;\n        }\n    str1[firstArrayLength] = '\\x00';\n    return 0;\n}\n","function_prediction":"int concatenateStrings_name_conflict(char *s1, char *s2) {\n  int i, j;\n  for (i = 0; s1[i] != '\\0'; i++)\n    ;\n  printf(\"%d\", i);\n  for (j = 0; s2[j] != '\\0'; j++)\n    s1[i + j] = s2[j];\n  s1[i + j] = '\\0';\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":0,"function":"int printString() {\n    char mystring[50];\n    printf(\"Please type a string\\n\\n\");\n    scanf(\"\\n%50[^\\n]s\", mystring);\n    printf(\"%s\\n\", mystring);\n}\n","function_prediction":"int printStringWLen(char *str, int *len) {\n  char str2[50];\n  if (str[0] == '\\0') {\n    printf(\"Error -- array is null\");\n    return 1;\n  } else {\n    *len = strlen(str) + 1;\n    printf(\"You Entered:%s\\n\", str);\n    printf(\"The Length of the string is: %d\\n\", *len);\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int printStringWLen(char *array, int *length) {\n    if (array[0] == '\\x00') {\n        printf(\"Error -- array is null\");\n        return 1;\n    }\n    int number = 0;\n    while (array[number] != '\\x00')\n        {\n            number++;\n        }\n    *length = number;\n    printf(\"You Entered:%s\\n\", array);\n    printf(\"The Length of the string is: %d\\n\", *length);\n    return 0;\n}\n","function_prediction":"int printStringWLen_name_conflict(char *str, int *len) {\n  if (str[0] == '\\0') {\n    printf(\"Error -- array is null\");\n    return 1;\n  }\n  *len = strlen(str + 1) + 1;\n  printf(\"You Entered:%s\\n\", str);\n  printf(\"The Length of the string is: %d\\n\", *len);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"int alphaNumeric(char ch) {\n    if (ch >= '0' && ch <= '9') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'A' && ch <= 'Z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else if (ch >= 'a' && ch <= 'z') {\n        printf(\"|%c| is alphanumeric.\\n\", ch);\n    } else {\n        printf(\"%c is not alphanumeric.\\n\", ch);\n    }\n    return 0;\n}\n","function_prediction":"int alphaNumeric_name_conflict(char c) {\n  if (((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||\n       (c >= '0' && c <= '9'))) {\n    printf(\"|%c| is alphanumeric.\\n\", c);\n  } else {\n    printf(\"%c is not alphanumeric.\\n\", c);\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/nathanamorin_CNIT315Lab4Main/lab4_lib.c"}
{"compilable":1,"function":"static int foo1(void) {\n    return 1;\n}\n","function_prediction":"int foo1_name_conflict(void) {\n  int x = 1;\n  return x;\n}","pass":1,"source_file":"C_COMPILE/keszybz_prelink/testsuite/ifunctest.c"}
{"compilable":1,"function":"static int foo2(void) {\n    return 2;\n}\n","function_prediction":"int foo2_name_conflict(void) { return 2; }","pass":1,"source_file":"C_COMPILE/keszybz_prelink/testsuite/ifunctest.c"}
{"compilable":0,"function":"int tty_break() {\n    struct termio modmodes;\n    if (ioctl(fileno(stdin), 21509, &saved_modes) == -1) {\n        return -1;\n    }\n    have_modes = 1;\n    modmodes = saved_modes;\n    modmodes.c_lflag &= ~(2 | 8);\n    modmodes.c_cc[6] = 1;\n    modmodes.c_cc[5] = 0;\n    return ioctl(fileno(stdin), 21511, &modmodes);\n}\n","function_prediction":"void tty_break_name_conflict(void) {\n  struct sgttyb tty;\n\n  if (ioctl(fileno(stdin), 0x5405, &saved_modes) == -1)\n    return;\n\n  tty = saved_modes;\n  have_modes = 1;\n\n  tty.sg_flags &= ~(0x0001 | 0x0002);\n\n  ioctl(fileno(stdin), 0x5407, &tty);\n}","pass":0,"source_file":"C_COMPILE/jtyr_legoirc-server/src/legoirc-client.c"}
{"compilable":0,"function":"int tty_fix() {\n    if (!have_modes) {\n        return 0;\n    }\n    return ioctl(fileno(stdin), 21511, &saved_modes);\n}\n","function_prediction":"void tty_fix_part_0(void) { ioctl(fileno(stdin), 0x5407, &saved_modes); }","pass":0,"source_file":"C_COMPILE/jtyr_legoirc-server/src/legoirc-client.c"}
{"compilable":0,"function":"size_t fmsynth_preset_size(void) {\n    return 8 + sizeof(struct fmsynth_preset_metadata) + FMSYNTH_PARAM_END * 8 * sizeof(uint32_t) + FMSYNTH_GLOBAL_PARAM_END * sizeof(uint32_t);\n}\n","function_prediction":"int fmsynth_preset_size_name_conflict(void) { return 1040; }","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"static uint32_t read_u32(const uint8_t *buffer) {\n    return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | (buffer[3] << 0);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"unsigned int fmsynth_get_version(void) {\n    return 2;\n}\n","function_prediction":"int fmsynth_get_version_name_conflict(void) { return 2; }","pass":0,"source_file":"C_COMPILE/Themaister_libfmsynth/src/fmsynth.c"}
{"compilable":0,"function":"int User_Authonrize(struct user *list_head, struct user *login) {\n    User_Login(login);\n    list_head = list_head->next;\n    while (list_head != ((void *)0))\n        {\n            if (!strcmp(login->ID, list_head->ID)) {\n                if (!strcmp(login->Key, list_head->Key)) {\n                    memcpy(login, list_head, sizeof(struct user));\n                    return 0;\n                }\n            }\n            list_head = list_head->next;\n        }\n    return -1;\n}\n","function_prediction":"int User_Authonrize_name_conflict(User_List *user_list, User *user) {\n  User_Login(user);\n  User *p = user_list->head;\n  while (p) {\n    if (!strcmp(user->name, p->name) && !strcmp(user->password, p->password)) {\n      *user = *p;\n      return 0;\n    }\n    p = p->next;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/sys.c"}
{"compilable":0,"function":"int getch(void) {\n    struct termios tm, tm_bak;\n    if (tcgetattr(0, &tm) < 0) {\n        perror(\"tcgetattr\");\n        exit(-1);\n    }\n    tm_bak = tm;\n    cfmakeraw(&tm);\n    if (tcsetattr(0, 0, &tm) < 0) {\n        perror(\"tcsetattr\");\n        exit(-1);\n    }\n    int ch = getchar();\n    if (tcsetattr(0, 0, &tm_bak) < 0) {\n        perror(\"tcsetattr\");\n        exit(-1);\n    }\n    if (ch == 3 || ch == 4)\n        exit(0);\n    else\n        return ch;\n}\n","function_prediction":"int getch_name_conflict() {\n  struct termios oldt, newt;\n  int ch;\n  int oldf;\n\n  if (tcgetattr(0, &oldt) < 0) {\n    perror(\"tcgetattr\");\n    exit(-1);\n  }\n  newt = oldt;\n\n  cfmakeraw(&newt);\n\n  if (tcsetattr(0, 0, &newt) < 0) {\n    perror(\"tcsetattr\");\n    exit(-1);\n  }\n\n  ch = getc(stdin);\n\n  if (tcsetattr(0, 0, &oldt) < 0) {\n    perror(\"tcsetattr\");\n    exit(-1);\n  }\n\n  switch (ch) {\n  case 3:\n  case 4:\n    exit(0);\n  }\n\n  return ch;\n}","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/getch.c"}
{"compilable":0,"function":"int Change_User_Passwd(struct user **list_head, char *key) {\n    struct user *pcur = (*list_head)->next;\n    while (pcur != ((void *)0))\n        {\n            if (!(strcmp(pcur->ID, key) && strcmp(pcur->Name, key))) {\n                char passwd_1[20] = {0};\n                char passwd_2[20] = {0};\n                int i;\n                for (i = 0; i < 3; i++) {\n                    printf(\"New password:\");\n                    scanf(\"%s\", passwd_1);\n                    printf(\"Retype new password:\");\n                    scanf(\"%s\", passwd_2);\n                    if (!strcmp(passwd_1, passwd_2)) {\n                        strcpy(pcur->Key, passwd_1);\n                        puts(\"all authentication tokens updated successfully.\");\n                        break;\n                    } else\n                        puts(\"Sorry, passwords do not match.\");\n                }\n                if (i == 3)\n                    puts(\"Have exhausted maximum number of retries for service\");\n                break;\n            }\n            pcur = pcur->next;\n        }\n    if (pcur == ((void *)0))\n        return -1;\n    return 0;\n}\n","function_prediction":"int Change_User_Passwd_name_conflict(struct passwd *pw, char *user) {\n  struct passwd *p;\n  int i;\n  char passwd1[16] = {0};\n  char passwd2[16] = {0};\n\n  for (p = pw->pw_shell; p; p = p->pw_shell) {\n    if (!strcmp(p->pw_passwd, user) || !strcmp(p->pw_name, user)) {\n      for (i = 0; i < 3; i++) {\n        printf(\"New password:\");\n        __isoc99_scanf(\"%s\", passwd1);\n        printf(\"Retype new password:\");\n        __isoc99_scanf(\"%s\", passwd2);\n        if (!strcmp(passwd1, passwd2)) {\n          strcpy(p->pw_passwd, passwd1);\n          printf(\"all authentication tokens updated successfully.\\n\");\n          return 0;\n        }\n        printf(\"Sorry, passwords do not match.\\n\");\n      }\n      printf(\"Have exhausted maximum number of retries for service\\n\");\n      return 0;\n    }\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/honeytavis_sims/src/linklist.c"}
{"compilable":1,"function":"const char *memstr(const char *full_data, int full_data_len, const char *substr) {\n    if (full_data == ((void *)0) || full_data_len <= 0 || substr == ((void *)0)) {\n        return ((void *)0);\n    }\n    if (*substr == '\\x00') {\n        return ((void *)0);\n    }\n    int sublen = strlen(substr);\n    int i;\n    const char *cur = full_data;\n    int last_possible = full_data_len - sublen + 1;\n    for (i = 0; i < last_possible; i++) {\n        if (*cur == *substr) {\n            if (memcmp(cur, substr, sublen) == 0) {\n                return cur;\n            }\n        }\n        cur++;\n    }\n    return ((void *)0);\n}\n","function_prediction":"char *memstr_name_conflict(char *haystack, int hlen, char *needle) {\n  int nlen;\n  int i;\n  char c;\n\n  if (hlen <= 0 || !haystack || !needle)\n    return NULL;\n\n  c = *needle;\n  if (!c)\n    return NULL;\n\n  nlen = strlen(needle);\n  hlen -= nlen;\n\n  for (i = 0; i <= hlen; i++) {\n    if (haystack[i] == c && !memcmp(haystack + i, needle, nlen))\n      return haystack + i;\n  }\n\n  return NULL;\n}","pass":1,"source_file":"C_COMPILE/qwerty258_HLSDownload_old/utils.c"}
{"compilable":0,"function":"int isdirreducable() {\n    int ndirs = (int)pow(2, directory->globle_depth);\n    for (int i = 0; i < ndirs; ++i) {\n        if (directory->dir_elem_list[i].flag == -1) {\n            if (directory->dir_elem_list[i].bucket->local_depth == directory->globle_depth) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"int isdirreducable_name_conflict(void) {\n  int i, n;\n  struct dir *d;\n\n  n = directory->n;\n  for (i = 0, d = directory->dir; i < pow(2, n); i++, d++)\n    if (d->index == -1 && d->dir[0] == n)\n      return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/nilesh2014_Extendible-Hashing/hashing.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint8(uint8_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (value <= 23) {\n        if (buffer_size >= 1) {\n            buffer[0] = value + offset;\n            return 1;\n        }\n    } else {\n        if (buffer_size >= 2) {\n            buffer[0] = 24 + offset;\n            buffer[1] = value;\n            return 2;\n        }\n    }\n    return 0;\n}\n","function_prediction":"size_t _cbor_encode_uint8(uint8_t value, uint8_t *buffer, size_t buffer_size,\n                          uint8_t offset) {\n  if (value < 24) {\n    if (buffer_size == 0) {\n      return 0;\n    }\n    buffer[0] = value + offset;\n    return 1;\n  }\n  if (buffer_size < 2) {\n    return 0;\n  }\n  buffer[0] = 24 + offset;\n  buffer[1] = value;\n  return 2;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint16(uint16_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 3) {\n        buffer[0] = 25 + offset;\n        buffer[1] = (unsigned char)(value >> 8);\n        buffer[2] = (unsigned char)value;\n        return 3;\n    } else\n        return 0;\n}\n","function_prediction":"size_t _cbor_encode_uint16(unsigned short value, unsigned char *buffer,\n                           size_t buffer_size, unsigned char offset) {\n  if (buffer_size < 3)\n    return 0;\n\n  buffer[0] = 0x19 + offset;\n  buffer[1] = (value >> 8) & 0xff;\n  buffer[2] = value & 0xff;\n\n  return 3;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint32(uint32_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 5) {\n        buffer[0] = 26 + offset;\n        buffer[1] = (unsigned char)(value >> 24);\n        buffer[2] = (unsigned char)(value >> 16);\n        buffer[3] = (unsigned char)(value >> 8);\n        buffer[4] = (unsigned char)value;\n        return 5;\n    } else\n        return 0;\n}\n","function_prediction":"size_t _cbor_encode_uint32(uint32_t value, uint8_t *buffer, size_t buffer_size,\n                           uint8_t major_type) {\n  if (buffer_size < 5)\n    return 0;\n\n  buffer[0] = (uint8_t)((value >> 24) & 0xFF) << 5 | major_type;\n  buffer[1] = (uint8_t)((value >> 16) & 0xFF);\n  buffer[2] = (uint8_t)((value >> 8) & 0xFF);\n  buffer[3] = (uint8_t)(value & 0xFF);\n  buffer[4] = 26;\n\n  return 5;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint64(uint64_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (buffer_size >= 9) {\n        buffer[0] = 27 + offset;\n        buffer[1] = (unsigned char)(value >> 56);\n        buffer[2] = (unsigned char)(value >> 48);\n        buffer[3] = (unsigned char)(value >> 40);\n        buffer[4] = (unsigned char)(value >> 32);\n        buffer[5] = (unsigned char)(value >> 24);\n        buffer[6] = (unsigned char)(value >> 16);\n        buffer[7] = (unsigned char)(value >> 8);\n        buffer[8] = (unsigned char)value;\n        return 9;\n    } else\n        return 0;\n}\n","function_prediction":"size_t _cbor_encode_uint64(uint64_t value, uint8_t *buffer, size_t buffer_size,\n                           uint8_t major_type) {\n  if (buffer_size < 9)\n    return 0;\n\n  buffer[0] = (uint8_t)((value >> 56) & 0xFF);\n  buffer[1] = (uint8_t)((value >> 48) & 0xFF);\n  buffer[2] = (uint8_t)((value >> 40) & 0xFF);\n  buffer[3] = (uint8_t)((value >> 32) & 0xFF);\n  buffer[4] = (uint8_t)((value >> 24) & 0xFF);\n  buffer[5] = (uint8_t)((value >> 16) & 0xFF);\n  buffer[6] = (uint8_t)((value >> 8) & 0xFF);\n  buffer[7] = (uint8_t)(value & 0xFF);\n  buffer[8] = (uint8_t)(0x1B | major_type);\n\n  return 9;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t _cbor_encode_uint(uint64_t value, unsigned char *buffer, size_t buffer_size, uint8_t offset) {\n    if (value <= (65535))\n        if (value <= (255))\n            return _cbor_encode_uint8((uint8_t)value, buffer, buffer_size, offset);\n        else\n            return _cbor_encode_uint16((uint16_t)value, buffer, buffer_size, offset);\n    else if (value <= (4294967295U))\n        return _cbor_encode_uint32((uint32_t)value, buffer, buffer_size, offset);\n    else\n        return _cbor_encode_uint64((uint64_t)value, buffer, buffer_size, offset);\n}\n","function_prediction":"size_t _cbor_encode_uint(uint64_t value, uint8_t *buffer, size_t buffer_size,\n                         uint8_t major_type) {\n  if (value < 24) {\n    if (buffer_size == 0) {\n      return 0;\n    }\n    buffer[0] = (uint8_t)value | major_type;\n    return 1;\n  }\n  if (value < 0x100) {\n    if (buffer_size < 2) {\n      return 0;\n    }\n    buffer[0] = (uint8_t)value | major_type;\n    buffer[1] = (uint8_t)(value >> 8);\n    return 2;\n  }\n  if (value < 0x10000) {\n    if (buffer_size < 3) {\n      return 0;\n    }\n    buffer[0] = (uint8_t)(0x18 + major_type);\n    buffer[1] = (uint8_t)value;\n    buffer[2] = (uint8_t)(value >> 8);\n    return 3;\n  }\n  if (value < 0x1000000) {\n    if (buffer_size < 5) {\n      return 0;\n    }\n    buffer[0] = (uint8_t)(0x19 + major_type);\n    buffer[1] = (uint8_t)value;\n    buffer[2] = (uint8_t)(value >> 8);\n    buffer[3] = (uint8_t)(value >> 16);\n    buffer[4] = (uint8_t)(value >> 24);\n    return 5;\n  }\n  if (value < 0x100000000) {\n    if (buffer_size < 9) {\n      return 0;\n    }\n    buffer[0] = (uint8_t)(0x1a + major_type);\n    buffer[1] = (uint8_t)value;\n    buffer[2] = (uint8_t)(value >> 8);\n","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/internal/encoders.c"}
{"compilable":0,"function":"size_t cbor_encode_uint8(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 0);\n}\n","function_prediction":"size_t cbor_encode_uint8_name_conflict(uint8_t value, uint8_t *buffer, size_t buffer_size) {\n  return _cbor_encode_uint8_name_conflict(value, buffer, buffer_size, 0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint16(uint16_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint16(value, buffer, buffer_size, 0);\n}\n","function_prediction":"size_t cbor_encode_uint16_name_conflict(uint16_t value, uint8_t *buffer, size_t buffer_size) {\n  return _cbor_encode_uint16_name_conflict(value, buffer, buffer_size, 0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint32(uint32_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint32(value, buffer, buffer_size, 0);\n}\n","function_prediction":"int cbor_encode_uint32_name_conflict(cbor_value_t *iter, uint32_t value) {\n  return _cbor_encode_uint32_name_conflict(iter, value);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint64(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint64(value, buffer, buffer_size, 0);\n}\n","function_prediction":"size_t cbor_encode_uint64_name_conflict(uint64_t value, uint8_t *buffer, size_t buffer_size) {\n  return _cbor_encode_uint64_name_conflict(value, buffer, buffer_size, 0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_uint(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 0);\n}\n","function_prediction":"void cbor_encode_uint8(uint8_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint8(value, buffer, index, 0);\n}\n\nvoid cbor_encode_uint16(uint16_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint16(value, buffer, index, 0);\n}\n\nvoid cbor_encode_uint32(uint32_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint32(value, buffer, index, 0);\n}\n\nvoid cbor_encode_uint64(uint64_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint64(value, buffer, index, 0);\n}\n\nvoid cbor_encode_uint(uint64_t value, uint8_t *buffer, size_t *index) {\n  _cbor_encode_uint(value, buffer, index, 0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint8(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 32);\n}\n","function_prediction":"int cbor_encode_negint8_name_conflict(uint8_t value, uint8_t *buffer, size_t len) {\n  return _cbor_encode_uint8(value, buffer, len, 32);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint16(uint16_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint16(value, buffer, buffer_size, 32);\n}\n","function_prediction":"int cbor_encode_negint16_name_conflict(cbor_stream_t *st, uint16_t value) {\n  return _cbor_encode_uint16(st, value, 32);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint32(uint32_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint32(value, buffer, buffer_size, 32);\n}\n","function_prediction":"int cbor_encode_negint32_name_conflict(cbor_stream_t *st, int32_t val) {\n  return _cbor_encode_uint32(st, (uint32_t)val);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint64(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint64(value, buffer, buffer_size, 32);\n}\n","function_prediction":"int cbor_encode_negint64_name_conflict(cbor_stream_t *st, int64_t val) {\n  return _cbor_encode_uint64(st, (uint64_t)val);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_negint(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 32);\n}\n","function_prediction":"size_t cbor_encode_negint8(int8_t value, uint8_t *buffer, size_t buffer_size) {\n  return _cbor_encode_uint8(value, buffer, buffer_size, 0x20);\n}\n\nsize_t cbor_encode_negint16(int16_t value, uint8_t *buffer,\n                            size_t buffer_size) {\n  return _cbor_encode_uint16(value, buffer, buffer_size, 0x20);\n}\n\nsize_t cbor_encode_negint32(int32_t value, uint8_t *buffer,\n                            size_t buffer_size) {\n  return _cbor_encode_uint32(value, buffer, buffer_size, 0x20);\n}\n\nsize_t cbor_encode_negint64(int64_t value, uint8_t *buffer,\n                            size_t buffer_size) {\n  return _cbor_encode_uint64(value, buffer, buffer_size, 0x20);\n}\n\nsize_t cbor_encode_negint(int value, uint8_t *buffer, size_t buffer_size) {\n  return _cbor_encode_uint(value, buffer, buffer_size, 0x20);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_bytestring_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 64);\n}\n","function_prediction":"int cbor_encode_bytestring_start_name_conflict(cbor_encode_buffer_t *buffer, size_t length) {\n  return _cbor_encode_uint(buffer, length);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t _cbor_encode_byte(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    if (buffer_size >= 1) {\n        buffer[0] = value;\n        return 1;\n    } else\n        return 0;\n}\n","function_prediction":"size_t _cbor_encode_byte_name_conflict(uint8_t value, uint8_t *buffer, size_t buffer_size) {\n  if (buffer_size < 1) {\n    return 0;\n  }\n\n  buffer[0] = value;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_bytestring_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(95, buffer, buffer_size);\n}\n","function_prediction":"size_t cbor_encode_indef_bytestring_start_name_conflict(uint8_t *buffer, size_t buffer_size) {\n  if (buffer_size < 1) {\n    return 0;\n  }\n\n  buffer[0] = 0x5F;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_string_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 96);\n}\n","function_prediction":"int cbor_encode_string_start_name_conflict(cbor_encode_buffer_t *buffer, size_t length) {\n  return _cbor_encode_uint(buffer, length);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_string_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(127, buffer, buffer_size);\n}\n","function_prediction":"size_t cbor_encode_indef_string_start_name_conflict(uint8_t *buffer, size_t buffer_size) {\n  if (buffer_size < 1) {\n    return 0;\n  }\n\n  buffer[0] = 0x7F;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_array_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 128);\n}\n","function_prediction":"int cbor_encode_array_start_name_conflict(cbor_encode_buffer_t *buffer, size_t size) {\n  return _cbor_encode_uint(buffer, size, 0x98);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_array_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(159, buffer, buffer_size);\n}\n","function_prediction":"size_t cbor_encode_indef_array_start_name_conflict(uint8_t *buffer, size_t buffer_size) {\n  if (buffer_size < 1) {\n    return 0;\n  }\n\n  buffer[0] = 0x9F;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_map_start(size_t length, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint((size_t)length, buffer, buffer_size, 160);\n}\n","function_prediction":"int cbor_encode_map_start_name_conflict(cbor_encode_buffer_t *buffer, size_t size) {\n  return _cbor_encode_uint(buffer, size, 0x8000000000000000ull);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_indef_map_start(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(191, buffer, buffer_size);\n}\n","function_prediction":"size_t cbor_encode_indef_map_start_name_conflict(uint8_t *buffer, size_t buffer_size) {\n  if (buffer_size < 1) {\n    return 0;\n  }\n\n  buffer[0] = 0xBF;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_tag(uint64_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint(value, buffer, buffer_size, 192);\n}\n","function_prediction":"int cbor_encode_tag_name_conflict(cbor_stream_t *s, uint64_t tag) {\n  return _cbor_encode_uint(s, tag);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_bool(bool value, unsigned char *buffer, size_t buffer_size) {\n    return value ? _cbor_encode_byte(245, buffer, buffer_size) : _cbor_encode_byte(244, buffer, buffer_size);\n}\n","function_prediction":"size_t cbor_encode_bool_name_conflict(char b, unsigned char *buf, size_t len) {\n  if (b) {\n    if (len < 1)\n      return 0;\n    buf[0] = 0xf5;\n    return 1;\n  } else {\n    if (len < 1)\n      return 0;\n    buf[0] = 0xf4;\n    return 1;\n  }\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_null(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(246, buffer, buffer_size);\n}\n","function_prediction":"size_t cbor_encode_null_name_conflict(uint8_t *buffer, size_t buffer_size) {\n  if (buffer_size < 1) {\n    return 0;\n  }\n  buffer[0] = 0xf6;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_undef(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(247, buffer, buffer_size);\n}\n","function_prediction":"size_t cbor_encode_undef_name_conflict(uint8_t *buffer, size_t buffer_size) {\n  if (buffer_size < 1) {\n    return 0;\n  }\n  buffer[0] = 0xf7;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_break(unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_byte(255, buffer, buffer_size);\n}\n","function_prediction":"size_t cbor_encode_break_name_conflict(uint8_t *buffer, size_t buffer_size) {\n  if (buffer_size < 1) {\n    return 0;\n  }\n\n  buffer[0] = 0xFF;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":0,"function":"size_t cbor_encode_ctrl(uint8_t value, unsigned char *buffer, size_t buffer_size) {\n    return _cbor_encode_uint8(value, buffer, buffer_size, 224);\n}\n","function_prediction":"int cbor_encode_ctrl_name_conflict(uint8_t ctrl, uint8_t *buf, size_t *len) {\n  return _cbor_encode_uint8(ctrl, buf, len, 0xE0);\n}","pass":0,"source_file":"C_COMPILE/PJK_libcbor/src/cbor/encoding.c"}
{"compilable":1,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":1,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":1,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":1,"function":"int work(long loop_count) {\n    while (loop_count-- > 0)\n        {\n            syslog(6, \"loglog\");\n        }\n    return 0;\n}\n","function_prediction":"int work_name_conflict(long long n) {\n  while (n-- > 0) {\n    syslog(6, \"loglog\");\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_syslog.c"}
{"compilable":1,"function":"int test(long process_count, long loop_count) {\n    long i;\n    pid_t pid;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            work(loop_count);\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"int test_name_conflict(long n, long m) {\n  long i;\n  for (i = 0; i < n; i++) {\n    pid_t pid = fork();\n    if (pid < 0) {\n      puts(\"fork fail\");\n    } else if (pid == 0) {\n      long j;\n      for (j = 0; j < m; j++) {\n        syslog(6, \"loglog\");\n      }\n      return 0;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    wait(NULL);\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_syslog.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, (void *)j);\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"int test_name_conflict(long long n, long long m) {\n  long long i, j;\n  pthread_t tid[m];\n  for (i = 0; i < n; i++) {\n    pid_t pid = fork();\n    if (pid < 0) {\n      printf(\"fork fail\\n\");\n    } else if (pid == 0) {\n      for (j = 0; j < m; j++) {\n        pthread_create(&tid[j], NULL, work, (void *)j);\n      }\n      for (j = 0; j < m; j++) {\n        pthread_join(tid[j], NULL);\n      }\n      return 0;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    wait(NULL);\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_write2.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, ((void *)0));\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"int test_name_conflict(long long n, long long m) {\n  long long i, j;\n  pthread_t tid[m];\n  for (i = 0; i < n; i++) {\n    pid_t pid = fork();\n    if (pid < 0) {\n      printf(\"fork fail\\n\");\n    } else if (pid == 0) {\n      for (j = 0; j < m; j++) {\n        pthread_create(&tid[j], NULL, work, NULL);\n      }\n      for (j = 0; j < m; j++) {\n        pthread_join(tid[j], NULL);\n      }\n      return 0;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    wait(NULL);\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_zlog.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"char *sgets(char *s, int size, char **string) {\n    if (*string == ((void *)0))\n        return ((void *)0);\n    char *nlp = strchr(*string, '\\n');\n    char *fstring = *string;\n    if (nlp == ((void *)0)) {\n        if (strlen(fstring) > 0) {\n            nlp = fstring + strlen(fstring);\n        } else {\n            return ((void *)0);\n        }\n    }\n    int ss = (int)(nlp + 1 - fstring);\n    if (size > ss)\n        size = ss;\n    memcpy(s, *string, size);\n    s[size] = 0;\n    if (strlen(*string) == strlen(s)) {\n        *string = ((void *)0);\n    } else {\n        *string += size;\n    }\n    return s;\n}\n","function_prediction":"char *sgets_name_conflict(char *buf, int len, char **str) {\n  char *p;\n\n  if (*str == NULL)\n    return NULL;\n\n  p = strchr(*str, '\\n');\n  if (p == NULL) {\n    if (**str == '\\0')\n      return NULL;\n    p = *str + strlen(*str);\n  }\n\n  len = ((p + 1) - *str) < len ? (p + 1) - *str : len;\n  memcpy(buf, *str, len);\n  buf[len] = '\\0';\n\n  if (strlen(*str) == strlen(buf))\n    *str = NULL;\n  else\n    *str += len;\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/conf.c"}
{"compilable":0,"function":"static int zlog_file_cmp(zlog_file_t *a_file_1, zlog_file_t *a_file_2) {\n    return (a_file_1->index > a_file_2->index);\n}\n","function_prediction":"int zlog_file_cmp_name_conflict(const void *a, const void *b) {\n  return ((zlog_file_t *)a)->index > ((zlog_file_t *)b)->index;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/rotater.c"}
{"compilable":0,"function":"const char *zlog_version(void) {\n    return \"1.2.12\";\n}\n","function_prediction":"const char *zlog_version_name_conflict(void) { return \"1.2.12\"; }","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zlog.c"}
{"compilable":0,"function":"int zc_profile_inner(int flag, const char *file, const long line, const char *fmt, ...) {\n    va_list args;\n    char time_str[21];\n    FILE *fp = ((void *)0);\n    static char *debug_log = ((void *)0);\n    static char *error_log = ((void *)0);\n    static size_t init_flag = 0;\n    if (!init_flag) {\n        init_flag = 1;\n        debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n        error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n    }\n    switch (flag) {\n      case ZC_DEBUG:\n        if (debug_log == ((void *)0))\n            return 0;\n        fp = fopen(debug_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s DEBUG (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_WARN:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n      case ZC_ERROR:\n        if (error_log == ((void *)0))\n            return 0;\n        fp = fopen(error_log, \"a\");\n        if (!fp)\n            return -1;\n        zc_time(time_str, sizeof (time_str));\n        fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n        break;\n    }\n    __builtin_va_start(args, fmt);\n    vfprintf(fp, fmt, args);\n    __builtin_va_end(args);\n    fprintf(fp, \"\\n\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"int zc_profile_inner(int level, const char *file, long line, const char *func,\n                     const char *fmt, ...) {\n  va_list ap;\n  FILE *fp;\n  char time_str[21];\n  struct tm tm;\n  time_t t;\n  static int init_flag = 0;\n  static char *debug_log = NULL;\n  static char *error_log = NULL;\n\n  if (!init_flag) {\n    init_flag = 1;\n    debug_log = getenv(\"ZLOG_PROFILE_DEBUG\");\n    error_log = getenv(\"ZLOG_PROFILE_ERROR\");\n  }\n\n  if (level == 1) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s WARN  (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 2) {\n    if (error_log) {\n      fp = fopen64(error_log, \"a\");\n      if (fp == NULL) {\n        return -1;\n      }\n      time(&t);\n      localtime_r(&t, &tm);\n      strftime(time_str, sizeof(time_str), \"%m-%d %H:%M:%S\", &tm);\n      fprintf(fp, \"%s ERROR (%d:%s:%ld) \", time_str, getpid(), file, line);\n    } else {\n      return 0;\n    }\n  } else if (level == 0) {\n    if (debug_log) {\n      fp = fopen64(debug_log, \"a\");\n      if (fp == NULL) {\n","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/src/zc_profile.c"}
{"compilable":0,"function":"int test(long process_count, long thread_count) {\n    long i;\n    pid_t pid;\n    long j;\n    for (i = 0; i < process_count; i++) {\n        pid = fork();\n        if (pid < 0) {\n            printf(\"fork fail\\n\");\n        } else if (pid == 0) {\n            pthread_t tid[thread_count];\n            for (j = 0; j < thread_count; j++) {\n                pthread_create(&(tid[j]), ((void *)0), work, ((void *)0));\n            }\n            for (j = 0; j < thread_count; j++) {\n                pthread_join(tid[j], ((void *)0));\n            }\n            return 0;\n        }\n    }\n    for (i = 0; i < process_count; i++) {\n        pid = wait(((void *)0));\n    }\n    return 0;\n}\n","function_prediction":"int test_name_conflict(long long n, long long m) {\n  long long i, j;\n  pthread_t tid[m];\n  for (i = 0; i < n; i++) {\n    pid_t pid = fork();\n    if (pid < 0) {\n      printf(\"fork fail\\n\");\n    } else if (pid == 0) {\n      for (j = 0; j < m; j++) {\n        pthread_create(&tid[j], NULL, work, NULL);\n      }\n      for (j = 0; j < m; j++) {\n        pthread_join(tid[j], NULL);\n      }\n      return 0;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    wait(NULL);\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/lisongmin_zlog/test/test_press_write.c"}
{"compilable":0,"function":"int send_garp(int ifindex, __be32 sip, char *sha, __be32 tip, char *tha) {\n    static char buf[64];\n    struct sockaddr_ll sll;\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    ;\n    arp->ar_hrd = htons(1);\n    arp->ar_pro = htons(2048);\n    arp->ar_hln = 6;\n    arp->ar_pln = 4;\n    arp->ar_op = htons(2);\n    memcpy(p, sha, 6);\n    p += 6;\n    memcpy(p, &sip, 4);\n    p += 4;\n    memcpy(p, tha, 6);\n    p += 6;\n    memcpy(p, &tip, 4);\n    p += 4;\n    memset(&sll, 0, sizeof (sll));\n    sll.sll_protocol = htons(2054);\n    sll.sll_ifindex = ifindex;\n    sll.sll_halen = 6;\n    memset(sll.sll_addr, 255, 6);\n    if (sendto(arp_sock, buf, p - buf, 0, (struct sockaddr *)&sll, sizeof (sll)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\", __func__, ifindex, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int send_garp(int ifindex, int iftype, struct in_addr *sender, int sender_type,\n              struct in_addr *target) {\n  struct sockaddr_ll sa;\n  struct timeval tv;\n\n  buf.ar_hrd = 1;\n  buf.ar_pro = 0x0800;\n  buf.ar_hln = 6;\n  buf.ar_pln = 4;\n  buf.ar_op = 2;\n  buf.ar_sip = sender->s_addr;\n  buf.ar_tip = target->s_addr;\n  buf.ar_tha[0] = 0xff;\n  buf.ar_tha[1] = 0xff;\n  buf.ar_tha[2] = 0xff;\n  buf.ar_tha[3] = 0xff;\n  buf.ar_tha[4] = 0xff;\n  buf.ar_tha[5] = 0xff;\n  buf.ar_sip = sender_type;\n  buf.ar_tip = iftype;\n\n  if (sendto(arp_sock, &buf, sizeof(buf), 0, (struct sockaddr *)&sa,\n             sizeof(sa)) < 0) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"send_garp\", ifindex, strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\",\n             \"send_garp\", ifindex, strerror(*__errno_location()));\n    }\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int recv_arp(int *ifindex, __u16 *type, __u16 *op, __be32 *sip, char *sha, __be32 *tip, char *tha) {\n    int len;\n    static char buf[1024];\n    struct sockaddr_ll sll;\n    socklen_t sll_len = sizeof (sll);\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    len = recvfrom(arp_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&sll, &sll_len);\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (len < sizeof (*arp) || (arp->ar_op != htons(1) && arp->ar_op != htons(2)) || arp->ar_pln != 4 || arp->ar_pro != htons(2048) || arp->ar_hln != 6 || len < sizeof (*arp) + 2 * 4 + 2 * 6) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = sll.sll_ifindex;\n    *type = sll.sll_pkttype;\n    *op = ntohs(arp->ar_op);\n    memcpy(sha, p, 6);\n    memcpy(sip, p + 6, 4);\n    memcpy(tha, p + 6 + 4, 6);\n    memcpy(tip, p + 6 + 4 + 6, 4);\n    return 0;\n}\n","function_prediction":"int recv_arp(unsigned int *ip, unsigned short *port, unsigned short *id,\n             unsigned int *mac, unsigned int *target, unsigned int *sender,\n             unsigned int *op) {\n  struct sockaddr_in from;\n  socklen_t fromlen = sizeof(from);\n  int n;\n\n  if ((n = recvfrom(arp_sock, buf_2, 1024, 0x40, (struct sockaddr *)&from,\n                    &fromlen)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"recv_arp\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\",\n             \"recv_arp\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  if (n < 28 || (buf_2[2] != 0x00 || buf_2[3] != 0x01) || buf_2[5] != 0x04 ||\n      buf_2[4] != 0x06 || buf_2[6] != 0x08) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\", tv.tv_sec,\n              tv.tv_usec, \"recv_arp\");\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\",\n             \"recv_arp\");\n    }\n    return -1;\n  }\n\n  *ip = from.sin_addr.s_addr;\n  *port = (buf_2[0] << 8) | buf_2[1];\n *id = (buf_","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":1,"function":"int open_arp(void) {\n    if ((arp_sock = socket(17, SOCK_DGRAM, htons(2054))) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return arp_sock;\n}\n","function_prediction":"int open_arp_name_conflict() {\n  struct timeval tv;\n\n  if ((arp_sock = socket(17, 2, 1544)) < 0) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"open_arp_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\",\n             \"open_arp_name_conflict\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n  return arp_sock;\n}","pass":1,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"static int fill_if_addrs(struct mpgw *gw) {\n    int sock, ret = -1;\n    struct ifreq ifr;\n    struct sockaddr_in saddr;\n    socklen_t len;\n    if ((sock = socket(2, SOCK_DGRAM, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    memset(&ifr, 0, sizeof (ifr));\n    ifr.ifr_ifru.ifru_ivalue = gw->if_id;\n    if (ioctl(sock, 35088, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, gw->if_id, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\", __func__, gw->if_id, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ioctl(sock, 35111, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ifr.ifr_ifru.ifru_hwaddr.sa_family != 1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid if %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name);\n        });\n        goto close_ret;\n    }\n    if (setsockopt(sock, 1, 25, ifr.ifr_ifrn.ifrn_name, strlen(ifr.ifr_ifrn.ifrn_name) + 1) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    memset(&saddr, 0, sizeof (saddr));\n    saddr.sin_family = 2;\n    saddr.sin_port = htons(1025);\n    saddr.sin_addr.s_addr = gw->gw_ip;\n    if (connect(sock, (struct sockaddr *)&saddr, sizeof (saddr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect to %s from %s %s\\\"}\", __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    len = sizeof (saddr);\n    if (getsockname(sock, (struct sockaddr *)&saddr, &len) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    ret = 0;\n    memcpy(gw->if_hw, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    gw->if_ip = saddr.sin_addr.s_addr;\n  close_ret:\n    close(sock);\n    return ret;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *add_mpgw(__be32 addr, int ifindex) {\n    int i, j = -1;\n    struct timespec now;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED) {\n            if (j == -1)\n                j = i;\n            continue;\n        }\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    if (j == -1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: not enough memory\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\", __func__);\n        });\n        return ((void *)0);\n    }\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return ((void *)0);\n    }\n    memset(&mpgws[j], 0, sizeof (mpgws[j]));\n    mpgws[j].gw_ip = addr;\n    mpgws[j].if_id = ifindex;\n    if (fill_if_addrs(&mpgws[j]) < 0)\n        return ((void *)0);\n    mpgws[j].last_sent = now;\n    mpgws[j].last_rcvd = now;\n    update_mpgw(&mpgws[j], MPGW_S_PROBE);\n    srandom(mpgws[j].if_ip);\n    return &mpgws[j];\n}\n","function_prediction":"struct mpgw *add_mpgw_name_conflict(int ip, int port) {\n  struct mpgw *mpgw;\n  struct ifreq ifr;\n  struct sockaddr_in sin;\n  struct timeval tv;\n  struct timespec ts;\n  int sock, i, found = -1;\n\n  for (i = 0; i < 32; i++) {\n    mpgw = &mpgws[i];\n    if (!mpgw->used) {\n      if (found == -1)\n        found = i;\n      continue;\n    }\n    if (mpgw->ip == ip && mpgw->port == port)\n      return mpgw;\n  }\n\n  if (found == -1) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: not enough memory\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, __func__);\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\",\n             __func__);\n    }\n    return NULL;\n  }\n\n  i = found;\n  mpgw = &mpgws[i];\n\n  if (clock_gettime(1, &ts) < 0) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, __func__,\n              strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\",\n             __func__, strerror(*__errno_location()));\n    }\n    return NULL;\n  }\n\n  mpgw->used = 0;\n  mpgw->ip = 0;\n  mpgw->port = 0;\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *find_mpgw(__be32 addr, int ifindex) {\n    int i;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED)\n            continue;\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    return ((void *)0);\n}\n","function_prediction":"struct mpgw_t *find_mpgw_name_conflict(int id, int port) {\n  int i;\n\n  for (i = 0; i < 32; i++) {\n    if (!mpgws[i].valid)\n      continue;\n    if (mpgws[i].id == id && mpgws[i].port == port)\n      return &mpgws[i];\n  }\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"int update_mpgw(struct mpgw *gw, enum mpgw_state newstate) {\n    if (gw->state == newstate)\n        return 0;\n    ({\n        if (foreground) {\n            struct timeval tv;\n            gettimeofday(&tv, ((void *)0));\n            fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec, tv.tv_usec, ip2str(gw->gw_ip), gw->if_id, newstate);\n        } else\n            syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\", ip2str(gw->gw_ip), gw->if_id, newstate);\n    });\n    gw->state = newstate;\n    if (gw->state == MPGW_S_PROBE)\n        gw->timeout = (1000 + 10 + random() % (1000));\n    else\n        gw->timeout = (60000 + random() % 30000);\n    return 1;\n}\n","function_prediction":"int update_mpgw_name_conflict(struct mpgw_info *mpgw, int state) {\n  if (mpgw->state == state)\n    return 0;\n\n  if (foreground) {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    snprintf(buf_2, 16, \"%d.%d.%d.%d\", (mpgw->ip & 0xff),\n             ((mpgw->ip >> 8) & 0xff), ((mpgw->ip >> 16) & 0xff),\n             ((mpgw->ip >> 24) & 0xff));\n    fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec,\n            tv.tv_usec, buf_2, mpgw->ifindex, state);\n  } else {\n    snprintf(buf_2, 16, \"%d.%d.%d.%d\", (mpgw->ip & 0xff),\n             ((mpgw->ip >> 8) & 0xff), ((mpgw->ip >> 16) & 0xff),\n             ((mpgw->ip >> 24) & 0xff));\n    syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\", buf_2,\n           mpgw->ifindex, state);\n  }\n\n  mpgw->state = state;\n\n  if (state == 1)\n    mpgw->next_update = random() % 1000 + 1000;\n  else\n    mpgw->next_update = random() % 30000 + 60000;\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"static struct rtattr *rta_find(struct rtattr *head, int len, int type) {\n    struct rtattr *rta;\n    for (rta = head; ((len) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len)); rta = ((len) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n        if (rta->rta_type == type)\n            return rta;\n    return ((void *)0);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"static int process_rt(struct nlmsghdr *nlh) {\n    int len;\n    struct rtmsg *rtm = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    struct rtattr *rta;\n    struct rtnexthop *nh;\n    len = ((nlh)->nlmsg_len - ((((((sizeof (*rtm))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid nlmsg_len %d\\\"}\", __func__, len);\n        });\n        return -1;\n    }\n    if (rtm->rtm_family != 2 || rtm->rtm_scope >= RT_SCOPE_LINK)\n        return 0;\n    rta = rta_find(((struct rtattr *)(((char *)(rtm)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1)))), len, RTA_MULTIPATH);\n    if (rta == ((void *)0))\n        return 0;\n    for (len = ((int)((rta)->rta_len) - ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))) , nh = ((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))); len >= sizeof (*nh) && len >= nh->rtnh_len; len -= (((nh->rtnh_len) + 4 - 1) & ~(4 - 1)) , nh = ((struct rtnexthop *)(((char *)(nh)) + ((((nh)->rtnh_len) + 4 - 1) & ~(4 - 1))))) {\n        __be32 gw;\n        rta = rta_find(((struct rtattr *)(((char *)(nh)) + ((((sizeof(struct rtnexthop)) + 4 - 1) & ~(4 - 1)) + (0)))), nh->rtnh_len - (((sizeof (*nh)) + 4 - 1) & ~(4 - 1)), RTA_GATEWAY);\n        if (rta == ((void *)0)) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: no gateway in nh info\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s no gateway in nh info\\\"}\", __func__);\n            });\n            return 0;\n        }\n        gw = *(__be32 *)((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))));\n        if (add_mpgw(gw, nh->rtnh_ifindex) == ((void *)0))\n            return -1;\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int get_nhs(void) {\n    int len;\n    struct nlmsghdr *nlh;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg rtm;\n    } req;\n    reset_mpgws();\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETROUTE;\n    req.nlh.nlmsg_flags = 1 | 256;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.rtm.rtgen_family = 2;\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        for (nlh = (struct nlmsghdr *)recv_buf; ((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len)); nlh = ((len) -= ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlh)) + ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n            if (nlh->nlmsg_seq != talk_seq) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n                });\n                continue;\n            }\n            if (nlh->nlmsg_type == 3)\n                return 0;\n            if (nlh->nlmsg_type == 2) {\n                ({\n                    struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    int rc __attribute__((unused));\n                    if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                        });\n                        rc = -1;\n                    } else if (err->error) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                        });\n                        rc = -1;\n                    }\n                    rc = 0;\n                });\n                return -1;\n            }\n            if (nlh->nlmsg_type != RTM_NEWROUTE) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n                });\n                continue;\n            }\n            if (process_rt(nlh) < 0)\n                return -1;\n        }\n    }\n}\n","function_prediction":"int get_nhs_name_conflict(void) {\n  int len;\n  int nlmsg_len;\n  int nlerr;\n  int nlmsg_type;\n  int nlseq;\n  int nlflags;\n  int nlattr_len;\n  int nlattr_type;\n  int nlattr_seq;\n  int nlattr_flags;\n  int nlattr_len_left;\n  int nlattr_type_left;\n  int nlattr_seq_left;\n  int nlattr_flags_left;\n  int nlattr_len_left_left;\n  int nlattr_type_left_left;\n  int nlattr_seq_left_left;\n  int nlattr_flags_left_left;\n  int nlattr_len_left_left_left;\n  int nlattr_type_left_left_left;\n  int nlattr_seq_left_left_left;\n  int nlattr_flags_left_left_left;\n  int nlattr_len_left_left_left_left;\n  int nlattr_type_left_left_left_left;\n  int nlattr_seq_left_left_left_left;\n  int nlattr_flags_left_left_left_left;\n  int nlattr_len_left_left_left_left_left;\n  int nlattr_type_left_left_left_left_left;\n  int nlattr_seq_left_left_left_left_left;\n  int nlattr_flags_left_left_left_left_left;\n  int nlattr_len_left_left_left_left_left_left;\n  int nlattr_type_left_left_left_left_left_left;\n  int nlattr_seq_left_left_left_left_left_left;\n  int nlattr_flags_left_left_left_left_left_left;\n  int nlattr_len_left_left_left_left_left_left_left;\n  int nlattr_type_left_left_left_","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int update_neigh(int ifindex, __be32 ip, char *hw, int reachable) {\n    struct {\n        struct nlmsghdr nlh;\n        struct ndmsg ndm;\n        struct nlattr nla_dst;\n        __be32 dst;\n        struct nlattr nla_hw;\n        char hw[8];\n    } req;\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_NEWNEIGH;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.nlh.nlmsg_flags = (1 | 4 | 1024 | 256);\n    req.ndm.ndm_family = 2;\n    req.ndm.ndm_ifindex = ifindex;\n    req.ndm.ndm_state = reachable ? 2 : 32;\n    req.nla_dst.nla_len = sizeof(struct nlattr) + sizeof(__be32);\n    req.nla_dst.nla_type = NDA_DST;\n    req.dst = ip;\n    req.nla_hw.nla_len = sizeof(struct nlattr) + 6;\n    req.nla_hw.nla_type = NDA_LLADDR;\n    memcpy(&req.hw, hw, 6);\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        int len;\n        struct nlmsghdr *nlh;\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        nlh = (struct nlmsghdr *)recv_buf;\n        if (!((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len))) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\", __func__, len);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_seq != talk_seq) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_type != 2) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n            });\n            return -1;\n        }\n        return ({\n            struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n            int rc __attribute__((unused));\n            if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                });\n                rc = -1;\n            } else if (err->error) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                });\n                rc = -1;\n            }\n            rc = 0;\n        });\n    }\n}\n","function_prediction":"int update_neigh(int neigh_id, int neigh_state, struct sockaddr_nl *neigh_addr,\n                 int neigh_addr_len) {\n  struct ndmsg ndm;\n  struct nlmsghdr *nlh;\n  struct ndrouterid *rid;\n  struct ndauthtype *at;\n  struct ndcacheinfo *ci;\n  struct ndcookie *c;\n  struct ndcookietable *ct;\n  struct ndcookie *c2;\n  struct ndcookietable *ct2;\n  struct ndcookie *c3;\n  struct ndcookietable *ct3;\n  struct ndcookie *c4;\n  struct ndcookietable *ct4;\n  struct ndcookie *c5;\n  struct ndcookietable *ct5;\n  struct ndcookie *c6;\n  struct ndcookietable *ct6;\n  struct ndcookie *c7;\n  struct ndcookietable *ct7;\n  struct ndcookie *c8;\n  struct ndcookietable *ct8;\n  struct ndcookie *c9;\n  struct ndcookietable *ct9;\n  struct ndcookie *c10;\n  struct ndcookietable *ct10;\n  struct ndcookie *c11;\n  struct ndcookietable *ct11;\n  struct ndcookie *c12;\n  struct ndcookietable *ct12;\n  struct ndcookie *c13;\n  struct ndcookietable *ct13;\n  struct ndcookie *c14;\n  struct ndcookietable *ct14;\n  struct ndcookie *c15;\n  struct ndcookietable *ct15;\n  struct ndcookie *c16;\n  struct ndcookietable *ct16;\n  struct ndcookie *c17;\n  struct ndcookietable *ct17;\n  struct ndcookie *c18;\n  struct ndcookietable","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":1,"function":"int recv_nl(void) {\n    struct sockaddr_nl saddr;\n    socklen_t addrlen = sizeof (saddr);\n    if (recvfrom(poll_sock, recv_buf, sizeof (recv_buf), MSG_DONTWAIT, (struct sockaddr *)&saddr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 0;\n    }\n    if (addrlen != sizeof (saddr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid addr len\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\", __func__);\n        });\n        return 0;\n    }\n    if (saddr.nl_pid)\n        return 0;\n    get_nhs();\n    return 1;\n}\n","function_prediction":"int recv_nl_name_conflict(void) {\n  struct sockaddr_nl nladdr;\n  socklen_t nladdr_len = sizeof(nladdr);\n  ssize_t n;\n\n  n = recvfrom(poll_sock, &recv_buf, 16384, 0x00000040,\n               (struct sockaddr *)&nladdr, &nladdr_len);\n  if (n < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"recvfrom %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"recv_nl_name_conflict\",\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"recvfrom %s\"\n               \"\\\"}\",\n               \"recv_nl_name_conflict\", strerror(*__errno_location()));\n      }\n    } while (0);\n    return 0;\n  }\n  if (nladdr_len != sizeof(nladdr)) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"invalid addr len\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"recv_nl_name_conflict\");\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"invalid addr len\"\n               \"\\\"}\",\n               \"recv_nl_name_conflict\");\n      }\n    } while (0);\n    return 0;\n  }\n  if (nladdr.nl_pid != 0)\n    return 0;\n\n  get_nhs();\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int open_nl(void) {\n    struct sockaddr_nl addr;\n    socklen_t addrlen = sizeof (addr);\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    if ((talk_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (connect(talk_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (getsockname(talk_sock, (struct sockaddr *)&addr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    talk_seq = random();\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    addr.nl_groups = 64;\n    if ((poll_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (bind(poll_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: bind poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_poll;\n    }\n    if (get_nhs() < 0)\n        goto cleanup_poll;\n    return poll_sock;\n  cleanup_poll:\n    close(poll_sock);\n  cleanup_talk:\n    close(talk_sock);\n  err_out:\n    return -1;\n}\n","function_prediction":"int open_nl_name_conflict(void) {\n  struct sockaddr_nl nladdr;\n  socklen_t nladdr_len = sizeof(nladdr);\n  struct timeval tv;\n\n  nladdr.nl_family = AF_NETLINK;\n  nladdr.nl_pad = 0;\n  nladdr.nl_pid = 0;\n  nladdr.nl_groups = 0;\n\n  talk_sock = socket(AF_NETLINK, 3, 0);\n  if (talk_sock < 0) {\n    do {\n      if (foreground) {\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"socket talk_sock %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"open_nl_name_conflict\",\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\",\n               \"open_nl_name_conflict\", strerror(*__errno_location()));\n      }\n    } while (0);\n    return -1;\n  }\n\n  if (connect(talk_sock, (struct sockaddr *)&nladdr, nladdr_len) < 0) {\n    do {\n      if (foreground) {\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"connect talk_sock %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"open_nl_name_conflict\",\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\",\n               \"open_nl_name_conflict\", strerror(*__errno_location()));\n      }\n    } while (0);\n    close(talk_sock);\n    return -1;\n  }\n\n    if (getsockname(talk_sock, (struct sockaddr *)&nladdr, &nladdr_len) < 0","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"static __be16 in_cksum(const __be16 *addr, register int len) {\n    register int nleft = len;\n    register __be32 sum = 0;\n    const __be16 *w = addr;\n    while (nleft > 1)\n        {\n            sum += *w++;\n            nleft -= 2;\n        }\n    if (nleft == 1)\n        sum += htons((__u16)(*(char *)w) << 8);\n    sum = (sum >> 16) + (sum & 65535);\n    sum += (sum >> 16);\n    return (__be16)~sum;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_ping(int ifindex, __be32 daddr) {\n    static struct sockaddr_in dest = {2, 0};\n    static char buf[16];\n    static struct iovec iov = {buf, sizeof (buf)};\n    static struct {\n        struct cmsghdr cm;\n        struct in_pktinfo ipi;\n    } cmsg = {{sizeof (cmsg.cm) + sizeof (cmsg.ipi), 0, 8}};\n    static struct msghdr msg = {&dest, sizeof (dest), &iov, 1, &cmsg, sizeof (cmsg), 0};\n    struct icmphdr *icmp = (struct icmphdr *)buf;\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    ;\n    dest.sin_addr.s_addr = daddr;\n    cmsg.ipi.ipi_ifindex = ifindex;\n    icmp->type = 8;\n    icmp->code = 0;\n    icmp->un.echo.id = ping_id;\n    icmp->un.echo.sequence = 0;\n    icmp->checksum = 0;\n    pmsg->ifindex = (__be32)ifindex;\n    pmsg->sig = 1297106775;\n    icmp->checksum = in_cksum((__be16 *)buf, sizeof (buf));\n    if (sendmsg(ping_sock, &msg, MSG_DONTROUTE) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\", __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int send_ping_name_conflict(int sock, int ip) {\n  int ret;\n  struct timeval tv;\n\n  buf_10.id = ping_id;\n  buf_10.seq = 0;\n  buf_10.len = sizeof(struct ping_buf);\n  buf_10.type = 'W' | ('P' << 8) | ('G' << 16) | ('M' << 24);\n  buf_10.cksum = ~(((ping_id + (sock & 0xffff) + ((sock >> 16) & 0xffff) +\n                     (ip & 0xffff) + ((ip >> 16) & 0xffff)) &\n                    0xffff) +\n                   (((ping_id + (sock & 0xffff) + ((sock >> 16) & 0xffff) +\n                      (ip & 0xffff) + ((ip >> 16) & 0xffff)) >>\n                     16) &\n                    0xffff));\n  cmsg_8.cmsg_level = sock;\n  dest_9.s_addr = ip;\n  buf_10.ip = ip;\n\n  ret = sendmsg(ping_sock, &msg_7, 4);\n  if (ret < 0) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      snprintf(buf_4, 16, \"%d.%d.%d.%d\", (ip >> 24) & 0xff, (ip >> 16) & 0xff,\n               (ip >> 8) & 0xff, ip & 0xff);\n      fprintf(stderr, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"send_ping_name_conflict\", sock, buf_4,\n              strerror(*__errno_location()));\n    } else {\n            snprintf(buf_4, 16, \"%d.%d.%d.%d\", (ip >> 24) & 0xff, (ip >> 16) &","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int recv_ping(int *ifindex, __be32 *daddr) {\n    static struct sockaddr_in src;\n    static char buf[1500];\n    struct icmphdr *icmp = (struct icmphdr *)(buf + sizeof(struct iphdr));\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    socklen_t srclen = sizeof (src);\n    int len;\n    len = recvfrom(ping_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&src, &srclen);\n    if (len < sizeof(struct iphdr) + sizeof (*icmp)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, len, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\", __func__, len, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (src.sin_family != 2) {\n        return -1;\n    }\n    if (icmp->un.echo.id != ping_id || icmp->type != 0 || icmp->un.echo.sequence != 0 || icmp->code != 0) {\n        return -1;\n    }\n    if (len < sizeof(struct iphdr) + sizeof (*icmp) + sizeof (*pmsg)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: msg too small\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (in_cksum((__be16 *)buf, len) != 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: checksum error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (pmsg->sig != 1297106775) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: signature error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = (int)pmsg->ifindex;\n    *daddr = src.sin_addr.s_addr;\n    ;\n    return 0;\n}\n","function_prediction":"int recv_ping_name_conflict(int *port, int *pid) {\n  int i, len, sum;\n  struct timeval tv;\n  socklen_t slen = sizeof(src);\n\n  len = recvfrom(ping_sock, buf, 1500, 0, (struct sockaddr *)&src, &slen);\n  if (len < 28) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"recv_ping_name_conflict\", len,\n              strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\",\n             \"recv_ping_name_conflict\", len, strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  if (src.sin_family != 2)\n    return -1;\n\n  if (buf[0] != ping_id)\n    return -1;\n\n  if (buf[1] != 0)\n    return -1;\n\n  if (buf[2] != 0)\n    return -1;\n\n  if (buf[3] != 0)\n    return -1;\n\n  if (len < 36) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: msg too small\\n\", (long)tv.tv_sec,\n              (long)tv.tv_usec, \"recv_ping_name_conflict\");\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\",\n             \"recv_ping_name_conflict\");\n    }\n    return -1;\n  }\n\n  sum = 0;\n    for (i =","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int open_ping(void) {\n    int one = 1;\n    if ((ping_sock = socket(2, SOCK_RAW, IPPROTO_ICMP)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 2, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 8, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_PKTINFO %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    ping_id = htons(getpid() & 65535);\n    return ping_sock;\n  err_out:\n    close(ping_sock);\n    return -1;\n}\n","function_prediction":"int open_ping_name_conflict() {\n  int ttl = 1;\n\n  ping_sock = socket(2, 3, 1);\n  if (ping_sock < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"open_ping_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\",\n             \"open_ping_name_conflict\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  if (setsockopt(ping_sock, 0, 2, &ttl, sizeof(ttl)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"open_ping_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3,\n             \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\",\n             \"open_ping_name_conflict\", strerror(*__errno_location()));\n    }\n    close(ping_sock);\n    return -1;\n  }\n\n  if (setsockopt(ping_sock, 0, 8, &ttl, sizeof(ttl)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\",\n              tv.tv_sec, tv.tv_usec, \"open_ping_name_conflict\",\n              strerror(*__errno_location()));\n    } else {\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_garp(int ifindex, __be32 sip, char *sha, __be32 tip, char *tha) {\n    static char buf[64];\n    struct sockaddr_ll sll;\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    ;\n    arp->ar_hrd = htons(1);\n    arp->ar_pro = htons(2048);\n    arp->ar_hln = 6;\n    arp->ar_pln = 4;\n    arp->ar_op = htons(2);\n    memcpy(p, sha, 6);\n    p += 6;\n    memcpy(p, &sip, 4);\n    p += 4;\n    memcpy(p, tha, 6);\n    p += 6;\n    memcpy(p, &tip, 4);\n    p += 4;\n    memset(&sll, 0, sizeof (sll));\n    sll.sll_protocol = htons(2054);\n    sll.sll_ifindex = ifindex;\n    sll.sll_halen = 6;\n    memset(sll.sll_addr, 255, 6);\n    if (sendto(arp_sock, buf, p - buf, 0, (struct sockaddr *)&sll, sizeof (sll)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\", __func__, ifindex, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int send_garp(int ifindex, int iftype, struct in_addr *sender, int sender_type,\n              struct in_addr *target) {\n  struct sockaddr_ll sa;\n  struct timeval tv;\n\n  buf.ar_hrd = 1;\n  buf.ar_pro = 0x0800;\n  buf.ar_hln = 6;\n  buf.ar_pln = 4;\n  buf.ar_op = 2;\n  buf.ar_sip = sender->s_addr;\n  buf.ar_tip = target->s_addr;\n  buf.ar_tha[0] = 0xff;\n  buf.ar_tha[1] = 0xff;\n  buf.ar_tha[2] = 0xff;\n  buf.ar_tha[3] = 0xff;\n  buf.ar_tha[4] = 0xff;\n  buf.ar_tha[5] = 0xff;\n  buf.ar_sip = sender_type;\n  buf.ar_tip = iftype;\n\n  if (sendto(arp_sock, &buf, sizeof(buf), 0, (struct sockaddr *)&sa,\n             sizeof(sa)) < 0) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: sendto if %d %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"send_garp\", ifindex, strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendto if %d %s\\\"}\",\n             \"send_garp\", ifindex, strerror(*__errno_location()));\n    }\n    return -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"int recv_arp(int *ifindex, __u16 *type, __u16 *op, __be32 *sip, char *sha, __be32 *tip, char *tha) {\n    int len;\n    static char buf[1024];\n    struct sockaddr_ll sll;\n    socklen_t sll_len = sizeof (sll);\n    struct arphdr *arp = (struct arphdr *)buf;\n    char *p = (char *)(arp + 1);\n    len = recvfrom(arp_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&sll, &sll_len);\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (len < sizeof (*arp) || (arp->ar_op != htons(1) && arp->ar_op != htons(2)) || arp->ar_pln != 4 || arp->ar_pro != htons(2048) || arp->ar_hln != 6 || len < sizeof (*arp) + 2 * 4 + 2 * 6) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = sll.sll_ifindex;\n    *type = sll.sll_pkttype;\n    *op = ntohs(arp->ar_op);\n    memcpy(sha, p, 6);\n    memcpy(sip, p + 6, 4);\n    memcpy(tha, p + 6 + 4, 6);\n    memcpy(tip, p + 6 + 4 + 6, 4);\n    return 0;\n}\n","function_prediction":"int recv_arp(unsigned int *ip, unsigned short *port, unsigned short *id,\n             unsigned int *mac, unsigned int *target, unsigned int *sender,\n             unsigned int *op) {\n  struct sockaddr_in from;\n  socklen_t fromlen = sizeof(from);\n  int n;\n\n  if ((n = recvfrom(arp_sock, buf_2, 1024, 0x40, (struct sockaddr *)&from,\n                    &fromlen)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"recv_arp\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\",\n             \"recv_arp\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  if (n < 28 || (buf_2[2] != 0x00 || buf_2[3] != 0x01) || buf_2[5] != 0x04 ||\n      buf_2[4] != 0x06 || buf_2[6] != 0x08) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: invalid message\\n\", tv.tv_sec,\n              tv.tv_usec, \"recv_arp\");\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid message\\\"}\",\n             \"recv_arp\");\n    }\n    return -1;\n  }\n\n  *ip = from.sin_addr.s_addr;\n  *port = (buf_2[0] << 8) | buf_2[1];\n *id = (buf_","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":1,"function":"int open_arp(void) {\n    if ((arp_sock = socket(17, SOCK_DGRAM, htons(2054))) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return arp_sock;\n}\n","function_prediction":"int open_arp_name_conflict() {\n  struct timeval tv;\n\n  if ((arp_sock = socket(17, 2, 1544)) < 0) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"open_arp_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\",\n             \"open_arp_name_conflict\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n  return arp_sock;\n}","pass":1,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/arp.c"}
{"compilable":0,"function":"static __be16 in_cksum(const __be16 *addr, register int len) {\n    register int nleft = len;\n    register __be32 sum = 0;\n    const __be16 *w = addr;\n    while (nleft > 1)\n        {\n            sum += *w++;\n            nleft -= 2;\n        }\n    if (nleft == 1)\n        sum += htons((__u16)(*(char *)w) << 8);\n    sum = (sum >> 16) + (sum & 65535);\n    sum += (sum >> 16);\n    return (__be16)~sum;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int send_ping(int ifindex, __be32 daddr) {\n    static struct sockaddr_in dest = {2, 0};\n    static char buf[16];\n    static struct iovec iov = {buf, sizeof (buf)};\n    static struct {\n        struct cmsghdr cm;\n        struct in_pktinfo ipi;\n    } cmsg = {{sizeof (cmsg.cm) + sizeof (cmsg.ipi), 0, 8}};\n    static struct msghdr msg = {&dest, sizeof (dest), &iov, 1, &cmsg, sizeof (cmsg), 0};\n    struct icmphdr *icmp = (struct icmphdr *)buf;\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    ;\n    dest.sin_addr.s_addr = daddr;\n    cmsg.ipi.ipi_ifindex = ifindex;\n    icmp->type = 8;\n    icmp->code = 0;\n    icmp->un.echo.id = ping_id;\n    icmp->un.echo.sequence = 0;\n    icmp->checksum = 0;\n    pmsg->ifindex = (__be32)ifindex;\n    pmsg->sig = 1297106775;\n    icmp->checksum = in_cksum((__be16 *)buf, sizeof (buf));\n    if (sendmsg(ping_sock, &msg, MSG_DONTROUTE) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s sendmsg %d %s %s\\\"}\", __func__, ifindex, ip2str(daddr), strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int send_ping_name_conflict(int sock, int ip) {\n  int ret;\n  struct timeval tv;\n\n  buf_10.id = ping_id;\n  buf_10.seq = 0;\n  buf_10.len = sizeof(struct ping_buf);\n  buf_10.type = 'W' | ('P' << 8) | ('G' << 16) | ('M' << 24);\n  buf_10.cksum = ~(((ping_id + (sock & 0xffff) + ((sock >> 16) & 0xffff) +\n                     (ip & 0xffff) + ((ip >> 16) & 0xffff)) &\n                    0xffff) +\n                   (((ping_id + (sock & 0xffff) + ((sock >> 16) & 0xffff) +\n                      (ip & 0xffff) + ((ip >> 16) & 0xffff)) >>\n                     16) &\n                    0xffff));\n  cmsg_8.cmsg_level = sock;\n  dest_9.s_addr = ip;\n  buf_10.ip = ip;\n\n  ret = sendmsg(ping_sock, &msg_7, 4);\n  if (ret < 0) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      snprintf(buf_4, 16, \"%d.%d.%d.%d\", (ip >> 24) & 0xff, (ip >> 16) & 0xff,\n               (ip >> 8) & 0xff, ip & 0xff);\n      fprintf(stderr, \"%ld.%06ld [error] %s: sendmsg %d %s %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"send_ping_name_conflict\", sock, buf_4,\n              strerror(*__errno_location()));\n    } else {\n            snprintf(buf_4, 16, \"%d.%d.%d.%d\", (ip >> 24) & 0xff, (ip >> 16) &","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int recv_ping(int *ifindex, __be32 *daddr) {\n    static struct sockaddr_in src;\n    static char buf[1500];\n    struct icmphdr *icmp = (struct icmphdr *)(buf + sizeof(struct iphdr));\n    struct ping_msg *pmsg = (struct ping_msg *)(icmp + 1);\n    socklen_t srclen = sizeof (src);\n    int len;\n    len = recvfrom(ping_sock, buf, sizeof (buf), MSG_DONTWAIT, (struct sockaddr *)&src, &srclen);\n    if (len < sizeof(struct iphdr) + sizeof (*icmp)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, len, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\", __func__, len, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (src.sin_family != 2) {\n        return -1;\n    }\n    if (icmp->un.echo.id != ping_id || icmp->type != 0 || icmp->un.echo.sequence != 0 || icmp->code != 0) {\n        return -1;\n    }\n    if (len < sizeof(struct iphdr) + sizeof (*icmp) + sizeof (*pmsg)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: msg too small\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (in_cksum((__be16 *)buf, len) != 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: checksum error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s checksum error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    if (pmsg->sig != 1297106775) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: signature error\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s signature error\\\"}\", __func__);\n        });\n        return -1;\n    }\n    *ifindex = (int)pmsg->ifindex;\n    *daddr = src.sin_addr.s_addr;\n    ;\n    return 0;\n}\n","function_prediction":"int recv_ping_name_conflict(int *port, int *pid) {\n  int i, len, sum;\n  struct timeval tv;\n  socklen_t slen = sizeof(src);\n\n  len = recvfrom(ping_sock, &buf, 1500, 0, (struct sockaddr *)&src, &slen);\n  if (len < 28) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: recvmsg len %d %s\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"recv_ping_name_conflict\", len,\n              strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvmsg len %d %s\\\"}\",\n             \"recv_ping_name_conflict\", len, strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  if (src.sin_family != 2)\n    return -1;\n\n  if (buf[0] != ping_id)\n    return -1;\n\n  if (buf[1] != 0)\n    return -1;\n\n  if (buf[2] != 0)\n    return -1;\n\n  if (buf[3] != 0)\n    return -1;\n\n  if (len < 36) {\n    if (foreground) {\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: msg too small\\n\", (long)tv.tv_sec,\n              (long)tv.tv_usec, \"recv_ping_name_conflict\");\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s msg too small\\\"}\",\n             \"recv_ping_name_conflict\");\n    }\n    return -1;\n  }\n\n  sum = 0;\n    for (i","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"int open_ping(void) {\n    int one = 1;\n    if ((ping_sock = socket(2, SOCK_RAW, IPPROTO_ICMP)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 2, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (setsockopt(ping_sock, IPPROTO_IP, 8, &one, sizeof (one)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_PKTINFO %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    ping_id = htons(getpid() & 65535);\n    return ping_sock;\n  err_out:\n    close(ping_sock);\n    return -1;\n}\n","function_prediction":"int open_ping_name_conflict() {\n  int ttl = 1;\n\n  ping_sock = socket(2, 3, 1);\n  if (ping_sock < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: socket %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"open_ping_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket %s\\\"}\",\n             \"open_ping_name_conflict\", strerror(*__errno_location()));\n    }\n    return -1;\n  }\n\n  if (setsockopt(ping_sock, 0, 2, &ttl, sizeof(ttl)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_TTL %s\\n\", tv.tv_sec,\n              tv.tv_usec, \"open_ping_name_conflict\", strerror(*__errno_location()));\n    } else {\n      syslog(3,\n             \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt IP_TTL %s\\\"}\",\n             \"open_ping_name_conflict\", strerror(*__errno_location()));\n    }\n    close(ping_sock);\n    return -1;\n  }\n\n  if (setsockopt(ping_sock, 0, 8, &ttl, sizeof(ttl)) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt IP_PKTINFO %s\\n\",\n              tv.tv_sec, tv.tv_usec, \"open_ping_name_conflict\",\n              strerror(*__errno_location()));\n    } else {\n","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/ping.c"}
{"compilable":0,"function":"static int fill_if_addrs(struct mpgw *gw) {\n    int sock, ret = -1;\n    struct ifreq ifr;\n    struct sockaddr_in saddr;\n    socklen_t len;\n    if ((sock = socket(2, SOCK_DGRAM, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    memset(&ifr, 0, sizeof (ifr));\n    ifr.ifr_ifru.ifru_ivalue = gw->if_id;\n    if (ioctl(sock, 35088, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFNAME %d %s\\n\", tv.tv_sec, tv.tv_usec, __func__, gw->if_id, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFNAME %d %s\\\"}\", __func__, gw->if_id, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ioctl(sock, 35111, &ifr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: SIOCGIFHWADDR %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s SIOCGIFHWADDR %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    if (ifr.ifr_ifru.ifru_hwaddr.sa_family != 1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid if %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid if %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name);\n        });\n        goto close_ret;\n    }\n    if (setsockopt(sock, 1, 25, ifr.ifr_ifrn.ifrn_name, strlen(ifr.ifr_ifrn.ifrn_name) + 1) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: setsockopt %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s setsockopt %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    memset(&saddr, 0, sizeof (saddr));\n    saddr.sin_family = 2;\n    saddr.sin_port = htons(1025);\n    saddr.sin_addr.s_addr = gw->gw_ip;\n    if (connect(sock, (struct sockaddr *)&saddr, sizeof (saddr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect to %s from %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect to %s from %s %s\\\"}\", __func__, ip2str(gw->gw_ip), ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    len = sizeof (saddr);\n    if (getsockname(sock, (struct sockaddr *)&saddr, &len) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname %s %s\\n\", tv.tv_sec, tv.tv_usec, __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname %s %s\\\"}\", __func__, ifr.ifr_ifrn.ifrn_name, strerror((*__errno_location())));\n        });\n        goto close_ret;\n    }\n    ret = 0;\n    memcpy(gw->if_hw, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    gw->if_ip = saddr.sin_addr.s_addr;\n  close_ret:\n    close(sock);\n    return ret;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *add_mpgw(__be32 addr, int ifindex) {\n    int i, j = -1;\n    struct timespec now;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED) {\n            if (j == -1)\n                j = i;\n            continue;\n        }\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    if (j == -1) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: not enough memory\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\", __func__);\n        });\n        return ((void *)0);\n    }\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return ((void *)0);\n    }\n    memset(&mpgws[j], 0, sizeof (mpgws[j]));\n    mpgws[j].gw_ip = addr;\n    mpgws[j].if_id = ifindex;\n    if (fill_if_addrs(&mpgws[j]) < 0)\n        return ((void *)0);\n    mpgws[j].last_sent = now;\n    mpgws[j].last_rcvd = now;\n    update_mpgw(&mpgws[j], MPGW_S_PROBE);\n    srandom(mpgws[j].if_ip);\n    return &mpgws[j];\n}\n","function_prediction":"struct mpgw *add_mpgw_name_conflict(int ip, int port) {\n  struct mpgw *mpgw;\n  struct ifreq ifr;\n  struct sockaddr_in sin;\n  struct timespec ts;\n  int sock, i, found = -1;\n\n  for (i = 0; i < 32; i++) {\n    mpgw = &mpgws[i];\n    if (mpgw->used) {\n      if (mpgw->ip == ip && mpgw->port == port)\n        return mpgw;\n    } else {\n      if (found == -1)\n        found = i;\n    }\n  }\n\n  if (found == -1) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: not enough memory\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"fill_if_addrs\");\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s not enough memory\\\"}\",\n             \"fill_if_addrs\");\n    }\n    return NULL;\n  }\n\n  if (clock_gettime(1, &ts) < 0) {\n    if (foreground) {\n      struct timeval tv;\n      gettimeofday(&tv, NULL);\n      fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\",\n              (long)tv.tv_sec, (long)tv.tv_usec, \"fill_if_addrs\",\n              strerror(*__errno_location()));\n    } else {\n      syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\",\n             \"fill_if_addrs\", strerror(*__errno_location()));\n    }\n    return NULL;\n  }\n\n  mpgw = &mpgws[found];\n  mpgw->used = 0;\n  m","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"struct mpgw *find_mpgw(__be32 addr, int ifindex) {\n    int i;\n    for (i = 0; i < 32; i++) {\n        if (mpgws[i].state == MPGW_S_UNUSED)\n            continue;\n        if (mpgws[i].gw_ip == addr && mpgws[i].if_id == ifindex)\n            return &mpgws[i];\n    }\n    return ((void *)0);\n}\n","function_prediction":"struct mpgw_t *find_mpgw_name_conflict(int id, int port) {\n  int i;\n\n  for (i = 0; i < 32; i++) {\n    if (!mpgws[i].valid)\n      continue;\n    if (mpgws[i].id == id && mpgws[i].port == port)\n      return &mpgws[i];\n  }\n\n  return NULL;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"int update_mpgw(struct mpgw *gw, enum mpgw_state newstate) {\n    if (gw->state == newstate)\n        return 0;\n    ({\n        if (foreground) {\n            struct timeval tv;\n            gettimeofday(&tv, ((void *)0));\n            fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec, tv.tv_usec, ip2str(gw->gw_ip), gw->if_id, newstate);\n        } else\n            syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\", ip2str(gw->gw_ip), gw->if_id, newstate);\n    });\n    gw->state = newstate;\n    if (gw->state == MPGW_S_PROBE)\n        gw->timeout = (1000 + 10 + random() % (1000));\n    else\n        gw->timeout = (60000 + random() % 30000);\n    return 1;\n}\n","function_prediction":"int update_mpgw_name_conflict(struct mpgw_info *mpgw, int state) {\n  if (mpgw->state == state)\n    return 0;\n\n  if (foreground) {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    snprintf(buf_2, 16, \"%d.%d.%d.%d\", (mpgw->ip & 0xff),\n             ((mpgw->ip >> 8) & 0xff), ((mpgw->ip >> 16) & 0xff),\n             ((mpgw->ip >> 24) & 0xff));\n    fprintf(stderr, \"%ld.%06ld [info] %s if %d state %d\\n\", tv.tv_sec,\n            tv.tv_usec, buf_2, mpgw->ifindex, state);\n  } else {\n    snprintf(buf_2, 16, \"%d.%d.%d.%d\", (mpgw->ip & 0xff),\n             ((mpgw->ip >> 8) & 0xff), ((mpgw->ip >> 16) & 0xff),\n             ((mpgw->ip >> 24) & 0xff));\n    syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": %s if %d state %d\\\"}\", buf_2,\n           mpgw->ifindex, state);\n  }\n\n  mpgw->state = state;\n\n  if (state == 1)\n    mpgw->next_update = random() % 1000 + 1000;\n  else\n    mpgw->next_update = random() % 30000 + 60000;\n\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/mpgw.c"}
{"compilable":0,"function":"static int process_ping(void) {\n    int ifindex;\n    __be32 addr;\n    struct mpgw *gw;\n    if (recv_ping(&ifindex, &addr) < 0)\n        return 0;\n    if ((gw = find_mpgw(addr, ifindex)) == ((void *)0))\n        return 0;\n    if (clock_gettime(1, &gw->last_rcvd) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 1;\n    }\n    if (memcmp(gw->gw_hw, \"\\000\\000\\000\\000\\000\\000\", 6) == 0)\n        return 1;\n    if (update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 1) == 0)\n        update_mpgw(gw, MPGW_S_PROBE);\n    if (gratuitous_arp)\n        send_garp(gw->if_id, gw->gw_ip, gw->gw_hw, gw->if_ip, gw->if_hw);\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static int process_arp(void) {\n    int ifindex;\n    __u16 type, op;\n    __be32 sip, tip;\n    char sha[6], tha[6];\n    struct mpgw *gw;\n    if (recv_arp(&ifindex, &type, &op, &sip, sha, &tip, tha) < 0)\n        return 0;\n    if ((gw = find_mpgw(sip, ifindex)) == ((void *)0))\n        return 0;\n    if (tip == gw->if_ip && type == 1 && op == 2)\n        return 0;\n    if (memcmp(gw->gw_hw, sha, 6)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [info] gw %s on if %d changed mac to %s\\n\", tv.tv_sec, tv.tv_usec, ip2str(sip), ifindex, hw2str(sha));\n            } else\n                syslog(6, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": gw %s on if %d changed mac to %s\\\"}\", ip2str(sip), ifindex, hw2str(sha));\n        });\n        memcpy(gw->gw_hw, sha, 6);\n    }\n    if (clock_gettime(1, &gw->last_rcvd) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 1;\n    }\n    if (update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 1) == 0)\n        update_mpgw(gw, MPGW_S_PROBE);\n    if (master_election && type == 1 && op == 2) {\n        if (tip < gw->if_ip)\n            gw->timeout = (1000 + 10 + random() % (1000));\n        else\n            gw->timeout = 1000;\n    }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static int refresh(void) {\n    int i, diff, timeout = 1000;\n    struct timespec now;\n    if (clock_gettime(1, &now) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: clock_gettime %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s clock_gettime %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return timeout;\n    }\n    for (i = 0; i < 32; i++) {\n        struct mpgw *gw = &mpgws[i];\n        if (gw->state == MPGW_S_UNUSED)\n            continue;\n        diff = (((&now)->tv_sec - (&gw->last_rcvd)->tv_sec) * 1000 + ((&now)->tv_nsec - (&gw->last_rcvd)->tv_nsec) / 1000000);\n        if (diff < gw->timeout) {\n            diff = gw->timeout - diff;\n            if (timeout > diff)\n                timeout = diff;\n            if (gw->timeout != 1000)\n                continue;\n        }\n        if (gw->state == MPGW_S_PROBE && diff > 3 * gw->timeout && update_neigh(gw->if_id, gw->gw_ip, gw->gw_hw, 0) == 0) {\n            update_mpgw(gw, MPGW_S_FAILED);\n            memset(&gw->gw_hw, 0, sizeof (6));\n        }\n        diff = (((&now)->tv_sec - (&gw->last_sent)->tv_sec) * 1000 + ((&now)->tv_nsec - (&gw->last_sent)->tv_nsec) / 1000000);\n        if (diff < gw->timeout) {\n            diff = gw->timeout - diff;\n            if (timeout > diff)\n                timeout = diff;\n            continue;\n        }\n        send_ping(gw->if_id, gw->gw_ip);\n        gw->last_sent = now;\n        if (timeout > gw->timeout)\n            timeout = gw->timeout;\n    }\n    return timeout;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/main.c"}
{"compilable":0,"function":"static struct rtattr *rta_find(struct rtattr *head, int len, int type) {\n    struct rtattr *rta;\n    for (rta = head; ((len) >= (int)sizeof(struct rtattr) && (rta)->rta_len >= sizeof(struct rtattr) && (rta)->rta_len <= (len)); rta = ((len) -= ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)) , (struct rtattr *)(((char *)(rta)) + ((((rta)->rta_len) + 4U - 1) & ~(4U - 1)))))\n        if (rta->rta_type == type)\n            return rta;\n    return ((void *)0);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"static int process_rt(struct nlmsghdr *nlh) {\n    int len;\n    struct rtmsg *rtm = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n    struct rtattr *rta;\n    struct rtnexthop *nh;\n    len = ((nlh)->nlmsg_len - ((((((sizeof (*rtm))) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) + 4U - 1) & ~(4U - 1)));\n    if (len < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid nlmsg_len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid nlmsg_len %d\\\"}\", __func__, len);\n        });\n        return -1;\n    }\n    if (rtm->rtm_family != 2 || rtm->rtm_scope >= RT_SCOPE_LINK)\n        return 0;\n    rta = rta_find(((struct rtattr *)(((char *)(rtm)) + (((sizeof(struct rtmsg)) + 4U - 1) & ~(4U - 1)))), len, RTA_MULTIPATH);\n    if (rta == ((void *)0))\n        return 0;\n    for (len = ((int)((rta)->rta_len) - ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))) , nh = ((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0)))); len >= sizeof (*nh) && len >= nh->rtnh_len; len -= (((nh->rtnh_len) + 4 - 1) & ~(4 - 1)) , nh = ((struct rtnexthop *)(((char *)(nh)) + ((((nh)->rtnh_len) + 4 - 1) & ~(4 - 1))))) {\n        __be32 gw;\n        rta = rta_find(((struct rtattr *)(((char *)(nh)) + ((((sizeof(struct rtnexthop)) + 4 - 1) & ~(4 - 1)) + (0)))), nh->rtnh_len - (((sizeof (*nh)) + 4 - 1) & ~(4 - 1)), RTA_GATEWAY);\n        if (rta == ((void *)0)) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: no gateway in nh info\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s no gateway in nh info\\\"}\", __func__);\n            });\n            return 0;\n        }\n        gw = *(__be32 *)((void *)(((char *)(rta)) + ((((sizeof(struct rtattr)) + 4U - 1) & ~(4U - 1)) + (0))));\n        if (add_mpgw(gw, nh->rtnh_ifindex) == ((void *)0))\n            return -1;\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int get_nhs(void) {\n    int len;\n    struct nlmsghdr *nlh;\n    struct {\n        struct nlmsghdr nlh;\n        struct rtgenmsg rtm;\n    } req;\n    reset_mpgws();\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_GETROUTE;\n    req.nlh.nlmsg_flags = 1 | 256;\n    req.nlh.nlmsg_pid = 0;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.rtm.rtgen_family = 2;\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        for (nlh = (struct nlmsghdr *)recv_buf; ((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len)); nlh = ((len) -= ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1)) , (struct nlmsghdr *)(((char *)(nlh)) + ((((nlh)->nlmsg_len) + 4U - 1) & ~(4U - 1))))) {\n            if (nlh->nlmsg_seq != talk_seq) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n                });\n                continue;\n            }\n            if (nlh->nlmsg_type == 3)\n                return 0;\n            if (nlh->nlmsg_type == 2) {\n                ({\n                    struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n                    int rc __attribute__((unused));\n                    if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                        });\n                        rc = -1;\n                    } else if (err->error) {\n                        ({\n                            if (foreground) {\n                                struct timeval tv;\n                                gettimeofday(&tv, ((void *)0));\n                                fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                            } else\n                                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                        });\n                        rc = -1;\n                    }\n                    rc = 0;\n                });\n                return -1;\n            }\n            if (nlh->nlmsg_type != RTM_NEWROUTE) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n                });\n                continue;\n            }\n            if (process_rt(nlh) < 0)\n                return -1;\n        }\n    }\n}\n","function_prediction":"int get_nhs_name_conflict(void) {\n  int len;\n  int nlerr;\n  int nlmsg_len;\n  int nlmsg_type;\n  int nlseq;\n  int nlpid;\n  int nlmsg_flags;\n  int nlmsg_type_len;\n  int nlmsg_len_len;\n  int nlmsg_seq_len;\n  int nlmsg_pid_len;\n  int nlmsg_flags_len;\n  int nlmsg_type_seq_len;\n  int nlmsg_type_seq_pid_len;\n  int nlmsg_type_seq_pid_flags_len;\n  int nlmsg_type_seq_pid_flags_len_len;\n  int nlmsg_type_seq_pid_flags_len_len_len;\n  int nlmsg_type_seq_pid_flags_len_len_len_len;\n  int nlmsg_type_seq_pid_flags_len_len_len_len_len;\n  int nlmsg_type_seq_pid_flags_len_len_len_len_len_len;\n  int nlmsg_type_seq_pid_flags_len_len_len_len_len_len_len;\n  int nlmsg_type_seq_pid_flags_len_len_len_len_len_len_len_len;\n  int nlmsg_type_seq_pid_flags_len_len_len_len_len_len_len_len_len;\n  int nlmsg_type_seq_pid_flags_len_len_len_len_len_len_len_len_len_len;\n  int nlmsg_type_seq_pid_flags_len_len_len_len_len_len_len_len_len_len_len;\n  int nlmsg_type_seq_pid_flags_len_len_len_len_len_len_len_len_len_len_len_len;\n  int nlmsg_type_seq_pid_flags_len_len_len_len_len_len_len_len","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int update_neigh(int ifindex, __be32 ip, char *hw, int reachable) {\n    struct {\n        struct nlmsghdr nlh;\n        struct ndmsg ndm;\n        struct nlattr nla_dst;\n        __be32 dst;\n        struct nlattr nla_hw;\n        char hw[8];\n    } req;\n    memset(&req, 0, sizeof (req));\n    req.nlh.nlmsg_len = sizeof (req);\n    req.nlh.nlmsg_type = RTM_NEWNEIGH;\n    req.nlh.nlmsg_seq = ++talk_seq;\n    req.nlh.nlmsg_flags = (1 | 4 | 1024 | 256);\n    req.ndm.ndm_family = 2;\n    req.ndm.ndm_ifindex = ifindex;\n    req.ndm.ndm_state = reachable ? 2 : 32;\n    req.nla_dst.nla_len = sizeof(struct nlattr) + sizeof(__be32);\n    req.nla_dst.nla_type = NDA_DST;\n    req.dst = ip;\n    req.nla_hw.nla_len = sizeof(struct nlattr) + 6;\n    req.nla_hw.nla_type = NDA_LLADDR;\n    memcpy(&req.hw, hw, 6);\n    if (send(talk_sock, (void *)&req, sizeof (req), 0) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: send %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s send %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return -1;\n    }\n    for (;;) {\n        int len;\n        struct nlmsghdr *nlh;\n        len = recv(talk_sock, recv_buf, sizeof (recv_buf), 0);\n        if (len < 0) {\n            if ((*__errno_location()) == 4 || (*__errno_location()) == 11)\n                continue;\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv %s\\\"}\", __func__, strerror((*__errno_location())));\n            });\n            return -1;\n        }\n        if (len == 0) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: recv len == 0\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recv len == 0\\\"}\", __func__);\n            });\n            return -1;\n        }\n        nlh = (struct nlmsghdr *)recv_buf;\n        if (!((len) >= (int)sizeof(struct nlmsghdr) && (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && (nlh)->nlmsg_len <= (len))) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid len %d\\n\", tv.tv_sec, tv.tv_usec, __func__, len);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid len %d\\\"}\", __func__, len);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_seq != talk_seq) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid seq %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_seq);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid seq %d\\\"}\", __func__, nlh->nlmsg_seq);\n            });\n            return -1;\n        }\n        if (nlh->nlmsg_type != 2) {\n            ({\n                if (foreground) {\n                    struct timeval tv;\n                    gettimeofday(&tv, ((void *)0));\n                    fprintf(stderr, \"%ld.%06ld [error] %s: invalid type %d\\n\", tv.tv_sec, tv.tv_usec, __func__, nlh->nlmsg_type);\n                } else\n                    syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid type %d\\\"}\", __func__, nlh->nlmsg_type);\n            });\n            return -1;\n        }\n        return ({\n            struct nlmsgerr *err = ((void *)(((char *)nlh) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1)))));\n            int rc __attribute__((unused));\n            if (nlh->nlmsg_len < ((sizeof (*err)) + ((int)(((sizeof(struct nlmsghdr)) + 4U - 1) & ~(4U - 1))))) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr msg truncated\\n\", tv.tv_sec, tv.tv_usec, __func__);\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr msg truncated\\\"}\", __func__);\n                });\n                rc = -1;\n            } else if (err->error) {\n                ({\n                    if (foreground) {\n                        struct timeval tv;\n                        gettimeofday(&tv, ((void *)0));\n                        fprintf(stderr, \"%ld.%06ld [error] %s: nlerr %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror(-err->error));\n                    } else\n                        syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s nlerr %s\\\"}\", __func__, strerror(-err->error));\n                });\n                rc = -1;\n            }\n            rc = 0;\n        });\n    }\n}\n","function_prediction":"int update_neigh(int neigh_id, int neigh_state, struct sockaddr_nl *neigh_addr,\n                 int neigh_addr_len) {\n  struct ndmsg ndm;\n  struct nlmsghdr *nlh;\n  struct ndrouterid *rid;\n  struct ndauthtype *at;\n  struct ndopt *opt;\n  struct ndopt_prefix *prefix;\n  struct ndopt_dst *dst;\n  struct ndopt_mtu *mtu;\n  struct ndopt_router *router;\n  struct ndopt_dst_ll *dst_ll;\n  struct ndopt_dst_l3 *dst_l3;\n  struct ndopt_dst_l2 *dst_l2;\n  struct ndopt_dst_l1 *dst_l1;\n  struct ndopt_dst_l0 *dst_l0;\n  struct ndopt_dst_l0_l1 *dst_l0_l1;\n  struct ndopt_dst_l0_l2 *dst_l0_l2;\n  struct ndopt_dst_l0_l3 *dst_l0_l3;\n  struct ndopt_dst_l0_l4 *dst_l0_l4;\n  struct ndopt_dst_l0_l5 *dst_l0_l5;\n  struct ndopt_dst_l0_l6 *dst_l0_l6;\n  struct ndopt_dst_l0_l7 *dst_l0_l7;\n  struct ndopt_dst_l0_l8 *dst_l0_l8;\n  struct ndopt_dst_l0_l9 *dst_l0_l9;\n  struct ndopt_dst_l0_l10 *dst_l0_l10;\n  struct ndopt_dst_l0_l11 *dst_l0_l11;\n  struct ndopt","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":1,"function":"int recv_nl(void) {\n    struct sockaddr_nl saddr;\n    socklen_t addrlen = sizeof (saddr);\n    if (recvfrom(poll_sock, recv_buf, sizeof (recv_buf), MSG_DONTWAIT, (struct sockaddr *)&saddr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: recvfrom %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s recvfrom %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        return 0;\n    }\n    if (addrlen != sizeof (saddr)) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: invalid addr len\\n\", tv.tv_sec, tv.tv_usec, __func__);\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s invalid addr len\\\"}\", __func__);\n        });\n        return 0;\n    }\n    if (saddr.nl_pid)\n        return 0;\n    get_nhs();\n    return 1;\n}\n","function_prediction":"int recv_nl_name_conflict(void) {\n  struct sockaddr_nl nladdr;\n  socklen_t nladdr_len = sizeof(nladdr);\n  ssize_t n;\n\n  n = recvfrom(poll_sock, &recv_buf, 16384, 0x00000040,\n               (struct sockaddr *)&nladdr, &nladdr_len);\n  if (n < 0) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"recvfrom %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"recv_nl_name_conflict\",\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"recvfrom %s\"\n               \"\\\"}\",\n               \"recv_nl_name_conflict\", strerror(*__errno_location()));\n      }\n    } while (0);\n    return 0;\n  }\n  if (nladdr_len != sizeof(nladdr)) {\n    do {\n      if (foreground) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"invalid addr len\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"recv_nl_name_conflict\");\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s \"\n               \"invalid addr len\"\n               \"\\\"}\",\n               \"recv_nl_name_conflict\");\n      }\n    } while (0);\n    return 0;\n  }\n  if (nladdr.nl_pid != 0)\n    return 0;\n\n  get_nhs();\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int open_nl(void) {\n    struct sockaddr_nl addr;\n    socklen_t addrlen = sizeof (addr);\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    if ((talk_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto err_out;\n    }\n    if (connect(talk_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: connect talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (getsockname(talk_sock, (struct sockaddr *)&addr, &addrlen) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: getsockname talk_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s getsockname talk_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    talk_seq = random();\n    memset(&addr, 0, sizeof (addr));\n    addr.nl_family = 16;\n    addr.nl_groups = 64;\n    if ((poll_sock = socket(16, SOCK_RAW, 0)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: socket poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_talk;\n    }\n    if (bind(poll_sock, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        ({\n            if (foreground) {\n                struct timeval tv;\n                gettimeofday(&tv, ((void *)0));\n                fprintf(stderr, \"%ld.%06ld [error] %s: bind poll_sock %s\\n\", tv.tv_sec, tv.tv_usec, __func__, strerror((*__errno_location())));\n            } else\n                syslog(3, \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s bind poll_sock %s\\\"}\", __func__, strerror((*__errno_location())));\n        });\n        goto cleanup_poll;\n    }\n    if (get_nhs() < 0)\n        goto cleanup_poll;\n    return poll_sock;\n  cleanup_poll:\n    close(poll_sock);\n  cleanup_talk:\n    close(talk_sock);\n  err_out:\n    return -1;\n}\n","function_prediction":"int open_nl_name_conflict(void) {\n  struct sockaddr_nl nladdr;\n  socklen_t nladdr_len = sizeof(nladdr);\n  struct timeval tv;\n\n  nladdr.nl_family = AF_NETLINK;\n  nladdr.nl_pad = 0;\n  nladdr.nl_pid = 0;\n  nladdr.nl_groups = 0;\n\n  talk_sock = socket(AF_NETLINK, 3, 0);\n  if (talk_sock < 0) {\n    do {\n      if (foreground) {\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"socket talk_sock %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"open_nl_name_conflict\",\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s socket talk_sock %s\\\"}\",\n               \"open_nl_name_conflict\", strerror(*__errno_location()));\n      }\n    } while (0);\n    return -1;\n  }\n\n  if (connect(talk_sock, (struct sockaddr *)&nladdr, nladdr_len) < 0) {\n    do {\n      if (foreground) {\n        gettimeofday(&tv, NULL);\n        fprintf(stderr,\n                \"%ld.%06ld [error] %s: \"\n                \"connect talk_sock %s\"\n                \"\\n\",\n                (long)tv.tv_sec, (long)tv.tv_usec, \"open_nl_name_conflict\",\n                strerror(*__errno_location()));\n      } else {\n        syslog(3,\n               \"{\\\"appname\\\": \\\"mpgwd\\\", \\\"msg\\\": \\\"%s connect talk_sock %s\\\"}\",\n               \"open_nl_name_conflict\", strerror(*__errno_location()));\n      }\n    } while (0);\n    close(talk_sock);\n    return -1;\n  }\n\n    if (getsockname(talk_sock, (struct sockaddr *)&nladdr, &nladdr_len) < 0","pass":0,"source_file":"C_COMPILE/flhs_ecmpd/ecmpd/nl.c"}
{"compilable":0,"function":"int open_device(char *devname, long sig) {\n    struct sigaction sa = {.__sigaction_handler.sa_handler = sigio};\n    int fd;\n    printf(\"device file = %s\\n\", devname);\n    fd = open(devname, 0);\n    if (fd < 0) {\n        perror(\"open\");\n        return fd;\n    }\n    sigaction(sig, &sa, ((void *)0));\n    if (fcntl(fd, 8, getpid()) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n    if (fcntl(fd, 10, sig) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n    if (fcntl(fd, 4, 8192) < 0) {\n        perror(\"fcntl\");\n        exit(1);\n    }\n}\n","function_prediction":"int open_device_name_conflict(char *device, int signum) {\n  int fd;\n  struct sigaction act;\n  int i;\n\n  for (i = 0; i < sizeof(act.sa_mask); i++)\n    act.sa_mask.sig[i] = 0;\n  act.sa_handler = sigio;\n\n  printf(\"device file = %s\\n\", device);\n\n  fd = open(device, 0);\n  if (fd < 0) {\n    perror(\"open\");\n    return fd;\n  }\n\n  sigaction(signum, &act, NULL);\n\n  if (fcntl(fd, 8, getpid()) < 0)\n    goto err;\n\n  if (fcntl(fd, 10, signum) < 0)\n    goto err;\n\n  if (fcntl(fd, 4, 0x2000) < 0)\n    goto err;\n\n  return fd;\n\nerr:\n  perror(\"fcntl\");\n  exit(1);\n}","pass":0,"source_file":"C_COMPILE/NeoCat_YUREX-driver-for-Linux/sample/timing-game.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"int parse_utf16_hex_name_conflict(const char *str, uint16_t *out) {\n  int i, c, c1, c2, c3, c4;\n  int error = 0;\n\n  for (i = 0; i < 4; i++) {\n    c = str[i];\n    if (c == 0)\n      return 0;\n    if (c >= '0' && c <= '9')\n      c -= '0';\n    else if (c >= 'a' && c <= 'f')\n      c -= 'a' - 10;\n    else if (c >= 'A' && c <= 'F')\n      c -= 'A' - 10;\n    else\n      error = 1;\n    if (i == 0)\n      c1 = c;\n    else if (i == 1)\n      c2 = c;\n    else if (i == 2)\n      c3 = c;\n    else if (i == 3)\n      c4 = c;\n  }\n\n  if (error)\n    return 0;\n\n  *out = (c1 << 12) | (c2 << 8) | (c3 << 4) | c4;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"char *read_file_name_conflict(const char *file_path) {\n  FILE *file = fopen(file_path, \"r\");\n  if (!file) {\n    return NULL;\n  }\n\n  fseek(file, 0, SEEK_END);\n  long file_size = ftell(file);\n  if (file_size < 0) {\n    fclose(file);\n    return NULL;\n  }\n\n  rewind(file);\n\n  char *file_content = (char *)parson_malloc(file_size + 1);\n  if (!file_content) {\n    fclose(file);\n    return NULL;\n  }\n\n  size_t bytes_read = fread(file_content, 1, file_size, file);\n  if (bytes_read == 0 || ferror(file)) {\n    fclose(file);\n    parson_free(file_content);\n    return NULL;\n  }\n\n  fclose(file);\n\n  file_content[bytes_read] = '\\0';\n  return file_content;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"int parse_utf16_hex(const char *str, uint16_t *out) {\n  int i, c, c1, c2, c3, c4;\n  int error = 0;\n\n  for (i = 0; i < 4; i++) {\n    c = str[i];\n    if (c == 0)\n      return 0;\n    if (c >= '0' && c <= '9')\n      c -= '0';\n    else if (c >= 'a' && c <= 'f')\n      c -= 'a' - 10;\n    else if (c >= 'A' && c <= 'F')\n      c -= 'A' - 10;\n    else\n      error = 1;\n    if (i == 0)\n      c1 = c;\n    else if (i == 1)\n      c2 = c;\n    else if (i == 2)\n      c3 = c;\n    else if (i == 3)\n      c4 = c;\n  }\n\n  if (error)\n    return 0;\n\n  *out = (c1 << 12) | (c2 << 8) | (c3 << 4) | c4;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"char *get_quoted_string_name_conflict(char **string) {\n  char *start = *string;\n  char *end = start;\n  char *result;\n  char *temp;\n  char *temp2;\n  char *temp3;\n  char *temp4;\n  char *temp5;\n  char *temp6;\n  char *temp7;\n  char *temp8;\n  char *temp9;\n  char *temp10;\n  char *temp11;\n  char *temp12;\n  char *temp13;\n  char *temp14;\n  char *temp15;\n  char *temp16;\n  char *temp17;\n  char *temp18;\n  char *temp19;\n  char *temp20;\n  char *temp21;\n  char *temp22;\n  char *temp23;\n  char *temp24;\n  char *temp25;\n  char *temp26;\n  char *temp27;\n  char *temp28;\n  char *temp29;\n  char *temp30;\n  char *temp31;\n  char *temp32;\n  char *temp33;\n  char *temp34;\n  char *temp35;\n  char *temp36;\n  char *temp37;\n  char *temp38;\n  char *temp39;\n  char *temp40;\n  char *temp41;\n  char *temp42;\n  char *temp43;\n  char *temp44;\n  char *temp45;\n  char *temp46;\n  char *temp47;\n  char *temp48;\n  char *temp49;\n  char *temp50;\n  char *temp51;\n  char *temp52;\n  char *temp53;\n  char *temp54;\n  char *temp55;\n  char *temp56;\n  char *temp57;\n  char *temp58;\n  char *temp59;\n  char *temp60;\n  char *temp","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"int json_serialize_string_name_conflict(const char *str, char *buf) {\n  size_t len = strlen(str);\n  char *p = buf;\n  int i, j = 0;\n\n  if (buf)\n    *p++ = '\"';\n\n  for (i = 0; i < len; i++) {\n    switch (str[i]) {\n    case '\\\\':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = '\\\\';\n      j += 2;\n      break;\n    case '/':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = '/';\n      j += 2;\n      break;\n    case '\"':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = '\"';\n      j += 2;\n      break;\n    case '\\b':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'b';\n      j += 2;\n      break;\n    case '\\f':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'f';\n      j += 2;\n      break;\n    case '\\n':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'n';\n      j += 2;\n      break;\n    case '\\r':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'r';\n      j += 2;\n      break;\n    case '\\t':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 't';\n      j += 2;\n      break;\n    case '\\0':\n      if (p) {\n        *p++ = '\\\\';\n        *p++ = 'u';\n        *p++ = '0';\n        *p++ = '0';\n        *p++ = '0';\n      }\n      j += 6;\n      break;\n    case '\\1':\n      if (p) {\n        *p++ = '\\\\';\n        *p++ = 'u';\n      *p++","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"int parse_utf16_hex_name_conflict(const char *str, uint16_t *out) {\n  int i, c, c1, c2, c3, c4;\n  int error = 0;\n\n  for (i = 0; i < 4; i++) {\n    c = str[i];\n    if (c == 0)\n      return 0;\n    if (c >= '0' && c <= '9')\n      c -= '0';\n    else if (c >= 'a' && c <= 'f')\n      c -= 'a' - 10;\n    else if (c >= 'A' && c <= 'F')\n      c -= 'A' - 10;\n    else\n      error = 1;\n    if (i == 0)\n      c1 = c;\n    else if (i == 1)\n      c2 = c;\n    else if (i == 2)\n      c3 = c;\n    else if (i == 3)\n      c4 = c;\n  }\n\n  if (error)\n    return 0;\n\n  *out = (c1 << 12) | (c2 << 8) | (c3 << 4) | c4;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"char *read_file_name_conflict(const char *file_path) {\n  FILE *file = fopen(file_path, \"r\");\n  if (!file) {\n    return NULL;\n  }\n\n  fseek(file, 0, SEEK_END);\n  long file_size = ftell(file);\n  if (file_size < 0) {\n    fclose(file);\n    return NULL;\n  }\n\n  rewind(file);\n\n  char *file_content = (char *)parson_malloc(file_size + 1);\n  if (!file_content) {\n    fclose(file);\n    return NULL;\n  }\n\n  size_t bytes_read = fread(file_content, 1, file_size, file);\n  if (bytes_read == 0 || ferror(file)) {\n    fclose(file);\n    parson_free(file_content);\n    return NULL;\n  }\n\n  fclose(file);\n\n  file_content[bytes_read] = '\\0';\n  return file_content;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"int parse_utf16_hex(const char *str, uint16_t *out) {\n  int i, c, c1, c2, c3, c4;\n  int error = 0;\n\n  for (i = 0; i < 4; i++) {\n    c = str[i];\n    if (c == 0)\n      return 0;\n    if (c >= '0' && c <= '9')\n      c -= '0';\n    else if (c >= 'a' && c <= 'f')\n      c -= 'a' - 10;\n    else if (c >= 'A' && c <= 'F')\n      c -= 'A' - 10;\n    else\n      error = 1;\n    if (i == 0)\n      c1 = c;\n    else if (i == 1)\n      c2 = c;\n    else if (i == 2)\n      c3 = c;\n    else if (i == 3)\n      c4 = c;\n  }\n\n  if (error)\n    return 0;\n\n  *out = (c1 << 12) | (c2 << 8) | (c3 << 4) | c4;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"char *get_quoted_string_name_conflict(char **string) {\n  char *start = *string;\n  char *end = start;\n  char *result;\n  char *temp;\n  char *temp2;\n  char *temp3;\n  char *temp4;\n  char *temp5;\n  char *temp6;\n  char *temp7;\n  char *temp8;\n  char *temp9;\n  char *temp10;\n  char *temp11;\n  char *temp12;\n  char *temp13;\n  char *temp14;\n  char *temp15;\n  char *temp16;\n  char *temp17;\n  char *temp18;\n  char *temp19;\n  char *temp20;\n  char *temp21;\n  char *temp22;\n  char *temp23;\n  char *temp24;\n  char *temp25;\n  char *temp26;\n  char *temp27;\n  char *temp28;\n  char *temp29;\n  char *temp30;\n  char *temp31;\n  char *temp32;\n  char *temp33;\n  char *temp34;\n  char *temp35;\n  char *temp36;\n  char *temp37;\n  char *temp38;\n  char *temp39;\n  char *temp40;\n  char *temp41;\n  char *temp42;\n  char *temp43;\n  char *temp44;\n  char *temp45;\n  char *temp46;\n  char *temp47;\n  char *temp48;\n  char *temp49;\n  char *temp50;\n  char *temp51;\n  char *temp52;\n  char *temp53;\n  char *temp54;\n  char *temp55;\n  char *temp56;\n  char *temp57;\n  char *temp58;\n  char *temp59;\n  char *temp60;\n  char *temp","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"int json_serialize_string_name_conflict(const char *str, char *buf) {\n  size_t len = strlen(str);\n  char *p = buf;\n  int i, j = 0;\n\n  if (buf)\n    *p++ = '\"';\n\n  for (i = 0; i < len; i++) {\n    switch (str[i]) {\n    case '\\\\':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = '\\\\';\n      j += 2;\n      break;\n    case '/':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = '/';\n      j += 2;\n      break;\n    case '\"':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = '\"';\n      j += 2;\n      break;\n    case '\\b':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'b';\n      j += 2;\n      break;\n    case '\\f':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'f';\n      j += 2;\n      break;\n    case '\\n':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'n';\n      j += 2;\n      break;\n    case '\\r':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'r';\n      j += 2;\n      break;\n    case '\\t':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 't';\n      j += 2;\n      break;\n    case '\\0':\n      if (p) {\n        *p++ = '\\\\';\n        *p++ = 'u';\n        *p++ = '0';\n        *p++ = '0';\n        *p++ = '0';\n      }\n      j += 6;\n      break;\n    case '\\1':\n      if (p) {\n        *p++ = '\\\\';\n        *p++ = 'u';\n      *p++","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strndup(const char *string, size_t n) {\n    char *output_string = (char *)parson_malloc(n + 1);\n    if (!output_string) {\n        return ((void *)0);\n    }\n    output_string[n] = '\\x00';\n    strncpy(output_string, string, n);\n    return output_string;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *parson_strdup(const char *string) {\n    return parson_strndup(string, strlen(string));\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int hex_char_to_int(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    } else if (c >= 'a' && c <= 'f') {\n        return c - 'a' + 10;\n    } else if (c >= 'A' && c <= 'F') {\n        return c - 'A' + 10;\n    }\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16_hex(const char *s, unsigned int *result) {\n    int x1, x2, x3, x4;\n    if (s[0] == '\\x00' || s[1] == '\\x00' || s[2] == '\\x00' || s[3] == '\\x00') {\n        return 0;\n    }\n    x1 = hex_char_to_int(s[0]);\n    x2 = hex_char_to_int(s[1]);\n    x3 = hex_char_to_int(s[2]);\n    x4 = hex_char_to_int(s[3]);\n    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {\n        return 0;\n    }\n    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);\n    return 1;\n}\n","function_prediction":"int parse_utf16_hex_name_conflict(const char *str, uint16_t *out) {\n  int i, c, c1, c2, c3, c4;\n  int error = 0;\n\n  for (i = 0; i < 4; i++) {\n    c = str[i];\n    if (c == 0)\n      return 0;\n    if (c >= '0' && c <= '9')\n      c -= '0';\n    else if (c >= 'a' && c <= 'f')\n      c -= 'a' - 10;\n    else if (c >= 'A' && c <= 'F')\n      c -= 'A' - 10;\n    else\n      error = 1;\n    if (i == 0)\n      c1 = c;\n    else if (i == 1)\n      c2 = c;\n    else if (i == 2)\n      c3 = c;\n    else if (i == 3)\n      c4 = c;\n  }\n\n  if (error)\n    return 0;\n\n  *out = (c1 << 12) | (c2 << 8) | (c3 << 4) | c4;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int num_bytes_in_utf8_sequence(unsigned char c) {\n    if (c == 192 || c == 193 || c > 244 || (((unsigned char)(c) & 192) == 128)) {\n        return 0;\n    } else if ((c & 128) == 0) {\n        return 1;\n    } else if ((c & 224) == 192) {\n        return 2;\n    } else if ((c & 240) == 224) {\n        return 3;\n    } else if ((c & 248) == 240) {\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int verify_utf8_sequence(const unsigned char *string, int *len) {\n    unsigned int cp = 0;\n    *len = num_bytes_in_utf8_sequence(string[0]);\n    if (*len == 1) {\n        cp = string[0];\n    } else if (*len == 2 && (((unsigned char)(string[1]) & 192) == 128)) {\n        cp = string[0] & 31;\n        cp = (cp << 6) | (string[1] & 63);\n    } else if (*len == 3 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128)) {\n        cp = ((unsigned char)string[0]) & 15;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n    } else if (*len == 4 && (((unsigned char)(string[1]) & 192) == 128) && (((unsigned char)(string[2]) & 192) == 128) && (((unsigned char)(string[3]) & 192) == 128)) {\n        cp = string[0] & 7;\n        cp = (cp << 6) | (string[1] & 63);\n        cp = (cp << 6) | (string[2] & 63);\n        cp = (cp << 6) | (string[3] & 63);\n    } else {\n        return 0;\n    }\n    if ((cp < 128 && *len > 1) || (cp < 2048 && *len > 2) || (cp < 65536 && *len > 3)) {\n        return 0;\n    }\n    if (cp > 1114111) {\n        return 0;\n    }\n    if (cp >= 55296 && cp <= 57343) {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_valid_utf8(const char *string, size_t string_len) {\n    int len = 0;\n    const char *string_end = string + string_len;\n    while (string < string_end)\n        {\n            if (!verify_utf8_sequence((const unsigned char *)string, &len)) {\n                return 0;\n            }\n            string += len;\n        }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int is_decimal(const char *string, size_t length) {\n    if (length > 1 && string[0] == '0' && string[1] != '.') {\n        return 0;\n    }\n    if (length > 2 && !strncmp(string, \"-0\", 2) && string[2] != '.') {\n        return 0;\n    }\n    while (length--)\n        {\n            if (strchr(\"xX\", string[length])) {\n                return 0;\n            }\n        }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *read_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    size_t size_to_read = 0;\n    size_t size_read = 0;\n    long pos;\n    char *file_contents;\n    if (!fp) {\n        return ((void *)0);\n    }\n    fseek(fp, 0L, 2);\n    pos = ftell(fp);\n    if (pos < 0) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_to_read = pos;\n    rewind(fp);\n    file_contents = (char *)parson_malloc(sizeof(char) * (size_to_read + 1));\n    if (!file_contents) {\n        fclose(fp);\n        return ((void *)0);\n    }\n    size_read = fread(file_contents, 1, size_to_read, fp);\n    if (size_read == 0 || ferror(fp)) {\n        fclose(fp);\n        parson_free(file_contents);\n        return ((void *)0);\n    }\n    fclose(fp);\n    file_contents[size_read] = '\\x00';\n    return file_contents;\n}\n","function_prediction":"char *read_file_name_conflict(const char *file_path) {\n  FILE *file = fopen(file_path, \"r\");\n  if (!file) {\n    return NULL;\n  }\n\n  fseek(file, 0, SEEK_END);\n  long file_size = ftell(file);\n  if (file_size < 0) {\n    fclose(file);\n    return NULL;\n  }\n\n  rewind(file);\n\n  char *file_content = (char *)parson_malloc(file_size + 1);\n  if (!file_content) {\n    fclose(file);\n    return NULL;\n  }\n\n  size_t bytes_read = fread(file_content, 1, file_size, file);\n  if (bytes_read == 0 || ferror(file)) {\n    fclose(file);\n    parson_free(file_content);\n    return NULL;\n  }\n\n  fclose(file);\n\n  file_content[bytes_read] = '\\0';\n  return file_content;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static JSON_Status skip_quotes(const char **string) {\n    if (**string != '\"') {\n        return JSONFailure;\n    }\n    ((*string)++);\n    while (**string != '\"')\n        {\n            if (**string == '\\x00') {\n                return JSONFailure;\n            } else if (**string == '\\\\') {\n                ((*string)++);\n                if (**string == '\\x00') {\n                    return JSONFailure;\n                }\n            }\n            ((*string)++);\n        }\n    ((*string)++);\n    return JSONSuccess;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int parse_utf16(const char **unprocessed, char **processed) {\n    unsigned int cp, lead, trail;\n    int parse_succeeded = 0;\n    char *processed_ptr = *processed;\n    const char *unprocessed_ptr = *unprocessed;\n    unprocessed_ptr++;\n    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);\n    if (!parse_succeeded) {\n        return JSONFailure;\n    }\n    if (cp < 128) {\n        processed_ptr[0] = (char)cp;\n    } else if (cp < 2048) {\n        processed_ptr[0] = ((cp >> 6) & 31) | 192;\n        processed_ptr[1] = ((cp) & 63) | 128;\n        processed_ptr += 1;\n    } else if (cp < 55296 || cp > 57343) {\n        processed_ptr[0] = ((cp >> 12) & 15) | 224;\n        processed_ptr[1] = ((cp >> 6) & 63) | 128;\n        processed_ptr[2] = ((cp) & 63) | 128;\n        processed_ptr += 2;\n    } else if (cp >= 55296 && cp <= 56319) {\n        lead = cp;\n        unprocessed_ptr += 4;\n        if (*unprocessed_ptr++ != '\\\\' || *unprocessed_ptr++ != 'u') {\n            return JSONFailure;\n        }\n        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);\n        if (!parse_succeeded || trail < 56320 || trail > 57343) {\n            return JSONFailure;\n        }\n        cp = ((((lead - 55296) & 1023) << 10) | ((trail - 56320) & 1023)) + 65536;\n        processed_ptr[0] = (((cp >> 18) & 7) | 240);\n        processed_ptr[1] = (((cp >> 12) & 63) | 128);\n        processed_ptr[2] = (((cp >> 6) & 63) | 128);\n        processed_ptr[3] = (((cp) & 63) | 128);\n        processed_ptr += 3;\n    } else {\n        return JSONFailure;\n    }\n    unprocessed_ptr += 3;\n    *processed = processed_ptr;\n    *unprocessed = unprocessed_ptr;\n    return JSONSuccess;\n}\n","function_prediction":"int parse_utf16_hex(const char *str, uint16_t *out) {\n  int i, c, c1, c2, c3, c4;\n  int error = 0;\n\n  for (i = 0; i < 4; i++) {\n    c = str[i];\n    if (c == 0)\n      return 0;\n    if (c >= '0' && c <= '9')\n      c -= '0';\n    else if (c >= 'a' && c <= 'f')\n      c -= 'a' - 10;\n    else if (c >= 'A' && c <= 'F')\n      c -= 'A' - 10;\n    else\n      error = 1;\n    if (i == 0)\n      c1 = c;\n    else if (i == 1)\n      c2 = c;\n    else if (i == 2)\n      c3 = c;\n    else if (i == 3)\n      c4 = c;\n  }\n\n  if (error)\n    return 0;\n\n  *out = (c1 << 12) | (c2 << 8) | (c3 << 4) | c4;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *process_string(const char *input, size_t len) {\n    const char *input_ptr = input;\n    size_t initial_size = (len + 1) * sizeof(char);\n    size_t final_size = 0;\n    char *output = ((void *)0), *output_ptr = ((void *)0), *resized_output = ((void *)0);\n    output = (char *)parson_malloc(initial_size);\n    if (output == ((void *)0)) {\n        goto error;\n    }\n    output_ptr = output;\n    while ((*input_ptr != '\\x00') && (size_t)(input_ptr - input) < len)\n        {\n            if (*input_ptr == '\\\\') {\n                input_ptr++;\n                switch (*input_ptr) {\n                  case '\"':\n                    *output_ptr = '\"';\n                    break;\n                  case '\\\\':\n                    *output_ptr = '\\\\';\n                    break;\n                  case '/':\n                    *output_ptr = '/';\n                    break;\n                  case 'b':\n                    *output_ptr = '\\b';\n                    break;\n                  case 'f':\n                    *output_ptr = '\\f';\n                    break;\n                  case 'n':\n                    *output_ptr = '\\n';\n                    break;\n                  case 'r':\n                    *output_ptr = '\\r';\n                    break;\n                  case 't':\n                    *output_ptr = '\\t';\n                    break;\n                  case 'u':\n                    if (parse_utf16(&input_ptr, &output_ptr) == JSONFailure) {\n                        goto error;\n                    }\n                    break;\n                  default:\n                    goto error;\n                }\n            } else if ((unsigned char)*input_ptr < 32) {\n                goto error;\n            } else {\n                *output_ptr = *input_ptr;\n            }\n            output_ptr++;\n            input_ptr++;\n        }\n    *output_ptr = '\\x00';\n    final_size = (size_t)(output_ptr - output) + 1;\n    resized_output = (char *)parson_malloc(final_size);\n    if (resized_output == ((void *)0)) {\n        goto error;\n    }\n    memcpy(resized_output, output, final_size);\n    parson_free(output);\n    return resized_output;\n  error:\n    parson_free(output);\n    return ((void *)0);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static char *get_quoted_string(const char **string) {\n    const char *string_start = *string;\n    size_t string_len = 0;\n    JSON_Status status = skip_quotes(string);\n    if (status != JSONSuccess) {\n        return ((void *)0);\n    }\n    string_len = *string - string_start - 2;\n    return process_string(string_start + 1, string_len);\n}\n","function_prediction":"char *get_quoted_string_name_conflict(char **string) {\n  char *start = *string;\n  char *end = start;\n  char *result;\n  char *temp;\n  char *temp2;\n  char *temp3;\n  char *temp4;\n  char *temp5;\n  char *temp6;\n  char *temp7;\n  char *temp8;\n  char *temp9;\n  char *temp10;\n  char *temp11;\n  char *temp12;\n  char *temp13;\n  char *temp14;\n  char *temp15;\n  char *temp16;\n  char *temp17;\n  char *temp18;\n  char *temp19;\n  char *temp20;\n  char *temp21;\n  char *temp22;\n  char *temp23;\n  char *temp24;\n  char *temp25;\n  char *temp26;\n  char *temp27;\n  char *temp28;\n  char *temp29;\n  char *temp30;\n  char *temp31;\n  char *temp32;\n  char *temp33;\n  char *temp34;\n  char *temp35;\n  char *temp36;\n  char *temp37;\n  char *temp38;\n  char *temp39;\n  char *temp40;\n  char *temp41;\n  char *temp42;\n  char *temp43;\n  char *temp44;\n  char *temp45;\n  char *temp46;\n  char *temp47;\n  char *temp48;\n  char *temp49;\n  char *temp50;\n  char *temp51;\n  char *temp52;\n  char *temp53;\n  char *temp54;\n  char *temp55;\n  char *temp56;\n  char *temp57;\n  char *temp58;\n  char *temp59;\n  char *temp60;\n  char *temp","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int json_serialize_string(const char *string, char *buf) {\n    size_t i = 0, len = strlen(string);\n    char c = '\\x00';\n    int written = -1, written_total = 0;\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    for (i = 0; i < len; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            do {\n                written = append_string(buf, (\"\\\\\\\"\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\\\':\n            do {\n                written = append_string(buf, (\"\\\\\\\\\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '/':\n            do {\n                written = append_string(buf, (\"\\\\/\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\b':\n            do {\n                written = append_string(buf, (\"\\\\b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\f':\n            do {\n                written = append_string(buf, (\"\\\\f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\n':\n            do {\n                written = append_string(buf, (\"\\\\n\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\r':\n            do {\n                written = append_string(buf, (\"\\\\r\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\t':\n            do {\n                written = append_string(buf, (\"\\\\t\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x00':\n            do {\n                written = append_string(buf, (\"\\\\u0000\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x01':\n            do {\n                written = append_string(buf, (\"\\\\u0001\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x02':\n            do {\n                written = append_string(buf, (\"\\\\u0002\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x03':\n            do {\n                written = append_string(buf, (\"\\\\u0003\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x04':\n            do {\n                written = append_string(buf, (\"\\\\u0004\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x05':\n            do {\n                written = append_string(buf, (\"\\\\u0005\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x06':\n            do {\n                written = append_string(buf, (\"\\\\u0006\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\a':\n            do {\n                written = append_string(buf, (\"\\\\u0007\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\v':\n            do {\n                written = append_string(buf, (\"\\\\u000b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0e':\n            do {\n                written = append_string(buf, (\"\\\\u000e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x0f':\n            do {\n                written = append_string(buf, (\"\\\\u000f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x10':\n            do {\n                written = append_string(buf, (\"\\\\u0010\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x11':\n            do {\n                written = append_string(buf, (\"\\\\u0011\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x12':\n            do {\n                written = append_string(buf, (\"\\\\u0012\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x13':\n            do {\n                written = append_string(buf, (\"\\\\u0013\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x14':\n            do {\n                written = append_string(buf, (\"\\\\u0014\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x15':\n            do {\n                written = append_string(buf, (\"\\\\u0015\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x16':\n            do {\n                written = append_string(buf, (\"\\\\u0016\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x17':\n            do {\n                written = append_string(buf, (\"\\\\u0017\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x18':\n            do {\n                written = append_string(buf, (\"\\\\u0018\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x19':\n            do {\n                written = append_string(buf, (\"\\\\u0019\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1a':\n            do {\n                written = append_string(buf, (\"\\\\u001a\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1b':\n            do {\n                written = append_string(buf, (\"\\\\u001b\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1c':\n            do {\n                written = append_string(buf, (\"\\\\u001c\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1d':\n            do {\n                written = append_string(buf, (\"\\\\u001d\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1e':\n            do {\n                written = append_string(buf, (\"\\\\u001e\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          case '\\x1f':\n            do {\n                written = append_string(buf, (\"\\\\u001f\"));\n                if (written < 0) {\n                    return -1;\n                }\n                if (buf != ((void *)0)) {\n                    buf += written;\n                }\n                written_total += written;\n            } while (0);\n            break;\n          default:\n            if (buf != ((void *)0)) {\n                buf[0] = c;\n                buf += 1;\n            }\n            written_total += 1;\n            break;\n        }\n    }\n    do {\n        written = append_string(buf, (\"\\\"\"));\n        if (written < 0) {\n            return -1;\n        }\n        if (buf != ((void *)0)) {\n            buf += written;\n        }\n        written_total += written;\n    } while (0);\n    return written_total;\n}\n","function_prediction":"int json_serialize_string_name_conflict(const char *str, char *buf) {\n  size_t len = strlen(str);\n  char *p = buf;\n  int i = 0;\n\n  if (buf)\n    *p++ = '\"';\n\n  for (i = 0; i < len; i++) {\n    switch (str[i]) {\n    case '\\\\':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = '\\\\';\n      break;\n    case '/':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = '/';\n      break;\n    case '\"':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = '\"';\n      break;\n    case '\\b':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'b';\n      break;\n    case '\\f':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'f';\n      break;\n    case '\\n':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'n';\n      break;\n    case '\\r':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 'r';\n      break;\n    case '\\t':\n      if (p)\n        *p++ = '\\\\';\n      *p++ = 't';\n      break;\n    case '\\0':\n      if (p) {\n        *p++ = '\\\\';\n        *p++ = 'u';\n        *p++ = '0';\n        *p++ = '0';\n        *p++ = '0';\n      }\n      break;\n    case '\\1':\n      if (p) {\n        *p++ = '\\\\';\n        *p++ = 'u';\n        *p++ = '0';\n        *p++ = '0';\n        *p++ = '1';\n      }\n      break;\n    case '\\2':\n      if (p) {\n        *p++ = '\\\\';\n      *p++","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_indent(char *buf, int level) {\n    int i;\n    int written = -1, written_total = 0;\n    for (i = 0; i < level; i++) {\n        do {\n            written = append_string(buf, (\"    \"));\n            if (written < 0) {\n                return -1;\n            }\n            if (buf != ((void *)0)) {\n                buf += written;\n            }\n            written_total += written;\n        } while (0);\n    }\n    return written_total;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"static int append_string(char *buf, const char *string) {\n    if (buf == ((void *)0)) {\n        return (int)strlen(string);\n    }\n    return sprintf(buf, \"%s\", string);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/msteinbeck_tinyspline/src/parson.c"}
{"compilable":0,"function":"int io_signal(int fd, int sig) {\n    int flags;\n    if (fcntl(fd, 10, sig) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to set signal %d on fd %d: %s\\n\", __func__, 11, sig, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    if (fcntl(fd, 8, getpid()) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to set process as owner of fd %d: %s\\n\", __func__, 15, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    flags = fcntl(fd, 3);\n    if (flags == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to get flags of fd %d: %s\\n\", __func__, 20, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    if (fcntl(fd, 4, flags | 8192 | 2048) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: failed to enable I/O signaling for fd %d: %s\\n\", __func__, 24, fd, strerror((*__errno_location())));\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int io_signal_name_conflict(int fd, int sig) {\n  int flags;\n\n  if (fcntl(fd, 10, sig) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"failed to set signal %d on fd %d: %s\\n\",\n            \"io_signal_name_conflict\", 10, sig, fd, strerror(*__errno_location()));\n    return 1;\n  }\n\n  if (fcntl(fd, 8, getpid()) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"failed to set process as owner of fd %d: %s\\n\",\n            \"io_signal_name_conflict\", 14, fd, strerror(*__errno_location()));\n    return 1;\n  }\n\n  if ((flags = fcntl(fd, 3)) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"failed to get flags of fd %d: %s\\n\",\n            \"io_signal_name_conflict\", 19, fd, strerror(*__errno_location()));\n    return 1;\n  }\n\n  if (fcntl(fd, 4, flags | 0x2000 | 0x0800) == -1) {\n    fprintf(stderr,\n            \"ERROR %s:%d: \"\n            \"failed to enable I/O signaling for fd %d: %s\\n\",\n            \"io_signal_name_conflict\", 23, fd, strerror(*__errno_location()));\n    return 1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"static ssize_t read_nonblock(int fd, char *buf, size_t size) {\n    ssize_t nr;\n    nr = read(fd, buf, size);\n    if (nr == -1) {\n        if ((*__errno_location()) == 11) {\n            return 0;\n        }\n        fprintf(stderr, \"ERROR %s:%d: read from %d: %s\\n\", __func__, 38, fd, strerror((*__errno_location())));\n        return -1;\n    }\n    return nr;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"int io_readline(int fd, char *buffer, size_t size) {\n    int nr = 0;\n    char c;\n    while (nr < size && read_nonblock(fd, &c, 1) > 0 && c != '\\n')\n        buffer[nr++] = c;\n    return nr;\n}\n","function_prediction":"int io_readline_name_conflict(int fd, char *buf, size_t len) {\n  int i = 0;\n  char c;\n  ssize_t r;\n\n  while (len > 0) {\n    r = read(fd, &c, 1);\n    if (r == -1) {\n      do {\n        if ((*__errno_location()) != 11) {\n          fprintf(stderr,\n                  \"ERROR %s:%d: \"\n                  \"read from %d: %s\"\n                  \"\\n\",\n                  \"read_nonblock\", 37, fd, strerror(*__errno_location()));\n        }\n      } while (0);\n      return i;\n    }\n    if (r <= 0)\n      return i;\n    if (c == '\\n')\n      return i;\n    buf[i++] = c;\n    len--;\n  }\n  return i;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/io.c"}
{"compilable":0,"function":"static inline bool is_number(const char *str) {\n    char *end;\n    strtoul(str, &end, 10);\n    return !(*str == 0 || *end != 0);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/json.c"}
{"compilable":0,"function":"static int parse_section(const char *line, char *name, unsigned int size) {\n    char *closing = strchr(line, ']');\n    const int len = strlen(line);\n    if (!closing || line + len - 1 != closing) {\n        fprintf(stderr, \"ERROR %s:%d: malformated section \\\"%s\\\"\\n\", __func__, 33, line);\n        return 1;\n    }\n    if (size - 1 < len - 2) {\n        fprintf(stderr, \"ERROR %s:%d: section name too long \\\"%s\\\"\\n\", __func__, 37, line);\n        return 1;\n    }\n    memcpy(name, line + 1, len - 2);\n    name[len - 2] = '\\x00';\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/ini.c"}
{"compilable":0,"function":"static int parse_property(const char *line, struct properties *props, bool strict) {\n    char *equal = strchr(line, '=');\n    const char *key, *value;\n    if (!equal) {\n        fprintf(stderr, \"ERROR %s:%d: malformated property, should be a key=value pair\\n\", __func__, 50);\n        return 1;\n    }\n    *equal = '\\x00';\n    key = line;\n    value = equal + 1;\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"full_text\") == 0) {\n        strncpy(props->full_text, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"short_text\") == 0) {\n        strncpy(props->short_text, value, 512 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"color\") == 0) {\n        strncpy(props->color, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2 | 4) & 1) && strcmp(key, \"min_width\") == 0) {\n        strncpy(props->min_width, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"align\") == 0) {\n        strncpy(props->align, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"name\") == 0) {\n        strncpy(props->name, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"instance\") == 0) {\n        strncpy(props->instance, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 8) & 1) && strcmp(key, \"urgent\") == 0) {\n        strncpy(props->urgent, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 8) & 1) && strcmp(key, \"separator\") == 0) {\n        strncpy(props->separator, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 4) & 1) && strcmp(key, \"separator_block_width\") == 0) {\n        strncpy(props->separator_block_width, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (1 | 2) & 1) && strcmp(key, \"markup\") == 0) {\n        strncpy(props->markup, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (2) & 1) && strcmp(key, \"command\") == 0) {\n        strncpy(props->command, value, 1024 - 1);\n        return 0;\n    }\n    if ((!strict || (2 | 4) & 1) && strcmp(key, \"interval\") == 0) {\n        strncpy(props->interval, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (4) & 1) && strcmp(key, \"signal\") == 0) {\n        strncpy(props->signal, value, 8 - 1);\n        return 0;\n    }\n    if ((!strict || (2) & 1) && strcmp(key, \"label\") == 0) {\n        strncpy(props->label, value, 32 - 1);\n        return 0;\n    }\n    if ((!strict || (2 | 4) & 1) && strcmp(key, \"format\") == 0) {\n        strncpy(props->format, value, 8 - 1);\n        return 0;\n    }\n    ;\n    fprintf(stderr, \"ERROR %s:%d: unknown key: \\\"%s\\\"\\n\", __func__, 63, key);\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/ini.c"}
{"compilable":0,"function":"static int gcd(int a, int b) {\n    while (b != 0)\n        a %= b , a ^= b , b ^= a , a ^= b;\n    return a;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/sched.c"}
{"compilable":0,"function":"static int setup_signals(void) {\n    if (sigemptyset(&sigset) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigemptyset: %s\\n\", __func__, 59, strerror((*__errno_location())));\n        return 1;\n    }\n    if (sigaddset(&sigset, 15) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 64, 15, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 2) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 65, 2, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 14) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 66, 14, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 17) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 67, 17, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 10) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 68, 10, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 12) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 69, 12, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, 29) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 70, 29, strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    if (sigaddset(&sigset, (__libc_current_sigrtmin())) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 71, (__libc_current_sigrtmin()), strerror((*__errno_location())));\n        return 1;\n    }\n    ;\n    for (int sig = (__libc_current_sigrtmin()) + 1; sig <= (__libc_current_sigrtmax()); ++sig) {\n        if (log_level >= LOG_DEBUG) {\n            fprintf(stderr, \"DEBUG %s:%d: provide signal %d (%s)\\n\", __func__, 73, sig, strsignal(sig));\n        }\n        ;\n        if (sigaddset(&sigset, sig) == -1) {\n            fprintf(stderr, \"ERROR %s:%d: sigaddset(%d): %s\\n\", __func__, 74, sig, strerror((*__errno_location())));\n            return 1;\n        }\n        ;\n    }\n    if (sigprocmask(2, &sigset, ((void *)0)) == -1) {\n        fprintf(stderr, \"ERROR %s:%d: sigprocmask: %s\\n\", __func__, 78, strerror((*__errno_location())));\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/barraponto_i3blocks/src/sched.c"}
{"compilable":1,"function":"int binsearch(int x, int v[], int n) {\n    int low, high, mid;\n    low = 0;\n    high = n - 1;\n    while (low < high)\n        {\n            mid = (low + high) / 2;\n            if (x <= v[mid])\n                high = mid;\n            else\n                low = mid + 1;\n        }\n    return x == v[low] ? low : -1;\n}\n","function_prediction":"int binsearch_name_conflict(int x, int v[], int n) {\n  int low, high, mid;\n\n  low = 0;\n  high = n - 1;\n  while (low < high) {\n    mid = (low + high) / 2;\n    if (x <= v[mid])\n      high = mid;\n    else\n      low = mid + 1;\n  }\n  if (v[low] == x)\n    return low;\n  else\n    return -1;\n}","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch3/bsearch.c"}
{"compilable":0,"function":"static int getword(char *word, int limit) {\n    int c;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        ;\n    if (c != (-1))\n        *word++ = c;\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        return c;\n    }\n    for (; --limit > 0; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/keyword_search.c"}
{"compilable":0,"function":"static int getch() {\n    return bufp > 0 ? buffer[--bufp] : getchar();\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/keyword_search.c"}
{"compilable":1,"function":"int getch() {\n    return bufp > 0 ? buffer[--bufp] : getchar();\n}\n","function_prediction":"int getch_name_conflict(void) {\n  if (bufp > 0)\n    return buffer[--bufp];\n  else\n    return getc(stdin);\n}","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":0,"function":"int getword(char *word, int limit) {\n    int c;\n    while (((*__ctype_b_loc())[(int)((c = getch()))] & (unsigned short)_ISspace))\n        ;\n    if (c != (-1))\n        *word++ = c;\n    if (!((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha)) {\n        *word = '\\x00';\n        return c;\n    }\n    for (; --limit > 0; word++) {\n        if (!((*__ctype_b_loc())[(int)((*word = getch()))] & (unsigned short)_ISalnum)) {\n            ungetch(*word);\n            break;\n        }\n    }\n    *word = '\\x00';\n    return word[0];\n}\n","function_prediction":"int getword_name_conflict(char *word, int lim) {\n  int c, getch(void);\n  void ungetch(int);\n  char *w = word;\n  const struct _ctype_t *ct = __ctype_b_loc();\n\n  while (bufp > 0 &&\n         ((ct)->__table[(unsigned char)((buffer[(bufp)-1]))] & (0x0020)))\n    c = buffer[--bufp];\n  if ((c = (bufp > 0 ? buffer[--bufp] : getc(stdin))) == EOF)\n    return EOF;\n  *w++ = c;\n  if (!((ct)->__table[(unsigned char)((c))] & (0x400))) {\n    *w = '\\0';\n    return c;\n  }\n  for (; --lim > 0; w++)\n    if (((c = (bufp > 0 ? buffer[--bufp] : getc(stdin))) == EOF) ||\n        !((ct)->__table[(unsigned char)((c))] & (0x0008))) {\n      if (bufp < 1000)\n        buffer[bufp++] = c;\n      else\n        puts(\"error: buffer overflow\");\n      break;\n    } else {\n      *w = c;\n    }\n  *w = '\\0';\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":0,"function":"char *_strdup(char *word) {\n    char *p = (char *)malloc(strlen(word) + 1);\n    p = strcpy(p, word);\n    return p;\n}\n","function_prediction":"char *_strdup_name_conflict(const char *s) {\n  size_t len = strlen(s);\n  char *p = malloc(len + 1);\n  return memcpy(p, s, len + 1);\n}","pass":0,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch6/binarysearch.c"}
{"compilable":1,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char *line, int max_len) {\n  int i = 0;\n  int c;\n\n  while (i < max_len - 1) {\n    c = getc(stdin);\n    if (c == -1)\n      break;\n    if (c == '\\n') {\n      line[i] = c;\n      break;\n    }\n    line[i] = c;\n    i++;\n  }\n  line[i] = '\\0';\n  return i;\n}","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/116.c"}
{"compilable":1,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char *line, int max_len) {\n  int i = 0;\n  int c;\n\n  while (i < max_len - 1) {\n    c = getc(stdin);\n    if (c == -1)\n      break;\n    if (c == '\\n') {\n      line[i] = c;\n      break;\n    }\n    line[i] = c;\n    i++;\n  }\n  line[i] = '\\0';\n  return i;\n}","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/get_line.c"}
{"compilable":1,"function":"int get_line(char *line, int limit) {\n    int c, i;\n    for (i = 0; i < limit - 1 && (c = getchar()) != (-1) && c != '\\n'; i++)\n        line[i] = c;\n    if (c == '\\n')\n        line[i++] = c;\n    line[i] = '\\x00';\n    return i;\n}\n","function_prediction":"int get_line_name_conflict(char *line, int max_len) {\n  int i = 0;\n  int c;\n\n  while (i < max_len - 1) {\n    c = getc(stdin);\n    if (c == -1)\n      break;\n    if (c == '\\n') {\n      line[i] = c;\n      break;\n    }\n    line[i] = c;\n    i++;\n  }\n  line[i] = '\\0';\n  return i;\n}","pass":1,"source_file":"C_COMPILE/tanwarmohit_swc-prep/cprog/ch1/117.c"}
{"compilable":0,"function":"static int test(int argc, char **argv, int t) {\n    static struct iovec iov[1024];\n    const int bs = 4 << 10;\n    const ssize_t s = bs * 1024;\n    char *p = (char *)mmap(0, bs * 1024, 1 | 2, 2 | 32, -1, 0);\n    int i;\n    for (i = 1024 - 1; i >= 0; i--) {\n        iov[i].iov_base = p;\n        iov[i].iov_len = bs;\n        *p = i;\n        p += bs;\n    }\n    for (i = 1; i < argc; i++) {\n        const char *nm = \"none\";\n        const double cs = (double)sysconf(_SC_CLK_TCK);\n        struct tms ptms, ctms;\n        clock_t pt, ct;\n        int l = 1 << 8;\n        int k = l;\n        const int fd = open(argv[i], 2 | 64 | 16384 | 262144, 438);\n        if (fd < 0) {\n            perror(argv[i]);\n            return 1;\n        }\n        pt = times(&ptms);\n        while (k-- > 0)\n            {\n                ssize_t n;\n                switch (t) {\n                  case 0:\n                    nm = \"write\";\n                    n = write(fd, iov[1024 - 1].iov_base, s);\n                    break;\n                  case 1:\n                    nm = \"writev\";\n                    n = writev(fd, iov, 1024);\n                    break;\n                  case 2:\n                    nm = \"read\";\n                    n = read(fd, iov[1024 - 1].iov_base, s);\n                    break;\n                  case 3:\n                    nm = \"readv\";\n                    n = readv(fd, iov, 1024);\n                    break;\n                  default:\n                    n = 0;\n                    break;\n                }\n                if (n != s) {\n                    perror(argv[i]);\n                    return 1;\n                }\n                if ((k & 63) == 0) {\n                    lseek(fd, 0, 0);\n                }\n            }\n        ct = times(&ctms);\n        {\n            const double d = (ct != pt) ? ct - pt : 1.0000000000000001E-9;\n            printf(\"u: %6.2f%% s: %6.2f%% w: %6.2f s %6.2f MB/s %s\\n\", (ctms.tms_utime - ptms.tms_utime) / d * 100, (ctms.tms_stime - ptms.tms_stime) / d * 100, d / cs, cs * l * s / ((1 << 20) * d), nm);\n        }\n        close(fd);\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/sumedhsakdeo_zynx/src/cc/qcdio/iovperf.c"}
{"compilable":0,"function":"static int print_dirlist(char *filename) {\n    struct dirent *de;\n    char c;\n    DIR *d;\n    fprintf(stdout, \"<br><br>--------<pre>Directory listing for %s:\\n\\n\", filename);\n    d = opendir(filename);\n    if (!d) {\n        fprintf(stdout, \"No such directory\\n</pre>\");\n        return -1;\n    }\n    while (de = readdir(d))\n        {\n            if (de->d_type == DT_DIR)\n                fprintf(stdout, \"%s/\\n\", de->d_name);\n            else\n                fprintf(stdout, \"%s\\n\", de->d_name);\n        }\n    closedir(d);\n    fprintf(stdout, \"</pre>\");\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":0,"function":"static int write_to_file(char *filename, char *writeval) {\n    char *line = ((void *)0);\n    size_t len;\n    FILE *fp;\n    fp = fopen(filename, \"w\");\n    if (!fp)\n        return -1;\n    fprintf(stdout, \"<br><br>--------<pre>Writing %s to file %s:\\n\\n\", writeval, filename);\n    if (fwrite(writeval, strlen(writeval), 1, fp) < strlen(writeval))\n        fprintf(stdout, \"Write failed\\n\");\n    else\n        fprintf(stdout, \"Write succeeded\\n\");\n    fprintf(stdout, \"</pre>\");\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":0,"function":"static int cat_file(char *filename) {\n    char *line = ((void *)0);\n    size_t len;\n    FILE *fp;\n    fp = fopen(filename, \"r\");\n    if (!fp) {\n        fprintf(stdout, \"No such file or directory\\n</pre>\");\n        return -1;\n    }\n    fprintf(stdout, \"<br><br>--------<pre>Contents of file %s:\\n\\n\", filename);\n    while (getline(&line, &len, fp) != -1)\n        fprintf(stdout, \"%s\", line);\n    fprintf(stdout, \"</pre>\");\n    free(line);\n    fclose(fp);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/tzanussi_meta-micro-galileo/recipes-httpd/cgi/micro-cgi/catafile.c"}
{"compilable":0,"function":"static int test(int do_exit) {\n    pthread_t t;\n    pthread_create(&t, ((void *)0), thread1_func, (void *)do_exit);\n    pthread_join(t, ((void *)0));\n    if (g_ok1 != +1) {\n        if (g_ok1 == 0) {\n            fprintf(stderr, \"cleanup1 not called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup1 called with wrong argument\\n\");\n        }\n        exit(1);\n    } else if (g_ok2 != +1) {\n        if (g_ok2 == 0)\n            fprintf(stderr, \"cleanup2 not called !!\\n\");\n        else\n            fprintf(stderr, \"cleanup2 called with wrong argument\\n\");\n        exit(2);\n    } else if (do_exit && g_ok3 != +1) {\n        if (g_ok3 == 0) {\n            fprintf(stderr, \"cleanup3 not called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup3 called with bad argument !!\\n\");\n        }\n        exit(3);\n    } else if (!do_exit && g_ok3 != 0) {\n        if (g_ok3 == 1) {\n            fprintf(stderr, \"cleanup3 wrongly called !!\\n\");\n        } else {\n            fprintf(stderr, \"cleanup3 wrongly called with bad argument !!\\n\");\n        }\n        exit(3);\n    }\n    return 0;\n}\n","function_prediction":"void test_isra_0(int arg) {\n  pthread_t thread;\n\n  pthread_create(&thread, NULL, thread1_func, (void *)arg);\n  pthread_join(thread, NULL);\n\n  if (g_ok1 != 1) {\n    if (g_ok1 == 0)\n      fputs(\"cleanup1 not called !!\\n\", stderr);\n    else\n      fputs(\"cleanup1 called with wrong argument\\n\", stderr);\n    exit(1);\n  }\n\n  if (g_ok2 != 1) {\n    if (g_ok2 == 0)\n      fputs(\"cleanup2 not called !!\\n\", stderr);\n    else\n      fputs(\"cleanup2 called with wrong argument\\n\", stderr);\n    exit(2);\n  }\n\n  if (arg == 0) {\n    if (g_ok3 != 0) {\n      if (g_ok3 == 1)\n        fputs(\"cleanup3 wrongly called !!\\n\", stderr);\n      else\n        fputs(\"cleanup3 wrongly called with bad argument !!\\n\", stderr);\n      exit(3);\n    }\n  } else {\n    if (g_ok3 != 1) {\n      if (g_ok3 == 0)\n        fputs(\"cleanup3 not called !!\\n\", stderr);\n      else\n        fputs(\"cleanup3 called with bad argument !!\\n\", stderr);\n      exit(3);\n    }\n  }\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/bionic/libc/common/test_pthread_cleanup_push.c"}
{"compilable":1,"function":"static int check_library(const char *libname) {\n    void *lib = dlopen(libname, 2);\n    int *to_x;\n    void (*set_y)(int *);\n    int y = 0;\n    if (lib == ((void *)0)) {\n        fprintf(stderr, \"Could not load shared library %s: %s\\n\", libname, dlerror());\n        return 1;\n    }\n    fprintf(stderr, \"%s loaded.\\n\", libname);\n    to_x = dlsym(lib, \"x\");\n    if (to_x == ((void *)0)) {\n        fprintf(stderr, \"Could not access global DLL variable (x) in %s: %s\\n\", libname, dlerror());\n        return 10;\n    }\n    if (*to_x != 1) {\n        fprintf(stderr, \"Constructor was not run on dlopen(\\\"%s\\\") !\\n\", libname);\n        return 11;\n    }\n    set_y = dlsym(lib, \"set_y\");\n    if (set_y == ((void *)0)) {\n        fprintf(stderr, \"Could not access global DLL function (set_y) in %s: %s\\n\", libname, dlerror());\n        return 12;\n    }\n    y = 0;\n    (*set_y)(&y);\n    if (dlclose(lib) < 0) {\n        fprintf(stderr, \"Could not unload shared library %s: %s\\n\", libname, dlerror());\n        return 2;\n    }\n    fprintf(stderr, \"%s unloaded.\\n\", libname);\n    if (y != 2) {\n        fprintf(stderr, \"Static destructors was not called on dlclose()!\\n\");\n        return 2;\n    }\n    return 0;\n}\n","function_prediction":"int check_library_name_conflict(const char *libname) {\n  void *handle;\n  int *x;\n  void (*set_y)(int *);\n  int y = 0;\n\n  handle = dlopen(libname, 2);\n  if (!handle) {\n    fprintf(stderr, \"Could not load shared library %s: %s\\n\", libname,\n            dlerror());\n    return 1;\n  }\n  fprintf(stderr, \"%s loaded.\\n\", libname);\n\n  x = dlsym(handle, \"x\");\n  if (!x) {\n    fprintf(stderr, \"Could not access global DLL variable (x) in %s: %s\\n\",\n            libname, dlerror());\n    return 10;\n  }\n  if (*x != 1) {\n    fprintf(stderr, \"Constructor was not run on dlopen(\\\"%s\\\") !\\n\", libname);\n    return 11;\n  }\n\n  set_y = dlsym(handle, \"set_y\");\n  if (!set_y) {\n    fprintf(stderr, \"Could not access global DLL function (set_y) in %s: %s\\n\",\n            libname, dlerror());\n    return 12;\n  }\n\n  y = 0;\n  set_y(&y);\n\n  if (dlclose(handle) < 0) {\n    fprintf(stderr, \"Could not unload shared library %s: %s\\n\", libname,\n            dlerror());\n    return 2;\n  }\n  fprintf(stderr, \"%s unloaded.\\n\", libname);\n\n  if (y != 2) {\n    fprintf(stderr, \"Static destructors was not called on dlclose()!\\n\");\n    return 2;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/bionic/libc/bionic/test_dlclose_destruction.c"}
{"compilable":0,"function":"static unsigned long long stop_watch() {\n    struct timespec t;\n    t.tv_sec = t.tv_nsec = 0;\n    clock_gettime(1, &t);\n    return t.tv_sec * 1000000000ULL + t.tv_nsec;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/pftest/pftest.c"}
{"compilable":1,"function":"int64_t systemTime() {\n    struct timespec t;\n    t.tv_sec = t.tv_nsec = 0;\n    clock_gettime(1, &t);\n    return (int64_t)(t.tv_sec) * 1000000000LL + t.tv_nsec;\n}\n","function_prediction":"long long systemTime_name_conflict() {\n  struct timespec t;\n  t.tv_sec = 0;\n  t.tv_nsec = 0;\n  clock_gettime(1, &t);\n  return t.tv_sec * 1000000000 + t.tv_nsec;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/framebuffer/refresh.c"}
{"compilable":0,"function":"static u64 get_block_device_size(int fd) {\n    u64 size = 0;\n    int ret;\n    ret = ioctl(fd, (((2U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((114)) << 0) | ((((sizeof(size_t)))) << ((0 + 8) + 8))), &size);\n    if (ret)\n        return 0;\n    return size;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/storage/wipe_blkdev.c"}
{"compilable":0,"function":"static int wipe_block_device(int fd, u64 len, int secure) {\n    u64 range[2];\n    int ret;\n    int req;\n    range[0] = 0;\n    range[1] = len;\n    if (secure) {\n        req = (((0U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((125)) << 0) | ((0) << ((0 + 8) + 8)));\n    } else {\n        req = (((0U) << (((0 + 8) + 8) + 14)) | (((18)) << (0 + 8)) | (((119)) << 0) | ((0) << ((0 + 8) + 8)));\n    }\n    ret = ioctl(fd, req, &range);\n    if (ret < 0) {\n        fprintf(stderr, \"%s discard failed, errno = %d\\n\", secure ? \"Secure\" : \"Nonsecure\", (*__errno_location()));\n    }\n    return ret;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/storage/wipe_blkdev.c"}
{"compilable":0,"function":"static uid_t str2uid(char *str, int line_num) {\n    struct passwd *pw;\n    if (((*__ctype_b_loc())[(int)((str[0]))] & (unsigned short)_ISdigit))\n        return (uid_t)atol(str);\n    if (!(pw = getpwnam(str))) {\n        printf(\"# ERROR # Invalid uid '%s' reading line %d\\n\", str, line_num);\n        exit(255);\n    }\n    return pw->pw_uid;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static gid_t str2gid(char *str, int line_num) {\n    struct group *gr;\n    if (((*__ctype_b_loc())[(int)((str[0]))] & (unsigned short)_ISdigit))\n        return (uid_t)atol(str);\n    if (!(gr = getgrnam(str))) {\n        printf(\"# ERROR # Invalid gid '%s' reading line %d\\n\", str, line_num);\n        exit(255);\n    }\n    return gr->gr_gid;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_file(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_FILE];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for file: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    if (rules_matched || retval)\n        return retval;\n    pr = rules[WILDCARD];\n    while (pr != ((void *)0))\n        {\n            if ((strstr(name, pr->spec) == name) && (!strchr(name + strlen(pr->spec), '/'))) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    pr = rules[RECURSIVE];\n    while (pr != ((void *)0))\n        {\n            if (strstr(name, pr->spec) == name) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if (!rules_matched)\n        retval++;\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_link(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_FILE];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for link: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int validate_dir(const char *name, mode_t mode, uid_t uid, gid_t gid) {\n    perm_rule_t *pr;\n    int rules_matched = 0;\n    int retval = 0;\n    pr = rules[EXACT_DIR];\n    while (pr != ((void *)0))\n        {\n            if (strcmp(name, pr->spec) == 0) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if ((retval + rules_matched) > 1)\n        printf(\"# WARNING # Multiple exact rules for directory: %s\\n\", name);\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    if (rules_matched || retval)\n        return retval;\n    pr = rules[RECURSIVE];\n    while (pr != ((void *)0))\n        {\n            if (strstr(name, pr->spec) == name) {\n                if (!pass_rule(pr, mode, uid, gid))\n                    retval++;\n                else\n                    rules_matched++;\n            }\n            pr = pr->next;\n        }\n    if (!rules_matched)\n        retval++;\n    if (retval)\n        print_new_rule(name, mode, uid, gid);\n    return retval;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int check_path(const char *name) {\n    char namebuf[4097];\n    char tmp[4097];\n    DIR *d;\n    struct dirent *de;\n    struct stat s;\n    int err;\n    int retval = 0;\n    err = lstat(name, &s);\n    if (err < 0) {\n        if ((*__errno_location()) != 2) {\n            perror(name);\n            return 1;\n        }\n        return 0;\n    }\n    if (((((s.st_mode)) & 61440) == (16384))) {\n        if (name[strlen(name) - 1] != '/')\n            snprintf(namebuf, sizeof (namebuf), \"%s/\", name);\n        else\n            snprintf(namebuf, sizeof (namebuf), \"%s\", name);\n        retval |= validate_dir(namebuf, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n        d = opendir(namebuf);\n        if (d == 0) {\n            printf(\"%s : opendir failed: %s\\n\", namebuf, strerror((*__errno_location())));\n            return 1;\n        }\n        while ((de = readdir(d)) != 0)\n            {\n                if (!strcmp(de->d_name, \".\") || !strcmp(de->d_name, \"..\"))\n                    continue;\n                snprintf(tmp, sizeof (tmp), \"%s%s\", namebuf, de->d_name);\n                retval |= check_path(tmp);\n            }\n        closedir(d);\n        return retval;\n    } else if (((((s.st_mode)) & 61440) == (40960))) {\n        return validate_link(name, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n    } else {\n        return validate_file(name, (s.st_mode & ~61440), s.st_uid, s.st_gid);\n    }\n}\n","function_prediction":"int check_path_name_conflict(const char *path) {\n  struct stat st;\n  int exact_rules = 0;\n  int exact_rules_failed = 0;\n  int glob_rules = 0;\n  int glob_rules_failed = 0;\n  int ret = 0;\n\n  if (lstat(path, &st) < 0) {\n    if (*__errno_location() == 2)\n      return 0;\n    perror(path);\n    return 1;\n  }\n\n  if ((st.st_mode & 0170000) == 0100000) {\n    char dir[4096 + 1];\n    DIR *d;\n    struct dirent *de;\n\n    if (path[strlen(path) - 1] == '/')\n      snprintf(dir, sizeof(dir), \"%s\", path);\n    else\n      snprintf(dir, sizeof(dir), \"%s/\", path);\n\n    for (rule *r = rules; r; r = r->next) {\n      if (!strcmp(dir, r->path)) {\n        if ((st.st_mode & r->mode) != r->mode ||\n            (st.st_mode | r->mode) != r->mode || st.st_gid < r->gid_min ||\n            st.st_gid > r->gid_max || st.st_uid < r->uid_min ||\n            st.st_uid > r->uid_max) {\n          exact_rules_failed++;\n          printf(\"# INFO # Failed rule #%d: %s\\n\", r->id, r->rule);\n        } else\n          exact_rules++;\n      }\n    }\n\n    if (exact_rules > 1)\n      printf(\"# WARNING # Multiple exact rules for directory: %s\\n\", dir);\n\n    if (exact_rules_failed) {\n      struct group *gr = getgrgid(st.st_gid);\n      struct passwd *pw = getpwuid(st.st_uid);\n\n   printf(\"%s","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/tests/fstest/perm_checker.c"}
{"compilable":0,"function":"static int get_cpu_count() {\n    int cpu_count = get_cpu_count_from_file(\"/sys/devices/system/cpu/present\");\n    if (cpu_count != get_cpu_count_from_file(\"/sys/devices/system/cpu/online\")) {\n        {\n            fprintf(stderr, \"present cpus != online cpus\\n\");\n            exit(1);\n        }\n        ;\n    }\n    return cpu_count;\n}\n","function_prediction":"int get_cpu_count_from_file(const char *file) {\n  FILE *f;\n  char buf[64];\n  int cpu_count;\n\n  f = fopen(file, \"r\");\n  if (!f) {\n    fprintf(stderr, \"Could not open %s\\n\", file);\n    exit(1);\n  }\n\n  if (fgets(buf, sizeof(buf), f) == NULL) {\n    fprintf(stderr, \"Could not get %s contents\\n\", file);\n    exit(1);\n  }\n  fclose(f);\n\n  if (buf[0] == 0xA30 && buf[1] == 0x000)\n    return 1;\n\n  if (__isoc99_sscanf(buf, \"0-%d\\n\", &cpu_count) != 1) {\n    fprintf(stderr, \"Unexpected input in file %s (%s).\\n\", file, buf);\n    exit(1);\n  }\n\n  return cpu_count + 1;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":1,"function":"static int get_cpu_count_from_file(char *filename) {\n    FILE *file;\n    char line[64];\n    int cpu_count;\n    file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n    ;\n    if (!fgets(line, 64, file)) {\n        fprintf(stderr, \"Could not get %s contents\\n\", filename);\n        exit(1);\n    }\n    ;\n    fclose(file);\n    if (strcmp(line, \"0\\n\") == 0) {\n        return 1;\n    }\n    if (1 == sscanf(line, \"0-%d\\n\", &cpu_count)) {\n        return cpu_count + 1;\n    }\n    {\n        fprintf(stderr, \"Unexpected input in file %s (%s).\\n\", filename, line);\n        exit(1);\n    }\n    ;\n    return -1;\n}\n","function_prediction":"int get_cpu_count_from_file_name_conflict(const char *file) {\n  FILE *f;\n  char buf[64];\n  int cpu_count;\n\n  f = fopen(file, \"r\");\n  if (!f) {\n    fprintf(stderr, \"Could not open %s\\n\", file);\n    exit(1);\n  }\n\n  if (fgets(buf, sizeof(buf), f) == NULL) {\n    fprintf(stderr, \"Could not get %s contents\\n\", file);\n    exit(1);\n  }\n  fclose(f);\n\n  if (buf[0] == 0xA30 && buf[1] == 0x000)\n    return 1;\n\n  if (__isoc99_sscanf(buf, \"0-%d\\n\", &cpu_count) != 1) {\n    fprintf(stderr, \"Unexpected input in file %s (%s).\\n\", file, buf);\n    exit(1);\n  }\n\n  return cpu_count + 1;\n}","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static int get_freq_scales_count(int cpu) {\n    FILE *file;\n    char filename[64];\n    unsigned long freq;\n    int count = 0;\n    sprintf(filename, \"/sys/devices/system/cpu/cpu%d/cpufreq/stats/time_in_state\", cpu);\n    file = fopen(filename, \"r\");\n    if (!file) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n    ;\n    do {\n        freq = 0;\n        fscanf(file, \"%lu %*d\\n\", &freq);\n        if (freq)\n            count++;\n    } while (freq);\n    fclose(file);\n    return count;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static char should_print_freq_stats() {\n    int i, j;\n    for (i = 1; i < cpu_count; i++) {\n        for (j = 0; j < new_cpus[i].freq_count; j++) {\n            if (new_cpus[i].freqs[j].time - old_cpus[i].freqs[j].time != new_cpus[0].freqs[j].time - old_cpus[0].freqs[j].time) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static char should_aggregate_freq_stats() {\n    int i, j;\n    for (i = 1; i < cpu_count; i++) {\n        if (new_cpus[i].freq_count != new_cpus[0].freq_count) {\n            return 0;\n        }\n        for (j = 0; j < new_cpus[i].freq_count; j++) {\n            if (new_cpus[i].freqs[j].freq != new_cpus[0].freqs[j].freq) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/cpustats/cpustats.c"}
{"compilable":0,"function":"static struct slab_info *get_slabinfo(struct slab_stat *stats) {\n    struct slab_info *head = ((void *)0), *p = ((void *)0), *prev = ((void *)0);\n    FILE *slabfile;\n    char line[512];\n    unsigned int major, minor;\n    slabfile = fopen(\"/proc/slabinfo\", \"r\");\n    if (!slabfile) {\n        perror(\"fopen\");\n        return ((void *)0);\n    }\n    if (!fgets(line, 512, slabfile)) {\n        fprintf(stderr, \"cannot read from /proc/slabinfo\\n\");\n        return ((void *)0);\n    }\n    if (sscanf(line, \"slabinfo - version: %u.%u\", &major, &minor) != 2) {\n        fprintf(stderr, \"unable to parse slabinfo version!\\n\");\n        return ((void *)0);\n    }\n    if (major != 2 || minor > 1) {\n        fprintf(stderr, \"we only support slabinfo 2.0 and 2.1!\\n\");\n        return ((void *)0);\n    }\n    stats->min_obj_size = 2147483647;\n    while (fgets(line, 512, slabfile))\n        {\n            unsigned long nr_active_slabs, pages_per_slab;\n            int ret;\n            if (line[0] == '#')\n                continue;\n            p = malloc(sizeof(struct slab_info));\n            if (!p) {\n                perror(\"malloc\");\n                head = ((void *)0);\n                break;\n            }\n            if (stats->nr_caches++ == 0)\n                head = prev = p;\n            ret = sscanf(line, \"%32s %lu %lu %lu %lu %lu : tunables %*d %*d %*d :         slabdata %lu %lu %*d\", p->name, &p->nr_active_objs, &p->nr_objs, &p->obj_size, &p->objs_per_slab, &pages_per_slab, &nr_active_slabs, &p->nr_slabs);\n            if (ret != 8) {\n                fprintf(stderr, \"unrecognizable data in slabinfo!\\n\");\n                head = ((void *)0);\n                break;\n            }\n            if (p->obj_size < stats->min_obj_size)\n                stats->min_obj_size = p->obj_size;\n            if (p->obj_size > stats->max_obj_size)\n                stats->max_obj_size = p->obj_size;\n            p->nr_pages = p->nr_slabs * pages_per_slab;\n            if (p->nr_objs) {\n                p->use = 100 * p->nr_active_objs / p->nr_objs;\n                stats->nr_active_caches++;\n            } else\n                p->use = 0;\n            stats->nr_objs += p->nr_objs;\n            stats->nr_active_objs += p->nr_active_objs;\n            stats->total_size += p->nr_objs * p->obj_size;\n            stats->active_size += p->nr_active_objs * p->obj_size;\n            stats->nr_slabs += p->nr_slabs;\n            stats->nr_active_slabs += nr_active_slabs;\n            prev->next = p;\n            prev = p;\n        }\n    if (fclose(slabfile))\n        perror(\"fclose\");\n    if (p)\n        p->next = ((void *)0);\n    if (stats->nr_objs)\n        stats->avg_obj_size = stats->total_size / stats->nr_objs;\n    return head;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"static struct slab_info *merge_objs(struct slab_info *a, struct slab_info *b) {\n    struct slab_info list;\n    struct slab_info *p = &list;\n    while (a && b)\n        {\n            if (sort_func(a, b)) {\n                p->next = a;\n                p = a;\n                a = a->next;\n            } else {\n                p->next = b;\n                p = b;\n                b = b->next;\n            }\n        }\n    p->next = (a == ((void *)0)) ? b : a;\n    return list.next;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"static struct slab_info *slabsort(struct slab_info *list) {\n    struct slab_info *a, *b;\n    if (!list || !list->next)\n        return list;\n    a = list;\n    b = list->next;\n    while (b && b->next)\n        {\n            list = list->next;\n            b = b->next->next;\n        }\n    b = list->next;\n    list->next = ((void *)0);\n    return merge_objs(slabsort(a), slabsort(b));\n}\n","function_prediction":"struct slab *slabsort_name_conflict(struct slab *slabs) {\n  struct slab *a, *b, *c, *d, *e, *f, *g, *h;\n\n  if (!slabs)\n    return NULL;\n\n  a = slabs;\n  b = slabs->next;\n\n  if (!b)\n    return slabs;\n\n  while (b->next) {\n    a = b;\n    b = b->next;\n  }\n\n  a->next = NULL;\n\n  c = slabsort_name_conflict(slabs);\n  d = slabsort_name_conflict(b);\n\n  e = f = g = h = &a;\n\n  while (c && d) {\n    if (!sort_func(c, d)) {\n      f->next = c;\n      c = c->next;\n    } else {\n      f->next = d;\n      d = d->next;\n    }\n    f = f->next;\n  }\n\n  if (c)\n    f->next = c;\n  else\n    f->next = d;\n\n  return h->next;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/showslab/showslab.c"}
{"compilable":0,"function":"int wav_play(const char *fn) {\n    struct wav_header hdr;\n    unsigned int rate, channels;\n    int fd;\n    fd = open(fn, 0);\n    if (fd < 0) {\n        fprintf(stderr, \"playwav: cannot open '%s'\\n\", fn);\n        return -1;\n    }\n    if (read(fd, &hdr, sizeof (hdr)) != sizeof (hdr)) {\n        fprintf(stderr, \"playwav: cannot read header\\n\");\n        return -1;\n    }\n    fprintf(stderr, \"playwav: %d ch, %d hz, %d bit, %s\\n\", hdr.num_channels, hdr.sample_rate, hdr.bits_per_sample, hdr.audio_format == 1 ? \"PCM\" : \"unknown\");\n    if ((hdr.riff_id != 1179011410) || (hdr.riff_fmt != 1163280727) || (hdr.fmt_id != 544501094)) {\n        fprintf(stderr, \"playwav: '%s' is not a riff/wave file\\n\", fn);\n        return -1;\n    }\n    if ((hdr.audio_format != 1) || (hdr.fmt_sz != 16)) {\n        fprintf(stderr, \"playwav: '%s' is not pcm format\\n\", fn);\n        return -1;\n    }\n    if (hdr.bits_per_sample != 16) {\n        fprintf(stderr, \"playwav: '%s' is not 16bit per sample\\n\", fn);\n        return -1;\n    }\n    play_file(hdr.sample_rate, hdr.num_channels, fd, hdr.data_sz);\n    return 0;\n}\n","function_prediction":"int wav_play_name_conflict(char *name) {\n  int fd;\n  struct wav_header hdr;\n\n  fd = open(name, 0);\n  if (fd < 0) {\n    fprintf(stderr, \"playwav: cannot open '%s'\\n\", name);\n    return -1;\n  }\n\n  if (read(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {\n    fprintf(stderr, \"playwav: cannot read header\\n\");\n    return -1;\n  }\n\n  fprintf(stderr, \"playwav: %d ch, %d hz, %d bit, %s\\n\", hdr.num_channels,\n          hdr.sample_rate, hdr.bits_per_sample,\n          hdr.audio_format == 1 ? \"PCM\" : \"unknown\");\n\n  if (hdr.riff_id != 0x46464952 || hdr.wave_id != 0x45564157 ||\n      hdr.fmt_id != 0x20746d66) {\n    fprintf(stderr, \"playwav: '%s' is not a riff/wave file\\n\", name);\n    return -1;\n  }\n\n  if (hdr.audio_format != 1 || hdr.block_align != 2) {\n    fprintf(stderr, \"playwav: '%s' is not pcm format\\n\", name);\n    return -1;\n  }\n\n  if (hdr.bits_per_sample != 16) {\n    fprintf(stderr, \"playwav: '%s' is not 16bit per sample\\n\", name);\n    return -1;\n  }\n\n  next = malloc(hdr.subchunk2_size);\n  if (!next) {\n    fprintf(stderr, \"could not allocate %d bytes\\n\", hdr.subchunk2_size);\n    return -1;\n  }\n\n    if (read(fd, next, hdr.subchunk2_size) != hdr.sub","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":0,"function":"int wav_rec(const char *fn, unsigned int channels, unsigned int rate) {\n    struct wav_header hdr;\n    unsigned char buf[8192];\n    struct msm_audio_config cfg;\n    unsigned int sz, n;\n    int fd, afd;\n    unsigned int total = 0;\n    unsigned char tmp;\n    hdr.riff_id = 1179011410;\n    hdr.riff_sz = 0;\n    hdr.riff_fmt = 1163280727;\n    hdr.fmt_id = 544501094;\n    hdr.fmt_sz = 16;\n    hdr.audio_format = 1;\n    hdr.num_channels = channels;\n    hdr.sample_rate = rate;\n    hdr.byte_rate = hdr.sample_rate * hdr.num_channels * 2;\n    hdr.block_align = hdr.num_channels * 2;\n    hdr.bits_per_sample = 16;\n    hdr.data_id = 1635017060;\n    hdr.data_sz = 0;\n    fd = open(fn, 64 | 2, 438);\n    if (fd < 0) {\n        perror(\"cannot open output file\");\n        return -1;\n    }\n    write(fd, &hdr, sizeof (hdr));\n    afd = open(\"/dev/msm_pcm_in\", 2);\n    if (afd < 0) {\n        perror(\"cannot open msm_pcm_in\");\n        close(fd);\n        return -1;\n    }\n    if (ioctl(afd, (((2U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot read audio config\");\n        goto fail;\n    }\n    cfg.channel_count = hdr.num_channels;\n    cfg.sample_rate = hdr.sample_rate;\n    if (ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((4)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot write audio config\");\n        goto fail;\n    }\n    if (ioctl(afd, (((2U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((3)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), &cfg)) {\n        perror(\"cannot read audio config\");\n        goto fail;\n    }\n    sz = cfg.buffer_size;\n    fprintf(stderr, \"buffer size %d x %d\\n\", sz, cfg.buffer_count);\n    if (sz > sizeof (buf)) {\n        fprintf(stderr, \"buffer size %d too large\\n\", sz);\n        goto fail;\n    }\n    if (ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), 0)) {\n        perror(\"cannot start audio\");\n        goto fail;\n    }\n    fcntl(0, 4, 2048);\n    fprintf(stderr, \"\\n*** RECORDING * HIT ENTER TO STOP ***\\n\");\n    for (;;) {\n        while (read(0, &tmp, 1) == 1)\n            {\n                if ((tmp == 13) || (tmp == 10))\n                    goto done;\n            }\n        if (read(afd, buf, sz) != sz) {\n            perror(\"cannot read buffer\");\n            goto fail;\n        }\n        if (write(fd, buf, sz) != sz) {\n            perror(\"cannot write buffer\");\n            goto fail;\n        }\n        total += sz;\n    }\n  done:\n    close(afd);\n    hdr.data_sz = total;\n    hdr.riff_sz = total + 8 + 16 + 8;\n    lseek(fd, 0, 0);\n    write(fd, &hdr, sizeof (hdr));\n    close(fd);\n    return 0;\n  fail:\n    close(afd);\n    close(fd);\n    unlink(fn);\n    return -1;\n}\n","function_prediction":"int wav_rec_name_conflict(char *filename, int rate, int channels) {\n  int fd, fd_msm, ret, size, count;\n  char c;\n  char buf[8192];\n  struct audio_config config;\n  struct WAVE_header header;\n  static const struct WAVE_fmt_data s_WAVEfmt_data = {\n      1, 2, 16, 16000, 32000, 16, 16,\n  };\n\n  header.RIFF_chunk_size = 0;\n  header.fmt_chunk_size = sizeof(s_WAVEfmt_data);\n  header.WAVE_chunk_size = 0;\n  header.WAVE_fmt_chunk_size = sizeof(s_WAVEfmt_data);\n  header.WAVE_fmt_data = s_WAVEfmt_data;\n  header.data_chunk_size = 0;\n  header.sample_rate = rate;\n  header.num_channels = channels;\n  header.bits_per_sample = 16;\n  header.block_align = channels * 2;\n  header.byte_rate = rate * channels * 2;\n\n  fd = open(filename, 0x42, 0666);\n  if (fd < 0) {\n    perror(\"cannot open output file\");\n    return -1;\n  }\n  write(fd, &header, sizeof(header));\n\n  fd_msm = open(\"/dev/msm_pcm_in\", 2);\n  if (fd_msm < 0) {\n    perror(\"cannot open msm_pcm_in\");\n    close(fd);\n    return -1;\n  }\n\n  ret = ioctl(fd_msm, 0x80046103, &config);\n  if (ret) {\n    perror(\"cannot read audio config\");\n    goto err_close_msm;\n  }\n\n  config.sample_rate = rate;\n  config.num_","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":1,"function":"int mp3_play(const char *fn) {\n    char buf[65536];\n    int r;\n    int fd, afd;\n    fd = open(fn, 0);\n    if (fd < 0) {\n        perror(\"cannot open mp3 file\");\n        return -1;\n    }\n    afd = open(\"/dev/msm_mp3\", 2);\n    if (afd < 0) {\n        close(fd);\n        perror(\"cannot open mp3 output device\");\n        return -1;\n    }\n    fprintf(stderr, \"MP3 PLAY\\n\");\n    ioctl(afd, (((1U) << (((0 + 8) + 8) + 14)) | ((('a')) << (0 + 8)) | (((0)) << 0) | ((((sizeof(unsigned int)))) << ((0 + 8) + 8))), 0);\n    for (;;) {\n        r = read(fd, buf, 64 * 1024);\n        if (r <= 0)\n            break;\n        r = write(afd, buf, r);\n        if (r < 0)\n            break;\n    }\n    close(fd);\n    close(afd);\n    return 0;\n}\n","function_prediction":"int mp3_play_name_conflict(char *mp3_file) {\n  int fd, fd_mp3, ret;\n  char buf[65536];\n\n  fd = open(mp3_file, 0);\n  if (fd < 0) {\n    perror(\"cannot open mp3 file\");\n    return -1;\n  }\n\n  fd_mp3 = open(\"/dev/msm_mp3\", 2);\n  if (fd_mp3 < 0) {\n    close(fd);\n    perror(\"cannot open mp3 output device\");\n    return -1;\n  }\n\n  fwrite(\"MP3 PLAY\\n\", 1, 9, stderr);\n\n  ioctl(fd_mp3, 0x40046100, 0);\n\n  while (1) {\n    ret = read(fd, buf, 65536);\n    if (ret <= 0)\n      break;\n    ret = write(fd_mp3, buf, ret);\n    if (ret < 0)\n      break;\n  }\n\n  close(fd);\n  close(fd_mp3);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sound/playwav.c"}
{"compilable":0,"function":"static struct latency_entry *read_global_stats(struct latency_entry *list, int erase) {\n    FILE *f;\n    struct latency_entry *e;\n    if (erase) {\n        f = fopen(GLOBAL_STATS_FILE, \"w\");\n        if (!f) {\n            fprintf(stderr, \"Could not open global latency stats file: %s\\n\", strerror((*__errno_location())));\n            exit(1);\n        }\n        fprintf(f, \"erase\\n\");\n        fclose(f);\n    }\n    f = fopen(GLOBAL_STATS_FILE, \"r\");\n    if (!f) {\n        fprintf(stderr, \"Could not open global latency stats file: %s\\n\", strerror((*__errno_location())));\n        exit(1);\n    }\n    e = read_latency_file(f, list);\n    fclose(f);\n    return e;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *read_process_stats(struct latency_entry *list, int erase, int pid) {\n    char dirname[64];\n    DIR *dir;\n    struct dirent *ent;\n    struct latency_entry *e;\n    int tid;\n    sprintf(dirname, \"/proc/%d/task\", pid);\n    dir = opendir(dirname);\n    if (!dir) {\n        fprintf(stderr, \"Could not open task dir for process %d.\\n\", pid);\n        fprintf(stderr, \"Perhaps the process has terminated?\\n\");\n        exit(1);\n    }\n    e = list;\n    while ((ent = readdir(dir)))\n        {\n            if (!((*__ctype_b_loc())[(int)((ent->d_name[0]))] & (unsigned short)_ISdigit))\n                continue;\n            tid = atoi(ent->d_name);\n            e = read_thread_stats(e, erase, pid, tid, 0);\n        }\n    closedir(dir);\n    return e;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *read_thread_stats(struct latency_entry *list, int erase, int pid, int tid, int fatal) {\n    char filename[64];\n    FILE *f;\n    struct latency_entry *e;\n    sprintf(filename, THREAD_STATS_FILE_FORMAT, pid, tid);\n    if (erase) {\n        f = fopen(filename, \"w\");\n        if (!f) {\n            if (fatal) {\n                fprintf(stderr, \"Could not open %s: %s\\n\", filename, strerror((*__errno_location())));\n                fprintf(stderr, \"Perhaps the process or thread has terminated?\\n\");\n                exit(1);\n            } else {\n                return list;\n            }\n        }\n        fprintf(f, \"erase\\n\");\n        fclose(f);\n    }\n    f = fopen(GLOBAL_STATS_FILE, \"r\");\n    if (!f) {\n        if (fatal) {\n            fprintf(stderr, \"Could not open %s: %s\\n\", filename, strerror((*__errno_location())));\n            fprintf(stderr, \"Perhaps the process or thread has terminated?\\n\");\n            exit(1);\n        } else {\n            return list;\n        }\n    }\n    e = read_latency_file(f, list);\n    fclose(f);\n    return e;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *alloc_latency_entry(void) {\n    struct latency_entry *e;\n    if (free_entries) {\n        e = free_entries;\n        free_entries = free_entries->next;\n    } else {\n        e = calloc(1, sizeof(struct latency_entry));\n        if (!e) {\n            fprintf(stderr, \"Could not allocate latency entry: %s\\n\", strerror((*__errno_location())));\n            exit(1);\n        }\n    }\n    return e;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static struct latency_entry *find_latency_entry(struct latency_entry *head, char *reason) {\n    struct latency_entry *e;\n    e = head;\n    while (e)\n        {\n            if (!strcmp(e->reason, reason))\n                return e;\n            e = e->next;\n        }\n    return ((void *)0);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static int numcmp(const long long a, const long long b) {\n    if (a < b)\n        return -1;\n    if (a > b)\n        return 1;\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/latencytop/latencytop.c"}
{"compilable":0,"function":"static const char *next_line(const char *b) {\n    while (1)\n        {\n            switch (*b) {\n              case '\\n':\n                return b + 1;\n              case '\\x00':\n                return ((void *)0);\n            }\n            b++;\n        }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int print() {\n    int i;\n    printf(\"CPU  yield() schedule() switch idle   ttwu() local  cpu_time wait_time timeslices\\n\");\n    for (i = 0; i < 2; i++) {\n        printf(\" %2d  %7u %10u %6u %4u %8u %5u %9llu %9llu %10lu\\n\", i, cpu_delta[i].yld_count, cpu_delta[i].sched_count, cpu_delta[i].sched_switch, cpu_delta[i].sched_goidle, cpu_delta[i].ttwu_count, cpu_delta[i].ttwu_local, cpu_delta[i].cpu_time / 1000000, cpu_delta[i].run_delay / 1000000, cpu_delta[i].pcount);\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int parse_cpu_v15(const char *b) {\n    int cpu;\n    if (sscanf(b, \"cpu%d %u %u %u %u %u %u %llu %llu %lu\\n\", &cpu, &tmp.yld_count, &tmp.sched_switch, &tmp.sched_count, &tmp.sched_goidle, &tmp.ttwu_count, &tmp.ttwu_local, &tmp.cpu_time, &tmp.run_delay, &tmp.pcount) != 10) {\n        printf(\"Could not parse %s\\n\", b);\n        return -1;\n    }\n    cpu_delta[cpu].yld_count = tmp.yld_count - cpu_prev[cpu].yld_count;\n    cpu_delta[cpu].sched_switch = tmp.sched_switch - cpu_prev[cpu].sched_switch;\n    cpu_delta[cpu].sched_count = tmp.sched_count - cpu_prev[cpu].sched_count;\n    cpu_delta[cpu].sched_goidle = tmp.sched_goidle - cpu_prev[cpu].sched_goidle;\n    cpu_delta[cpu].ttwu_count = tmp.ttwu_count - cpu_prev[cpu].ttwu_count;\n    cpu_delta[cpu].ttwu_local = tmp.ttwu_local - cpu_prev[cpu].ttwu_local;\n    cpu_delta[cpu].cpu_time = tmp.cpu_time - cpu_prev[cpu].cpu_time;\n    cpu_delta[cpu].run_delay = tmp.run_delay - cpu_prev[cpu].run_delay;\n    cpu_delta[cpu].pcount = tmp.pcount - cpu_prev[cpu].pcount;\n    cpu_prev[cpu] = tmp;\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static int parse(const char *b) {\n    unsigned int version;\n    unsigned long long ts;\n    if (sscanf(b, \"version %u\\n\", &version) != 1) {\n        printf(\"Could not parse version\\n\");\n        return -1;\n    }\n    switch (version) {\n      case 15:\n        b = next_line(b);\n        if (!b || sscanf(b, \"timestamp %llu\\n\", &ts) != 1) {\n            printf(\"Could not parse timestamp\\n\");\n            return -1;\n        }\n        while (1)\n            {\n                b = next_line(b);\n                if (!b)\n                    break;\n                if (b[0] == 'c') {\n                    if (parse_cpu_v15(b))\n                        return -1;\n                }\n            }\n        break;\n      default:\n        printf(\"Can not handle version %u\\n\", version);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Smartandroidtech_platform_system_extras/sane_schedstat/sane_schedstat.c"}
{"compilable":0,"function":"static off_t hash_file(struct MD5Context *ctx, int fd) {\n    off_t count = 0;\n    ssize_t r;\n    unsigned char buf[4096];\n    while ((r = read(fd, buf, sizeof (buf))) > 0)\n        {\n            MD5Update(ctx, buf, r);\n            count += r;\n        }\n    buf[0] = 0;\n    MD5Update(ctx, buf, 1);\n    return count;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/Malvineous_buildroot-openipcam/package/x11r7/mcookie/mcookie.c"}
{"compilable":0,"function":"char *path_filename_ext(const char *path) {\n    char *fname = __xpg_basename((char *)path);\n    char *dot = strrchr(fname, '.');\n    if (!dot || dot == fname)\n        return (\"\");\n    return (dot);\n}\n","function_prediction":"const char *path_filename_ext_name_conflict(const char *path) {\n  char *filename = __xpg_basename(path);\n  char *dot = strrchr(filename, '.');\n  if (!dot || dot == filename)\n    return \"\";\n  return dot;\n}","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_filename_ext.c"}
{"compilable":0,"function":"int path_isdir(const char *path) {\n    struct stat *sb = calloc(1, sizeof(struct stat));\n    int s = stat(path, sb);\n    if (s == -1) {\n        log_perror(\"stat error\");\n        free(sb);\n        return (-1);\n    }\n    mode_t m = sb->st_mode;\n    free(sb);\n    return (((((m)) & 61440) == (16384)));\n}\n","function_prediction":"int path_isdir_name_conflict(const char *path) {\n  struct stat *st = calloc(1, sizeof(struct stat));\n  int ret = stat(path, st);\n  if (ret == -1) {\n    log_perror(\"stat error\");\n    free(st);\n    return -1;\n  }\n  int isdir = (st->st_mode & 0170000) == 0040000;\n  free(st);\n  return isdir;\n}","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_isdir.c"}
{"compilable":0,"function":"int path_exists(const char *path) {\n    int ret = access(path, 0);\n    if (ret == 0)\n        return (1);\n    return (0);\n}\n","function_prediction":"int path_exists_name_conflict(const char *path) { return !access(path, 0); }","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/path/path_exists.c"}
{"compilable":0,"function":"int log_perror(char *fmt, ...) {\n    perror(\"\");\n    va_list ap;\n    __builtin_va_start(ap, fmt);\n    int ret = _logfp(stderr, \"ERR\", fmt, ap);\n    __builtin_va_end(ap);\n    return (ret);\n}\n","function_prediction":"void log_perror(const char *file, int line, const char *func, const char *fmt,\n                ...) {\n  perror(\"\");\n  va_list ap;\n  _logfp(stderr, \"E\", file, &line, func, fmt, ap);\n}","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/log/log_perror.c"}
{"compilable":0,"function":"int log_warn(char *fmt, ...) {\n    va_list ap;\n    __builtin_va_start(ap, fmt);\n    int ret = _logfp(stderr, \"WARN\", fmt, ap);\n    __builtin_va_end(ap);\n    return (ret);\n}\n","function_prediction":"void log_warn_name_conflict(const char *file, int line, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  _logfp(stderr, \"WARN\", file, line, fmt, ap);\n  va_end(ap);\n}","pass":0,"source_file":"C_COMPILE/jrmsdev_jcaslib/lib/log/log_warn.c"}
{"compilable":1,"function":"char *currTime(const char *format) {\n    static char buf[1000];\n    time_t t;\n    size_t s;\n    struct tm *tm;\n    t = time(((void *)0));\n    tm = localtime(&t);\n    if (tm == ((void *)0))\n        return ((void *)0);\n    s = strftime(buf, 1000, (format != ((void *)0)) ? format : \"%c\", tm);\n    return (s == 0) ? ((void *)0) : buf;\n}\n","function_prediction":"char *currTime_name_conflict(const char *format) {\n  static char buf[1000];\n  time_t t = time(NULL);\n  struct tm *tm = localtime(&t);\n  if (tm == NULL)\n    return NULL;\n  if (format == NULL)\n    format = \"%c\";\n  if (strftime(buf, sizeof(buf), format, tm) == 0)\n    return NULL;\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/matianfu_mock-server-for-witness/formatter.c"}
{"compilable":1,"function":"bool isValidMacAddrStr(char *str) {\n    return 1;\n}\n","function_prediction":"int isValidMacAddrStr_name_conflict(char *mac) { return 1; }","pass":1,"source_file":"C_COMPILE/matianfu_mock-server-for-witness/formatter.c"}
{"compilable":0,"function":"size_t addst(size_t x, size_t y) {\n    if ((18446744073709551615UL) - x < y) {\n        fatal(\"integer overflow\");\n    }\n    return x + y;\n}\n","function_prediction":"void addst_name_conflict(uint8_t a, uint8_t b) {\n  if (CARRY8(a, b))\n    fatal(\"integer overflow\");\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"size_t mulst(size_t x, size_t y) {\n    if (x == 0 || y == 0) {\n        return 0;\n    }\n    if ((18446744073709551615UL) / x < y) {\n        fatal(\"integer overflow\");\n    }\n    return x * y;\n}\n","function_prediction":"size_t mulst_name_conflict(size_t a, size_t b) {\n  if (a == 0 || b == 0)\n    return 0;\n  if (a > (SIZE_MAX - b) / a)\n    fatal(\"integer overflow\");\n  return a * b;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xstrdup(const char *s) {\n    char *result = strdup(s);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"char *xstrdup_name_conflict(const char *s) {\n  char *p = strdup(s);\n  if (p == NULL)\n    fatal(\"out of memory\");\n  return p;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xstrndup(const char *s, size_t size) {\n    char *result = strndup(s, size);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"char *xstrndup_name_conflict(const char *s, size_t n) {\n  char *p;\n\n  p = strndup(s, n);\n  if (p == NULL)\n    fatal(\"out of memory\");\n  return p;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int xasprintf(char **s, const char *template, ...) {\n    va_list a;\n    __builtin_va_start(a, template);\n    int result = vasprintf(s, template, a);\n    __builtin_va_end(a);\n    if (result < 0) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"void xasprintf_name_conflict(char **ret, const char *fmt, ...) {\n  va_list ap;\n  int n;\n\n  n = vasprintf(ret, fmt, ap);\n  if (n < 0)\n    fatal(\"out of memory\");\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *xgetcwd(void) {\n    char *result = getcwd(((void *)0), 0);\n    if (result == ((void *)0)) {\n        fatal(\"out of memory\");\n    }\n    return result;\n}\n","function_prediction":"char *xgetcwd_name_conflict(void) {\n  char *p;\n\n  p = getcwd(NULL, 0);\n  if (p == NULL)\n    fatal(\"out of memory\");\n  return (p);\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool str_starts_with(const char *string, const char *prefix) {\n    const char *string_ptr = string;\n    const char *prefix_ptr = prefix;\n    while (*string_ptr != '\\x00' && *prefix_ptr != '\\x00')\n        {\n            if (*string_ptr != *prefix_ptr) {\n                return 0;\n            }\n            string_ptr++;\n            prefix_ptr++;\n        }\n    if (*string_ptr == '\\x00' && *prefix_ptr != '\\x00') {\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"bool str_starts_with_name_conflict(const char *str, const char *prefix) {\n  while (*str && *prefix) {\n    if (*str++ != *prefix++)\n      return false;\n  }\n  return !*prefix;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool str_ends_with(const char *string, const char *suffix) {\n    size_t string_length = strlen(string);\n    size_t suffix_length = strlen(suffix);\n    if (string_length < suffix_length) {\n        return 0;\n    }\n    return strcmp(string + string_length - suffix_length, suffix) == 0;\n}\n","function_prediction":"int str_ends_with_name_conflict(const char *str, const char *suffix) {\n  size_t str_len = strlen(str);\n  size_t suffix_len = strlen(suffix);\n\n  if (suffix_len > str_len)\n    return 0;\n\n  return !strcmp(str + str_len - suffix_len, suffix);\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_path(const char *parent, const char *relative_path) {\n    size_t parent_length = strlen(parent);\n    size_t relative_path_length = strlen(relative_path);\n    size_t result_length = addst(parent_length, relative_path_length);\n    result_length = addst(result_length, 2);\n    char *result = xmalloc(result_length);\n    strcpy(result, parent);\n    result[parent_length] = '/';\n    strcpy(result + parent_length + 1, relative_path);\n    return result;\n}\n","function_prediction":"char *make_path_name_conflict(const char *dir, const char *file) {\n  size_t dir_len = strlen(dir);\n  size_t file_len = strlen(file);\n  char *path = malloc(dir_len + 1 + file_len + 1);\n  if (!path)\n    fatal(\"out of memory\");\n  memcpy(path, dir, dir_len);\n  path[dir_len] = '/';\n  memcpy(path + dir_len + 1, file, file_len + 1);\n  return path;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_canonical_path(const char *relative_path) {\n    char *original_directory = xgetcwd();\n    char *base = make_basename(relative_path);\n    char *dir = make_dirname(relative_path);\n    xchdir(dir);\n    char *canonical_dir = xgetcwd();\n    char *result = make_path(canonical_dir, base);\n    free(canonical_dir);\n    free(base);\n    free(dir);\n    xchdir(original_directory);\n    free(original_directory);\n    return result;\n}\n","function_prediction":"char *make_canonical_path_name_conflict(const char *path) {\n  char *cwd, *dir, *base, *newpath;\n  size_t cwdlen, baselen;\n\n  cwd = getcwd(NULL, 0);\n  if (cwd == NULL)\n    fatal(\"out of memory\");\n\n  dir = strdup(path);\n  if (dir == NULL)\n    fatal(\"out of memory\");\n  base = strdup(__xpg_basename(dir));\n  if (base == NULL)\n    fatal(\"out of memory\");\n  free(dir);\n\n  dir = strdup(path);\n  if (dir == NULL)\n    fatal(\"out of memory\");\n  dir = dirname(dir);\n  if (dir == NULL)\n    fatal(\"out of memory\");\n  dir = strdup(dir);\n  if (dir == NULL)\n    fatal(\"out of memory\");\n  free(dir);\n\n  if (chdir(dir) == -1)\n    fatal(\"cannot change directory: %s\", dir);\n\n  cwd = getcwd(NULL, 0);\n  if (cwd == NULL)\n    fatal(\"out of memory\");\n  cwdlen = strlen(cwd);\n  baselen = strlen(base);\n\n  newpath = malloc(cwdlen + baselen + 2);\n  if (newpath == NULL)\n    fatal(\"out of memory\");\n\n  memcpy(newpath, cwd, cwdlen);\n  newpath[cwdlen] = '/';\n  memcpy(newpath + cwdlen + 1, base, baselen + 1);\n\n  free(cwd);\n  free(base);\n  free(dir);\n\n  if (chdir(cwd) == -1)\n    fatal(\"cannot change directory: %s\", cwd);\n  free(cwd);\n\n  return newpath;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_basename(const char *path) {\n    char *copy = xstrdup(path);\n    char *result = xstrdup(__xpg_basename(copy));\n    free(copy);\n    return result;\n}\n","function_prediction":"char *make_basename_name_conflict(const char *path) {\n  char *dup, *base;\n\n  dup = strdup(path);\n  if (dup == NULL)\n    fatal(\"out of memory\");\n\n  base = strdup(__xpg_basename(dup));\n  if (base == NULL)\n    fatal(\"out of memory\");\n\n  free(dup);\n  return base;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"char *make_dirname(const char *path) {\n    char *copy = xstrdup(path);\n    char *result = xstrdup(dirname(copy));\n    free(copy);\n    return result;\n}\n","function_prediction":"char *make_dirname_name_conflict(const char *path) {\n  char *dir, *dir2;\n\n  dir = strdup(path);\n  if (!dir)\n    fatal(\"out of memory\");\n  dir2 = strdup(dirname(dir));\n  if (!dir2)\n    fatal(\"out of memory\");\n  free(dir);\n  return dir2;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int is_same_file(const char *file1, const char *file2) {\n    if (strcmp(file1, file2) == 0) {\n        return 1;\n    }\n    char *canonical1 = make_canonical_path(file1);\n    char *canonical2 = make_canonical_path(file2);\n    int cmp = strcmp(canonical1, canonical2);\n    free(canonical1);\n    free(canonical2);\n    if (cmp == 0) {\n        return 1;\n    }\n    struct stat buf1;\n    if (stat(file1, &buf1) == -1) {\n        if ((*__errno_location()) == 2) {\n            return 0;\n        } else {\n            fatal(\"cannot stat file: %s\", file1);\n        }\n    }\n    struct stat buf2;\n    if (stat(file2, &buf2) == -1) {\n        if ((*__errno_location()) == 2) {\n            return 0;\n        } else {\n            fatal(\"cannot stat file: %s\", file2);\n        }\n    }\n    if (buf1.st_dev == buf2.st_dev && buf1.st_ino == buf2.st_ino) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int is_same_file_name_conflict(const char *path1, const char *path2) {\n  struct stat st1, st2;\n  char *canonical_path1, *canonical_path2;\n\n  if (!strcmp(path1, path2))\n    return 1;\n\n  canonical_path1 = make_canonical_path(path1);\n  canonical_path2 = make_canonical_path(path2);\n  if (!strcmp(canonical_path1, canonical_path2)) {\n    free(canonical_path1);\n    free(canonical_path2);\n    return 1;\n  }\n  free(canonical_path1);\n  free(canonical_path2);\n\n  if (stat(path1, &st1) == -1) {\n    if (*__errno_location() == 2)\n      return 0;\n    fatal(\"cannot stat file: %s\", path1);\n  }\n  if (stat(path2, &st2) == -1) {\n    if (*__errno_location() == 2)\n      return 0;\n    fatal(\"cannot stat file: %s\", path2);\n  }\n\n  return st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"int contains_file(const char *file1, const char *file2) {\n    int result = 0;\n    char *ancestor = make_canonical_path(file1);\n    char *d = make_canonical_path(file2);\n    char *parent = make_dirname(d);\n    while (strcmp(d, parent) != 0)\n        {\n            if (is_same_file(ancestor, parent)) {\n                result = 1;\n                break;\n            }\n            free(d);\n            d = parent;\n            parent = make_dirname(d);\n        }\n    free(d);\n    free(parent);\n    free(ancestor);\n    return result;\n}\n","function_prediction":"int contains_file_name_conflict(const char *dir, const char *file) {\n  char *dir1, *dir2, *dir3;\n\n  dir1 = make_canonical_path(dir);\n  dir2 = make_canonical_path(file);\n  dir3 = strdup(dirname(dir2));\n  if (!dir3)\n    fatal(\"out of memory\");\n\n  do {\n    if (!strcmp(dir2, dir3)) {\n      free(dir2);\n      free(dir3);\n      free(dir1);\n      return 0;\n    }\n\n    if (is_same_file(dir1, dir3)) {\n      free(dir2);\n      free(dir3);\n      free(dir1);\n      return 1;\n    }\n\n    free(dir2);\n    dir2 = strdup(dir3);\n    if (!dir2)\n      break;\n    dir3 = strdup(dirname(dir2));\n    if (!dir3)\n      break;\n    free(dir2);\n    dir2 = dir3;\n    dir3 = dir1;\n  } while (1);\n\n  fatal(\"out of memory\");\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":0,"function":"bool directory_is_empty(const char *directory) {\n    bool result = 1;\n    DIR *dir = xopendir(directory);\n    struct dirent *e;\n    while ((e = readdir(dir)) != ((void *)0))\n        {\n            if (strcmp(e->d_name, \".\") != 0 && strcmp(e->d_name, \"..\") != 0) {\n                result = 0;\n                break;\n            }\n        }\n    closedir(dir);\n    return result;\n}\n","function_prediction":"int directory_is_empty_name_conflict(const char *path) {\n  DIR *dir;\n  struct dirent *d;\n  int empty = 1;\n\n  dir = opendir(path);\n  if (!dir)\n    fatal(\"cannot open directory: %s\", path);\n\n  while ((d = readdir(dir))) {\n    if (!strcmp(d->d_name, \".\") || !strcmp(d->d_name, \"..\"))\n      continue;\n    empty = 0;\n    break;\n  }\n\n  closedir(dir);\n  return empty;\n}","pass":0,"source_file":"C_COMPILE/rpaterson_nodeunit/deps/ejs/node_modules/expresso/deps/jscoverage/util.c"}
{"compilable":1,"function":"int verify_values(char **values, char **expected, int n) {\n    int i = 0;\n    while (i < n)\n        {\n            if (0 != strcmp(values[i], expected[i])) {\n                return -1;\n            }\n            i++;\n        }\n    return 0;\n}\n","function_prediction":"int verify_values_name_conflict(char **values, char **expected, int count) {\n  int i;\n\n  for (i = 0; i < count; i++) {\n    if (strcmp(values[i], expected[i]))\n      return -1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *test_split_string_by_comma_ok() {\n    int rv;\n    char *test_str;\n    char *values[24];\n    test_str = strdup(\"JACK,ENGQVIST,JOHANSSON,89\");\n    rv = _split_string_by_comma(test_str, values, (sizeof values / sizeof (values[0])));\n    do {\n        if (!(4 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return the correct number of values\", \"\\033[0m\");\n            return \"should return the correct number of values\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return the correct number of values\", \"\\033[0m\");\n    } while (0);\n    char *expected[] = {\"JACK\", \"ENGQVIST\", \"JOHANSSON\", \"89\"};\n    do {\n        if (!(0 == verify_values(values, expected, rv))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to split a comma seperated string\", \"\\033[0m\");\n            return \"should be able to split a comma seperated string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to split a comma seperated string\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\",SOME,EMPTY,VALUES,,\");\n    rv = _split_string_by_comma(test_str, values, (sizeof values / sizeof (values[0])));\n    do {\n        if (!(6 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return the correct number of values even when there is empty values (,,)\", \"\\033[0m\");\n            return \"should return the correct number of values even when there is empty values (,,)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return the correct number of values even when there is empty values (,,)\", \"\\033[0m\");\n    } while (0);\n    char *expected2[] = {\"\", \"SOME\", \"EMPTY\", \"VALUES\", \"\", \"\"};\n    do {\n        if (!(0 == verify_values(values, expected2, rv))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to split empty values (,,)\", \"\\033[0m\");\n            return \"should be able to split empty values (,,)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to split empty values (,,)\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    return 0;\n}\n","function_prediction":"char *test_split_string_by_comma_ok_name_conflict() {\n  char *test_string = strdup(\"JACK,ENGQVIST,JOHANSSON,89\");\n  char *values[24];\n  int number_of_values = _split_string_by_comma(test_string, values, 24);\n  if (number_of_values != 4) {\n    printf(\"\\033[31m\"\n           \"✗ %s %s\\n\"\n           \"\\033[0m\",\n           \"should\", \"should return the correct number of values\");\n    return \"should return the correct number of values\";\n  }\n  printf(\"\\033[32m\"\n         \"✓ %s %s\\n\"\n         \"\\033[0m\",\n         \"should\", \"should return the correct number of values\");\n\n  char *expected_values[] = {\"JACK\", \"ENGQVIST\", \"JOHANSSON\", \"89\"};\n  if (!verify_values(values, expected_values, 4)) {\n    printf(\"\\033[31m\"\n           \"✗ %s %s\\n\"\n           \"\\033[0m\",\n           \"should\", \"should be able to split a comma seperated string\");\n    return \"should be able to split a comma seperated string\";\n  }\n  printf(\"\\033[32m\"\n         \"✓ %s %s\\n\"\n         \"\\033[0m\",\n         \"should\", \"should be able to split a comma seperated string\");\n\n  free(test_string);\n  test_string = strdup(\",SOME,EMPTY,VALUES,,\");\n  number_of_values = _split_string_by_comma(test_string, values, 24);\n  if (number_of_values != 6) {\n    printf(\"\\033[31m\"\n           \"✗ %s %s\\n\"\n           \"\\033[0m\",\n           \"should\",\n           \"should return the correct number of values even when there is \"\n           \"empty values (,,)\");\n    return \"should return the correct number of values even when there is \"\n           \"empty values (,,)\";\n","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *test_crop_sentence_ok() {\n    char *rv;\n    char *test_str;\n    test_str = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89*D1\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \"ENGQVIST,JOHANSSON,89\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return a cropped string\", \"\\033[0m\");\n            return \"should return a cropped string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return a cropped string\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,ENGQVIST,JOHANSSON,89\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \"ENGQVIST,JOHANSSON,89\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return a cropped string without checksum\", \"\\033[0m\");\n            return \"should return a cropped string without checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return a cropped string without checksum\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,,ENGQVIST,,JOHANSSON,,89,,\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \",ENGQVIST,,JOHANSSON,,89,,\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should work with empty values\", \"\\033[0m\");\n            return \"should work with empty values\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should work with empty values\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    test_str = strdup(\"$GPGGA,,ENGQVIST,,JOHANSSON,,89,,*1D\\r\\n\");\n    rv = _crop_sentence(test_str, strlen(test_str));\n    do {\n        if (!(0 == strcmp(rv, \",ENGQVIST,,JOHANSSON,,89,,\"))) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should work with empty values and checksum\", \"\\033[0m\");\n            return \"should work with empty values and checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should work with empty values and checksum\", \"\\033[0m\");\n    } while (0);\n    free(test_str);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *test_is_value_set() {\n    int rv;\n    rv = _is_value_set(\"JACK\");\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when there is a value\", \"\\033[0m\");\n            return \"should return 0 when there is a value\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when there is a value\", \"\\033[0m\");\n    } while (0);\n    rv = _is_value_set(\"\");\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when the string is empty\", \"\\033[0m\");\n            return \"should return -1 when the string is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when the string is empty\", \"\\033[0m\");\n    } while (0);\n    rv = _is_value_set(((void *)0));\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on NULL\", \"\\033[0m\");\n            return \"should return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_split_string_by_comma()\", \"\\033[0m\");\n    do {\n        char *message = test_split_string_by_comma_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_crop_sentence()\", \"\\033[0m\");\n    do {\n        char *message = test_crop_sentence_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"_is_value_set()\", \"\\033[0m\");\n    do {\n        char *message = test_is_value_set();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_nmea_helpers.c"}
{"compilable":0,"function":"static int _get_so_files(const char *path, char **files) {\n    int j, i = 0;\n    size_t len;\n    char *name;\n    DIR *d = ((void *)0);\n    struct dirent *dir;\n    d = opendir(path);\n    if (((void *)0) == d) {\n        return -1;\n    }\n    while (((void *)0) != (dir = readdir(d)))\n        {\n            if ('.' == dir->d_name[0]) {\n                continue;\n            }\n            len = strlen(dir->d_name);\n            if (len < 3) {\n                continue;\n            }\n            if (0 != strncmp(dir->d_name + len - 3, \".so\", 3)) {\n                continue;\n            }\n            name = malloc(255);\n            if (((void *)0) == name) {\n                goto fail;\n            }\n            strcpy(name, path);\n            strcat(name, dir->d_name);\n            files[i++] = name;\n        }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return i;\n  fail:\n    for (j = 0; j < i; i++) {\n        free(files[j]);\n    }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":1,"function":"int nmea_load_parsers() {\n    int i;\n    char *files[255];\n    char *parser_path;\n    nmea_parser_module_s *parser;\n    parser_path = getenv(\"NMEA_PARSER_PATH\");\n    if (((void *)0) == parser_path) {\n        parser_path = \"/usr/lib/nmea/\";\n    }\n    n_parsers = _get_so_files(parser_path, files);\n    if (1 > n_parsers) {\n        return -1;\n    }\n    parsers = malloc((sizeof(nmea_parser_module_s *)) * n_parsers);\n    if (((void *)0) == parsers) {\n        return -1;\n    }\n    memset(parsers, 0, (sizeof(nmea_parser_module_s *)) * n_parsers);\n    i = n_parsers;\n    while (i-- > 0)\n        {\n            parser = nmea_init_parser(files[i]);\n            free(files[i]);\n            if (((void *)0) == parser) {\n                return -1;\n            }\n            parsers[i] = parser;\n        }\n    return n_parsers;\n}\n","function_prediction":"int nmea_load_parsers_name_conflict(void) {\n  DIR *dir;\n  struct dirent *dent;\n  char *path;\n  char *files[256];\n  int n = 0;\n\n  path = getenv(\"NMEA_PARSER_PATH\");\n  if (path == NULL)\n    path = \"/usr/lib/nmea/\";\n\n  dir = opendir(path);\n  if (dir == NULL)\n    return n_parsers = -1;\n\n  while ((dent = readdir(dir)) != NULL) {\n    char *name = dent->d_name;\n    if (name[0] == '.')\n      continue;\n\n    size_t len = strlen(name);\n    if (len < 3 || name[len - 3] != '.' || name[len - 2] != 's' ||\n        name[len - 1] != 'o')\n      continue;\n\n    char *file = malloc(255);\n    if (file == NULL)\n      goto error;\n\n    char *p = stpcpy(file, path);\n    strcpy(p, name);\n    files[n++] = file;\n  }\n\n  closedir(dir);\n\n  n_parsers = n;\n  if (n == 0)\n    return -1;\n\n  parsers = calloc(n, sizeof(struct nmea_parser *));\n  if (parsers == NULL)\n    return -1;\n\n  while (n--) {\n    char *file = files[n];\n    struct nmea_parser *parser = nmea_init_parser(file);\n    free(file);\n    if (parser == NULL)\n      goto error;\n\n    parsers[n] = parser;\n  }\n\n  return n_parsers;\n\nerror:\n  while (n--)\n    free(files[n]);\n\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"static char *test_position_parse_ok() {\n    int res;\n    char *s;\n    nmea_position *pos = malloc(sizeof(nmea_position));\n    s = strdup(\"12311.12\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(123 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(11.119999999999999 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"2621.44\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(26 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(21.440000000000001 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"901.01\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1.01 == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"901.\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return 0 when successfull\", \"\\033[0m\");\n            return \"should return return 0 when successfull\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return 0 when successfull\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == pos->degrees)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->degrees should be 123\", \"\\033[0m\");\n            return \"pos->degrees should be 123\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->degrees should be 123\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1. == pos->minutes)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n            return \"pos->minutes should be 11.12\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"pos->minutes should be 11.12\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    free(pos);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_position_parse_fail() {\n    int res;\n    char *s;\n    nmea_position *pos = malloc(sizeof(nmea_position));\n    s = strdup(\"123\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on failure\", \"\\033[0m\");\n            return \"should return return -1 on failure\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on failure\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    s = strdup(\"\");\n    res = nmea_position_parse(s, pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on empty string\", \"\\033[0m\");\n            return \"should return return -1 on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on empty string\", \"\\033[0m\");\n    } while (0);\n    free(s);\n    res = nmea_position_parse(((void *)0), pos);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return return -1 on NULL\", \"\\033[0m\");\n            return \"should return return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    free(pos);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_cardinal_dir_parse_ok() {\n    nmea_cardinal_t card;\n    card = nmea_cardinal_direction_parse(\"N\");\n    do {\n        if (!((nmea_cardinal_t)'N' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_NORTH on \\\"N\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"E\");\n    do {\n        if (!((nmea_cardinal_t)'E' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_EAST on \\\"E\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"S\");\n    do {\n        if (!((nmea_cardinal_t)'S' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_SOUTH on \\\"S\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"W\");\n    do {\n        if (!((nmea_cardinal_t)'W' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_WEST on \\\"W\\\"\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_cardinal_dir_parse_fail() {\n    nmea_cardinal_t card;\n    card = nmea_cardinal_direction_parse(\"\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on empty string\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on empty string\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(((void *)0));\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on NULL\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on NULL\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"J\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"J\\\"\", \"\\033[0m\");\n    } while (0);\n    card = nmea_cardinal_direction_parse(\"n\");\n    do {\n        if (!((nmea_cardinal_t)'\\x00' == card)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\", \"\\033[0m\");\n            return \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_CARDINAL_UNKNOWN on \\\"n\\\"\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_time_parse_ok() {\n    int rv;\n    struct tm t;\n    rv = nmea_time_parse(\"171521\", &t);\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 on success\", \"\\033[0m\");\n            return \"should return 0 on success\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 on success\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(21 == t.tm_sec)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_sec should be 21\", \"\\033[0m\");\n            return \"t.tm_sec should be 21\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_sec should be 21\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(15 == t.tm_min)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_min should be 15\", \"\\033[0m\");\n            return \"t.tm_min should be 15\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_min should be 15\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(17 == t.tm_hour)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_hour should be 17\", \"\\033[0m\");\n            return \"t.tm_hour should be 17\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_hour should be 17\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"090801\", &t);\n    do {\n        if (!(0 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 on success\", \"\\033[0m\");\n            return \"should return 0 on success\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 on success\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(1 == t.tm_sec)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_sec should be 1\", \"\\033[0m\");\n            return \"t.tm_sec should be 1\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_sec should be 1\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(8 == t.tm_min)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_min should be 8\", \"\\033[0m\");\n            return \"t.tm_min should be 8\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_min should be 8\", \"\\033[0m\");\n    } while (0);\n    do {\n        if (!(9 == t.tm_hour)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"t.tm_hour should be 9\", \"\\033[0m\");\n            return \"t.tm_hour should be 9\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"t.tm_hour should be 9\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *test_time_parse_fail() {\n    int rv;\n    struct tm t;\n    rv = nmea_time_parse(\"240000\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when hours is over 23\", \"\\033[0m\");\n            return \"should return -1 when hours is over 23\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when hours is over 23\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"006000\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when minutes is over 59\", \"\\033[0m\");\n            return \"should return -1 when minutes is over 59\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when minutes is over 59\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"000062\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when seconds is over 59\", \"\\033[0m\");\n            return \"should return -1 when seconds is over 59\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when seconds is over 59\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"2345\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on too short string\", \"\\033[0m\");\n            return \"should return -1 on too short string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on too short string\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"2345XX\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on invalid characters\", \"\\033[0m\");\n            return \"should return -1 on invalid characters\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on invalid characters\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(\"\", &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on empty string\", \"\\033[0m\");\n            return \"should return -1 on empty string\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on empty string\", \"\\033[0m\");\n    } while (0);\n    rv = nmea_time_parse(((void *)0), &t);\n    do {\n        if (!(-1 == rv)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 on NULL\", \"\\033[0m\");\n            return \"should return -1 on NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 on NULL\", \"\\033[0m\");\n    } while (0);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":0,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_position_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_position_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_position_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_cardinal_dir_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_cardinal_dir_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_cardinal_dir_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_time_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_time_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_time_parse_fail();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_parse.c"}
{"compilable":1,"function":"nmea_cardinal_t nmea_cardinal_direction_parse(char *s) {\n    if (((void *)0) == s || '\\x00' == *s) {\n        return (nmea_cardinal_t)'\\x00';\n    }\n    switch (*s) {\n      case (nmea_cardinal_t)'N':\n        return (nmea_cardinal_t)'N';\n      case (nmea_cardinal_t)'E':\n        return (nmea_cardinal_t)'E';\n      case (nmea_cardinal_t)'S':\n        return (nmea_cardinal_t)'S';\n      case (nmea_cardinal_t)'W':\n        return (nmea_cardinal_t)'W';\n      default:\n        break;\n    }\n    return (nmea_cardinal_t)'\\x00';\n}\n","function_prediction":"char nmea_cardinal_direction_parse_name_conflict(const char *direction) {\n  if (direction == NULL)\n    return '\\0';\n\n  switch (*direction) {\n  case 'N':\n  case 'E':\n  case 'S':\n  case 'W':\n    return *direction;\n  default:\n    return '\\0';\n  }\n}","pass":1,"source_file":"C_COMPILE/jacketizer_libnmea/src/parsers/parse.c"}
{"compilable":0,"function":"static char *test_get_type_ok() {\n    char *sentence;\n    nmea_t res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_GPGLL == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct type (GPGLL)\", \"\\033[0m\");\n            return \"should return correct type (GPGLL)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct type (GPGLL)\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GPGGA,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_GPGGA == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct type (GPGGA)\", \"\\033[0m\");\n            return \"should return correct type (GPGGA)\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct type (GPGGA)\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_type_unknown() {\n    char *sentence;\n    nmea_t res;\n    sentence = strdup(\"THISISWRONG\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n            return \"should return NMEA_UNKNOWN on unknown sentence type\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$UNKNOWN\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n            return \"should return NMEA_UNKNOWN on unknown sentence type\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NMEA_UNKNOWN on unknown sentence type\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"\");\n    res = nmea_get_type(sentence);\n    do {\n        if (!(NMEA_UNKNOWN == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return nmea_unknown on empty sentence\", \"\\033[0m\");\n            return \"should return nmea_unknown on empty sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return nmea_unknown on empty sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_checksum_with_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    uint8_t res = nmea_get_checksum(sentence);\n    do {\n        if (!(29 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct checksum\", \"\\033[0m\");\n            return \"should return correct checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_get_checksum_without_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,\\r\\n\");\n    uint8_t res = nmea_get_checksum(sentence);\n    do {\n        if (!(29 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return correct checksum\", \"\\033[0m\");\n            return \"should return correct checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return correct checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_has_checksum_yes() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*1D\\r\\n\");\n    int res = nmea_has_checksum(sentence, strlen(sentence));\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence has a checksum\", \"\\033[0m\");\n            return \"should return 0 when sentence has a checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence has a checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_has_checksum_no() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_has_checksum(sentence, strlen(sentence));\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence does not have a checksum\", \"\\033[0m\");\n            return \"should return -1 when sentence does not have a checksum\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence does not have a checksum\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_ok_with_crc() {\n    char *sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A,*1D\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n            return \"should return 0 when sentence is valid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_ok_without_crc() {\n    char *sentence;\n    int res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n            return \"should return 0 when sentence is valid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when sentence is valid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A*FF\\r\\n\");\n    res = nmea_validate(sentence, strlen(sentence), 0);\n    do {\n        if (!(0 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return 0 when check_checksum is 0 and crc is invalid\", \"\\033[0m\");\n            return \"should return 0 when check_checksum is 0 and crc is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return 0 when check_checksum is 0 and crc is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_type() {\n    char *sentence = strdup(\"$GPgll,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence type is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence type is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence type is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_start() {\n    char *sentence = strdup(\"\\302\\243GPGLL,4916.45,N,12311.12,W,225444,A\\r\\n\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence start is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence start is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence start is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_end() {\n    char *sentence;\n    int res;\n    sentence = strdup(\"$GPGLL,4916.45,N,12311.12,W,225444,A\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence ending is invalid\", \"\\033[0m\");\n            return \"should return -1 when sentence ending is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence ending is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    sentence = strdup(\"$GP\");\n    res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence is too short\", \"\\033[0m\");\n            return \"should return -1 when sentence is too short\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence is too short\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_validate_fail_empty() {\n    char *sentence = strdup(\"\");\n    int res = nmea_validate(sentence, strlen(sentence), 1);\n    do {\n        if (!(-1 == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return -1 when sentence is empty\", \"\\033[0m\");\n            return \"should return -1 when sentence is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return -1 when sentence is empty\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_ok() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) != res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n            return \"should be able to parse a GPGGA sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 0);\n    do {\n        if (!(((void *)0) != res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n            return \"should be able to parse a GPGGA sentence\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should be able to parse a GPGGA sentence\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_unknown() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$JACK1,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence type is unknown\", \"\\033[0m\");\n            return \"should return NULL when sentence type is unknown\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence type is unknown\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *test_parse_invalid() {\n    char *sentence;\n    nmea_s *res;\n    sentence = strdup(\"$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*FF\\r\\n\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when checksum is invalid\", \"\\033[0m\");\n            return \"should return NULL when checksum is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when checksum is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is empty\", \"\\033[0m\");\n            return \"should return NULL when sentence is empty\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is empty\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    sentence = strdup(\"invalid\");\n    res = nmea_parse(sentence, strlen(sentence), 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is invalid\", \"\\033[0m\");\n            return \"should return NULL when sentence is invalid\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is invalid\", \"\\033[0m\");\n    } while (0);\n    free(sentence);\n    nmea_free(res);\n    res = nmea_parse(((void *)0), 0, 1);\n    do {\n        if (!(((void *)0) == res)) {\n            printf(\"\\t%s\\303\\227 %s%s\\n\", \"\\033[5;31;50m\", \"should return NULL when sentence is NULL\", \"\\033[0m\");\n            return \"should return NULL when sentence is NULL\";\n        }\n        printf(\"\\t%s\\342\\200\\242 %s%s\\n\", \"\\033[32m\", \"should return NULL when sentence is NULL\", \"\\033[0m\");\n    } while (0);\n    nmea_free(res);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static char *all_tests() {\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_get_type()\", \"\\033[0m\");\n    do {\n        char *message = test_get_type_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_get_type_unknown();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_get_checksum()\", \"\\033[0m\");\n    do {\n        char *message = test_get_checksum_with_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_get_checksum_without_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_has_checksum()\", \"\\033[0m\");\n    do {\n        char *message = test_has_checksum_yes();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_has_checksum_no();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_validate()\", \"\\033[0m\");\n    do {\n        char *message = test_validate_ok_with_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_ok_without_crc();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_type();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_start();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_end();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_validate_fail_empty();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    printf(\"%s \\342\\200\\242 %s%s\\n\", \"\\033[34m\", \"nmea_parse()\", \"\\033[0m\");\n    do {\n        char *message = test_parse_ok();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_parse_unknown();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    do {\n        char *message = test_parse_invalid();\n        tests_run++;\n        if (message) {\n            return message;\n        }\n    } while (0);\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/tests/unit-tests/test_lib.c"}
{"compilable":0,"function":"static int _is_value_set(const char *value) {\n    if (((void *)0) == value || '\\x00' == *value) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static char *_crop_sentence(char *sentence, size_t length) {\n    sentence += 5 + 2;\n    sentence[length - 9] = '\\x00';\n    if ('*' == sentence[length - 12]) {\n        sentence[length - 12] = '\\x00';\n    }\n    return sentence;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static int _split_string_by_comma(char *string, char **values, int max_values) {\n    int i = 0;\n    values[i++] = string;\n    while (i < max_values && ((void *)0) != (string = strchr(string, ',')))\n        {\n            *string = '\\x00';\n            values[i++] = ++string;\n        }\n    return i;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"nmea_t nmea_get_type(const char *sentence) {\n    if (((void *)0) == sentence) {\n        return NMEA_UNKNOWN;\n    }\n    nmea_parser_module_s *parser = nmea_get_parser_by_sentence(sentence);\n    if (((void *)0) == parser) {\n        return NMEA_UNKNOWN;\n    }\n    return parser->parser.type;\n}\n","function_prediction":"nmea_type_t nmea_get_type_name_conflict(const char *sentence) {\n  nmea_parser_t *parser = NULL;\n\n  if (sentence == NULL)\n    return 0;\n\n  parser = nmea_get_parser_by_sentence(sentence);\n  if (parser == NULL)\n    return 0;\n\n  return parser->type;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"uint8_t nmea_get_checksum(const char *sentence) {\n    const char *n = sentence + 1;\n    uint8_t chk = 0;\n    while ('*' != *n && '\\r' != *n && '\\x00' != *n)\n        {\n            chk ^= (uint8_t)*n;\n            n++;\n        }\n    return chk;\n}\n","function_prediction":"unsigned char nmea_get_checksum_name_conflict(const char *sentence) {\n  unsigned char checksum = 0;\n  const char *p = sentence + 1;\n\n  while (*p != '*') {\n    checksum ^= *p;\n    p++;\n  }\n\n  return checksum;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"int nmea_has_checksum(const char *sentence, size_t length) {\n    if ('*' == sentence[length - 5]) {\n        return 0;\n    }\n    return -1;\n}\n","function_prediction":"int nmea_has_checksum_name_conflict(const char *sentence, size_t len) {\n  return sentence[len - 5] == '*' ? 0 : -1;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"int nmea_validate(const char *sentence, size_t length, int check_checksum) {\n    const char *n;\n    if (9 > length) {\n        return -1;\n    }\n    if (82 < length) {\n        return -1;\n    }\n    if ('$' != *sentence) {\n        return -1;\n    }\n    if ('\\n' != sentence[length - 1] || '\\r' != sentence[length - 2]) {\n        return -1;\n    }\n    n = sentence;\n    while (++n < sentence + 6)\n        {\n            if (*n < 'A' || *n > 'Z') {\n                return -1;\n            }\n        }\n    if (',' != sentence[6]) {\n        return -1;\n    }\n    if (1 == check_checksum && 0 == nmea_has_checksum(sentence, length)) {\n        uint8_t actual_chk;\n        uint8_t expected_chk;\n        char checksum[3];\n        checksum[0] = sentence[length - 4];\n        checksum[1] = sentence[length - 3];\n        checksum[2] = '\\x00';\n        actual_chk = nmea_get_checksum(sentence);\n        expected_chk = (uint8_t)strtol(checksum, ((void *)0), 16);\n        if (expected_chk != actual_chk) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int nmea_validate_name_conflict(char *buf, size_t len, int checksum) {\n  unsigned char ck_a, ck_b;\n  unsigned char *p;\n  char ck_str[3];\n  int ck;\n\n  if (len < 10 || len > 73)\n    return -1;\n\n  if (buf[0] != '$' || buf[len - 1] != '\\n' || buf[len - 2] != '\\r')\n    return -1;\n\n  if (buf[1] < 'A' || buf[1] > 'Z')\n    return -1;\n\n  if (buf[2] < 'A' || buf[2] > 'Z')\n    return -1;\n\n  if (buf[3] < '0' || buf[3] > '9')\n    return -1;\n\n  if (buf[4] < '0' || buf[4] > '9')\n    return -1;\n\n  if (buf[5] < '0' || buf[5] > '9')\n    return -1;\n\n  if (buf[6] != ',')\n    return -1;\n\n  if (checksum == 1) {\n    if (buf[len - 5] != '*')\n      return -1;\n\n    ck_a = buf[len - 4];\n    ck_b = buf[len - 3];\n    ck_str[0] = ck_a;\n    ck_str[1] = ck_b;\n    ck_str[2] = 0;\n\n    ck = 0;\n    p = (unsigned char *)buf + 1;\n    while (*p != '*') {\n      ck ^= *p;\n      p++;\n    }\n\n    if (ck != strtol(ck_str, NULL, 16))\n      return -1;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"nmea_s *nmea_parse(char *sentence, size_t length, int check_checksum) {\n    unsigned int n_vals, val_index;\n    char *value, *val_string;\n    char *values[255];\n    nmea_parser_module_s *parser;\n    nmea_t type;\n    if (-1 == nmea_validate(sentence, length, check_checksum)) {\n        return (nmea_s *)((void *)0);\n    }\n    type = nmea_get_type(sentence);\n    if (NMEA_UNKNOWN == type) {\n        return (nmea_s *)((void *)0);\n    }\n    val_string = _crop_sentence(sentence, length);\n    if (((void *)0) == val_string) {\n        return (nmea_s *)((void *)0);\n    }\n    n_vals = _split_string_by_comma(val_string, values, (sizeof values / sizeof (values[0])));\n    if (0 == n_vals) {\n        return (nmea_s *)((void *)0);\n    }\n    parser = nmea_get_parser_by_type(type);\n    if (((void *)0) == parser) {\n        return (nmea_s *)((void *)0);\n    }\n    parser->allocate_data((nmea_parser_s *)parser);\n    if (((void *)0) == parser->parser.data) {\n        return (nmea_s *)((void *)0);\n    }\n    parser->set_default((nmea_parser_s *)parser);\n    parser->errors = 0;\n    for (val_index = 0; val_index < n_vals; val_index++) {\n        value = values[val_index];\n        if (-1 == _is_value_set(value)) {\n            continue;\n        }\n        if (-1 == parser->parse((nmea_parser_s *)parser, value, val_index)) {\n            parser->errors++;\n        }\n    }\n    parser->parser.data->type = type;\n    parser->parser.data->errors = parser->errors;\n    return parser->parser.data;\n}\n","function_prediction":"nmeaPARSERESULT *nmea_parse_name_conflict(char *nmea_data, size_t nmea_data_len) {\n  int i, sentence_type, ret;\n  char *tokens[255], *p, *q;\n  nmeaPARSER *parser;\n  nmeaPARSERESULT *result;\n\n  if ((sentence_type = nmea_validate(nmea_data, nmea_data_len)) == -1)\n    return NULL;\n\n  if (nmea_data == NULL)\n    return NULL;\n\n  if ((parser = nmea_get_parser_by_sentence(nmea_data)) == NULL)\n    return NULL;\n\n  if (parser->type == 0)\n    return NULL;\n\n  nmea_data[nmea_data_len - 2] = '\\0';\n  nmea_data[nmea_data_len - 5] = '\\0';\n\n  p = nmea_data + 7;\n  q = p;\n  i = 0;\n  while ((q = strchr(p, ',')) != NULL) {\n    *q = '\\0';\n    tokens[i++] = p;\n    p = q + 1;\n    if (i == 255)\n      break;\n  }\n\n  if ((parser = nmea_get_parser_by_type(parser->type)) == NULL)\n    return NULL;\n\n  parser->reset(parser);\n\n  if (parser->result == NULL)\n    return NULL;\n\n  parser->init(parser);\n  parser->error_count = 0;\n\n  for (i = 0; i < 255; i++) {\n    if (tokens[i] == NULL || tokens[i][0] == '\\0')\n      continue;\n\n    ret = parser->parse(parser, tokens[i], i);\n    if (ret == -1)\n      parser->error_count++;\n  }\n\n  result = parser->result;\n  result->","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/nmea.c"}
{"compilable":0,"function":"static int _get_so_files(const char *path, char **files) {\n    int j, i = 0;\n    size_t len;\n    char *name;\n    DIR *d = ((void *)0);\n    struct dirent *dir;\n    d = opendir(path);\n    if (((void *)0) == d) {\n        return -1;\n    }\n    while (((void *)0) != (dir = readdir(d)))\n        {\n            if ('.' == dir->d_name[0]) {\n                continue;\n            }\n            len = strlen(dir->d_name);\n            if (len < 3) {\n                continue;\n            }\n            if (0 != strncmp(dir->d_name + len - 3, \".so\", 3)) {\n                continue;\n            }\n            name = malloc(255);\n            if (((void *)0) == name) {\n                goto fail;\n            }\n            strcpy(name, path);\n            strcat(name, dir->d_name);\n            files[i++] = name;\n        }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return i;\n  fail:\n    for (j = 0; j < i; i++) {\n        free(files[j]);\n    }\n    if (((void *)0) != d) {\n        closedir(d);\n    }\n    return -1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"int nmea_load_parsers() {\n    int i;\n    char *files[255];\n    char *parser_path;\n    nmea_parser_module_s *parser;\n    parser_path = getenv(\"NMEA_PARSER_PATH\");\n    if (((void *)0) == parser_path) {\n        parser_path = \"/usr/lib/nmea/\";\n    }\n    n_parsers = _get_so_files(parser_path, files);\n    if (1 > n_parsers) {\n        return -1;\n    }\n    parsers = malloc((sizeof(nmea_parser_module_s *)) * n_parsers);\n    if (((void *)0) == parsers) {\n        return -1;\n    }\n    memset(parsers, 0, (sizeof(nmea_parser_module_s *)) * n_parsers);\n    i = n_parsers;\n    while (i-- > 0)\n        {\n            parser = nmea_init_parser(files[i]);\n            free(files[i]);\n            if (((void *)0) == parser) {\n                return -1;\n            }\n            parsers[i] = parser;\n        }\n    return n_parsers;\n}\n","function_prediction":"int nmea_load_parsers_name_conflict(void) {\n  DIR *dir;\n  struct dirent *dent;\n  char *path;\n  char *files[256];\n  int n = 0;\n\n  path = getenv(\"NMEA_PARSER_PATH\");\n  if (path == NULL)\n    path = \"/usr/lib/nmea/\";\n\n  dir = opendir(path);\n  if (dir == NULL)\n    return n_parsers = -1;\n\n  while ((dent = readdir(dir)) != NULL) {\n    char *name = dent->d_name;\n    if (name[0] == '.')\n      continue;\n\n    size_t len = strlen(name);\n    if (len < 3 || name[len - 3] != '.' || name[len - 2] != 's' ||\n        name[len - 1] != 'o')\n      continue;\n\n    char *file = malloc(255);\n    if (file == NULL)\n      goto error;\n\n    char *p = stpcpy(file, path);\n    strcpy(p, name);\n\n    files[n++] = file;\n  }\n\n  closedir(dir);\n\n  n_parsers = n;\n  if (n == 0)\n    return -1;\n\n  parsers = calloc(n, sizeof(struct nmea_parser *));\n  if (parsers == NULL)\n    return -1;\n\n  while (n--) {\n    char *file = files[n];\n    struct nmea_parser *parser = nmea_init_parser(file);\n    free(file);\n    if (parser == NULL)\n      return -1;\n\n    parsers[n] = parser;\n  }\n\n  return n_parsers;\n\nerror:\n  while (n--)\n    free(files[n]);\n\n  closedir(dir);\n  return n_parsers = -1;\n}","pass":0,"source_file":"C_COMPILE/jacketizer_libnmea/src/nmea/parser.c"}
{"compilable":0,"function":"uint8_t usart_recv(uint16_t usart) {\n    return (*(volatile uint8_t *)(usart + 1));\n}\n","function_prediction":"unsigned char usart_recv_name_conflict(unsigned short usart) {\n  return *(unsigned char *)(usart + 1);\n}\n\nunsigned char usart_recv_name_conflict_blocking(unsigned short usart) {\n  while (!(*(unsigned char *)(usart + 0) & 0x20))\n    ;\n  return *(unsigned char *)(usart + 1);\n}","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv_blocking(uint16_t usart) {\n    usart_wait_recv_ready(usart);\n    return usart_recv(usart);\n}\n","function_prediction":"char usart_recv_blocking_name_conflict(volatile unsigned short *usart) {\n  while (!(*usart & 0x20))\n    ;\n  return *(char *)(usart + 1);\n}","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv(uint16_t usart) {\n    return (*(volatile uint8_t *)(usart + 1));\n}\n","function_prediction":"unsigned char usart_recv_name_conflict(unsigned short usart) {\n  return *(unsigned char *)(usart + 1);\n}\n\nunsigned char usart_recv_name_conflict_blocking(unsigned short usart) {\n  while (!(*(unsigned char *)(usart + 0) & 0x20))\n    ;\n  return *(unsigned char *)(usart + 1);\n}","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"uint8_t usart_recv_blocking(uint16_t usart) {\n    usart_wait_recv_ready(usart);\n    return usart_recv(usart);\n}\n","function_prediction":"char usart_recv_blocking_name_conflict(volatile unsigned short *usart) {\n  while (!(*usart & 0x20))\n    ;\n  return *(char *)(usart + 1);\n}","pass":0,"source_file":"C_COMPILE/mnd_libstm8/lib/l/usart.c"}
{"compilable":0,"function":"char *replace_str(char *str, char *orig, char *rep) {\n    static char buffer[4096];\n    char *p;\n    int i = 0;\n    while (str[i])\n        {\n            if (!(p = strstr(str + i, orig)))\n                return str;\n            strncpy(buffer + strlen(buffer), str + i, (p - str) - i);\n            buffer[p - str] = '\\x00';\n            strcat(buffer, rep);\n            printf(\"STR:%s\\n\", buffer);\n            i = (p - str) + strlen(orig);\n        }\n    return buffer;\n}\n","function_prediction":"char *replace_str_name_conflict(char *str, char *old_str, char *new_str) {\n  char *p = str;\n  int i = 0;\n  while (*p != '\\0') {\n    char *p_old = strstr(p, old_str);\n    if (p_old == NULL) {\n      return str;\n    }\n    int len = p_old - p;\n    strncpy(buffer_0 + strlen(buffer_0), p, len - i);\n    buffer_0[len] = '\\0';\n    strcpy(buffer_0 + strlen(buffer_0), new_str);\n    printf(\"STR:%s\\n\", buffer_0);\n    p = p + len + strlen(old_str);\n    i = len + strlen(old_str);\n  }\n  return buffer_0;\n}","pass":0,"source_file":"C_COMPILE/cwkx_cgim/prc/cg_prc.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len;\n  unsigned long hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = hash * 257 + word[i];\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 1 + (unsigned int)length;\n  for (hash = 0; length > 0; length--)\n    hash = hash * a + (unsigned int)word[length - 1];\n  hash = hash % 500000000;\n  a = vocab_hash[hash];\n  while (a != -1) {\n    if (!strcmp(word, vocab[a].word))\n      return a;\n    else\n      hash = (hash + 1) % 500000000;\n    a = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  long long len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 500000000;\n  while (vocab_hash[hash] != -1) {\n    hash = (hash + 1) % 500000000;\n  }\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len, hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = (hash << 8) + word[i];\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 0;\n  hash = 0;\n  for (int i = 0; i < length; i++) {\n    hash = hash * 257 + word[i];\n    a = a * 257 + word[i];\n  }\n  hash = hash % 30000000;\n  a = a % 30000000;\n  int hentry = vocab_hash[hash];\n  while (hentry != -1) {\n    if (!strcmp(word, vocab[hentry].word)) {\n      return hentry;\n    }\n    hash = (hash + 1) % 30000000;\n    a = (a + 1) % 30000000;\n    hentry = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  int length = strlen(word) + 1;\n  if (length > 100)\n    length = 100;\n  vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 30000000;\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 30000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/cscvenkatmadurai_word2vec/word2vec.c"}
{"compilable":1,"function":"int read_pid(char *pidfile) {\n    FILE *f;\n    int pid;\n    if (!(f = fopen(pidfile, \"r\")))\n        return 0;\n    fscanf(f, \"%d\", &pid);\n    fclose(f);\n    return pid;\n}\n","function_prediction":"int read_pid_name_conflict(char *file) {\n  FILE *f;\n  int pid;\n\n  f = fopen(file, \"r\");\n  if (f == NULL)\n    return 0;\n  __isoc99_fscanf(f, \"%d\", &pid);\n  fclose(f);\n  return pid;\n}","pass":0,"source_file":"C_COMPILE/danielsen_boxstats/src/process-cpu.c"}
{"compilable":0,"function":"int get_usage(const pid_t pid, struct pstat *result) {\n    char pid_s[20];\n    snprintf(pid_s, sizeof (pid_s), \"%d\", pid);\n    char stat_filepath[30] = \"/proc/\";\n    strncat(stat_filepath, pid_s, sizeof (stat_filepath) - strlen(stat_filepath) - 1);\n    strncat(stat_filepath, \"/stat\", sizeof (stat_filepath) - strlen(stat_filepath) - 1);\n    FILE *fpstat = fopen(stat_filepath, \"r\");\n    if (fpstat == ((void *)0)) {\n        perror(\"FOPEN ERROR \");\n        return -1;\n    }\n    FILE *fstat = fopen(\"/proc/stat\", \"r\");\n    if (fstat == ((void *)0)) {\n        perror(\"FOPEN ERROR \");\n        fclose(fstat);\n        return -1;\n    }\n    memset(result, 0, sizeof(struct pstat));\n    long rss;\n    if (fscanf(fpstat, \"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %lu%lu %ld %ld %*d %*d %*d %*d %*u %lu %ld\", &result->utime_ticks, &result->stime_ticks, &result->cutime_ticks, &result->cstime_ticks, &result->vsize, &rss) == (-1)) {\n        fclose(fpstat);\n        return -1;\n    }\n    fclose(fpstat);\n    result->rss = rss * sysconf(_SC_PAGESIZE);\n    unsigned long cpu_time[10];\n    memset(cpu_time, 0, sizeof (cpu_time));\n    if (fscanf(fstat, \"%*s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\", &cpu_time[0], &cpu_time[1], &cpu_time[2], &cpu_time[3], &cpu_time[4], &cpu_time[5], &cpu_time[6], &cpu_time[7], &cpu_time[8], &cpu_time[9]) == (-1)) {\n        fclose(fstat);\n        return -1;\n    }\n    fclose(fstat);\n    for (int i = 0; i < 10; i++)\n        result->cpu_total_time += cpu_time[i];\n    return 0;\n}\n","function_prediction":"int get_usage_name_conflict(int pid, struct proc_stat *ps) {\n  char path[20];\n  snprintf(path, sizeof(path), \"%d\", pid);\n  char proc_path[20] = \"/proc/\";\n  strncat(proc_path, path, sizeof(proc_path) - strlen(proc_path) - 1);\n  strncat(proc_path, \"/stat\", sizeof(proc_path) - strlen(proc_path) - 1);\n  FILE *fp = fopen(proc_path, \"r\");\n  if (fp == NULL) {\n    perror(\"FOPEN ERROR \");\n    return -1;\n  }\n\n  FILE *fp_stat = fopen(\"/proc/stat\", \"r\");\n  if (fp_stat == NULL) {\n    perror(\"FOPEN ERROR \");\n    fclose(fp);\n    return -1;\n  }\n\n  ps->utime = 0;\n  ps->stime = 0;\n  ps->cutime = 0;\n  ps->cstime = 0;\n  ps->starttime = 0;\n  ps->vsize = 0;\n  if (__isoc99_fscanf(fp,\n                      \"%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u \"\n                      \"%lu%lu %ld %ld %*d %*d %*d %*d %*u %lu %ld\",\n                      &ps->utime, &ps->stime, &ps->cutime, &ps->cstime,\n                      &ps->starttime, &ps->vsize) == -1) {\n    fclose(fp);\n    return -1;\n  }\n  fclose(fp);\n\n  long page_size = sysconf(_SC_PAGE_SIZE);\n  ps->vsize = ps->vsize * page_size;\n\n  unsigned long long utime_ticks[2] = {0};\n  unsigned long long stime_ticks[2] = {0};\n  unsigned long long cutime_","pass":0,"source_file":"C_COMPILE/danielsen_boxstats/src/process-cpu.c"}
{"compilable":0,"function":"pid_t launch(int argc, char **argv) {\n    int pid = fork();\n    if (pid != 0) {\n        if (pid < 0) {\n            die(\"fork\");\n        }\n        return pid;\n    }\n    sigset_t set;\n    sigfillset(&set);\n    sigprocmask(1, &set, 0);\n    setsid();\n    setpgid(0, 0);\n    char **argvn = __builtin_alloca(sizeof (argv[0]) * (argc + 1));\n    memcpy(argvn, argv, sizeof (argv[0]) * argc);\n    argvn[argc] = ((void *)0);\n    if (putenv(\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\")) {\n        die(\"putenv\");\n    }\n    execvpe(argvn[0], argvn, (char **)default_envp);\n    die2(\"execvpe\", argvn[0]);\n}\n","function_prediction":"void launch_name_conflict(int argc, char **argv) {\n  int pid;\n\n  pid = fork();\n  if (pid == 0) {\n\n    sigset_t sigset;\n    sigfillset(&sigset);\n    sigprocmask(1, &sigset, NULL);\n\n    setsid();\n    setpgid(0, 0);\n\n    char *new_argv[argc + 1];\n    memcpy(new_argv, argv, sizeof(char *) * argc);\n    new_argv[argc] = NULL;\n\n    if (putenv(\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\"))\n      die(\"putenv\");\n\n    execvpe(new_argv[0], new_argv, default_envp);\n    die2(\"execvpe\", new_argv[0]);\n  } else if (pid < 0) {\n    die(\"fork\");\n  }\n}","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/init/init.c"}
{"compilable":1,"function":"int reap_until(pid_t until_pid) {\n    for (;;) {\n        int status;\n        pid_t pid = wait(&status);\n        if (pid < 0) {\n            die(\"wait\");\n        }\n        if (pid == until_pid) {\n            if ((((status) & 127) == 0)) {\n                if ((((status) & 65280) >> 8) != 0) {\n                    fputs(\"child exited with error\\n\", stderr);\n                }\n                return (((status) & 65280) >> 8);\n            }\n            fputs(\"child exited by signal\\n\", stderr);\n            return 128 + ((status) & 127);\n        }\n    }\n}\n","function_prediction":"int reap_until_name_conflict(pid_t pid) {\n  int status;\n  pid_t ret;\n\n  do {\n    ret = wait(&status);\n    if (ret < 0)\n      die(\"wait\");\n  } while (ret != pid);\n\n  if (status & 0x7f) {\n    fputs(\"child exited by signal\\n\", stderr);\n    return (status & 0x7f) + 128;\n  }\n\n  if (status >> 8) {\n    fputs(\"child exited with error\\n\", stderr);\n    return status >> 8;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/init/init.c"}
{"compilable":0,"function":"static int openvsock(unsigned int cid, unsigned int port) {\n    int s = socket(40, SOCK_STREAM, 0);\n    if (s < 0) {\n        perror(\"socket: AF_VSOCK\");\n        return -1;\n    }\n    struct sockaddr_vm addr = {0};\n    addr.svm_family = 40;\n    addr.svm_port = port;\n    addr.svm_cid = cid;\n    if (connect(s, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        fprintf(stderr, \"connect: port %u: %s\", port, strerror((*__errno_location())));\n        return -1;\n    }\n    return s;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/vsockexec/vsockexec.c"}
{"compilable":0,"function":"static int opentcp(unsigned short port) {\n    int s = socket(2, SOCK_STREAM, 0);\n    if (s < 0) {\n        perror(\"socket: AF_INET\");\n        return -1;\n    }\n    struct sockaddr_in addr = {0};\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = htonl(((in_addr_t)2130706433));\n    if (connect(s, (struct sockaddr *)&addr, sizeof (addr)) < 0) {\n        fprintf(stderr, \"connect: port %u: %s\\n\", port, strerror((*__errno_location())));\n        return -1;\n    }\n    return s;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/kojiromike_docker/vendor/github.com/Microsoft/opengcs/vsockexec/vsockexec.c"}
{"compilable":1,"function":"int fib_rec(int n) {\n    int result;\n    if (n == 0 || n == 1) {\n        result = 1;\n    } else {\n        result = fib_rec(n - 1) + fib_rec(n - 2);\n    }\n    return result;\n}\n","function_prediction":"int fib_rec_name_conflict(int n) {\n  if (n < 2)\n    return 1;\n  else\n    return fib_rec_name_conflict(n - 1) + fib_rec_name_conflict(n - 2);\n}","pass":1,"source_file":"C_COMPILE/jstolarek_sandbox/c/fibonacci.c"}
{"compilable":1,"function":"int fib_it(int n) {\n    int result;\n    if (n == 0 || n == 1) {\n        result = 1;\n    } else {\n        int a = 1, b = 1, c = 1;\n        for (int i = 1; i < n; i++) {\n            a = b;\n            b = c;\n            c = a + b;\n        }\n        result = c;\n    }\n    return result;\n}\n","function_prediction":"int fib_it_name_conflict(int n) {\n  int i, a, b, c;\n  a = b = c = 1;\n  for (i = 2; i < n; i++) {\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return c;\n}","pass":0,"source_file":"C_COMPILE/jstolarek_sandbox/c/fibonacci.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len;\n  unsigned long hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = hash * 257 + word[i];\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 1 + (unsigned int)length;\n  for (hash = 0; length > 0; length--)\n    hash = hash * a + (unsigned int)word[length - 1];\n  hash = hash % 500000000;\n  a = vocab_hash[hash];\n  while (a != -1) {\n    if (!strcmp(word, vocab[a].word))\n      return a;\n    else\n      hash = (hash + 1) % 500000000;\n    a = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  long long len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 500000000;\n  while (vocab_hash[hash] != -1) {\n    hash = (hash + 1) % 500000000;\n  }\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len, hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = (hash << 8) + word[i];\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 0;\n  hash = 0;\n  for (int i = 0; i < length; i++) {\n    hash = hash * 257 + word[i];\n    a = a * 257 + word[i];\n  }\n  hash = hash % 30000000;\n  a = a % 30000000;\n  int hentry = vocab_hash[hash];\n  while (hentry != -1) {\n    if (!strcmp(word, vocab[hentry].word)) {\n      return hentry;\n    }\n    hash = (hash + 1) % 30000000;\n    a = (a + 1) % 30000000;\n    hentry = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  int length = strlen(word) + 1;\n  if (length > 100)\n    length = 100;\n  vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 30000000;\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 30000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/inmanhust_word2vec/word2vec.c"}
{"compilable":0,"function":"static char *xstrdup(const char *s) {\n    char *p = xmalloc(strlen(s) + 1);\n    strcpy(p, s);\n    return p;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static int writen(int fd, const char *buffer, size_t length) {\n    while (length)\n        {\n            int nwritten = write(fd, buffer, length);\n            if (nwritten < 0) {\n                if ((*__errno_location()) == 4)\n                    continue;\n                return -1;\n            }\n            length -= nwritten;\n            buffer += nwritten;\n        }\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static char *read_assuan(int fd) {\n    static char pending[2048];\n    static size_t pending_len;\n    size_t nleft = sizeof recv_line;\n    char *buf = recv_line;\n    char *p;\n    while (nleft > 0)\n        {\n            int n;\n            if (pending_len) {\n                if (pending_len >= nleft)\n                    (die)(\"%s: received line too large\", __func__);\n                memcpy(buf, pending, pending_len);\n                n = pending_len;\n                pending_len = 0;\n            } else {\n                do {\n                    n = read(fd, buf, nleft);\n                } while (n < 0 && (*__errno_location()) == 4);\n            }\n            if (opt_verbose && n >= 0) {\n                int i;\n                printf(\"%s: read \\\"\", __func__);\n                for (i = 0; i < n; i++)\n                    putc(buf[i], stdout);\n                printf(\"\\\"\\n\");\n            }\n            if (n < 0)\n                (die)(\"%s: reading fd %d failed: %s\", __func__, (fd), (strerror((*__errno_location()))));\n            else if (!n)\n                (die)(\"%s: received incomplete line on fd %d\", __func__, (fd));\n            p = buf;\n            nleft -= n;\n            buf += n;\n            for (; n && *p != '\\n'; n-- , p++)\n                ;\n            if (n) {\n                if (n > 1) {\n                    n--;\n                    memcpy(pending, p + 1, n);\n                    pending_len = n;\n                }\n                *p = '\\x00';\n                break;\n            }\n        }\n    if (!nleft)\n        (die)(\"%s: received line too large\", __func__);\n    p = recv_line;\n    if (p[0] == 'O' && p[1] == 'K' && (p[2] == ' ' || !p[2])) {\n        recv_type = LINE_OK;\n        p += 3;\n    } else if (p[0] == 'E' && p[1] == 'R' && p[2] == 'R' && (p[3] == ' ' || !p[3])) {\n        recv_type = LINE_ERR;\n        p += 4;\n    } else if (p[0] == 'S' && (p[1] == ' ' || !p[1])) {\n        recv_type = LINE_STAT;\n        p += 2;\n    } else if (p[0] == 'D' && p[1] == ' ') {\n        recv_type = LINE_DATA;\n        p += 2;\n    } else if (p[0] == 'E' && p[1] == 'N' && p[2] == 'D' && !p[3]) {\n        recv_type = LINE_END;\n        p += 3;\n    } else\n        (die)(\"%s: invalid line type (%.5s)\", __func__, (p));\n    return p;\n}\n","function_prediction":"char *read_assuan_name_conflict(int fd) {\n  char *p;\n  int len;\n  size_t max_len = 2048;\n\n  do {\n    if (pending_len) {\n      if (pending_len > max_len)\n        break;\n      len = pending_len;\n      memcpy(recv_line, pending, pending_len);\n      pending_len = 0;\n    } else {\n      len = read(fd, recv_line, max_len);\n      if (len < 0) {\n        if (errno != 4)\n          die(\"%s: reading fd %d failed: %s\", \"read_assuan_name_conflict\", fd,\n              strerror(errno));\n      }\n    }\n    if (opt_verbose) {\n      printf(\"%s: read \\\"\", \"read_assuan_name_conflict\");\n      for (p = recv_line; len; len--, p++)\n        putc(*p, stdout);\n      puts(\"\\\"\");\n    }\n    max_len -= len;\n    while (len && recv_line[0] != '\\n') {\n      len--;\n      p = recv_line;\n      recv_line++;\n    }\n    if (len) {\n      if (len > 1)\n        memcpy(pending, recv_line + 1, len - 1);\n      pending_len = len - 1;\n      recv_line[0] = '\\0';\n    }\n  } while (len && max_len);\n\n  if (len == 0)\n    die(\"%s: received line too large\", \"read_assuan_name_conflict\");\n\n  if (recv_line[0] == 'O') {\n    if (recv_line[1] == 'K' && recv_line[2] == '\\0') {\n      recv_type = 0;\n      return \"\";\n    }\n  }\n  if (recv_line[0] == 'E') {\n      if (recv_line[1] == 'R' && recv_line","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static const char *get_var(const char *name) {\n    VARIABLE var;\n    for (var = variable_list; var && strcmp(var->name, name); var = var->next)\n        ;\n    if (!var)\n        return ((void *)0);\n    if (var->type == VARTYPE_COUNTER && var->value) {\n        char *p = var->value + strlen(var->value) + 1;\n        sprintf(p, \"%u\", var->count);\n        return p;\n    } else\n        return var->value;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static char *expand_line(char *buffer) {\n    char *line = buffer;\n    char *p, *pend;\n    const char *value;\n    size_t valuelen, n;\n    char *result = ((void *)0);\n    while (*line)\n        {\n            p = strchr(line, '$');\n            if (!p)\n                return result;\n            if (p[1] == '$') {\n                memmove(p, p + 1, strlen(p + 1) + 1);\n                line = p + 1;\n                continue;\n            }\n            for (pend = p + 1; *pend && !(*(pend) == ' ' || *(pend) == '\\t') && *pend != '$' && *pend != '/'; pend++)\n                ;\n            if (*pend) {\n                int save = *pend;\n                *pend = 0;\n                value = get_var(p + 1);\n                *pend = save;\n            } else\n                value = get_var(p + 1);\n            if (!value)\n                value = \"\";\n            valuelen = strlen(value);\n            if (valuelen <= pend - p) {\n                memcpy(p, value, valuelen);\n                p += valuelen;\n                n = pend - p;\n                if (n)\n                    memmove(p, p + n, strlen(p + n) + 1);\n                line = p;\n            } else {\n                char *src = result ? result : buffer;\n                char *dst;\n                dst = xmalloc(strlen(src) + valuelen + 1);\n                n = p - src;\n                memcpy(dst, src, n);\n                memcpy(dst + n, value, valuelen);\n                n += valuelen;\n                strcpy(dst + n, pend);\n                line = dst + n;\n                free(result);\n                result = dst;\n            }\n        }\n    return result;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static int eval_boolean(const char *cond) {\n    int true = 1;\n    for (; *cond == '!'; cond++)\n        true = !true;\n    if (!*cond || (*cond == '0' && !cond[1]))\n        return !true;\n    return true;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static int interpreter(char *line) {\n    static struct {\n        const char *name;\n        void (*fnc)(const char *, char *);\n    } cmdtbl[] = {{\"let\", cmd_let}, {\"echo\", cmd_echo}, {\"send\", cmd_send}, {\"expect-ok\", cmd_expect_ok}, {\"expect-err\", cmd_expect_err}, {\"count-status\", cmd_count_status}, {\"openfile\", cmd_openfile}, {\"createfile\", cmd_createfile}, {\"pipeserver\", cmd_pipeserver}, {\"quit\", ((void *)0)}, {\"quit-if\", cmd_quit_if}, {\"fail-if\", cmd_fail_if}, {\"cmpfiles\", cmd_cmpfiles}, {\"getenv\", cmd_getenv}, {((void *)0)}};\n    char *p, *save_p;\n    int i, save_c;\n    char *stmt = ((void *)0);\n    char *assign_to = ((void *)0);\n    char *must_free = ((void *)0);\n    for (; (*(line) == ' ' || *(line) == '\\t'); line++)\n        ;\n    if (!*line || *line == '#')\n        return 0;\n    p = expand_line(line);\n    if (p) {\n        must_free = p;\n        line = p;\n        for (; (*(line) == ' ' || *(line) == '\\t'); line++)\n            ;\n        if (!*line || *line == '#') {\n            free(must_free);\n            return 0;\n        }\n    }\n    for (p = line; *p && !(*(p) == ' ' || *(p) == '\\t') && *p != '='; p++)\n        ;\n    if (*p == '=') {\n        *p = 0;\n        assign_to = line;\n    } else if (*p) {\n        for (*p++ = 0; (*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (*p == '=')\n            assign_to = line;\n    }\n    if (!*line)\n        (die)(\"%s: syntax error\", __func__);\n    stmt = line;\n    save_c = 0;\n    save_p = ((void *)0);\n    if (assign_to) {\n        for (p++; (*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (!*p) {\n            unset_var(assign_to);\n            free(must_free);\n            return 0;\n        }\n        stmt = p;\n        for (; *p && !(*(p) == ' ' || *(p) == '\\t'); p++)\n            ;\n        if (*p) {\n            save_p = p;\n            save_c = *p;\n            for (*p++ = 0; (*(p) == ' ' || *(p) == '\\t'); p++)\n                ;\n        }\n    }\n    for (i = 0; cmdtbl[i].name && strcmp(stmt, cmdtbl[i].name); i++)\n        ;\n    if (!cmdtbl[i].name) {\n        if (!assign_to)\n            (die)(\"%s: invalid statement '%s'\\n\", __func__, (stmt));\n        if (save_p)\n            *save_p = save_c;\n        set_var(assign_to, stmt);\n        free(must_free);\n        return 0;\n    }\n    if (cmdtbl[i].fnc)\n        cmdtbl[i].fnc(assign_to, p);\n    free(must_free);\n    return cmdtbl[i].fnc ? 0 : 1;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tests/asschk.c"}
{"compilable":0,"function":"static char *xstrdup(const char *string) {\n    void *p = malloc(strlen(string) + 1);\n    if (!p)\n        die(\"out of core: %s\", strerror((*__errno_location())));\n    strcpy(p, string);\n    return p;\n}\n","function_prediction":"void xstrdup_part_0(void) {\n  die(\"out of core: %s\", strerror(*__errno_location()));\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"static char *ascii_strupr(char *string) {\n    char *p;\n    for (p = string; *p; p++)\n        if (!(*p & 128))\n            *p = toupper(*p);\n    return string;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"const char *isodatestring(void) {\n    static char buffer[16];\n    struct tm *tp;\n    time_t atime = time(((void *)0));\n    if (atime < 0)\n        strcpy(buffer, \"????-??-??\");\n    else {\n        tp = gmtime(&atime);\n        sprintf(buffer, \"%04d-%02d-%02d\", 1900 + tp->tm_year, tp->tm_mon + 1, tp->tm_mday);\n    }\n    return buffer;\n}\n","function_prediction":"char *isodatestring_name_conflict() {\n  time_t t = time(NULL);\n  if (t < 0) {\n    sprintf(buffer, \"????-??-??\");\n    return buffer;\n  }\n  struct tm *tm = gmtime(&t);\n  sprintf(buffer, \"%04d-%02d-%02d\", tm->tm_year + 1900, tm->tm_mon + 1,\n          tm->tm_mday);\n  return buffer;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"static int is_standard_section(const char *name) {\n    int i;\n    const char *s;\n    for (i = 0; (s = standard_sections[i]); i++)\n        if (!strcmp(s, name))\n            return 1;\n    return 0;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/doc/yat2m.c"}
{"compilable":0,"function":"static const char *pcsc_error_string(long err) {\n    const char *s;\n    if (!err)\n        return \"okay\";\n    if ((err & 2148532224U) != 2148532224U)\n        return \"invalid PC/SC error code\";\n    err &= 65535;\n    switch (err) {\n      case 2:\n        s = \"cancelled\";\n        break;\n      case 14:\n        s = \"can't dispose\";\n        break;\n      case 8:\n        s = \"insufficient buffer\";\n        break;\n      case 21:\n        s = \"invalid ATR\";\n        break;\n      case 3:\n        s = \"invalid handle\";\n        break;\n      case 4:\n        s = \"invalid parameter\";\n        break;\n      case 5:\n        s = \"invalid target\";\n        break;\n      case 17:\n        s = \"invalid value\";\n        break;\n      case 6:\n        s = \"no memory\";\n        break;\n      case 19:\n        s = \"comm error\";\n        break;\n      case 1:\n        s = \"internal error\";\n        break;\n      case 20:\n        s = \"unknown error\";\n        break;\n      case 7:\n        s = \"waited too long\";\n        break;\n      case 9:\n        s = \"unknown reader\";\n        break;\n      case 10:\n        s = \"timeout\";\n        break;\n      case 11:\n        s = \"sharing violation\";\n        break;\n      case 12:\n        s = \"no smartcard\";\n        break;\n      case 13:\n        s = \"unknown card\";\n        break;\n      case 15:\n        s = \"proto mismatch\";\n        break;\n      case 16:\n        s = \"not ready\";\n        break;\n      case 18:\n        s = \"system cancelled\";\n        break;\n      case 22:\n        s = \"not transacted\";\n        break;\n      case 23:\n        s = \"reader unavailable\";\n        break;\n      case 101:\n        s = \"unsupported card\";\n        break;\n      case 102:\n        s = \"unresponsive card\";\n        break;\n      case 103:\n        s = \"unpowered card\";\n        break;\n      case 104:\n        s = \"reset card\";\n        break;\n      case 105:\n        s = \"removed card\";\n        break;\n      case 106:\n        s = \"inserted card\";\n        break;\n      case 31:\n        s = \"unsupported feature\";\n        break;\n      case 25:\n        s = \"PCI too small\";\n        break;\n      case 26:\n        s = \"reader unsupported\";\n        break;\n      case 27:\n        s = \"duplicate reader\";\n        break;\n      case 28:\n        s = \"card unsupported\";\n        break;\n      case 29:\n        s = \"no service\";\n        break;\n      case 30:\n        s = \"service stopped\";\n        break;\n      default:\n        s = \"unknown PC/SC error code\";\n        break;\n    }\n    return s;\n}\n","function_prediction":"const char *pcsc_error_string_part_0(unsigned short error) {\n  switch (error) {\n  case SCARD_S_SUCCESS:\n    return \"no error\";\n  case SCARD_E_CANCELLED:\n    return \"cancelled\";\n  case SCARD_E_INVALID_HANDLE:\n    return \"invalid handle\";\n  case SCARD_E_INVALID_PARAMETER:\n    return \"invalid parameter\";\n  case SCARD_E_INVALID_TARGET:\n    return \"invalid target\";\n  case SCARD_E_NO_MEMORY:\n    return \"no memory\";\n  case SCARD_F_COMM_ERROR:\n    return \"comm error\";\n  case SCARD_F_CONNECT_TO_TERMINAL:\n    return \"connect to terminal\";\n  case SCARD_F_UNKNOWN_ERROR:\n    return \"unknown error\";\n  case SCARD_F_UNKNOWN_ACTION:\n    return \"unknown action\";\n  case SCARD_E_INVALID_VALUE:\n    return \"invalid value\";\n  case SCARD_F_WARN_UNRESPONSIVE_CARD:\n    return \"unresponsive card\";\n  case SCARD_F_WARN_UNPOWERED_CARD:\n    return \"unpowered card\";\n  case SCARD_F_WARN_EJECT_CARD:\n    return \"eject card\";\n  case SCARD_F_WARN_RESET_CARD:\n    return \"reset card\";\n  case SCARD_F_WARN_RETRY_EXPULSE:\n    return \"retry expulse\";\n  case SCARD_E_NOT_TRANSACTED:\n    return \"not transacted\";\n  case SCARD_E_READER_UNAVAILABLE:\n    return \"reader unavailable\";\n  case SCARD_P_SHUTDOWN:\n    return \"shutdown\";\n  case SCARD_E_PCI_TOO_SMALL:\n    return \"PCI too small\";\n  case SCARD_E_READER_UNSUPPORTED:\n    return \"reader unsupported\";\n  case SCARD_E_DUPLICATE_READER:\n","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/scd/pcsc-wrapper.c"}
{"compilable":0,"function":"static unsigned int convert_le_u32(const unsigned char *buf) {\n    return buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tools/ccidmon.c"}
{"compilable":0,"function":"static unsigned int convert_le_u16(const unsigned char *buf) {\n    return buf[0] | (buf[1] << 8);\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/jerkey_gnupg/tools/ccidmon.c"}
{"compilable":0,"function":"unsigned int libplayer_version(void) {\n    return (2 << 16 | 0 << 8 | 2);\n}\n","function_prediction":"int libplayer_version_name_conflict(void) { return 0x020002; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_enabled(player_type_t type) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int libplayer_wrapper_enabled_name_conflict(int wrapper) { return wrapper == 4; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_supported_res(player_type_t type, mrl_resource_t res) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return pl_supported_resources_dummy(res);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int libplayer_wrapper_supported_res_name_conflict(int type, int res) {\n  switch (type) {\n  case 4:\n    return pl_supported_resources_dummy(res);\n  default:\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int pl_supported_resources_dummy(__attribute__((unused)) mrl_resource_t mrl) {\n    return 1;\n}\n","function_prediction":"int pl_supported_resources_dummy_name_conflict(void) { return 1; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/wrapper_dummy.c"}
{"compilable":0,"function":"mrl_metadata_dvd_title_t *mrl_metadata_dvd_title_new(void) {\n    mrl_metadata_dvd_title_t *title;\n    title = calloc(1, sizeof(mrl_metadata_dvd_title_t));\n    return title;\n}\n","function_prediction":"MRLMetadataDVDTitle *mrl_metadata_dvd_title_new_name_conflict(void) {\n  return calloc(1, sizeof(MRLMetadataDVDTitle));\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/mrl_internal.c"}
{"compilable":0,"function":"static uint32_t getch(void) {\n    struct termios oldt, newt;\n    uint32_t ch = 0;\n    uint32_t val = 0;\n    int n;\n    tcgetattr(0, &oldt);\n    newt = oldt;\n    newt.c_lflag &= ~(2 | 8);\n    tcsetattr(0, 0, &newt);\n    n = read(0, &ch, sizeof (ch));\n    if (!n)\n        return 0;\n    putchar('\\n');\n    while (ch)\n        {\n            val <<= 8;\n            val += ch & 255;\n            ch >>= 8;\n        }\n    tcsetattr(0, 0, &oldt);\n    return val;\n}\n","function_prediction":"int getch_name_conflict() {\n  int c = 0;\n  int ret = 0;\n  struct termios oldt, newt;\n\n  tcgetattr(0, &oldt);\n  newt = oldt;\n  newt.c_lflag &= ~(ICANON | ECHO);\n  tcsetattr(0, 0, &newt);\n\n  if (read(0, &c, sizeof(c)) == 0)\n    return 0;\n\n  putc('\\n', stdout);\n\n  while (c) {\n    ret = (ret << 8) + (c & 0xFF);\n    c >>= 8;\n  }\n\n  tcsetattr(0, 0, &oldt);\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/libplayer-test.c"}
{"compilable":0,"function":"unsigned int libplayer_version(void) {\n    return (2 << 16 | 0 << 8 | 2);\n}\n","function_prediction":"int libplayer_version_name_conflict(void) { return 0x020002; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_enabled(player_type_t type) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return 1;\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int libplayer_wrapper_enabled_name_conflict(int wrapper) { return wrapper == 4; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int libplayer_wrapper_supported_res(player_type_t type, mrl_resource_t res) {\n    switch (type) {\n      case PLAYER_TYPE_DUMMY:\n        return pl_supported_resources_dummy(res);\n      default:\n        return 0;\n    }\n}\n","function_prediction":"int libplayer_wrapper_supported_res_name_conflict(int type, int res) {\n  switch (type) {\n  case 4:\n    return pl_supported_resources_dummy(res);\n  default:\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/player.c"}
{"compilable":0,"function":"int pl_supported_resources_dummy(__attribute__((unused)) mrl_resource_t mrl) {\n    return 1;\n}\n","function_prediction":"int pl_supported_resources_dummy_name_conflict(void) { return 1; }","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/wrapper_dummy.c"}
{"compilable":0,"function":"mrl_metadata_dvd_title_t *mrl_metadata_dvd_title_new(void) {\n    mrl_metadata_dvd_title_t *title;\n    title = calloc(1, sizeof(mrl_metadata_dvd_title_t));\n    return title;\n}\n","function_prediction":"MRLMetadataDVDTitle *mrl_metadata_dvd_title_new_name_conflict(void) {\n  return calloc(1, sizeof(MRLMetadataDVDTitle));\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/src/mrl_internal.c"}
{"compilable":0,"function":"static uint32_t getch(void) {\n    struct termios oldt, newt;\n    uint32_t ch = 0;\n    uint32_t val = 0;\n    int n;\n    tcgetattr(0, &oldt);\n    newt = oldt;\n    newt.c_lflag &= ~(2 | 8);\n    tcsetattr(0, 0, &newt);\n    n = read(0, &ch, sizeof (ch));\n    putchar('\\n');\n    while (ch)\n        {\n            val <<= 8;\n            val += ch & 255;\n            ch >>= 8;\n        }\n    tcsetattr(0, 0, &oldt);\n    return val;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/GeeXboX_libplayer/libplayer-testvdr.c"}
{"compilable":0,"function":"int f(int u, int v) {\n    if (v > 0)\n        return 5 * u + 3 * v;\n    return u;\n}\n","function_prediction":"int f_name_conflict(int a, int b) {\n  register_tm_clones();\n  if_name_conflict (b > 0)\n    return a * 5 + b * 3;\n  return a;\n}","pass":0,"source_file":"C_COMPILE/andrewburger_c-and-c-plus-plus/hw9f02.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 1;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len;\n  unsigned long hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = hash * 257 + word[i];\n  return hash % 500000000;\n}","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 1 + (unsigned int)length;\n  for (hash = 0; length > 0; length--)\n    hash = hash * a + (unsigned int)word[length - 1];\n  hash = hash % 500000000;\n  a = vocab_hash[hash];\n  while (a != -1) {\n    if (!strcmp(word, vocab[a].word))\n      return a;\n    else\n      hash = (hash + 1) % 500000000;\n    a = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 60)\n        length = 60;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 10000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  long long len = strlen(word) + 1;\n  if (len > 60)\n    len = 60;\n  vocab[vocab_size].word = (char *)calloc(len, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 10000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 500000000;\n  while (vocab_hash[hash] != -1) {\n    hash = (hash + 1) % 500000000;\n  }\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2phrase.c"}
{"compilable":1,"function":"int GetWordHash(char *word) {\n    unsigned long long a, hash = 0;\n    for (a = 0; a < strlen(word); a++)\n        hash = hash * 257 + word[a];\n    hash = hash % vocab_hash_size;\n    return hash;\n}\n","function_prediction":"int GetWordHash_name_conflict(char *word) {\n  int i, len, hash;\n\n  len = strlen(word);\n  hash = 0;\n  for (i = 0; i < len; i++)\n    hash = (hash << 8) + word[i];\n  return hash % 30000000;\n}","pass":0,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":1,"function":"int SearchVocab(char *word) {\n    unsigned int hash = GetWordHash(word);\n    while (1)\n        {\n            if (vocab_hash[hash] == -1)\n                return -1;\n            if (!strcmp(word, vocab[vocab_hash[hash]].word))\n                return vocab_hash[hash];\n            hash = (hash + 1) % vocab_hash_size;\n        }\n    return -1;\n}\n","function_prediction":"int SearchVocab_name_conflict(char *word) {\n  unsigned long long a, hash;\n  unsigned int length = strlen(word);\n  a = 0;\n  hash = 0;\n  for (int i = 0; i < length; i++) {\n    hash = hash * 257 + word[i];\n    a = a * 257 + word[i];\n  }\n  hash = hash % 30000000;\n  a = a % 30000000;\n  int hentry = vocab_hash[hash];\n  while (hentry != -1) {\n    if (!strcmp(word, vocab[hentry].word)) {\n      return hentry;\n    }\n    hash = (hash + 1) % 30000000;\n    a = (a + 1) % 30000000;\n    hentry = vocab_hash[hash];\n  }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":1,"function":"int AddWordToVocab(char *word) {\n    unsigned int hash, length = strlen(word) + 1;\n    if (length > 100)\n        length = 100;\n    vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n    strcpy(vocab[vocab_size].word, word);\n    vocab[vocab_size].cn = 0;\n    vocab_size++;\n    if (vocab_size + 2 >= vocab_max_size) {\n        vocab_max_size += 1000;\n        vocab = (struct vocab_word *)realloc(vocab, vocab_max_size * sizeof(struct vocab_word));\n    }\n    hash = GetWordHash(word);\n    while (vocab_hash[hash] != -1)\n        hash = (hash + 1) % vocab_hash_size;\n    vocab_hash[hash] = vocab_size - 1;\n    return vocab_size - 1;\n}\n","function_prediction":"int AddWordToVocab_name_conflict(char *word) {\n  long long a, hash = 0;\n  int length = strlen(word) + 1;\n  if (length > 100)\n    length = 100;\n  vocab[vocab_size].word = (char *)calloc(length, sizeof(char));\n  strcpy(vocab[vocab_size].word, word);\n  vocab[vocab_size].cn = 0;\n  vocab_size++;\n  if (vocab_size + 2 >= vocab_max_size) {\n    vocab_max_size += 1000;\n    vocab = (struct vocab_word *)realloc(vocab, vocab_max_size *\n                                                    sizeof(struct vocab_word));\n  }\n  for (a = 0; a < strlen(word); a++)\n    hash = hash * 257 + word[a];\n  hash = hash % 30000000;\n  while (vocab_hash[hash] != -1)\n    hash = (hash + 1) % 30000000;\n  vocab_hash[hash] = vocab_size - 1;\n  return vocab_size - 1;\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":1,"function":"int ArgPos(char *str, int argc, char **argv) {\n    int a;\n    for (a = 1; a < argc; a++)\n        if (!strcmp(str, argv[a])) {\n            if (a == argc - 1) {\n                printf(\"Argument missing for %s\\n\", str);\n                exit(1);\n            }\n            return a;\n        }\n    return -1;\n}\n","function_prediction":"int ArgPos_name_conflict(char *str, int argc, char **argv) {\n  int a;\n  for (a = 1; a < argc; a++)\n    if (!strcmp(str, argv[a])) {\n      if (a == argc - 1) {\n        printf(\"Argument missing for %s\\n\", str);\n        exit(1);\n      }\n      return a;\n    }\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/JayLei-999_word2vec/word2vec.c"}
{"compilable":0,"function":"WinMsgTokState *wmtok_init(WinMsgTokState *st) {\n    if (st == ((void *)0)) {\n        st = malloc(sizeof(WinMsgTokState));\n        st->_dofree = 1;\n    }\n    return st;\n}\n","function_prediction":"wmtok_t *wmtok_init_name_conflict(wmtok_t *tok) {\n  if (tok == NULL) {\n    tok = malloc(sizeof(wmtok_t) + 1);\n    tok->buf[0] = 1;\n  }\n  return tok;\n}","pass":0,"source_file":"C_COMPILE/swegener_screen/src/winmsgtok.c"}
{"compilable":1,"function":"int parsemac(char *str, unsigned char *mac) {\n    char *s;\n    while ((s = strsep(&str, \":\")) != ((void *)0))\n        {\n            unsigned int byte;\n            if (sscanf(s, \"%x\", &byte) != 1 || byte > 255)\n                return -1;\n            *mac++ = byte;\n        }\n    return 0;\n}\n","function_prediction":"int parsemac_name_conflict(char *mac, unsigned char *macbuf) {\n  char *p;\n  int i;\n  unsigned int val[3];\n\n  while ((p = strsep(&mac, \":\")) != NULL) {\n    if (__isoc99_sscanf(p, \"%x\", val) != 1 || val[0] > 0xff)\n      return -1;\n    macbuf[i++] = val[0];\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":0,"function":"int setname(char *oldname, char *newname) {\n    struct ifreq ifr;\n    opensock();\n    memset(&ifr, 0, sizeof(struct ifreq));\n    strcpy(ifr.ifr_ifrn.ifrn_name, oldname);\n    strcpy(ifr.ifr_ifru.ifru_newname, newname);\n    return ioctl(ctl_sk, 35107, &ifr);\n}\n","function_prediction":"void setname_name_conflict(char *ifname, char *ifalias) {\n  struct ifaliasreq ifr;\n  int s;\n\n  if (ctl_sk < 0)\n    ctl_sk = socket(2, 2, 0);\n  s = ctl_sk;\n\n  ifr.ifr_name[0] = '\\0';\n  ifr.ifr_newname[0] = '\\0';\n  ifr.ifr_aliases = NULL;\n\n  strcpy(ifr.ifr_name, ifname);\n  strcpy(ifr.ifr_newname, ifalias);\n\n  ioctl(s, 0x8923, &ifr);\n}","pass":0,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":0,"function":"int getmac(char *name, unsigned char *mac) {\n    int r;\n    struct ifreq ifr;\n    opensock();\n    memset(&ifr, 0, sizeof(struct ifreq));\n    strcpy(ifr.ifr_ifrn.ifrn_name, name);\n    r = ioctl(ctl_sk, 35111, &ifr);\n    memcpy(mac, ifr.ifr_ifru.ifru_hwaddr.sa_data, 6);\n    return r;\n}\n","function_prediction":"void getmac_name_conflict(char *ifname, unsigned char *mac) {\n  struct ifreq ifr;\n  int sock;\n\n  if (ctl_sk < 0)\n    ctl_sk = socket(2, 2, 0);\n  sock = ctl_sk;\n\n  ifr.ifr_addr.sa_family = 0;\n  ifr.ifr_addr.sa_len = 0;\n  ifr.ifr_addr.sa_data[0] = 0;\n  ifr.ifr_addr.sa_data[1] = 0;\n  ifr.ifr_addr.sa_data[2] = 0;\n  ifr.ifr_addr.sa_data[3] = 0;\n  ifr.ifr_addr.sa_data[4] = 0;\n  ifr.ifr_addr.sa_data[5] = 0;\n  ifr.ifr_addr.sa_data[6] = 0;\n  ifr.ifr_addr.sa_data[7] = 0;\n  ifr.ifr_addr.sa_data[8] = 0;\n  ifr.ifr_addr.sa_data[9] = 0;\n  ifr.ifr_addr.sa_data[10] = 0;\n  ifr.ifr_addr.sa_data[11] = 0;\n  ifr.ifr_addr.sa_data[12] = 0;\n  ifr.ifr_addr.sa_data[13] = 0;\n  ifr.ifr_addr.sa_data[14] = 0;\n  ifr.ifr_addr.sa_data[15] = 0;\n  ifr.ifr_addr.sa_data[16] = 0;\n  ifr.ifr_addr.sa_data[17] = 0;\n  ifr.ifr_addr.sa_data[18] = 0;\n  ifr.ifr_addr.sa_data[19] = 0;\n  ifr.ifr_addr.sa_data[20] = 0;\n","pass":0,"source_file":"C_COMPILE/Mayalinux_net-tools/nameif.c"}
{"compilable":0,"function":"char *MakeCRC(char *BitString) {\n    static char Res[6];\n    char CRC[5];\n    int i;\n    char DoInvert;\n    for (i = 0; i < 5; ++i)\n        CRC[i] = 0;\n    for (i = 0; i < strlen(BitString); ++i) {\n        DoInvert = ('1' == BitString[i]) ^ CRC[4];\n        printf(\"%i %i %i\\t\", i, ('1' == BitString[i]), DoInvert);\n        CRC[4] = CRC[3];\n        CRC[3] = CRC[2];\n        CRC[2] = CRC[1] ^ DoInvert;\n        CRC[1] = CRC[0];\n        CRC[0] = DoInvert;\n        printf(\"%i %i %i %i %i\\n\", CRC[0], CRC[1], CRC[2], CRC[3], CRC[4]);\n    }\n    for (i = 0; i < 5; ++i)\n        Res[4 - i] = CRC[i] ? '1' : '0';\n    Res[5] = 0;\n    return (Res);\n}\n","function_prediction":"CRC_t MakeCRC_name_conflict(char *str) {\n  int i;\n  CRC_t Res;\n  char CRC_bit = 0;\n  char CRC_bit_prev = 0;\n\n  for (i = 0; i < strlen(str); i++) {\n    CRC_bit = CRC_bit_prev ^ (str[i] == '1');\n    printf(\"%i %i %i\\t\", i, str[i] == '1', CRC_bit);\n    Res.bit0 = Res.bit0 ^ CRC_bit;\n    Res.bit1 = Res.bit1 ^ CRC_bit;\n    Res.bit2 = Res.bit2 ^ CRC_bit;\n    Res.bit3 = Res.bit3 ^ CRC_bit;\n    Res.bit4 = Res.bit4 ^ CRC_bit;\n    CRC_bit_prev = CRC_bit;\n    printf(\"%i %i %i %i %i\\n\", CRC_bit, CRC_bit_prev, Res.bit0, Res.bit1,\n           Res.bit2);\n  }\n\n  Res.bit0 = '1' - Res.bit0;\n  Res.bit1 = '1' - Res.bit1;\n  Res.bit2 = '1' - Res.bit2;\n  Res.bit3 = '1' - Res.bit3;\n  Res.bit4 = '1' - Res.bit4;\n\n  return Res;\n}","pass":0,"source_file":"C_COMPILE/aeburriel_tetrapol-kit/misc/crc.c"}
{"compilable":1,"function":"uint8_t ReadUint8(void) {\n    uint8_t temp;\n    int data_read = read(0, &temp, 1);\n    if (data_read != 1) {\n        exit(-1);\n    }\n    return temp;\n}\n","function_prediction":"uint8_t ReadUint8_name_conflict() {\n  uint8_t value;\n  if (read(0, &value, 1) != 1)\n    exit(-1);\n  return value;\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":1,"function":"uint8_t IntToHexChar(uint8_t val) {\n    if (val < 10)\n        return '0' + val;\n    else\n        return 'a' + (val - 10);\n}\n","function_prediction":"char IntToHexChar_name_conflict(int i) {\n  if (i < 10)\n    return '0' + i;\n  else\n    return 'A' + i - 10;\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":0,"function":"char *ConvertDataBytes(char *pszData, uint8_t foodTotal, uint8_t maxConvert) {\n    uint32_t outIdx = 0;\n    uint32_t i;\n    int bTruncated = 0;\n    if (foodTotal > maxConvert) {\n        bTruncated = 1;\n        foodTotal = maxConvert;\n    }\n    for (i = 0; i < maxConvert; i++) {\n        g_displayFoodString[outIdx++] = IntToHexChar((pszData[i] >> 4) & 15);\n        g_displayFoodString[outIdx++] = IntToHexChar((pszData[i]) & 15);\n    }\n    g_displayFoodString[outIdx] = '\\x00';\n    if (bTruncated)\n        strcpy(g_displayFoodString + outIdx, \"...\");\n    return g_displayFoodString;\n}\n","function_prediction":"char *ConvertDataBytes(unsigned char *data, unsigned char length,\n                       unsigned char size) {\n  unsigned char i;\n\n  if (size == 0) {\n    g_displayFoodString[0] = '\\0';\n    if (length > 0) {\n      g_displayFoodString[0] = '.';\n      g_displayFoodString[1] = '.';\n      g_displayFoodString[2] = '.';\n    }\n    return g_displayFoodString;\n  }\n\n  for (i = 0; i < size; i++) {\n    g_displayFoodString[i * 2] = (data[i] >> 4) + '0';\n    if (g_displayFoodString[i * 2] > '9') {\n      g_displayFoodString[i * 2] += 7;\n    }\n    g_displayFoodString[i * 2 + 1] = (data[i] & 0x0F) + '0';\n    if (g_displayFoodString[i * 2 + 1] > '9') {\n      g_displayFoodString[i * 2 + 1] += 7;\n    }\n  }\n  g_displayFoodString[i * 2] = '\\0';\n\n  if (length > size) {\n    g_displayFoodString[i * 2] = '.';\n    g_displayFoodString[i * 2 + 1] = '.';\n    g_displayFoodString[i * 2 + 2] = '.';\n  }\n\n  return g_displayFoodString;\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":0,"function":"uint8_t GetFood(void) {\n    char szEchoData[32];\n    uint8_t foodTotal;\n    printf(\"FEED ME!\\n\");\n    foodTotal = ReadUint8();\n    ReadData(szEchoData, foodTotal);\n    printf(\"ATE %s\\n\", ConvertDataBytes(szEchoData, foodTotal, 16));\n    return foodTotal;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_feedme/files/main.c"}
{"compilable":1,"function":"uint64_t exp_l(uint64_t base, uint64_t power) {\n    int i = 0;\n    uint64_t j = base;\n    if (power == 0) {\n        return 1;\n    }\n    for (i = 0; i < power - 1; i++) {\n        j *= base;\n    }\n    return j;\n}\n","function_prediction":"long exp_l_name_conflict(long base, long exp) {\n  long result = 1;\n  int i;\n\n  for (i = 0; i < exp; i++)\n    result *= base;\n\n  return result;\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t xor(uint64_t a, uint64_t b) {\n    return a ^ b;\n}\n","function_prediction":"uint64_t xor_name_conflict (uint64_t a, uint64_t b) { return a ^ b; }","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t shla(uint64_t a, uint64_t dabits) {\n    uint64_t high = 0;\n    uint64_t low = 0;\n    dabits = dabits % 64;\n    if (dabits == 0) {\n        return a;\n    }\n    high = a << dabits;\n    low = a >> (64 - dabits);\n    return high | low;\n}\n","function_prediction":"uint64_t shla_name_conflict(uint64_t a, uint64_t b) { return (a << b) | (a >> (64 - b)); }","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t shra(uint64_t a, uint64_t dabits) {\n    uint64_t high = 0;\n    uint64_t low = 0;\n    dabits = dabits % 64;\n    if (dabits == 0) {\n        return a;\n    }\n    low = a >> dabits;\n    high = a << (64 - dabits);\n    return high | low;\n}\n","function_prediction":"uint64_t shra_name_conflict(uint64_t a, uint64_t b) { return (a >> b) | (a << (64 - b)); }","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t swap_bytes(uint64_t value) {\n    uint64_t final = 0;\n    final |= ((value & 255) << 24);\n    final |= ((value & 65280) << 24);\n    final |= ((value & 16711680) << 40);\n    final |= ((value & 4278190080U) << 16);\n    final |= ((value & 1095216660480L) >> 16);\n    final |= ((value & 280375465082880L) >> 40);\n    final |= ((value & 71776119061217280L) >> 40);\n    final |= ((value & 18374686479671623680UL) >> 8);\n    return final;\n}\n","function_prediction":"uint64_t swap_bytes_name_conflict(uint64_t x) {\n  return (((x) & 0x00000000000000FFULL) << 56) |\n         (((x) & 0x000000000000FF00ULL) << 40) |\n         (((x) & 0x0000000000FF0000ULL) << 24) |\n         (((x) & 0x00000000FF000000ULL) << 8) |\n         (((x) & 0x000000FF00000000ULL) >> 8) |\n         (((x) & 0x0000FF0000000000ULL) >> 24) |\n         (((x) & 0x00FF000000000000ULL) >> 40) |\n         (((x) & 0xFF00000000000000ULL) >> 56);\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t swap_two(uint64_t value, uint64_t one, uint64_t two) {\n    uint64_t t_one = 0;\n    uint64_t t_two = 0;\n    uint64_t mask_one = 255;\n    uint64_t mask_two = 255;\n    mask_one <<= one * 8;\n    mask_two <<= two * 8;\n    mask_one ^= 18446744073709551615UL;\n    mask_two ^= 18446744073709551615UL;\n    t_one = (value >> (one * 8)) & 255;\n    t_two = (value >> (two * 8)) & 255;\n    value &= (mask_one & mask_two);\n    value |= (t_two << (one * 8));\n    value |= (t_one << (two * 8));\n    return value;\n}\n","function_prediction":"uint64_t swap_two_name_conflict(uint64_t x, int i, int j) {\n  uint64_t a = (x >> (i * 8)) & 0xff;\n  uint64_t b = (x >> (j * 8)) & 0xff;\n  return (x & ~(0xffULL << (i * 8))) | (b << (i * 8)) |\n         (x & ~(0xffULL << (j * 8))) | (a << (j * 8));\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t xor_neighbor(uint64_t value) {\n    int i = 0;\n    uint64_t t = 0;\n    t |= ((value & 18374686479671623680UL) >> 8) ^ (value & 71776119061217280L);\n    t |= ((value & 71776119061217280L) >> 8) ^ (value & 280375465082880L);\n    t |= ((value & 280375465082880L) >> 8) ^ (value & 1095216660480L);\n    t |= ((value & 1095216660480L) >> 8) ^ (value & 4278190080U);\n    t |= ((value & 4278190080U) >> 8) ^ (value & 16711680);\n    t |= ((value & 16711680) >> 8) ^ (value & 65280);\n    t |= ((value & 65280) >> 8) ^ (value & 255);\n    t |= ((value & 255) << 56) ^ (value & 18374686479671623680UL);\n    return t;\n}\n","function_prediction":"uint64_t xor_neighbor_name_conflict(uint64_t x) {\n  return (x ^ (x << 32)) & 0x00000000FFFFFFFF00000000FFFFFFFFULL |\n         (x ^ (x >> 8)) & 0x00FF00FF00FF00FF00FF00FF00FF00FFULL;\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_one(uint64_t value) {\n    value = xor(value, 3861390726976975706L);\n    value = swap_two(value, 2, 0);\n    value = xor(value, 9943296405002333681UL);\n    value = xor(value, 16857834378267756394UL);\n    value = swap_two(value, 2, 3);\n    value = xor(value, 13674338511762446054UL);\n    value = shla(value, 16);\n    value = shla(value, 35);\n    value = shra(value, 19);\n    value = xor_neighbor(value);\n    value = shla(value, 36);\n    value = shra(value, 40);\n    value = swap_two(value, 1, 0);\n    value = xor(value, 6765015749217278743L);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = swap_two(value, 2, 1);\n    value = xor(value, 7686949068708848117L);\n    value = swap_two(value, 3, 0);\n    value = swap_bytes(value);\n    value = xor(value, 6401935715922169987L);\n    value = shra(value, 22);\n    value = xor_neighbor(value);\n    value = xor(value, 5166993816397978483L);\n    value = xor_neighbor(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 6, 5);\n    value = shla(value, 59);\n    value = swap_two(value, 5, 2);\n    value = swap_two(value, 2, 3);\n    value = shla(value, 12);\n    value = xor(value, 12476431667104729879UL);\n    value = xor(value, 5234710379464860866L);\n    value = shla(value, 6);\n    value = swap_two(value, 6, 5);\n    value = shra(value, 11);\n    value = swap_bytes(value);\n    value = xor(value, 9697206415216557238UL);\n    value = swap_bytes(value);\n    value = shra(value, 2);\n    value = xor(value, 4649309708712362587L);\n    value = shla(value, 35);\n    value = shla(value, 9);\n    value = xor_neighbor(value);\n    value = shla(value, 7);\n    value = shla(value, 38);\n    value = xor_neighbor(value);\n    value = xor(value, 16065139371609640475UL);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = swap_two(value, 2, 7);\n    value = shra(value, 51);\n    value = swap_bytes(value);\n    value = shra(value, 19);\n    value = xor(value, 10799149603522670113UL);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = shra(value, 16);\n    return value;\n}\n","function_prediction":"uint64_t munge_one_name_conflict(uint64_t x) {\n  x ^= 0x35966a685c73335a;\n  x = (((x) << 16) | ((x) >> 48)) ^ 0x600ea06ae391aa9b;\n  x = (((x) << 8) | ((x) >> 56)) ^ 0xbdc5026d3c0b56e6;\n  x = (((x) << 32) | ((x) >> 32)) ^ 0x5de229fb3804db17;\n  x = (((x) & 0xffff0000ffff0000) | ((x) & 0x0000ffff0000ffff) << 16) ^\n      0x6aad877366e921f5;\n  x = (((x) & 0xff00ff00ff00ff00) | ((x) >> 8 & 0x00ff00ff00ff00ff)) ^\n      0x58d83e9d5e6d5083;\n  x = (((x) << 22) | ((x) >> 40)) ^ 0x47b4d980070a9b73;\n  x = (((x) << 8) | ((x) >> 56)) ^ 0x47b4d980070a9b73;\n  x = (((x) << 37) | ((x) >> 37)) ^ 0x070a9b7347b4d980;\n  x = (((x) << 1) | ((x) >> 63)) ^ 0x85aa8c0693425b40;\n  x = (((x) << 28) | ((x) >> 36)) ^ 0x425b4085aa8c0693;\n    x = (((x) <<","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_two(uint64_t value) {\n    value = shla(value, 22);\n    value = swap_bytes(value);\n    value = swap_two(value, 4, 1);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shla(value, 35);\n    value = swap_two(value, 2, 6);\n    value = xor(value, 9271198935367831530UL);\n    value = shla(value, 3);\n    value = swap_two(value, 0, 1);\n    value = swap_two(value, 1, 2);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 5, 1);\n    value = shra(value, 24);\n    value = shla(value, 39);\n    value = swap_two(value, 2, 4);\n    value = xor(value, 7462025471038891063L);\n    value = swap_two(value, 4, 3);\n    value = swap_two(value, 0, 7);\n    value = shla(value, 62);\n    value = swap_bytes(value);\n    value = swap_two(value, 7, 6);\n    value = swap_two(value, 2, 6);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 5, 2);\n    value = xor_neighbor(value);\n    value = swap_two(value, 1, 7);\n    value = xor(value, 4749710960471120103L);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = swap_two(value, 1, 4);\n    value = shla(value, 10);\n    value = swap_bytes(value);\n    value = swap_bytes(value);\n    value = shra(value, 24);\n    value = swap_two(value, 0, 4);\n    value = shra(value, 61);\n    value = swap_two(value, 3, 4);\n    value = shra(value, 35);\n    value = shla(value, 55);\n    value = shla(value, 34);\n    value = xor_neighbor(value);\n    value = xor_neighbor(value);\n    value = shra(value, 23);\n    value = shla(value, 59);\n    value = shra(value, 20);\n    value = shla(value, 28);\n    value = xor(value, 14007489205149181901UL);\n    value = xor_neighbor(value);\n    value = shra(value, 13);\n    return value;\n}\n","function_prediction":"uint64_t munge_two_name_conflict(uint64_t x) {\n  x = (((x) << (24)) | ((x) >> (32 - (24))));\n  x = (((x) << (32)) | ((x) >> (64 - (32)))) ^\n      (((x) << (8)) ^ ((x) >> (64 - (8))));\n  x = (((x) << (32)) | ((x) >> (64 - (32)))) ^\n      (((x) << (13)) ^ ((x) >> (64 - (13))));\n  x = (((x) << (32)) | ((x) >> (64 - (32)))) ^\n      (((x) << (32)) ^ ((x) >> (64 - (32))));\n  x = (((x) << (32)) | ((x) >> (64 - (32)))) ^\n      (((x) << (32)) ^ ((x) >> (64 - (32))));\n  x = (((x) << (32)) | ((x) >> (64 - (32)))) ^\n      (((x) << (32)) ^ ((x) >> (64 - (32))));\n  x = (((x) << (32)) | ((x) >> (64 - (32)))) ^\n      (((x) << (32)) ^ ((x) >> (64 - (32))));\n  x = (((x) << (32)) | ((x) >> (64 - (32)))) ^\n      (((x) << (32)) ^ ((x) >> (64 - (32))));\n  x = (((x) << (32)) | ((x) >> (64 - (32)))) ^\n      (((x) << (32)) ^ ((x) >> (64 - (32))));\n  x = (((x) << (32)) | ((x) >> (64 - (32)))) ^\n      (((x) << (32)) ^ ((x) >> (64 - (32))));\n    x = (((x) <<","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"uint64_t munge_three(uint64_t value) {\n    value = shla(value, 18);\n    value = shla(value, 29);\n    value = swap_two(value, 5, 3);\n    value = swap_two(value, 0, 7);\n    value = shla(value, 18);\n    value = xor(value, 14531814500985747629UL);\n    value = shra(value, 33);\n    value = swap_two(value, 0, 4);\n    value = xor_neighbor(value);\n    value = swap_two(value, 6, 2);\n    value = shra(value, 13);\n    value = shra(value, 20);\n    value = xor(value, 6368261268581873766L);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = shra(value, 46);\n    value = swap_two(value, 2, 3);\n    value = shra(value, 44);\n    value = shra(value, 3);\n    value = swap_two(value, 4, 3);\n    value = xor_neighbor(value);\n    value = swap_two(value, 7, 6);\n    value = shra(value, 59);\n    value = shra(value, 38);\n    value = swap_bytes(value);\n    value = swap_two(value, 1, 5);\n    value = swap_bytes(value);\n    value = shla(value, 27);\n    value = xor(value, 13751028607104816751UL);\n    value = shra(value, 14);\n    value = shla(value, 7);\n    value = shla(value, 18);\n    value = shla(value, 57);\n    value = xor(value, 12989550924262916891UL);\n    value = xor(value, 929788566303591270L);\n    value = xor(value, 10714451137995436577UL);\n    value = xor(value, 9637405481907436618UL);\n    value = swap_two(value, 5, 1);\n    value = shla(value, 20);\n    value = shla(value, 24);\n    value = shra(value, 46);\n    value = shra(value, 13);\n    value = xor(value, 14510136432192624501UL);\n    value = shla(value, 7);\n    value = xor(value, 641209893495219690L);\n    value = xor(value, 6473287570272602621L);\n    value = xor_neighbor(value);\n    value = swap_two(value, 4, 7);\n    value = xor_neighbor(value);\n    value = shra(value, 22);\n    value = shra(value, 50);\n    value = xor_neighbor(value);\n    return value;\n}\n","function_prediction":"uint64_t munge_three_name_conflict(uint64_t x) {\n  x = (((x) << (61)) | ((x) >> (63 - (61)))) ^ 0xc9ab604bb92038ad;\n  x = (((x) << (1)) | ((x) >> (64 - (1)))) ^ 0x58609be21eb37866;\n  x = (((x) << (8)) | ((x) >> (64 - (8)))) ^ 0xbed577a97eb7966f;\n  x = (((x) << (4)) | ((x) >> (64 - (4)))) ^ 0xa9acf3cb7836c616;\n  x = (((x) << (7)) | ((x) >> (64 - (7)))) ^ 0xc95e5c35034b9775;\n  x = (((x) << (5)) | ((x) >> (64 - (5)))) ^ 0x5133b5bfb3336c17;\n  x = (((x) << (8)) | ((x) >> (64 - (8)))) ^ 0x8000000000000000;\n  return x;\n}","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":0,"function":"uint64_t munge_four(uint64_t value) {\n    value = swap_two(value, 1, 7);\n    value = shla(value, 6);\n    value = swap_two(value, 2, 5);\n    value = shra(value, 57);\n    value = xor(value, 902179681853661902L);\n    value = swap_two(value, 5, 1);\n    value = shla(value, 1);\n    value = xor_neighbor(value);\n    value = xor(value, 6764338754798371998L);\n    value = xor_neighbor(value);\n    value = shla(value, 6);\n    value = xor_neighbor(value);\n    value = shla(value, 33);\n    value = shra(value, 25);\n    value = xor_neighbor(value);\n    value = xor(value, 762415417889401952L);\n    value = swap_two(value, 6, 2);\n    value = xor_neighbor(value);\n    value = xor(value, 14722425112553694635UL);\n    value = xor(value, 9800422926138268860UL);\n    value = xor_neighbor(value);\n    value = xor(value, 9644430456772077073UL);\n    value = shra(value, 8);\n    value = shra(value, 43);\n    value = xor(value, 7150187182015826299L);\n    value = swap_two(value, 3, 1);\n    value = swap_two(value, 5, 7);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shra(value, 59);\n    value = shra(value, 10);\n    value = xor_neighbor(value);\n    value = swap_two(value, 2, 1);\n    value = swap_two(value, 7, 2);\n    value = xor_neighbor(value);\n    value = xor(value, 7246290916701591349L);\n    value = xor(value, 18203423676804128435UL);\n    value = xor(value, 18403139030640123059UL);\n    value = swap_two(value, 2, 4);\n    value = swap_two(value, 5, 4);\n    value = shra(value, 11);\n    value = xor_neighbor(value);\n    value = shla(value, 39);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = xor(value, 14382479493256805148UL);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    value = shla(value, 35);\n    value = swap_two(value, 3, 5);\n    value = xor_neighbor(value);\n    value = swap_bytes(value);\n    value = xor_neighbor(value);\n    return value;\n}\n","function_prediction":"uint64_t munge_four_name_conflict(uint64_t x) {\n  x = (((x) & 0x00000000ffff00ff) | ((x) & 0x000000ff00000000) << 8 |\n       ((x) & 0x0000ff0000000000) >> 8 | ((x) & 0x00ff000000000000) << 6 |\n       ((x) & 0xff00000000000000) >> 6);\n  x = (((x) & 0x000000000000ff00) | ((x) & 0x0000000000ff0000) << 8 |\n       ((x) & 0x00000000ff000000) >> 8 | ((x) & 0x000000ff00000000) << 7 |\n       ((x) & 0x0000ff0000000000) >> 7 | ((x) & 0x00ff000000000000) << 1 |\n       ((x) & 0xff00000000000000) >> 1);\n    x = (((x) & 0x00000000000000ff) | ((x) & 0x000000000000ff00) << 8 | ((x) & 0x0000000000ff0000) >> 8 | ((x) & 0x00000000ff000000) << 1 | ((x) & 0x000000ff00000000) >> 1 | ((x) & 0x0000ff0000000000) << 7 | ((x) & 0x00ff00","pass":0,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"int munge_all(unsigned char *data) {\n    int i = 0;\n    uint64_t *base = ((void *)0);\n    uint64_t one;\n    uint64_t two;\n    uint64_t thr;\n    uint64_t fou;\n    read(0, data, 32);\n    for (i = 0; i < 32; i++) {\n        if (((data[i] < 65) || (122 < data[i])) && (data[i] != 32)) {\n            return 0;\n        } else if (data[i] == ']') {\n            return 0;\n        } else if (data[i] == '\\\\') {\n            return 0;\n        } else if (data[i] == '^') {\n            return 0;\n        } else if (data[i] == '`') {\n            return 0;\n        } else if (data[i] == '[') {\n            return 0;\n        }\n    }\n    base = (uint64_t *)data;\n    one = munge_one(base[0]);\n    two = munge_two(base[1]);\n    thr = munge_three(base[2]);\n    fou = munge_four(base[3]);\n    one = one ^ two ^ thr ^ fou;\n    if (one == 12754495720971571466UL) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int munge_all_name_conflict(char *buf) {\n  unsigned long long a, b, c, d;\n  int i;\n\n  read(0, buf, 32);\n\n  for (i = 0; i < 4; i++) {\n    if (buf[i] != ' ' && buf[i] != '.' && buf[i] != '`' && buf[i] != 'a' &&\n        buf[i] != 'b' && buf[i] != 'c' && buf[i] != 'd' && buf[i] != 'e' &&\n        buf[i] != 'f' && buf[i] != 'g' && buf[i] != 'h' && buf[i] != 'i' &&\n        buf[i] != 'j' && buf[i] != 'k' && buf[i] != 'l' && buf[i] != 'm' &&\n        buf[i] != 'n' && buf[i] != 'o' && buf[i] != 'p' && buf[i] != 'q' &&\n        buf[i] != 'r' && buf[i] != 's' && buf[i] != 't' && buf[i] != 'u' &&\n        buf[i] != 'v' && buf[i] != 'w' && buf[i] != 'x' && buf[i] != 'y' &&\n        buf[i] != 'z')\n      return 0;\n  }\n\n  a = munge_one(buf[0]);\n  b = munge_two(buf[1]);\n  c = munge_three(buf[2]);\n  d = munge_four(buf[3]);\n\n  return (a ^ b ^ c ^ d) == 0xb101124831c0110aULL;\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_amadhj/files/amadhj.c"}
{"compilable":1,"function":"int countLiveNeighbors(int x, int y) {\n    int ret = 0;\n    int bit = ((y * 110) + x);\n    if (y > 0) {\n        if ((bit_field[(bit - 110) / 8] & (1 << (7 - ((bit - 110) % 8)))))\n            ret++;\n        if ((x > 0) && (bit_field[((bit - 110) - 1) / 8] & (1 << (7 - (((bit - 110) - 1) % 8)))))\n            ret++;\n        if ((x < (110 - 1)) && (bit_field[((bit - 110) + 1) / 8] & (1 << (7 - (((bit - 110) + 1) % 8)))))\n            ret++;\n    }\n    if ((x > 0) && (bit_field[(bit - 1) / 8] & (1 << (7 - ((bit - 1) % 8)))))\n        ret++;\n    if ((x < (110 - 1)) && (bit_field[(bit + 1) / 8] & (1 << (7 - ((bit + 1) % 8)))))\n        ret++;\n    if (y < (110 - 1)) {\n        if ((bit_field[(bit + 110) / 8] & (1 << (7 - ((bit + 110) % 8)))))\n            ret++;\n        if ((x > 0) && (bit_field[((bit + 110) - 1) / 8] & (1 << (7 - (((bit + 110) - 1) % 8)))))\n            ret++;\n        if ((x < (110 - 1)) && (bit_field[((bit + 110) + 1) / 8] & (1 << (7 - (((bit + 110) + 1) % 8)))))\n            ret++;\n    }\n    return ret;\n}\n","function_prediction":"int countLiveNeighbors_name_conflict(int x, int y) {\n  int count = 0;\n  int i, j;\n  for (i = -1; i <= 1; i++) {\n    for (j = -1; j <= 1; j++) {\n      if (i == 0 && j == 0) {\n        continue;\n      }\n      if (bit_field[(y + i) * 110 + (x + j)] & 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_b3s23/files/b3s23.c"}
{"compilable":1,"function":"int processCoord(int x, int y) {\n    int ret;\n    if (x < 0 || y < 0) {\n        printf(\"Illegal Coordinate!\\n\");\n        fflush(stdout);\n        exit(-1);\n    }\n    if ((x >= 110) || (y >= 110)) {\n        printf(\"Illegal Coordinate!\\n\");\n        fflush(stdout);\n        exit(-1);\n    }\n    ret = (y * 110) + x;\n    return ret;\n}\n","function_prediction":"int processCoord_name_conflict(int x, int y) {\n  if (x >= 0 && x < 110 && y >= 0 && y < 110)\n    return y * 110 + x;\n  else {\n    puts(\"Illegal Coordinate!\");\n    fflush(stdout);\n    exit(-1);\n  }\n}","pass":1,"source_file":"C_COMPILE/SecGen_SecGen/modules/vulnerabilities/unix/ctf/defcon_quals_2016/dc16_b3s23/files/b3s23.c"}
{"compilable":1,"function":"unsigned int FindRoot(unsigned int *set, unsigned int node) {\n    if (set[node] == node)\n        return node;\n    else\n        return FindRoot(set, set[node]);\n}\n","function_prediction":"int FindRoot_name_conflict(int *parent, int x) {\n  while (parent[x] != x)\n    x = parent[x];\n  return x;\n}","pass":1,"source_file":"C_COMPILE/arnikz_netclust/src/netclust.c"}
{"compilable":1,"function":"int udp_epoll_add(int epollfd, int fd, U32 u32flag) {\n    int ret = -1;\n    int block_opt = 0;\n    struct epoll_event event;\n    if (epollfd == 0 || fd == 0) {\n        ;\n        return (-1);\n    }\n    event.data.fd = fd;\n    event.events = u32flag;\n    ret = epoll_ctl(epollfd, 1, fd, &event);\n    if (ret < 0) {\n        ;\n        return (-1);\n    }\n    block_opt = fcntl(fd, 3) | 2048;\n    fcntl(fd, 4, block_opt);\n    return (0);\n}\n","function_prediction":"int udp_epoll_add_name_conflict(int epfd, int fd, uint32_t events) {\n  struct epoll_event ev;\n  int flags, ret;\n\n  if (epfd == 0 || fd == 0)\n    return -1;\n\n  ev.events = events;\n  ev.data.fd = fd;\n  ret = epoll_ctl(epfd, 1, fd, &ev);\n  if (ret < 0)\n    return -1;\n\n  flags = fcntl(fd, 3);\n  fcntl(fd, 4, flags | 0x800);\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_setup(INSTANCE_T *pinst) {\n    int ret = -1;\n    if (!pinst) {\n        ;\n        return (-1);\n    }\n    pinst->epollfd = epoll_create(5);\n    if (pinst->epollfd == -1) {\n        ;\n        return (-1);\n    }\n    ret = socketpair(1, SOCK_STREAM, 0, pinst->pipefd);\n    if (ret != (0)) {\n        ;\n        return (-1);\n    }\n    ret |= udp_epoll_add(pinst->epollfd, pinst->pipefd[0], EPOLLIN | EPOLLET);\n    if (ret != (0)) {\n        ;\n        return (-1);\n    }\n    int block_opt = fcntl(pinst->pipefd[1], 3) | 2048;\n    fcntl(pinst->pipefd[1], 4, block_opt);\n    g_sig_fd = pinst->pipefd[1];\n    return (0);\n}\n","function_prediction":"int udp_epoll_setup_name_conflict(struct udp_epoll_t *epoll) {\n  if (epoll == NULL)\n    return -1;\n\n  epoll->epoll_fd = epoll_create(5);\n  if (epoll->epoll_fd == -1)\n    return -1;\n\n  if (socketpair(1, 1, 0, &epoll->sig_fd))\n    return -1;\n\n  if (epoll->epoll_fd == 0 || epoll->sig_fd == 0)\n    return -1;\n\n  struct epoll_event ev;\n  ev.events = EPOLLIN;\n  ev.data.fd = epoll->sig_fd;\n  if (epoll_ctl(epoll->epoll_fd, 1, epoll->sig_fd, &ev) < 0)\n    return -1;\n\n  fcntl(epoll->sig_fd, 4, fcntl(epoll->sig_fd, 3) | 0x800);\n  fcntl(epoll->udp_fd, 4, fcntl(epoll->udp_fd, 3) | 0x800);\n\n  g_sig_fd = epoll->udp_fd;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_shutdown(const INSTANCE_T *pinst) {\n    if (!pinst) {\n        ;\n        return (-1);\n    }\n    close(pinst->pipefd[0]);\n    close(pinst->pipefd[1]);\n    close(pinst->epollfd);\n    return (0);\n}\n","function_prediction":"int udp_epoll_shutdown_name_conflict(struct udp_epoll_t *udp_epoll) {\n  if (udp_epoll == NULL) {\n    return -1;\n  }\n\n  close(udp_epoll->epoll_fd);\n  close(udp_epoll->udp_fd);\n  close(udp_epoll->udp_fd_recv);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_core_listen(INSTANCE_T *pinst) {\n    int ret = 0;\n    int reuseaddr = 1;\n    int recv_buf_size = 65535;\n    int send_buf_size = 65535;\n    struct sockaddr_in lsn_addr = {0};\n    if (!pinst) {\n        ;\n        goto _E1;\n    }\n    pinst->lsn_fd = socket(2, SOCK_DGRAM, 0);\n    if (pinst->lsn_fd < 0) {\n        ;\n        goto _E1;\n    }\n    ret = setsockopt(pinst->lsn_fd, 1, 2, &reuseaddr, sizeof (reuseaddr));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    memset(&lsn_addr, 0, sizeof (lsn_addr));\n    lsn_addr.sin_family = 2;\n    lsn_addr.sin_port = pinst->task.nlsn_port;\n    lsn_addr.sin_addr.s_addr = pinst->task.u32lsn_ip;\n    ret = bind(pinst->lsn_fd, (struct sockaddr *)&lsn_addr, sizeof(struct sockaddr_in));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    goto _S0;\n  _E2:\n    close(pinst->lsn_fd);\n  _E1:\n    pinst->lsn_fd = 0;\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"int udp_core_listen_name_conflict(udp_core_t *udp) {\n  int ret;\n  int on = 1;\n  struct sockaddr_in addr = {0};\n\n  if (udp == NULL)\n    return -1;\n\n  udp->fd = socket(2, 2, 0);\n  if (udp->fd < 0)\n    goto err;\n\n  ret = setsockopt(udp->fd, 1, 2, &on, sizeof(on));\n  if (ret < 0)\n    goto err_close;\n\n  addr.sin_family = 2;\n  addr.sin_port = udp->port;\n  addr.sin_addr.s_addr = udp->addr;\n\n  ret = bind(udp->fd, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret < 0)\n    goto err_close;\n\n  return 0;\n\nerr_close:\n  close(udp->fd);\nerr:\n  udp->fd = 0;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_core_connect(struct sockaddr_in *psrv_addr, struct sockaddr_in *plcl_addr, int *psrv_fd) {\n    int ret = 0;\n    int reuseaddr = 1;\n    int recv_buf_size = 65535;\n    int send_buf_size = 65535;\n    socklen_t socklen = sizeof(struct sockaddr_in);\n    if (!psrv_addr || !plcl_addr) {\n        ;\n        goto _E1;\n    }\n    *psrv_fd = socket(2, SOCK_DGRAM, 0);\n    if (*psrv_fd < 0) {\n        ;\n        goto _E1;\n    }\n    ret = bind(*psrv_fd, (struct sockaddr *)plcl_addr, socklen);\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ret = setsockopt(*psrv_fd, 1, 2, &reuseaddr, sizeof (reuseaddr));\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ret = connect(*psrv_fd, (struct sockaddr *)psrv_addr, socklen);\n    if (ret < 0) {\n        ;\n        goto _E2;\n    }\n    ;\n    int block_opt = fcntl(*psrv_fd, 3) | 2048;\n    fcntl(*psrv_fd, 4, block_opt);\n    goto _S0;\n  _E2:\n    close(*psrv_fd);\n  _E1:\n    *psrv_fd = 0;\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"int udp_core_connect(struct sockaddr_in *addr, struct sockaddr_in *local,\n                     int *sock) {\n  int ret;\n  int one = 1;\n\n  if (addr == NULL || local == NULL)\n    return -1;\n\n  *sock = socket(2, 2, 0);\n  if (*sock < 0)\n    goto err;\n\n  ret = bind(*sock, (struct sockaddr *)local, sizeof(struct sockaddr_in));\n  if (ret < 0)\n    goto err;\n\n  ret = setsockopt(*sock, 1, 2, &one, sizeof(one));\n  if (ret < 0)\n    goto err;\n\n  ret = connect(*sock, (struct sockaddr *)addr, sizeof(struct sockaddr_in));\n  if (ret < 0)\n    goto err;\n\n  fcntl(*sock, 4, fcntl(*sock, 3) | 0x800);\n\n  return 0;\n\nerr:\n  if (*sock > 0)\n    close(*sock);\n  *sock = 0;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":1,"function":"int udp_send_nonblock(int fd, const char *pbuf, size_t bufsize) {\n    int ret = (-1);\n    if (!pbuf) {\n        ;\n        return (-1);\n    }\n    while (ret < 0)\n        {\n            ret = send(fd, pbuf, bufsize, 0);\n            if (ret < 0) {\n                if ((*__errno_location()) == 11) {\n                    ;\n                    usleep(10);\n                    continue;\n                } else {\n                    return (-1);\n                }\n            }\n        }\n    return ret;\n}\n","function_prediction":"int udp_send_nonblock_name_conflict(int sock, const void *buf, size_t len) {\n  int ret;\n\n  if (buf == NULL)\n    return -1;\n\n  while (1) {\n    ret = send(sock, buf, len, 0);\n    if (ret >= 0)\n      return ret;\n\n    if (*__errno_location() != 11)\n      return -1;\n\n    usleep(10);\n  }\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_snat_add(PROXY_APP_T *proxy_app) {\n    char cmd[512] = {0};\n    char srv_ip[16] = {0};\n    char clt_ip[16] = {0};\n    if (!proxy_app) {\n        ;\n        return (-1);\n    }\n    snprintf(cmd, sizeof (cmd), \"iptables -t nat -A POSTROUTING -p udp -d %s --sport %d -j SNAT --to %s:%u\", ip_ntoa(proxy_app->srv_ip, srv_ip), ntohs(proxy_app->lcl_port), ip_ntoa(proxy_app->clt_ip, clt_ip), ntohs(proxy_app->clt_port));\n    ;\n    system(cmd);\n    return (0);\n}\n","function_prediction":"int udp_snat_add_name_conflict(struct udp_snat *snat) {\n  char cmd[512] = {0};\n  char src_ip[16] = {0};\n  char dst_ip[16] = {0};\n\n  if (snat == NULL)\n    return -1;\n\n  snprintf(cmd, sizeof(cmd),\n           \"iptables -t nat -A POSTROUTING -p udp -d %s --sport %d -j SNAT \"\n           \"--to %s:%u\",\n           ip_ntoa(snat->dst_ip, dst_ip),\n           ((((unsigned short)(snat->dst_port) & 0xFF00) >> 8) |\n            (((unsigned short)(snat->dst_port) & 0x00FF) << 8)),\n           ip_ntoa(snat->src_ip, src_ip),\n           ((((unsigned short)(snat->src_port) & 0xFF00) >> 8) |\n            (((unsigned short)(snat->src_port) & 0x00FF) << 8)));\n\n  system(cmd);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_snat_del(PROXY_APP_T *proxy_app) {\n    char cmd[512] = {0};\n    char srv_ip[16] = {0};\n    char clt_ip[16] = {0};\n    if (!proxy_app) {\n        ;\n        return (-1);\n    }\n    if (proxy_app->udp_type & UDP_TYPE_CLIENT) {\n        snprintf(cmd, sizeof (cmd), \"iptables -t nat -D POSTROUTING -p udp -d %s --sport %d -j SNAT --to %s:%u\", ip_ntoa(proxy_app->srv_ip, srv_ip), ntohs(proxy_app->lcl_port), ip_ntoa(proxy_app->clt_ip, clt_ip), ntohs(proxy_app->clt_port));\n        ;\n    }\n    system(cmd);\n    return (0);\n}\n","function_prediction":"int udp_snat_del_name_conflict(struct udp_snat *snat) {\n  char cmd[512] = {0};\n  char src_ip[16] = {0};\n  char dst_ip[16] = {0};\n  unsigned short src_port;\n  unsigned short dst_port;\n\n  if (snat == NULL)\n    return -1;\n\n  if (snat->enable & (1 << 3)) {\n    src_port = (snat->src_port & 0xff00) >> 8;\n    src_port |= (snat->src_port & 0x00ff) << 8;\n    dst_port = (snat->dst_port & 0xff00) >> 8;\n    dst_port |= (snat->dst_port & 0x00ff) << 8;\n    ip_ntoa(snat->src_ip, src_ip);\n    ip_ntoa(snat->dst_ip, dst_ip);\n    snprintf(cmd, sizeof(cmd),\n             \"iptables -t nat -D POSTROUTING -p udp -d %s --sport %d -j SNAT \"\n             \"--to %s:%u\",\n             dst_ip, dst_port, src_ip, src_port);\n  }\n\n  system(cmd);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler_request(const INSTANCE_T *pinst, char *pbuf) {\n    int ret = 0;\n    int srv_fd = 0;\n    int recv_byte = 0;\n    int send_byte = 0;\n    char debug[16] = {0};\n    char *pdata = ((void *)0);\n    UDP_HEAD *phead = ((void *)0);\n    TIMER_T *ptimer = ((void *)0);\n    struct sockaddr_in clt_addr = {0};\n    socklen_t clt_len = sizeof (clt_addr);\n    dsp_time(385, \"\");\n    if (!pbuf) {\n        ;\n        goto _E1;\n    }\n    phead = (UDP_HEAD *)pbuf;\n    pdata = pbuf + sizeof(UDP_HEAD);\n    memset(phead, 0, sizeof(UDP_HEAD));\n    if (recv_byte < 0) {\n        ;\n        goto _E1;\n    }\n    ;\n    ptimer = time_wheel_search_by_addr(clt_addr);\n    if (!ptimer) {\n        ptimer = udp_connection_setup(pinst, phead, &clt_addr, &srv_fd);\n        if (!ptimer) {\n            ;\n            goto _E1;\n        }\n        dsp_time(417, \"udp_connection_setup\");\n    } else {\n        srv_fd = ptimer->proxy_app.srv_fd;\n        ret = time_wheel_refresh(ptimer, 2);\n        if (!ptimer) {\n            ;\n            goto _E2;\n        }\n        dsp_time(426, \"time_wheel_refresh\");\n    }\n    if (send_byte < 0) {\n        ;\n        goto _E2;\n    }\n    dsp_time(443, \"udp_epoll_handler_request\");\n    goto _S0;\n  _E2:\n    time_wheel_del(&ptimer);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"int udp_epoll_handler_request_name_conflict(int fd, struct epoll_event *event) {\n  struct time_wheel_node *node = NULL;\n  dsp_time(240, \"udp_epoll_handler_request_name_conflict\");\n  if (event == NULL) {\n    return -1;\n  }\n  event->data.fd = 0;\n  node = time_wheel_search_by_addr(0, 0);\n  if (node == NULL) {\n    close(0);\n    return -1;\n  }\n  time_wheel_refresh(node, 2);\n  if (node == NULL) {\n    time_wheel_del(&node);\n    return -1;\n  }\n  dsp_time(417, \"time_wheel_refresh\");\n  dsp_time(442, \"udp_epoll_handler_request_name_conflict\");\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler_respone(const INSTANCE_T *pinst, int srv_fd, char *pbuf) {\n    int ret = 0;\n    int clt_fd = 0;\n    int recv_byte = 0;\n    int send_byte = 0;\n    struct sockaddr_in srv_addr = {0};\n    socklen_t clt_len = sizeof(struct sockaddr_in);\n    TIMER_T *ptimer = ((void *)0);\n    recv_byte = recv(srv_fd, pbuf, 65535, 0);\n    if (recv_byte <= 0) {\n        ;\n        goto _E2;\n    }\n    ;\n    ptimer = time_wheel_search_by_fd(srv_fd);\n    if (!ptimer) {\n        ;\n        goto _E2;\n    }\n    ret = time_wheel_refresh(ptimer, 2);\n    if (!ptimer) {\n        ;\n        goto _E3;\n    }\n    clt_fd = ptimer->proxy_app.clt_fd;\n    send_byte = sendto(clt_fd, pbuf, recv_byte, 0, (struct sockaddr *)&ptimer->proxy_app.clt_addr, clt_len);\n    if (send_byte <= 0) {\n        ;\n        goto _E3;\n    }\n    goto _S0;\n  _E3:\n    time_wheel_del(&ptimer);\n  _E2:\n    close(srv_fd);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"int udp_epoll_handler_respone_name_conflict(int fd, int events, void *arg) {\n  int ret;\n  char buf[65535];\n  struct time_wheel_node *node = NULL;\n\n  ret = recv(fd, buf, 65535, 0);\n  if (ret <= 0) {\n    goto err;\n  }\n\n  node = time_wheel_search_by_fd(fd);\n  if (node == NULL) {\n    goto err;\n  }\n\n  time_wheel_refresh(node, 2);\n\n  if (node == NULL) {\n    goto err;\n  }\n\n  ret = sendto(node->fd, buf, ret, 0, (struct sockaddr *)&node->addr,\n               sizeof(node->addr));\n  if (ret <= 0) {\n    goto err;\n  }\n\n  return 0;\n\nerr:\n  if (node != NULL) {\n    time_wheel_del(&node);\n  }\n\n  close(fd);\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":1,"function":"int udp_epoll_handler_signal(int pipefd) {\n    int ret = 0;\n    int sig = 0;\n    int jx = 0;\n    char signals[1024];\n    ret = recv(pipefd, signals, sizeof (signals), 0);\n    if (ret <= 0) {\n        ;\n        return (-1);\n    } else {\n        for (jx = 0; jx < ret; jx++) {\n            switch (signals[jx]) {\n              case 14:\n                g_timeout = 1;\n                break;\n              case 2:\n              case 15:\n                ;\n                g_enable = 0;\n                break;\n              default:\n                break;\n            }\n        }\n    }\n    return (0);\n}\n","function_prediction":"int udp_epoll_handler_signal_name_conflict(int fd) {\n  char buf[1024];\n  int len = recv(fd, buf, 1024, 0);\n  if (len <= 0)\n    return -1;\n\n  int i;\n  int is_exit = 0;\n  int is_timeout = 0;\n  for (i = 0; i < len; i++) {\n    if (buf[i] == 14)\n      is_timeout = 1;\n    else if (buf[i] == 15)\n      is_exit = 1;\n    else if (buf[i] == 2)\n      is_exit = 1;\n  }\n\n  if (is_exit)\n    g_enable = 0;\n  if (is_timeout)\n    g_timeout = 1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":0,"function":"int udp_epoll_handler(const INSTANCE_T *pinst) {\n    char *buffer = ((void *)0);\n    int ret = 0;\n    int ix = 0;\n    int sockfd = 0;\n    int timeout = 0;\n    if (!pinst) {\n        ;\n        goto _E1;\n    }\n    buffer = (char *)malloc(sizeof(char) * 65535);\n    if (!buffer) {\n        ;\n        goto _E1;\n    }\n    int epoll_num = 0;\n    struct epoll_event events[65535] = {0};\n    while (g_enable)\n        {\n            epoll_num = epoll_wait(pinst->epollfd, events, 65535, -1);\n            if (epoll_num < 0 && (*__errno_location()) != 4) {\n                ;\n                goto _E2;\n            }\n            for (ix = 0; ix < epoll_num; ix++) {\n                sockfd = events[ix].data.fd;\n                if (sockfd == pinst->lsn_fd) {\n                    ret = udp_epoll_handler_request(pinst, buffer);\n                    if (ret != (0)) {\n                        ;\n                    }\n                } else if (sockfd == pinst->pipefd[0]) {\n                    ret = udp_epoll_handler_signal(pinst->pipefd[0]);\n                    if (ret != (0)) {\n                        ;\n                        goto _E2;\n                    }\n                } else if (events[ix].events & EPOLLIN) {\n                    ret = udp_epoll_handler_respone(pinst, sockfd, buffer);\n                    if (ret != (0)) {\n                        ;\n                        goto _E2;\n                    }\n                } else {\n                }\n                if (g_timeout) {\n                    time_wheel_tick();\n                    alarm(10);\n                    g_timeout = 0;\n                    continue;\n                }\n            }\n        }\n    goto _S0;\n  _E2:\n    free(buffer);\n    buffer = ((void *)0);\n  _E1:\n    return (-1);\n  _S0:\n    return (0);\n}\n","function_prediction":"int udp_epoll_handler_name_conflict(void *arg) {\n  int i, j, nfds, fd, n;\n  char buf[1024];\n  struct epoll_event ev, events[65535];\n  struct udp_epoll_t *udp_epoll = (struct udp_epoll_t *)arg;\n  struct time_wheel_t *tw = NULL;\n\n  if (udp_epoll == NULL)\n    return -1;\n\n  buf[1024 - 1] = '\\0';\n\n  if ((buf = malloc(65535)) == NULL)\n    return -1;\n\n  memset(events, 0, sizeof(events));\n\n  while (g_enable) {\n    nfds = epoll_wait(udp_epoll->epfd, events, 65535, -1);\n    if (nfds < 0) {\n      if (*__errno_location() == 4)\n        continue;\n      else\n        break;\n    }\n\n    for (i = 0; i < nfds; ++i) {\n      fd = events[i].data.fd;\n\n      if (fd == udp_epoll->fd_request) {\n        udp_epoll_handler_name_conflict_request(udp_epoll, buf);\n        if (g_timeout) {\n          time_wheel_tick();\n          alarm(10);\n          g_timeout = 0;\n        }\n      } else if (fd == udp_epoll->fd_respone) {\n        n = recv(udp_epoll->fd_respone, buf, 1024, 0);\n        if (n > 0) {\n          int enable = 0, timeout = 0;\n          for (j = 0; j < n; ++j) {\n            if (buf[j] == 0x0e)\n              enable = 1;\n            else if (buf[j] == 0x0f)\n              timeout = 1;\n                        else if (buf[j] == 0x02","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_proxy.c"}
{"compilable":1,"function":"int ip_aton(char *sip) {\n    int ix = 0;\n    int rv = 0;\n    U8 val[4] = {0};\n    if (sip == ((void *)0)) {\n        return 0;\n    }\n    sscanf(sip, \"%hhu.%hhu.%hhu.%hhu\", &val[3], &val[2], &val[1], &val[0]);\n    do {\n        rv <<= 8;\n        rv |= val[ix] & 255;\n    } while (++ix < 4);\n    return rv;\n}\n","function_prediction":"uint32_t ip_aton_name_conflict(const char *ip) {\n  uint8_t ip_bytes[4] = {0};\n  if (ip)\n    __isoc99_sscanf(ip, \"%hhu.%hhu.%hhu.%hhu\", &ip_bytes[3], &ip_bytes[2],\n                    &ip_bytes[1], &ip_bytes[0]);\n  return *(uint32_t *)ip_bytes;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":1,"function":"int ip_atoh(char *sip) {\n    int ix = 0;\n    int rv = 0;\n    U8 val[4] = {0};\n    if (sip == ((void *)0)) {\n        return 0;\n    }\n    sscanf(sip, \"%hhu.%hhu.%hhu.%hhu\", &val[0], &val[1], &val[2], &val[3]);\n    do {\n        rv <<= 8;\n        rv |= val[ix] & 255;\n    } while (++ix < 4);\n    return rv;\n}\n","function_prediction":"uint32_t ip_atoh_name_conflict(const char *ip) {\n  uint8_t ip_bytes[4] = {0};\n  if (ip)\n    __isoc99_sscanf(ip, \"%hhu.%hhu.%hhu.%hhu\", &ip_bytes[0], &ip_bytes[1],\n                    &ip_bytes[2], &ip_bytes[3]);\n  return *(uint32_t *)ip_bytes;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":1,"function":"char *ip_htoa(int sip, char *rvip) {\n    if (rvip == ((void *)0)) {\n        return rvip;\n    }\n    sprintf(rvip, \"%d.%d.%d.%d\", sip >> 24 & 255, sip >> 16 & 255, sip >> 8 & 255, sip & 255);\n    return rvip;\n}\n","function_prediction":"char *ip_htoa_name_conflict(uint32_t ip, char *buf) {\n  if (buf)\n    sprintf(buf, \"%d.%d.%d.%d\", (ip >> 24) & 0xff, (ip >> 16) & 0xff,\n            (ip >> 8) & 0xff, ip & 0xff);\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":1,"function":"char *ip_ntoa(int sip, char *rvip) {\n    if (rvip == ((void *)0)) {\n        return rvip;\n    }\n    sprintf(rvip, \"%d.%d.%d.%d\", sip & 255, sip >> 8 & 255, sip >> 16 & 255, sip >> 24 & 255);\n    return rvip;\n}\n","function_prediction":"char *ip_ntoa_name_conflict(unsigned int ip, char *buf) {\n  if (buf)\n    sprintf(buf, \"%d.%d.%d.%d\", (ip & 0xff), (ip >> 8) & 0xff,\n            (ip >> 16) & 0xff, (ip >> 24) & 0xff);\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_common.c"}
{"compilable":0,"function":"int time_wheel_create() {\n    int i;\n    g_cur_slot = 0;\n    for (i = 0; i < 4; i++) {\n        gp_slots[i] = ((void *)0);\n    }\n    return (0);\n}\n","function_prediction":"int time_wheel_create_name_conflict() {\n  g_cur_slot = 0;\n  for (int i = 0; i < 60; i++) {\n    gp_slots[i].p_head = NULL;\n    gp_slots[i].p_tail = NULL;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":0,"function":"int time_wheel_destroy() {\n    int i;\n    TIMER_T *pt = ((void *)0);\n    for (i = 0; i < 4; i++) {\n        pt = gp_slots[i];\n        while (pt)\n            {\n                gp_slots[i] = pt->next;\n                free(pt);\n                pt = gp_slots[i];\n            }\n    }\n    return (0);\n}\n","function_prediction":"int time_wheel_destroy_name_conflict(void) {\n  int i;\n  struct time_slot *slot;\n  struct time_slot **slotp;\n\n  for (i = 0; i < (60 * 24); i++) {\n    slotp = &gp_slots[i];\n    while ((slot = *slotp) != NULL) {\n      *slotp = slot->next;\n      free(slot);\n    }\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":0,"function":"int time_wheel_tick() {\n    TIMER_T *pt = gp_slots[g_cur_slot];\n    TIMER_T *pn = ((void *)0);\n    ;\n    while (pt)\n        {\n            ;\n            if (pt->rotation > 0) {\n                pt->rotation--;\n                pt = pt->next;\n            } else {\n                ;\n                pt->cb_func(&pt->proxy_app);\n                if (pt == gp_slots[g_cur_slot]) {\n                    gp_slots[g_cur_slot] = pt->next;\n                    free(pt);\n                    if (gp_slots[g_cur_slot]) {\n                        gp_slots[g_cur_slot]->prev = ((void *)0);\n                    }\n                    pt = gp_slots[g_cur_slot];\n                } else {\n                    pt->prev->next = pt->next;\n                    if (pt->next) {\n                        pt->next->prev = pt->prev;\n                    }\n                    pn = pt->next;\n                    free(pt);\n                    pt = pn;\n                }\n            }\n        }\n    g_cur_slot = ++g_cur_slot % 4;\n    return (0);\n}\n","function_prediction":"int time_wheel_tick_name_conflict() {\n  int cur_slot = g_cur_slot;\n  struct time_wheel_node *p_node = gp_slots[cur_slot];\n  while (p_node) {\n    if (p_node->timeout > 0) {\n      p_node->timeout--;\n      p_node = p_node->next;\n    } else {\n      p_node->callback(p_node);\n      if (gp_slots[cur_slot] == p_node) {\n        gp_slots[cur_slot] = p_node->next;\n        free(p_node);\n        p_node = gp_slots[cur_slot];\n        if (p_node) {\n          p_node->prev = NULL;\n        }\n      } else {\n        p_node->prev->next = p_node->next;\n        if (p_node->next) {\n          p_node->next->prev = p_node->prev;\n        }\n        free(p_node);\n        p_node = p_node->next;\n      }\n    }\n  }\n  g_cur_slot = (cur_slot + 1) % 4;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/stayneckwind_udp_proxy/udp_timer.c"}
{"compilable":1,"function":"int *make(int rows, int cols) {\n    return (int *)malloc(rows * cols * sizeof(int));\n}\n","function_prediction":"int *make_name_conflict(int n, int m) { return malloc(n * m * sizeof(int)); }","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":1,"function":"int penalty(int *lhs, int *rhs, int mwidth, int *individuum) {\n    int *l = make(mwidth, mwidth);\n    eval(lhs, mwidth, individuum, l);\n    int *r = make(mwidth, mwidth);\n    eval(rhs, mwidth, individuum, r);\n    int s = 0;\n    for (int row = 0; row < mwidth; row++) {\n        for (int col = 0; col < mwidth; col++) {\n            int x = l[row * mwidth + col];\n            int y = r[row * mwidth + col];\n            int p = 0;\n            if ((row == 0) && (col == mwidth - 1)) {\n                p = (x > y) ? 0 : 10000 * (y - x + 1);\n            } else {\n                p = (x >= y) ? 0 : y * y - x * x;\n            }\n            if (p > 1000000)\n                p = 1000000;\n            s += p;\n        }\n    }\n    free(l);\n    free(r);\n    return s;\n}\n","function_prediction":"int penalty_name_conflict(int *a, int *b, int n, int *p) {\n  int i, j, k, l, m, o, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I,\n      J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z;\n  int *a1, *b1;\n  int penalty_name_conflict = 0;\n\n  a1 = (int *)malloc(n * n * sizeof(int));\n  eval(a, n, p, a1);\n  b1 = (int *)malloc(n * n * sizeof(int));\n  eval(b, n, p, b1);\n\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      A = a1[i * n + j];\n      B = b1[i * n + j];\n      if (A < B) {\n        C = B * B - A * A;\n        if (C > 1000000)\n          C = 1000000;\n        penalty_name_conflict += C;\n      }\n    }\n  }\n\n  free(a1);\n  free(b1);\n\n  return penalty_name_conflict;\n}","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":1,"function":"int anneal(int total, int *lhs, int *rhs, int mcount, int mwidth, int *individuum) {\n    int best = penalty(lhs, rhs, mwidth, individuum);\n    if (0 == best)\n        return 0;\n    size_t s = mcount * mwidth * mwidth * sizeof(int);\n    int *candidate = malloc(s);\n    for (int steps = 0; steps < total; steps++) {\n        memcpy(candidate, individuum, s);\n        mutate(mcount, mwidth, candidate);\n        int p = penalty(lhs, rhs, mwidth, candidate);\n        int luck = 0 == random() % total;\n        if (p <= best || luck) {\n            memcpy(individuum, candidate, s);\n            best = p;\n        }\n    }\n    free(candidate);\n    return best;\n}\n","function_prediction":"int anneal_name_conflict(int steps, int *a, int *b, int n, int m, int *c) {\n  int i, j, k, p, q, r, s, t, u, v, w, x, y, z, *d, penalty_c, penalty_d;\n  size_t size;\n\n  penalty_c = penalty(a, b, m, c);\n  if (penalty_c == 0) {\n    return 0;\n  }\n\n  size = sizeof(int) * n * m * m;\n  d = malloc(size);\n\n  for (i = 0; i < steps; i++) {\n    memcpy(d, c, size);\n\n    p = random() % n;\n    q = random() % (m - 1);\n    r = random() % (m - 1);\n    s = p * m * m + q * m + r;\n    d[s]--;\n    if (d[s] < 0) {\n      d[s] = 0;\n    }\n\n    penalty_d = penalty(a, b, m, d);\n    if (random() % steps != 0 && penalty_d > penalty_c) {\n      continue;\n    }\n\n    memcpy(c, d, size);\n    penalty_c = penalty_d;\n  }\n\n  free(d);\n\n  return penalty_c;\n}","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":1,"function":"int bits(int x) {\n    int c = 0;\n    while (x > 0)\n        {\n            x >>= 1;\n            c++;\n        }\n    return c;\n}\n","function_prediction":"int bits_name_conflict(int n) {\n  int i;\n  for (i = 0; n > 0; i++)\n    n >>= 1;\n  return i;\n}","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":0,"function":"static inline int timespec_subtract(struct timespec *result, struct timespec *after, struct timespec *before) {\n    result->tv_nsec = after->tv_nsec - before->tv_nsec;\n    if (result->tv_nsec < 0) {\n        result->tv_nsec += 1000000000;\n        result->tv_sec = after->tv_sec - before->tv_sec - 1;\n        return 1;\n    } else {\n        result->tv_sec = after->tv_sec - before->tv_sec;\n        return 0;\n    }\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/tkalbitz_matrix_terminator/src/matrix.c"}
{"compilable":1,"function":"char control_letter(size_t rest) {\n    const char sequence[] = \"TRWAGMYFPDXBNJZSQVHLCKE\";\n    if (rest >= sizeof (sequence)) {\n        return '.';\n    } else {\n        return sequence[rest];\n    }\n}\n","function_prediction":"char control_letter_name_conflict(int i) {\n  char letters[] = \"QVHCLKE.\";\n  if (i < 0 || i > 7)\n    return '.';\n  return letters[i];\n}","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"int nif_detect_type(const char *nif) {\n    char pos_zero = nif[0];\n    if (((*__ctype_b_loc())[(int)((pos_zero))] & (unsigned short)_ISdigit)) {\n        return 10;\n    } else if (pos_zero == 'X' || pos_zero == 'Y' || pos_zero == 'Z') {\n        return 20;\n    } else {\n        return -20;\n    }\n}\n","function_prediction":"int nif_detect_type_name_conflict(char *str) {\n  if (__ctype_b_loc()[(unsigned char)str[0]] & (1 << 3))\n    return 10;\n  else if (str[0] == '+' || str[0] == '-' || str[0] == 'e' || str[0] == 'E')\n    return 11;\n  else\n    return 12;\n}","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":1,"function":"char nie_convert_init_letter(const char *nie) {\n    char ret_val = -1;\n    switch (nie[0]) {\n      case 'X':\n        ret_val = '0';\n        break;\n      case 'Y':\n        ret_val = '1';\n        break;\n      case 'Z':\n        ret_val = '2';\n        break;\n      default:\n        break;\n    }\n    return ret_val;\n}\n","function_prediction":"int nie_convert_init_letter_name_conflict(const char *letter) {\n  int ret;\n\n  ret = *letter - '(';\n  if (ret < 0 || ret > 2)\n    ret = -1;\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"long prepare_nif(const char *nif) {\n    char buf_nif_no_letter[9];\n    memset(buf_nif_no_letter, 0, sizeof (buf_nif_no_letter));\n    for (size_t i = 0; i < sizeof (buf_nif_no_letter) - 1; ++i) {\n        buf_nif_no_letter[i] = nif[i];\n    }\n    int nif_type = nif_detect_type(nif);\n    if (nif_type == 20) {\n        buf_nif_no_letter[0] = nie_convert_init_letter(nif);\n    }\n    char *error_str;\n    long result = strtol(buf_nif_no_letter, &error_str, 10);\n    if (error_str[0]) {\n        result = -20;\n    }\n    return result;\n}\n","function_prediction":"int prepare_nif_name_conflict(char *nif) {\n  char *endptr;\n  int n;\n\n  if (__ctype_b_loc()[(unsigned char)nif[0]] & (1 << 3))\n    nif++;\n\n  if (nif[0] == 'A' || nif[0] == 'B' || nif[0] == 'C')\n    nif -= 2;\n\n  n = strtol(nif, &endptr, 10);\n\n  if (*endptr != '\\0')\n    return -20;\n\n  return n;\n}","pass":0,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":1,"function":"int nif_check_integrity(const char *nif) {\n    size_t nif_size = strlen(nif);\n    if (nif_size != 9) {\n        return -10;\n    }\n    long num_nif = prepare_nif(nif);\n    if (num_nif == -20) {\n        return -20;\n    }\n    int rest = num_nif % 23;\n    return nif[8] == control_letter(rest) ? 1 : 0;\n}\n","function_prediction":"int nif_check_integrity_name_conflict(char *nif) {\n  if (strlen(nif) != 9)\n    return -10;\n\n  long long nif_number = prepare_nif(nif);\n\n  if (nif_number == -20)\n    return -20;\n\n  char nif_check_digit = \"KLMHVXZQWERTYUPBFGJNÑCDS\"[nif_number % 23];\n\n  return nif[8] == nif_check_digit;\n}","pass":1,"source_file":"C_COMPILE/emvigo_nif/nif.c"}
{"compilable":0,"function":"struct Node *newNode(struct Node *sentinel) {\n    struct Node *p;\n    p = (struct Node *)malloc(sizeof(struct Node));\n    if (p == ((void *)0)) {\n        fprintf(stderr, \"Memory allocation error...\\n\");\n        exit(1);\n    }\n    p->label = 0;\n    p->data = 0;\n    p->leftSon = sentinel;\n    p->rightSon = sentinel;\n    p->father = sentinel;\n    p->colour = 0;\n    return p;\n}\n","function_prediction":"Node *newNode_name_conflict(Point p) {\n  Node *node = (Node *)malloc(sizeof(Node));\n  if (node == NULL) {\n    fwrite(\"Memory allocation error...\\n\", 1, 27, stderr);\n    exit(1);\n  }\n  node->left = NULL;\n  node->right = NULL;\n  node->p = p;\n  node->x = p.x;\n  node->y = p.y;\n  return node;\n}","pass":0,"source_file":"C_COMPILE/akrzemi1_Mach7/code/msvc/RedBlackTree/AnotherRBTree.c"}
{"compilable":0,"function":"cpu_t init_cpu(uint8_t *opcodes, uint16_t size, uint16_t start_address) {\n    cpu_t cpu = {};\n    int i = 0;\n    cpu.memory_pointer = start_address;\n    while (cpu.memory_pointer < start_address + size && cpu.memory_pointer < 65535)\n        {\n            cpu.memory[cpu.memory_pointer++] = opcodes[i++];\n        }\n    cpu.memory_pointer = start_address;\n    return cpu;\n}\n","function_prediction":"void init_cpu(struct cpu *cpu, const char *name, unsigned short size,\n              unsigned short start) {\n  char *mem = memset(cpu->mem, 0, 128 * 1024);\n  unsigned short i;\n\n  for (i = start; i < start + size && i < 65535; i++)\n    mem[i] = name[i - start];\n\n  memcpy(cpu->name, mem, 128 * 1024);\n}","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"uint16_t concat_numbers(uint8_t arg1, uint8_t arg2) {\n    return (arg1 << 8) + arg2;\n}\n","function_prediction":"uint16_t concat_numbers_name_conflict(uint8_t high, uint8_t low) { return (high << 8) + low; }","pass":1,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":0,"function":"uint16_t get_address_from_registers(cpu_t *cpu, register_t r1, register_t r2) {\n    return concat_numbers(cpu->registers[r1], cpu->registers[r2]);\n}\n","function_prediction":"uint16_t get_address_from_registers(uint8_t *registers, uint8_t low_reg,\n                                    uint8_t high_reg) {\n  return (registers[high_reg] << 8) + registers[low_reg];\n}","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"uint8_t pop_stack(cpu_t *cpu) {\n    return cpu->stack[cpu->stack_pointer--];\n}\n","function_prediction":"char pop_stack_name_conflict(char *stack) {\n  unsigned short *sp = (unsigned short *)(stack + 0x20000);\n  return stack[*sp--];\n}","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":0,"function":"int execute_command(cpu_t *cpu, code_t command) {\n    uint16_t b_address = get_address_from_registers(cpu, REG_C, REG_B);\n    uint16_t d_address = get_address_from_registers(cpu, REG_E, REG_D);\n    uint16_t h_address = get_address_from_registers(cpu, REG_L, REG_H);\n    uint8_t next_byte = cpu->memory[cpu->memory_pointer + 1];\n    switch (command) {\n      case ADD_A:\n        cpu->registers[REG_A] += cpu->registers[REG_A];\n        break;\n      case ADD_B:\n        cpu->registers[REG_A] += cpu->registers[REG_B];\n        break;\n      case ADD_C:\n        cpu->registers[REG_A] += cpu->registers[REG_C];\n        break;\n      case ADD_D:\n        cpu->registers[REG_A] += cpu->registers[REG_D];\n        break;\n      case ADD_E:\n        cpu->registers[REG_A] += cpu->registers[REG_E];\n        break;\n      case ADD_H:\n        cpu->registers[REG_A] += cpu->registers[REG_H];\n        break;\n      case ADD_L:\n        cpu->registers[REG_A] += cpu->registers[REG_L];\n        break;\n      case ADD_M:\n        cpu->registers[REG_A] += cpu->memory[h_address];\n        break;\n      case ADI_D8:\n        cpu->registers[REG_A] += cpu->memory[++cpu->memory_pointer];\n        break;\n      case ADC_A:\n        cpu->registers[REG_A] += cpu->registers[REG_A] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_B:\n        cpu->registers[REG_A] += cpu->registers[REG_B] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_C:\n        cpu->registers[REG_A] += cpu->registers[REG_C] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_D:\n        cpu->registers[REG_A] += cpu->registers[REG_D] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_E:\n        cpu->registers[REG_A] += cpu->registers[REG_E] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_H:\n        cpu->registers[REG_A] += cpu->registers[REG_H] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_L:\n        cpu->registers[REG_A] += cpu->registers[REG_L] + cpu->flags[CARRY_FLAG];\n        break;\n      case ADC_M:\n        cpu->registers[REG_A] += cpu->memory[h_address] + cpu->flags[CARRY_FLAG];\n        break;\n      case ACI_D8:\n        cpu->registers[REG_A] += cpu->memory[++cpu->memory_pointer] + cpu->flags[CARRY_FLAG];\n        break;\n      case ANA_A:\n        cpu->registers[REG_A] &= cpu->registers[REG_A];\n        break;\n      case ANA_B:\n        cpu->registers[REG_A] &= cpu->registers[REG_B];\n        break;\n      case ANA_C:\n        cpu->registers[REG_A] &= cpu->registers[REG_C];\n        break;\n      case ANA_D:\n        cpu->registers[REG_A] &= cpu->registers[REG_D];\n        break;\n      case ANA_E:\n        cpu->registers[REG_A] &= cpu->registers[REG_E];\n        break;\n      case ANA_H:\n        cpu->registers[REG_A] &= cpu->registers[REG_H];\n        break;\n      case ANA_L:\n        cpu->registers[REG_A] &= cpu->registers[REG_L];\n        break;\n      case ANA_M:\n        cpu->registers[REG_A] &= cpu->memory[h_address];\n        break;\n      case ANI_D8:\n        cpu->registers[REG_A] &= cpu->memory[++cpu->memory_pointer];\n        break;\n      case CALL_A16:\n        break;\n      case CZ_A16:\n        break;\n      case CNZ_A16:\n        break;\n      case CP_A16:\n        break;\n      case CM_A16:\n        break;\n      case CC_A16:\n        break;\n      case CNC_A16:\n        break;\n      case CPE_A16:\n        break;\n      case CPO_A16:\n        break;\n      case CMA:\n        cpu->registers[REG_A] = ~cpu->registers[REG_A];\n        break;\n      case CMC:\n        cpu->flags[CARRY_FLAG] = ~cpu->flags[CARRY_FLAG];\n        break;\n      case CMP_A:\n        set_flag(cpu, ZERO_FLAG, 1);\n        break;\n      case CMP_B:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_B] - cpu->registers[REG_A]));\n        break;\n      case CMP_C:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_C] - cpu->registers[REG_A]));\n        break;\n      case CMP_D:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_D] - cpu->registers[REG_A]));\n        break;\n      case CMP_E:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_C] - cpu->registers[REG_A]));\n        break;\n      case CMP_H:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_H] - cpu->registers[REG_A]));\n        break;\n      case CMP_L:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->registers[REG_L] - cpu->registers[REG_A]));\n        break;\n      case CMP_M:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->memory[h_address] - cpu->registers[REG_A]));\n        break;\n      case CPI_D8:\n        set_flag(cpu, ZERO_FLAG, (bool)(cpu->memory[++cpu->memory_pointer] - cpu->registers[REG_A]));\n        break;\n      case DAA:\n        break;\n      case DAD_B:\n        b_address += h_address;\n        break;\n      case DAD_D:\n        d_address += h_address;\n        break;\n      case DAD_H:\n        h_address += h_address;\n        break;\n      case DAD_SP:\n        cpu->stack_pointer += h_address;\n        break;\n      case DCR_A:\n        cpu->registers[REG_A]--;\n        break;\n      case DCR_B:\n        cpu->registers[REG_B]--;\n        break;\n      case DCR_C:\n        cpu->registers[REG_C]--;\n        break;\n      case DCR_D:\n        cpu->registers[REG_D]--;\n        break;\n      case DCR_E:\n        cpu->registers[REG_E]--;\n        break;\n      case DCR_H:\n        cpu->registers[REG_H]--;\n        break;\n      case DCR_L:\n        cpu->registers[REG_L]--;\n        break;\n      case DCR_M:\n        cpu->memory[h_address]--;\n        break;\n      case DCX_B:\n        b_address--;\n        break;\n      case DCX_D:\n        d_address--;\n        break;\n      case DCX_H:\n        h_address--;\n        break;\n      case DCX_SP:\n        cpu->stack_pointer--;\n        break;\n      case DI:\n        cpu->interrupts_enabled = 0;\n        break;\n      case EI:\n        cpu->interrupts_enabled = 1;\n        break;\n      case IN_PP:\n        break;\n      case INR_A:\n        cpu->registers[REG_A]++;\n        break;\n      case INR_B:\n        cpu->registers[REG_B]++;\n        break;\n      case INR_C:\n        cpu->registers[REG_C]++;\n        break;\n      case INR_D:\n        cpu->registers[REG_D]++;\n        break;\n      case INR_E:\n        cpu->registers[REG_E]++;\n        break;\n      case INR_H:\n        cpu->registers[REG_H]++;\n        break;\n      case INR_L:\n        cpu->registers[REG_L]++;\n        break;\n      case INR_M:\n        cpu->memory[h_address]++;\n        break;\n      case INX_B:\n        b_address++;\n        break;\n      case INX_D:\n        d_address++;\n        break;\n      case INX_H:\n        h_address++;\n        break;\n      case INX_SP:\n        cpu->stack_pointer++;\n        break;\n      case JMP_A16:\n        cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JZ_A16:\n        if (cpu->flags[ZERO_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JNZ_A16:\n        if (!cpu->flags[ZERO_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JP_A16:\n        break;\n      case JM_A16:\n        break;\n      case JC_A16:\n        if (cpu->flags[CARRY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JNC_A16:\n        if (!cpu->flags[CARRY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JPE_A16:\n        if (cpu->flags[PARITY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case JPO_A16:\n        if (!cpu->flags[PARITY_FLAG])\n            cpu->memory_pointer = concat_numbers(cpu->memory[cpu->memory_pointer + 2], cpu->memory[cpu->memory_pointer + 1]) - 1;\n        break;\n      case LDA_A16:\n        cpu->registers[REG_A] = cpu->memory[concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer])];\n        break;\n      case LDAX_B:\n        cpu->registers[REG_A] = cpu->memory[b_address];\n        break;\n      case LDAX_D:\n        cpu->registers[REG_A] = cpu->memory[d_address];\n        break;\n      case LHLD_A16:\n        cpu->registers[REG_L] = (uint8_t)(cpu->memory[h_address] & 255);\n        cpu->registers[REG_H] = (uint8_t)(cpu->memory[h_address] >> 8);\n        break;\n      case LXI_B_D16:\n        cpu->registers[REG_C] = cpu->memory[++cpu->memory_pointer];\n        cpu->registers[REG_B] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case LXI_H_D16:\n        cpu->registers[REG_L] = cpu->memory[++cpu->memory_pointer];\n        cpu->registers[REG_H] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case LXI_SP_D16:\n        cpu->stack_pointer = concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer]);\n        break;\n      case MOV_A_A:\n        cpu->registers[REG_A] = cpu->registers[REG_A];\n        break;\n      case MOV_A_B:\n        cpu->registers[REG_A] = cpu->registers[REG_B];\n        break;\n      case MOV_A_C:\n        cpu->registers[REG_A] = cpu->registers[REG_C];\n        break;\n      case MOV_A_D:\n        cpu->registers[REG_A] = cpu->registers[REG_D];\n        break;\n      case MOV_A_E:\n        cpu->registers[REG_A] = cpu->registers[REG_E];\n        break;\n      case MOV_A_H:\n        cpu->registers[REG_A] = cpu->registers[REG_H];\n        break;\n      case MOV_A_L:\n        cpu->registers[REG_A] = cpu->registers[REG_L];\n        break;\n      case MOV_A_M:\n        cpu->registers[REG_A] = cpu->memory[h_address];\n        break;\n      case MOV_B_A:\n        cpu->registers[REG_B] = cpu->registers[REG_A];\n        break;\n      case MOV_B_B:\n        cpu->registers[REG_B] = cpu->registers[REG_B];\n        break;\n      case MOV_B_C:\n        cpu->registers[REG_B] = cpu->registers[REG_C];\n        break;\n      case MOV_B_D:\n        cpu->registers[REG_B] = cpu->registers[REG_D];\n        break;\n      case MOV_B_E:\n        cpu->registers[REG_B] = cpu->registers[REG_E];\n        break;\n      case MOV_B_H:\n        cpu->registers[REG_B] = cpu->registers[REG_H];\n        break;\n      case MOV_B_L:\n        cpu->registers[REG_B] = cpu->registers[REG_L];\n        break;\n      case MOV_B_M:\n        cpu->registers[REG_B] = cpu->memory[h_address];\n        break;\n      case MOV_C_A:\n        cpu->registers[REG_C] = cpu->registers[REG_A];\n        break;\n      case MOV_C_B:\n        cpu->registers[REG_C] = cpu->registers[REG_B];\n        break;\n      case MOV_C_C:\n        cpu->registers[REG_C] = cpu->registers[REG_C];\n        break;\n      case MOV_C_D:\n        cpu->registers[REG_C] = cpu->registers[REG_D];\n        break;\n      case MOV_C_E:\n        cpu->registers[REG_C] = cpu->registers[REG_E];\n        break;\n      case MOV_C_H:\n        cpu->registers[REG_C] = cpu->registers[REG_H];\n        break;\n      case MOV_C_L:\n        cpu->registers[REG_C] = cpu->registers[REG_L];\n        break;\n      case MOV_C_M:\n        cpu->registers[REG_C] = cpu->memory[h_address];\n        break;\n      case MOV_D_A:\n        cpu->registers[REG_D] = cpu->registers[REG_A];\n        break;\n      case MOV_D_B:\n        cpu->registers[REG_D] = cpu->registers[REG_B];\n        break;\n      case MOV_D_C:\n        cpu->registers[REG_D] = cpu->registers[REG_C];\n        break;\n      case MOV_D_D:\n        cpu->registers[REG_D] = cpu->registers[REG_D];\n        break;\n      case MOV_D_E:\n        cpu->registers[REG_D] = cpu->registers[REG_E];\n        break;\n      case MOV_D_H:\n        cpu->registers[REG_D] = cpu->registers[REG_H];\n        break;\n      case MOV_D_L:\n        cpu->registers[REG_D] = cpu->registers[REG_L];\n        break;\n      case MOV_D_M:\n        cpu->registers[REG_D] = cpu->memory[h_address];\n        break;\n      case MOV_E_A:\n        cpu->registers[REG_E] = cpu->registers[REG_A];\n        break;\n      case MOV_E_B:\n        cpu->registers[REG_E] = cpu->registers[REG_B];\n        break;\n      case MOV_E_C:\n        cpu->registers[REG_E] = cpu->registers[REG_C];\n        break;\n      case MOV_E_D:\n        cpu->registers[REG_E] = cpu->registers[REG_D];\n        break;\n      case MOV_E_E:\n        cpu->registers[REG_E] = cpu->registers[REG_E];\n        break;\n      case MOV_E_H:\n        cpu->registers[REG_E] = cpu->registers[REG_H];\n        break;\n      case MOV_E_L:\n        cpu->registers[REG_E] = cpu->registers[REG_L];\n        break;\n      case MOV_E_M:\n        cpu->registers[REG_E] = cpu->memory[h_address];\n        break;\n      case MOV_H_A:\n        cpu->registers[REG_H] = cpu->registers[REG_A];\n        break;\n      case MOV_H_B:\n        cpu->registers[REG_H] = cpu->registers[REG_B];\n        break;\n      case MOV_H_C:\n        cpu->registers[REG_H] = cpu->registers[REG_C];\n        break;\n      case MOV_H_D:\n        cpu->registers[REG_H] = cpu->registers[REG_D];\n        break;\n      case MOV_H_E:\n        cpu->registers[REG_H] = cpu->registers[REG_E];\n        break;\n      case MOV_H_H:\n        cpu->registers[REG_H] = cpu->registers[REG_H];\n        break;\n      case MOV_H_L:\n        cpu->registers[REG_H] = cpu->registers[REG_L];\n        break;\n      case MOV_H_M:\n        cpu->registers[REG_H] = cpu->memory[h_address];\n        break;\n      case MOV_L_A:\n        cpu->registers[REG_L] = cpu->registers[REG_A];\n        break;\n      case MOV_L_B:\n        cpu->registers[REG_L] = cpu->registers[REG_B];\n        break;\n      case MOV_L_C:\n        cpu->registers[REG_L] = cpu->registers[REG_C];\n        break;\n      case MOV_L_D:\n        cpu->registers[REG_L] = cpu->registers[REG_D];\n        break;\n      case MOV_L_E:\n        cpu->registers[REG_L] = cpu->registers[REG_E];\n        break;\n      case MOV_L_H:\n        cpu->registers[REG_L] = cpu->registers[REG_H];\n        break;\n      case MOV_L_L:\n        cpu->registers[REG_L] = cpu->registers[REG_L];\n        break;\n      case MOV_L_M:\n        cpu->registers[REG_L] = cpu->memory[h_address];\n        break;\n      case MOV_M_A:\n        cpu->memory[h_address] = cpu->registers[REG_A];\n        break;\n      case MOV_M_B:\n        cpu->memory[h_address] = cpu->registers[REG_B];\n        break;\n      case MOV_M_C:\n        cpu->memory[h_address] = cpu->registers[REG_C];\n        break;\n      case MOV_M_D:\n        cpu->memory[h_address] = cpu->registers[REG_D];\n        break;\n      case MOV_M_E:\n        cpu->memory[h_address] = cpu->registers[REG_E];\n        break;\n      case MOV_M_H:\n        cpu->memory[h_address] = cpu->registers[REG_H];\n        break;\n      case MOV_M_L:\n        cpu->memory[h_address] = cpu->registers[REG_L];\n        break;\n      case MVI_A_D8:\n        cpu->registers[REG_A] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_B_D8:\n        cpu->registers[REG_B] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_C_D8:\n        cpu->registers[REG_C] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_D_D8:\n        cpu->registers[REG_D] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_E_D8:\n        cpu->registers[REG_E] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_H_D8:\n        cpu->registers[REG_H] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_L_D8:\n        cpu->registers[REG_L] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case MVI_M_D8:\n        cpu->memory[h_address] = cpu->memory[++cpu->memory_pointer];\n        break;\n      case ORA_A:\n        cpu->registers[REG_A] |= cpu->registers[REG_A];\n        break;\n      case ORA_B:\n        cpu->registers[REG_A] |= cpu->registers[REG_B];\n        break;\n      case ORA_C:\n        cpu->registers[REG_A] |= cpu->registers[REG_C];\n        break;\n      case ORA_D:\n        cpu->registers[REG_A] |= cpu->registers[REG_D];\n        break;\n      case ORA_E:\n        cpu->registers[REG_A] |= cpu->registers[REG_E];\n        break;\n      case ORA_H:\n        cpu->registers[REG_A] |= cpu->registers[REG_H];\n        break;\n      case ORA_L:\n        cpu->registers[REG_A] |= cpu->registers[REG_L];\n        break;\n      case ORA_M:\n        cpu->registers[REG_A] |= cpu->memory[h_address];\n        break;\n      case ORI_D8:\n        cpu->registers[REG_A] |= cpu->memory[++cpu->memory_pointer];\n        break;\n      case OUT_PP:\n        break;\n      case PCHL:\n        break;\n      case POP_B:\n        break;\n      case POP_D:\n        break;\n      case POP_H:\n        break;\n      case POP_PSW:\n        break;\n      case PUSH_B:\n        break;\n      case PUSH_D:\n        break;\n      case PUSH_H:\n        break;\n      case PUSH_PSW:\n        break;\n      case RAL:\n        break;\n      case RAR:\n        break;\n      case RLC:\n        break;\n      case RRC:\n        break;\n      case RIM:\n        break;\n      case RET:\n        break;\n      case RZ:\n        break;\n      case RNZ:\n        break;\n      case RP:\n        break;\n      case RM:\n        break;\n      case RC:\n        break;\n      case RNC:\n        break;\n      case RPE:\n        break;\n      case RPO:\n        break;\n      case RST_0:\n        break;\n      case RST_1:\n        break;\n      case RST_2:\n        break;\n      case RST_3:\n        break;\n      case RST_4:\n        break;\n      case RST_5:\n        break;\n      case RST_6:\n        break;\n      case RST_7:\n        break;\n      case SIM:\n        break;\n      case SPHL:\n        cpu->stack_pointer = h_address;\n        break;\n      case SHLD_A16:\n        cpu->memory[++cpu->memory_pointer] = cpu->registers[REG_L];\n        cpu->memory[++cpu->memory_pointer] = cpu->registers[REG_H];\n        break;\n      case STA_A16:\n        cpu->memory[concat_numbers(cpu->memory[++cpu->memory_pointer], cpu->memory[++cpu->memory_pointer])] = cpu->registers[REG_A];\n        break;\n      case STAX_B:\n        cpu->memory[b_address] = cpu->registers[REG_A];\n        break;\n      case STAX_D:\n        cpu->memory[d_address] = cpu->registers[REG_A];\n        break;\n      case STC:\n        set_flag(cpu, CARRY_FLAG, 1);\n        break;\n      case SUB_A:\n        cpu->registers[REG_A] -= cpu->registers[REG_A];\n        break;\n      case SUB_B:\n        cpu->registers[REG_A] -= cpu->registers[REG_B];\n        break;\n      case SUB_C:\n        cpu->registers[REG_A] -= cpu->registers[REG_C];\n        break;\n      case SUB_D:\n        cpu->registers[REG_A] -= cpu->registers[REG_D];\n        break;\n      case SUB_E:\n        cpu->registers[REG_A] -= cpu->registers[REG_E];\n        break;\n      case SUB_H:\n        cpu->registers[REG_A] -= cpu->registers[REG_H];\n        break;\n      case SUB_L:\n        cpu->registers[REG_A] -= cpu->registers[REG_E];\n        break;\n      case SUB_M:\n        cpu->registers[REG_A] -= cpu->memory[h_address];\n        break;\n      case SUI_D8:\n        cpu->registers[REG_A] -= cpu->memory[++cpu->memory_pointer];\n        break;\n      case SBB_A:\n        break;\n      case SBB_B:\n        break;\n      case SBB_C:\n        break;\n      case SBB_D:\n        break;\n      case SBB_E:\n        break;\n      case SBB_H:\n        break;\n      case SBB_L:\n        break;\n      case SBB_M:\n        break;\n      case SBI_D8:\n        break;\n      case XCHG:\n        push_stack(cpu, cpu->registers[REG_E]);\n        push_stack(cpu, cpu->registers[REG_D]);\n        cpu->registers[REG_E] = cpu->registers[REG_L];\n        cpu->registers[REG_D] = cpu->registers[REG_H];\n        cpu->registers[REG_L] = pop_stack(cpu);\n        cpu->registers[REG_H] = pop_stack(cpu);\n        break;\n      case XTHL:\n        break;\n      case XRA_A:\n        cpu->registers[REG_A] ^= cpu->registers[REG_A];\n        break;\n      case XRA_B:\n        cpu->registers[REG_A] ^= cpu->registers[REG_B];\n        break;\n      case XRA_C:\n        cpu->registers[REG_A] ^= cpu->registers[REG_C];\n        break;\n      case XRA_D:\n        cpu->registers[REG_A] ^= cpu->registers[REG_D];\n        break;\n      case XRA_E:\n        cpu->registers[REG_A] ^= cpu->registers[REG_E];\n        break;\n      case XRA_H:\n        cpu->registers[REG_A] ^= cpu->registers[REG_H];\n        break;\n      case XRA_L:\n        cpu->registers[REG_A] ^= cpu->registers[REG_L];\n        break;\n      case XRA_M:\n        cpu->registers[REG_A] ^= cpu->memory[h_address];\n        break;\n      case XRI_D8:\n        cpu->registers[REG_A] ^= cpu->memory[++cpu->memory_pointer];\n        break;\n      case NOP:\n      case HLT:\n        return 0;\n    }\n    cpu->program_counter = cpu->memory_pointer++;\n    return 0;\n}\n","function_prediction":"int execute_command_name_conflict(unsigned char *memory, unsigned char command) {\n  unsigned short pc = memory[0x20014];\n  unsigned short pc_next = pc + 1;\n  unsigned short pc_next_next = pc + 2;\n  unsigned short pc_next_next_next = pc + 3;\n  unsigned short pc_next_next_next_next = pc + 4;\n  unsigned short pc_next_next_next_next_next = pc + 5;\n  unsigned short pc_next_next_next_next_next_next = pc + 6;\n  unsigned short pc_next_next_next_next_next_next_next = pc + 7;\n  unsigned short pc_next_next_next_next_next_next_next_next = pc + 8;\n  unsigned short pc_next_next_next_next_next_next_next_next_next = pc + 9;\n  unsigned short pc_next_next_next_next_next_next_next_next_next_next = pc + 10;\n  unsigned short pc_next_next_next_next_next_next_next_next_next_next_next =\n      pc + 11;\n  unsigned short\n      pc_next_next_next_next_next_next_next_next_next_next_next_next = pc + 12;\n  unsigned short\n      pc_next_next_next_next_next_next_next_next_next_next_next_next_next =\n          pc + 13;\n  unsigned short\n      pc_next_next_next_next_next_next_next_next_next_next_next_next_next_next =\n          pc + 14;\n  unsigned short\n      pc_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next =\n          pc + 15;\n  unsigned short\n      pc_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next =\n          pc + 16;\n  unsigned short\n      pc_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next =\n          pc + 17;\n  unsigned short pc_next_next_next_next_next","pass":0,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"int execute(cpu_t *cpu) {\n    while (cpu->memory[cpu->memory_pointer] != HLT && cpu->memory_pointer < 65535)\n        {\n            execute_command(cpu, (code_t)cpu->memory[cpu->memory_pointer]);\n        }\n    return 0;\n}\n","function_prediction":"int execute_name_conflict(char *memory) {\n  unsigned short pc = *(unsigned short *)(memory + 0x20014);\n  char command;\n\n  while (pc != 0xffff) {\n    command = *(memory + pc + 0x0d);\n    if (command == 'v') {\n      break;\n    }\n    execute_name_conflict_command(memory, command);\n    pc = *(unsigned short *)(memory + 0x20014);\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/gsedometov_KR580-emulator/CPU.c"}
{"compilable":1,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"int k_errno_name_conflict(void) { return *__errno_location(); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"char *k_strerr_name_conflict(void) { return strerror(*__errno_location()); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"int k_chbindir_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len <= 0)\n    return 1;\n\n  while (len > 0 && path[len - 1] != '/')\n    path[--len] = 0;\n\n  if (len > 0)\n    path[len - 1] = 0;\n\n  return chdir(path);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"int k_core_dump_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len > 0) {\n    while (len-- && path[len] != '/')\n      path[len] = 0;\n    if (len)\n      path[len] = 0;\n    chdir(path);\n  }\n\n  struct rlimit rlim = {-1, -1};\n  setrlimit(RLIMIT_CORE, &rlim);\n  getrlimit(RLIMIT_NPROC, &rlim);\n\n  struct sigaction act = {\n      .sa_handler = k_core_handler,\n      .sa_flags = SA_RESETHAND,\n  };\n  sigemptyset(&act.sa_mask);\n  sigaction(SIGSEGV, &act, NULL);\n  sigaction(SIGBUS, &act, NULL);\n\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"void k_demon_handler(int sig) {\n  if (sig == 15) {\n    puts(\"SIGTERM\");\n    if (g_exit_cb) {\n      g_exit_cb(g_exit_arg);\n    }\n    signal(15, NULL);\n    exit(0);\n  }\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"int ksock_init_name_conflict() {\n  struct sigaction sa;\n  sa.sa_handler = (void *)1;\n  sa.sa_flags = 0;\n  for (int i = 0; i < 18; i++)\n    sa.sa_mask[i] = 0;\n  sigaction(13, &sa, NULL);\n\n  struct rlimit rl;\n  rl.rlim_cur = 1024;\n  rl.rlim_max = 1024;\n  setrlimit(RLIMIT_NOFILE, &rl);\n  getrlimit(RLIMIT_NOFILE, &rl);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_non_blocking_name_conflict(int fd) {\n  int flags;\n\n  flags = fcntl(fd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 11);\n  flags = fcntl(fd, 4, flags);\n\n  return flags;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_close_onexec_name_conflict(int sockfd) {\n  int flags = fcntl(sockfd, 3);\n  if (flags == -1)\n    return 1;\n  flags |= (1 << 0);\n  if (fcntl(sockfd, 4, flags) == -1)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_shutdown_name_conflict(int sock, int how) {\n  if (shutdown(sock, how) != 0)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"int ksock_close_name_conflict(int fd) {\n  int ret;\n  while ((ret = close(fd)) == -1 && *__errno_location() == 4)\n    ;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_ioctl_name_conflict(int fd, int cmd) {\n  int ret;\n\n  ret = ioctl(fd, cmd);\n  if (ret) {\n    printf(\"ioctl :%s\\n\", strerror(*__errno_location()));\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"int ksock_from_addr_name_conflict(struct sockaddr_in addr, int addrlen, char *ip, int *port) {\n  unsigned short port_tmp = addr.sin_port;\n  unsigned char *p = (unsigned char *)&port_tmp;\n  unsigned char tmp;\n\n  strcpy(ip, inet_ntoa(addr.sin_addr));\n  tmp = p[0];\n  p[0] = p[1];\n  p[1] = tmp;\n  *port = port_tmp;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"int ksock_to_addr_name_conflict(struct sockaddr_in *addr, char *ip, unsigned short port) {\n  addr->sin_family = 2;\n  addr->sin_port = (port << 8) | (port >> 8);\n  addr->sin_addr.s_addr = inet_addr(ip);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_reuse_name_conflict(int fd) {\n  int optval = 1;\n  if (setsockopt(fd, 1, 2, &optval, sizeof(optval)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_sendbuf_name_conflict(int fd, int size) {\n  int ret;\n\n  ret = setsockopt(fd, 1, 7, &size, sizeof(size));\n  if (ret == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_alive_name_conflict(int fd, int idle, int interval, int count) {\n  int ret;\n  int alive = 1;\n\n  ret = setsockopt(fd, 1, 9, &alive, sizeof(alive));\n  if (ret == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 4, &idle, sizeof(idle));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 5, &interval, sizeof(interval));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 6, &count, sizeof(count));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int ksock_init_fd_name_conflict() {\n  int fd = socket(2, 1, 0);\n  if (fd == -1) {\n    printf(\"socket :%d\\n\", *__errno_location());\n    return -1;\n  }\n\n  int on = 1;\n  if (setsockopt(fd, 1, 2, &on, sizeof(on)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return -1;\n  }\n\n  return fd;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_bind_name_conflict(int sock, unsigned short port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = port;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_listen_at_name_conflict(int sock, unsigned short port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = port;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  if (listen(sock, 4096) == -1) {\n    printf(\"listen :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"int ksock_accept_name_conflict(int fd, char *ip, int *port) {\n  int ret;\n  struct sockaddr_in client;\n  socklen_t len = sizeof(client);\n  ret = accept(fd, (struct sockaddr *)&client, &len);\n  if (ret == -1) {\n    printf(\"accept :%d, fd:%d\\n\", *__errno_location(), fd);\n    return ret;\n  }\n  strcpy(ip, inet_ntoa(client.sin_addr));\n  *port = (client.sin_port >> 8) | (client.sin_port << 8);\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_connect_name_conflict(int sock, char *ip, int port) {\n  struct sockaddr_in addr;\n  int ret;\n\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = inet_addr(ip);\n  addr.sin_port = (port >> 8) | (port << 8);\n\n  ret = connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret == -1) {\n    printf(\"connect :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"int k_errno_name_conflict(void) { return *__errno_location(); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"char *k_strerr_name_conflict(void) { return strerror(*__errno_location()); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"int k_chbindir_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len <= 0)\n    return 1;\n\n  while (len > 0 && path[len - 1] != '/')\n    path[--len] = 0;\n\n  if (len > 0)\n    path[len - 1] = 0;\n\n  return chdir(path);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"int k_core_dump_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len > 0) {\n    while (path[--len] != '/' && len)\n      path[len] = 0;\n    if (len)\n      path[len] = 0;\n    chdir(path);\n  }\n\n  struct rlimit rlim = {-1, -1};\n  setrlimit(RLIMIT_CORE, &rlim);\n  getrlimit(RLIMIT_NPROC, &rlim);\n\n  struct sigaction act = {\n      .sa_handler = k_core_handler,\n      .sa_flags = SA_RESETHAND,\n  };\n  sigemptyset(&act.sa_mask);\n  sigaction(SIGSEGV, &act, NULL);\n  sigaction(SIGBUS, &act, NULL);\n\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"void k_demon_handler(int sig) {\n  if (sig == 15) {\n    puts(\"SIGTERM\");\n    if (g_exit_cb) {\n      g_exit_cb(g_exit_arg);\n    }\n    signal(15, NULL);\n    exit(0);\n  }\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"int ksock_init_name_conflict() {\n  struct sigaction sa;\n  sa.sa_handler = (void *)1;\n  sa.sa_flags = 0;\n  for (int i = 0; i < 18; i++)\n    sa.sa_mask[i] = 0;\n  sigaction(13, &sa, NULL);\n\n  struct rlimit rl;\n  rl.rlim_cur = 1024;\n  rl.rlim_max = 1024;\n  setrlimit(RLIMIT_NOFILE, &rl);\n  getrlimit(RLIMIT_NOFILE, &rl);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_non_blocking_name_conflict(int fd) {\n  int flags;\n\n  flags = fcntl(fd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 11);\n  flags = fcntl(fd, 4, flags);\n\n  return flags;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_close_onexec_name_conflict(int sockfd) {\n  int flags = fcntl(sockfd, 3);\n  if (flags == -1)\n    return 1;\n  flags |= (1 << 0);\n  if (fcntl(sockfd, 4, flags) == -1)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_shutdown_name_conflict(int sock, int how) {\n  if (shutdown(sock, how) != 0)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"int ksock_close_name_conflict(int fd) {\n  int ret;\n  while ((ret = close(fd)) == -1 && *__errno_location() == 4)\n    ;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_ioctl_name_conflict(int fd, int cmd) {\n  int ret;\n\n  ret = ioctl(fd, cmd);\n  if (ret) {\n    printf(\"ioctl :%s\\n\", strerror(*__errno_location()));\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"int ksock_from_addr_name_conflict(struct sockaddr_in addr, int addrlen, char *ip, int *port) {\n  unsigned short port_tmp = addr.sin_port;\n  unsigned char *p = (unsigned char *)&port_tmp;\n  unsigned char tmp;\n\n  strcpy(ip, inet_ntoa(addr.sin_addr));\n  tmp = p[0];\n  p[0] = p[1];\n  p[1] = tmp;\n  *port = port_tmp;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"int ksock_to_addr_name_conflict(struct sockaddr_in *addr, char *ip, unsigned short port) {\n  addr->sin_family = 2;\n  addr->sin_port = (port << 8) | (port >> 8);\n  addr->sin_addr.s_addr = inet_addr(ip);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_reuse_name_conflict(int fd) {\n  int optval = 1;\n  if (setsockopt(fd, 1, 2, &optval, sizeof(optval)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_sendbuf_name_conflict(int fd, int size) {\n  int ret;\n\n  ret = setsockopt(fd, 1, 7, &size, sizeof(size));\n  if (ret == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_alive_name_conflict(int fd, int idle, int interval, int count) {\n  int ret;\n  int alive = 1;\n\n  ret = setsockopt(fd, 1, 9, &alive, sizeof(alive));\n  if (ret == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 4, &idle, sizeof(idle));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 5, &interval, sizeof(interval));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 6, &count, sizeof(count));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int ksock_init_fd_name_conflict() {\n  int fd = socket(2, 1, 0);\n  if (fd == -1) {\n    printf(\"socket :%d\\n\", *__errno_location());\n    return -1;\n  }\n\n  int on = 1;\n  if (setsockopt(fd, 1, 2, &on, sizeof(on)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return -1;\n  }\n\n  return fd;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_bind_name_conflict(int sock, unsigned short port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = port;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_listen_at_name_conflict(int sock, unsigned short port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = port;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  if (listen(sock, 4096) == -1) {\n    printf(\"listen :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"int ksock_accept_name_conflict(int fd, char *ip, int *port) {\n  int ret;\n  struct sockaddr_in client;\n  socklen_t len = sizeof(client);\n  ret = accept(fd, (struct sockaddr *)&client, &len);\n  if (ret == -1) {\n    printf(\"accept :%d, fd:%d\\n\", *__errno_location(), fd);\n    return ret;\n  }\n  strcpy(ip, inet_ntoa(client.sin_addr));\n  *port = (client.sin_port >> 8) | (client.sin_port << 8);\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_connect_name_conflict(int sock, char *ip, int port) {\n  struct sockaddr_in addr;\n  int ret;\n\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = inet_addr(ip);\n  addr.sin_port = (port >> 8) | (port << 8);\n\n  ret = connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret == -1) {\n    printf(\"connect :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"int k_errno_name_conflict(void) { return *__errno_location(); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"char *k_strerr_name_conflict(void) { return strerror(*__errno_location()); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"int k_chbindir_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len <= 0)\n    return 1;\n\n  while (len > 0 && path[len - 1] != '/')\n    path[--len] = 0;\n\n  if (len > 0)\n    path[len - 1] = 0;\n\n  return chdir(path);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"int k_core_dump_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len > 0) {\n    while (path[--len] != '/' && len)\n      path[len] = 0;\n    if (len)\n      path[len] = 0;\n    chdir(path);\n  }\n\n  struct rlimit rlim = {-1, -1};\n  setrlimit(RLIMIT_CORE, &rlim);\n  getrlimit(RLIMIT_NPROC, &rlim);\n\n  struct sigaction act = {\n      .sa_handler = k_core_handler,\n      .sa_flags = SA_RESETHAND,\n  };\n  sigemptyset(&act.sa_mask);\n  sigaction(SIGSEGV, &act, NULL);\n  sigaction(SIGBUS, &act, NULL);\n\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"void k_demon_handler(int sig) {\n  if (sig == 15) {\n    puts(\"SIGTERM\");\n    if (g_exit_cb) {\n      g_exit_cb(g_exit_arg);\n    }\n    signal(15, NULL);\n    exit(0);\n  }\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"int ksock_init_name_conflict() {\n  struct rlimit rl;\n  struct sigaction sa;\n  sa.sa_handler = (void *)1;\n  for (int i = 0; i < 18; i++)\n    sa.sa_mask.sig[i] = 0;\n  sigaction(13, &sa, NULL);\n  rl.rlim_cur = 1024;\n  rl.rlim_max = 1024;\n  setrlimit(RLIMIT_NOFILE, &rl);\n  getrlimit(RLIMIT_NOFILE, &rl);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_non_blocking_name_conflict(int fd) {\n  int flags;\n\n  flags = fcntl(fd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 11);\n  flags = fcntl(fd, 4, flags);\n\n  return flags;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_close_onexec_name_conflict(int sockfd) {\n  int flags = fcntl(sockfd, 3);\n  if (flags == -1)\n    return 1;\n  flags |= (1 << 0);\n  if (fcntl(sockfd, 4, flags) == -1)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_shutdown_name_conflict(int sock, int how) {\n  if (shutdown(sock, how) != 0)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"int ksock_close_name_conflict(int fd) {\n  int ret;\n  while ((ret = close(fd)) == -1 && *__errno_location() == 4)\n    ;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_ioctl_name_conflict(int fd, int cmd) {\n  int ret;\n\n  ret = ioctl(fd, cmd);\n  if (ret) {\n    printf(\"ioctl :%s\\n\", strerror(*__errno_location()));\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"int ksock_from_addr_name_conflict(struct sockaddr_in addr, int addrlen, char *ip, int *port) {\n  unsigned short port_tmp = addr.sin_port;\n  unsigned char *p = (unsigned char *)&port_tmp;\n  unsigned char tmp;\n\n  strcpy(ip, inet_ntoa(addr.sin_addr));\n  tmp = p[0];\n  p[0] = p[1];\n  p[1] = tmp;\n  *port = port_tmp;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"int ksock_to_addr_name_conflict(struct sockaddr_in *addr, char *ip, unsigned short port) {\n  addr->sin_family = 2;\n  addr->sin_port = (port << 8) | (port >> 8);\n  addr->sin_addr.s_addr = inet_addr(ip);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_reuse_name_conflict(int fd) {\n  int optval = 1;\n  if (setsockopt(fd, 1, 2, &optval, sizeof(optval)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_sendbuf_name_conflict(int fd, int size) {\n  int ret;\n\n  ret = setsockopt(fd, 1, 7, &size, sizeof(size));\n  if (ret == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_alive_name_conflict(int fd, int idle, int interval, int count) {\n  int ret;\n  int alive = 1;\n\n  ret = setsockopt(fd, 1, 9, &alive, sizeof(alive));\n  if (ret == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 4, &idle, sizeof(idle));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 5, &interval, sizeof(interval));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 6, &count, sizeof(count));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int ksock_init_fd_name_conflict() {\n  int fd = socket(2, 1, 0);\n  if (fd == -1) {\n    printf(\"socket :%d\\n\", *__errno_location());\n    return -1;\n  }\n\n  int on = 1;\n  if (setsockopt(fd, 1, 2, &on, sizeof(on)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return -1;\n  }\n\n  return fd;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_bind_name_conflict(int sock, unsigned short port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = port;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_listen_at_name_conflict(int sock, unsigned short port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = port;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  if (listen(sock, 4096) == -1) {\n    printf(\"listen :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"int ksock_accept_name_conflict(int fd, char *ip, int *port) {\n  int ret;\n  struct sockaddr_in client;\n  socklen_t len = sizeof(client);\n  ret = accept(fd, (struct sockaddr *)&client, &len);\n  if (ret == -1) {\n    printf(\"accept :%d, fd:%d\\n\", *__errno_location(), fd);\n    return ret;\n  }\n  strcpy(ip, inet_ntoa(client.sin_addr));\n  *port = (client.sin_port >> 8) | (client.sin_port << 8);\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_connect_name_conflict(int sock, char *ip, int port) {\n  struct sockaddr_in addr;\n  int ret;\n\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = inet_addr(ip);\n  addr.sin_port = (port >> 8) | (port << 8);\n\n  ret = connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret == -1) {\n    printf(\"connect :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"int k_errno_name_conflict(void) { return *__errno_location(); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"char *k_strerr_name_conflict(void) { return strerror(*__errno_location()); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"int k_chbindir_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len <= 0)\n    return 1;\n\n  while (len > 0 && path[len - 1] != '/')\n    path[--len] = 0;\n\n  if (len > 0)\n    path[len - 1] = 0;\n\n  return chdir(path);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"int k_core_dump_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len > 0) {\n    while (path[--len] != '/' && len)\n      path[len] = '\\0';\n    if (len)\n      path[len] = '\\0';\n    chdir(path);\n  }\n\n  struct rlimit rlim = {-1, -1};\n  setrlimit(RLIMIT_CORE, &rlim);\n  getrlimit(RLIMIT_NPROC, &rlim);\n\n  struct sigaction act = {\n      .sa_handler = k_core_handler,\n      .sa_flags = SA_RESETHAND,\n  };\n  sigemptyset(&act.sa_mask);\n  sigaction(SIGSEGV, &act, NULL);\n  sigaction(SIGBUS, &act, NULL);\n\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"void k_demon_handler(int sig) {\n  if (sig == 15) {\n    puts(\"SIGTERM\");\n    if (g_exit_cb) {\n      g_exit_cb(g_exit_arg);\n    }\n    signal(15, NULL);\n    exit(0);\n  }\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"int ksock_init_name_conflict() {\n  struct sigaction sa;\n  sa.sa_handler = (void *)1;\n  sa.sa_flags = 0;\n  for (int i = 0; i < 18; i++)\n    sa.sa_mask[i] = 0;\n  sigaction(13, &sa, NULL);\n\n  struct rlimit rl;\n  rl.rlim_cur = 1024;\n  rl.rlim_max = 1024;\n  setrlimit(RLIMIT_NOFILE, &rl);\n  getrlimit(RLIMIT_NOFILE, &rl);\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_non_blocking_name_conflict(int fd) {\n  int flags;\n\n  flags = fcntl(fd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 11);\n  flags = fcntl(fd, 4, flags);\n\n  return flags;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_close_onexec_name_conflict(int sockfd) {\n  int flags = fcntl(sockfd, 3);\n  if (flags == -1)\n    return 1;\n  flags |= (1 << 0);\n  if (fcntl(sockfd, 4, flags) == -1)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_shutdown_name_conflict(int sock, int how) {\n  if (shutdown(sock, how) != 0)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"int ksock_close_name_conflict(int fd) {\n  int ret;\n  while ((ret = close(fd)) == -1 && *__errno_location() == 4)\n    ;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_ioctl_name_conflict(int fd, int cmd) {\n  int ret;\n\n  ret = ioctl(fd, cmd);\n  if (ret) {\n    printf(\"ioctl :%s\\n\", strerror(*__errno_location()));\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"int ksock_from_addr_name_conflict(struct sockaddr_in addr, int addrlen, char *ip, int *port) {\n  unsigned short port_tmp = addr.sin_port;\n  unsigned char *p = (unsigned char *)&port_tmp;\n  unsigned char tmp;\n\n  strcpy(ip, inet_ntoa(addr.sin_addr));\n  tmp = p[0];\n  p[0] = p[1];\n  p[1] = tmp;\n  *port = port_tmp;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"int ksock_to_addr_name_conflict(struct sockaddr_in *addr, char *ip, unsigned short port) {\n  addr->sin_family = 2;\n  addr->sin_port = (port << 8) | (port >> 8);\n  addr->sin_addr.s_addr = inet_addr(ip);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_reuse_name_conflict(int fd) {\n  int optval = 1;\n  if (setsockopt(fd, 1, 2, &optval, sizeof(optval)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_sendbuf_name_conflict(int fd, int size) {\n  int ret;\n\n  ret = setsockopt(fd, 1, 7, &size, sizeof(size));\n  if (ret == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_alive_name_conflict(int fd, int idle, int interval, int count) {\n  int ret;\n  int alive = 1;\n\n  ret = setsockopt(fd, 1, 9, &alive, sizeof(alive));\n  if (ret == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 4, &idle, sizeof(idle));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 5, &interval, sizeof(interval));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 6, &count, sizeof(count));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int ksock_init_fd_name_conflict() {\n  int fd = socket(2, 1, 0);\n  if (fd == -1) {\n    printf(\"socket :%d\\n\", *__errno_location());\n    return -1;\n  }\n\n  int on = 1;\n  if (setsockopt(fd, 1, 2, &on, sizeof(on)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return -1;\n  }\n\n  return fd;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_bind_name_conflict(int sock, unsigned short port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = port;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_listen_at_name_conflict(int sock, unsigned short port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = port;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  if (listen(sock, 4096) == -1) {\n    printf(\"listen :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"int ksock_accept_name_conflict(int fd, char *ip, int *port) {\n  int ret;\n  struct sockaddr_in client;\n  socklen_t len = sizeof(client);\n  ret = accept(fd, (struct sockaddr *)&client, &len);\n  if (ret == -1) {\n    printf(\"accept :%d, fd:%d\\n\", *__errno_location(), fd);\n    return ret;\n  }\n  strcpy(ip, inet_ntoa(client.sin_addr));\n  *port = (client.sin_port >> 8) | (client.sin_port << 8);\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_connect_name_conflict(int sock, char *ip, int port) {\n  struct sockaddr_in addr;\n  int ret;\n\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = inet_addr(ip);\n  addr.sin_port = (port >> 8) | (port << 8);\n\n  ret = connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret == -1) {\n    printf(\"connect :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_errno() {\n    return (*__errno_location());\n}\n","function_prediction":"int k_errno_name_conflict(void) { return *__errno_location(); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"char *k_strerr() {\n    return strerror((*__errno_location()));\n}\n","function_prediction":"char *k_strerr_name_conflict(void) { return strerror(*__errno_location()); }","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_chbindir() {\n    char dirbuf[256] = {0};\n    int c = readlink(\"/proc/self/exe\", dirbuf, 256);\n    if (0 >= c) {\n        return 1;\n    }\n    int index = c - 1;\n    while (dirbuf[index] != '/' && 0 != index)\n        {\n            dirbuf[index--] = '\\x00';\n        }\n    if (dirbuf[index] != '/') {\n        return 1;\n    }\n    if (0 != index) {\n        dirbuf[index] = '\\x00';\n    }\n    return chdir(dirbuf);\n}\n","function_prediction":"int k_chbindir_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len <= 0)\n    return 1;\n\n  while (len > 0 && path[len - 1] != '/')\n    path[--len] = 0;\n\n  if (len > 0)\n    path[len - 1] = 0;\n\n  return chdir(path);\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int k_core_dump() {\n    k_chbindir();\n    struct rlimit r;\n    r.rlim_cur = r.rlim_max = ((__rlim_t)-1);\n    setrlimit(RLIMIT_CORE, &r);\n    getrlimit(__RLIMIT_NPROC, &r);\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_core_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(8, &sat, ((void *)0));\n    sigaction(11, &sat, ((void *)0));\n    const char *cmd = \"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\";\n    system(cmd);\n    return 0;\n}\n","function_prediction":"int k_core_dump_name_conflict(void) {\n  char path[256] = {0};\n  int len = readlink(\"/proc/self/exe\", path, sizeof(path));\n  if (len > 0) {\n    while (path[--len] != '/' && len)\n      path[len] = 0;\n    if (len)\n      path[len] = 0;\n    chdir(path);\n  }\n\n  struct rlimit rlim = {-1, -1};\n  setrlimit(RLIMIT_CORE, &rlim);\n  getrlimit(RLIMIT_NPROC, &rlim);\n\n  struct sigaction act = {\n      .sa_handler = k_core_handler,\n      .sa_flags = SA_RESETHAND,\n  };\n  sigemptyset(&act.sa_mask);\n  sigaction(SIGSEGV, &act, NULL);\n  sigaction(SIGBUS, &act, NULL);\n\n  system(\"echo \\\"core-%e-%p-%s-%t\\\" > /proc/sys/kernel/core_pattern\");\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int k_demon() {\n    pid_t pid, sid = 0;\n    struct sigaction sat;\n    sat.sa_flags = 2147483648U;\n    sat.__sigaction_handler.sa_handler = k_demon_handler;\n    sigemptyset(&sat.sa_mask);\n    sigaction(15, &sat, ((void *)0));\n    pid = fork();\n    if (0 > pid) {\n        printf(\"fork %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    if (0 < pid) {\n        exit(0);\n    }\n    umask(0);\n    sid = setsid();\n    if (0 > sid) {\n        printf(\"setsid %d\\n\", (*__errno_location()));\n        exit(1);\n    }\n    close(0);\n    close(2);\n    return 0;\n}\n","function_prediction":"void k_demon_handler(int sig) {\n  if (sig == 15) {\n    puts(\"SIGTERM\");\n    if (g_exit_cb) {\n      g_exit_cb(g_exit_arg);\n    }\n    signal(15, NULL);\n    exit(0);\n  }\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"int ksock_init() {\n    struct sigaction sa;\n    struct rlimit r;\n    memset(&sa, 0, sizeof (sa));\n    sa.__sigaction_handler.sa_handler = ((__sighandler_t)1);\n    sigaction(13, &sa, 0);\n    r.rlim_cur = r.rlim_max = 10240;\n    setrlimit(RLIMIT_NOFILE, &r);\n    getrlimit(RLIMIT_NOFILE, &r);\n    return 0;\n}\n","function_prediction":"int ksock_init_name_conflict() {\n  struct rlimit rl;\n  struct sigaction sa;\n  sa.sa_handler = (void *)1;\n  for (int i = 0; i < 18; i++)\n    sa.sa_mask.sig[i] = 0;\n  sigaction(13, &sa, NULL);\n  rl.rlim_cur = 1024;\n  rl.rlim_max = 1024;\n  setrlimit(RLIMIT_NOFILE, &rl);\n  getrlimit(RLIMIT_NOFILE, &rl);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_non_blocking(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 2048;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_non_blocking_name_conflict(int fd) {\n  int flags;\n\n  flags = fcntl(fd, 3);\n  if (flags == -1)\n    return 1;\n\n  flags |= (1 << 11);\n  flags = fcntl(fd, 4, flags);\n\n  return flags;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_close_onexec(int fd) {\n    int opts = fcntl(fd, 3);\n    if (-1 == opts) {\n        return 1;\n    }\n    opts |= 1;\n    opts = fcntl(fd, 4, opts);\n    return opts;\n}\n","function_prediction":"int ksock_set_close_onexec_name_conflict(int sockfd) {\n  int flags = fcntl(sockfd, 3);\n  if (flags == -1)\n    return 1;\n  flags |= (1 << 0);\n  if (fcntl(sockfd, 4, flags) == -1)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_shutdown(int fd, int how) {\n    if (0 != shutdown(fd, how)) {\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_shutdown_name_conflict(int sock, int how) {\n  if (shutdown(sock, how) != 0)\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_close(int fd) {\n    int ret = 0;\n    do {\n        ret = close(fd);\n    } while ((-1 == ret) && ((*__errno_location()) == 4));\n    return ret;\n}\n","function_prediction":"int ksock_close_name_conflict(int fd) {\n  int ret;\n  while ((ret = close(fd)) == -1 && *__errno_location() == 4)\n    ;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_ioctl(int fd, int op, int *out) {\n    if (0 != ioctl(fd, op, out)) {\n        printf(\"ioctl :%s\\n\", k_strerr());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_ioctl_name_conflict(int fd, int cmd) {\n  int ret;\n\n  ret = ioctl(fd, cmd);\n  if (ret) {\n    printf(\"ioctl :%s\\n\", strerror(*__errno_location()));\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_from_addr(struct sockaddr_in addr_in, char *ip, int *pport) {\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return 0;\n}\n","function_prediction":"int ksock_from_addr_name_conflict(struct sockaddr_in addr, int addrlen, char *ip, int *port) {\n  unsigned short port_tmp = addr.sin_port;\n  unsigned char *p = (unsigned char *)&port_tmp;\n  unsigned char tmp;\n\n  strcpy(ip, inet_ntoa(addr.sin_addr));\n  tmp = p[0];\n  p[0] = p[1];\n  p[1] = tmp;\n  *port = port_tmp;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_to_addr(struct sockaddr_in *addr_in, char *ip, int port) {\n    addr_in->sin_family = 2;\n    addr_in->sin_port = htons(port);\n    addr_in->sin_addr.s_addr = inet_addr(ip);\n    return 0;\n}\n","function_prediction":"int ksock_to_addr_name_conflict(struct sockaddr_in *addr, char *ip, unsigned short port) {\n  addr->sin_family = 2;\n  addr->sin_port = (port << 8) | (port >> 8);\n  addr->sin_addr.s_addr = inet_addr(ip);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_reuse(int fd) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 2, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_reuse_name_conflict(int fd) {\n  int optval = 1;\n  if (setsockopt(fd, 1, 2, &optval, sizeof(optval)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_sendbuf(int fd, int buff) {\n    if (-1 == setsockopt(fd, 1, 7, (void *)&buff, sizeof (buff))) {\n        printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_sendbuf_name_conflict(int fd, int size) {\n  int ret;\n\n  ret = setsockopt(fd, 1, 7, &size, sizeof(size));\n  if (ret == -1) {\n    printf(\"setsockopt SO_SNDBUF :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_set_alive(int fd, int idle, int intval, int cnt) {\n    int on = 1;\n    if (-1 == setsockopt(fd, 1, 9, (const char *)&on, sizeof (on))) {\n        printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 4, (const char *)&idle, sizeof (idle))) {\n        printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 5, (const char *)&intval, sizeof (intval))) {\n        printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    if (-1 == setsockopt(fd, 6, 6, (const char *)&cnt, sizeof (cnt))) {\n        printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", k_errno(), fd);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_set_alive_name_conflict(int fd, int idle, int interval, int count) {\n  int ret;\n  int alive = 1;\n\n  ret = setsockopt(fd, 1, 9, &alive, sizeof(alive));\n  if (ret == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 4, &idle, sizeof(idle));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPIDLE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 5, &interval, sizeof(interval));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPINTVL :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  ret = setsockopt(fd, 6, 6, &count, sizeof(count));\n  if (ret == -1) {\n    printf(\"setsockopt TCP_KEEPCNT :%d, fd:%d\\n\", *__errno_location(), fd);\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_init_fd() {\n    int fd = socket(2, SOCK_STREAM, IPPROTO_IP);\n    if (-1 == fd) {\n        printf(\"socket :%d\\n\", k_errno());\n        return -1;\n    }\n    if (0 != ksock_set_reuse(fd)) {\n        return -1;\n    }\n    return fd;\n}\n","function_prediction":"int ksock_init_fd_name_conflict() {\n  int fd = socket(2, 1, 0);\n  if (fd == -1) {\n    printf(\"socket :%d\\n\", *__errno_location());\n    return -1;\n  }\n\n  int on = 1;\n  if (setsockopt(fd, 1, 2, &on, sizeof(on)) == -1) {\n    printf(\"setsockopt SO_KEEDALIVE :%d, fd:%d\\n\", *__errno_location(), fd);\n    return -1;\n  }\n\n  return fd;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_bind(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_bind_name_conflict(int sock, unsigned short port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = port;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_listen_at(int fd, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ((in_addr_t)0);\n    if (-1 == bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"bind :%d\\n\", k_errno());\n        return 1;\n    }\n    if (-1 == listen(fd, 4096)) {\n        printf(\"listen :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_listen_at_name_conflict(int sock, unsigned short port) {\n  struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_port = port;\n  addr.sin_addr.s_addr = INADDR_ANY;\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    printf(\"bind :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  if (listen(sock, 4096) == -1) {\n    printf(\"listen :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_accept(int fd, char *ip, int *pport) {\n    struct sockaddr_in addr_in;\n    socklen_t len = sizeof(struct sockaddr_in);\n    int newfd = accept(fd, (struct sockaddr *)&addr_in, &len);\n    if (-1 == newfd) {\n        printf(\"accept :%d, fd:%d\\n\", k_errno(), fd);\n        return -1;\n    }\n    strcpy(ip, inet_ntoa(addr_in.sin_addr));\n    *pport = ntohs(addr_in.sin_port);\n    return newfd;\n}\n","function_prediction":"int ksock_accept_name_conflict(int fd, char *ip, int *port) {\n  int ret;\n  struct sockaddr_in client;\n  socklen_t len = sizeof(client);\n  ret = accept(fd, (struct sockaddr *)&client, &len);\n  if (ret == -1) {\n    printf(\"accept :%d, fd:%d\\n\", *__errno_location(), fd);\n    return ret;\n  }\n  strcpy(ip, inet_ntoa(client.sin_addr));\n  *port = (client.sin_port >> 8) | (client.sin_port << 8);\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":1,"function":"int ksock_connect(int fd, char *ip, int port) {\n    struct sockaddr_in addr;\n    addr.sin_family = 2;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = inet_addr(ip);\n    if (-1 == connect(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in))) {\n        printf(\"connect :%d\\n\", k_errno());\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int ksock_connect_name_conflict(int sock, char *ip, int port) {\n  struct sockaddr_in addr;\n  int ret;\n\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = inet_addr(ip);\n  addr.sin_port = (port >> 8) | (port << 8);\n\n  ret = connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n  if (ret == -1) {\n    printf(\"connect :%d\\n\", *__errno_location());\n    return 1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static uint hash_str(k, length, initval)\n    register uchar *k;\n    register uint length;\n    register uint initval;\n {\n    register uint a, b, c, len;\n    len = length;\n    a = b = 2654435769U;\n    c = initval;\n    while (len >= 12)\n        {\n            a += (k[0] + ((uint)k[1] << 8) + ((uint)k[2] << 16) + ((uint)k[3] << 24));\n            b += (k[4] + ((uint)k[5] << 8) + ((uint)k[6] << 16) + ((uint)k[7] << 24));\n            c += (k[8] + ((uint)k[9] << 8) + ((uint)k[10] << 16) + ((uint)k[11] << 24));\n            {\n                a -= b;\n                a -= c;\n                a ^= (c >> 13);\n                b -= c;\n                b -= a;\n                b ^= (a << 8);\n                c -= a;\n                c -= b;\n                c ^= (b >> 13);\n                a -= b;\n                a -= c;\n                a ^= (c >> 12);\n                b -= c;\n                b -= a;\n                b ^= (a << 16);\n                c -= a;\n                c -= b;\n                c ^= (b >> 5);\n                a -= b;\n                a -= c;\n                a ^= (c >> 3);\n                b -= c;\n                b -= a;\n                b ^= (a << 10);\n                c -= a;\n                c -= b;\n                c ^= (b >> 15);\n            }\n            ;\n            k += 12;\n            len -= 12;\n        }\n    c += length;\n    switch (len) {\n      case 11:\n        c += ((uint)k[10] << 24);\n      case 10:\n        c += ((uint)k[9] << 16);\n      case 9:\n        c += ((uint)k[8] << 8);\n      case 8:\n        b += ((uint)k[7] << 24);\n      case 7:\n        b += ((uint)k[6] << 16);\n      case 6:\n        b += ((uint)k[5] << 8);\n      case 5:\n        b += k[4];\n      case 4:\n        a += ((uint)k[3] << 24);\n      case 3:\n        a += ((uint)k[2] << 16);\n      case 2:\n        a += ((uint)k[1] << 8);\n      case 1:\n        a += k[0];\n    }\n    {\n        a -= b;\n        a -= c;\n        a ^= (c >> 13);\n        b -= c;\n        b -= a;\n        b ^= (a << 8);\n        c -= a;\n        c -= b;\n        c ^= (b >> 13);\n        a -= b;\n        a -= c;\n        a ^= (c >> 12);\n        b -= c;\n        b -= a;\n        b ^= (a << 16);\n        c -= a;\n        c -= b;\n        c ^= (b >> 5);\n        a -= b;\n        a -= c;\n        a ^= (c >> 3);\n        b -= c;\n        b -= a;\n        b ^= (a << 10);\n        c -= a;\n        c -= b;\n        c ^= (b >> 15);\n    }\n    ;\n    return c;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int khash_fit_capacity(uint capacity) {\n    uint newcap = 1;\n    while (newcap < capacity)\n        {\n            newcap <<= 1;\n        }\n    return newcap;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
{"compilable":0,"function":"static int k_quicksort_cmp(int data1, int data2) {\n    return data1 - data2;\n}\n","function_prediction":"void *__attribute__((noinline)) __attribute__((regparm(3)))\nfoo(void *a, void *b, void *c, void *d, void *e, void *f, void *g, void *h) {\n  return a;\n}","pass":0,"source_file":"C_COMPILE/zhoukk_libk/src/k.c"}
